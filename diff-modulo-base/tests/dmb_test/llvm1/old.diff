diff --git a/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll b/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll
new file mode 100644
index 000000000000..84d255d8ec7e
--- /dev/null
+++ b/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll
@@ -0,0 +1,8 @@
+; Use grep as an easily available "custom tool". Strip out comment lines to get
+; identical output before and after update_test_checks has run.
+; RUN: grep -v ';' %s | FileCheck --check-prefixes=CHECK %s
+
+define i32 @foo(i32 %x) {
+  %y = add i32 %x, 1
+  ret i32 %y
+}
diff --git a/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll.expected b/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll.expected
new file mode 100644
index 000000000000..af99202eb349
--- /dev/null
+++ b/llvm/test/tools/UpdateTestChecks/update_test_checks/Inputs/custom-tool.ll.expected
@@ -0,0 +1,13 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool grep
+; Use grep as an easily available "custom tool". Strip out comment lines to get
+; identical output before and after update_test_checks has run.
+; RUN: grep -v ';' %s | FileCheck --check-prefixes=CHECK %s
+
+define i32 @foo(i32 %x) {
+; CHECK-LABEL: @foo(
+; CHECK-NEXT:    [[Y:%.*]] = add i32 [[X:%.*]], 1
+; CHECK-NEXT:    ret i32 [[Y]]
+;
+  %y = add i32 %x, 1
+  ret i32 %y
+}
diff --git a/llvm/test/tools/UpdateTestChecks/update_test_checks/custom-tool.test b/llvm/test/tools/UpdateTestChecks/update_test_checks/custom-tool.test
new file mode 100644
index 000000000000..98a91dfdfa97
--- /dev/null
+++ b/llvm/test/tools/UpdateTestChecks/update_test_checks/custom-tool.test
@@ -0,0 +1,9 @@
+# Don't rely on 'grep' being available on Windows.
+# UNSUPPORTED: system-windows
+
+# RUN: cp -f %S/Inputs/custom-tool.ll %t.ll && %update_test_checks %t.ll --tool=grep --tool-binary=grep
+# RUN: diff -u %t.ll %S/Inputs/custom-tool.ll.expected
+
+## Check that running the script again does not change the result:
+# RUN: %update_test_checks %t.ll --tool=grep --tool-binary=grep
+# RUN: diff -u %t.ll %S/Inputs/custom-tool.ll.expected
diff --git a/llvm/utils/UpdateTestChecks/common.py b/llvm/utils/UpdateTestChecks/common.py
index 8e02488da985..127a7404431e 100644
--- a/llvm/utils/UpdateTestChecks/common.py
+++ b/llvm/utils/UpdateTestChecks/common.py
@@ -1147,22 +1147,22 @@ def verify_filecheck_prefixes(fc_cmd):
         if prefixes.count(prefix) > 1:
           warn("Supplied prefix '%s' is not unique in the prefix list." % (prefix,))
 
 
 def get_autogennote_suffix(parser, args):
   autogenerated_note_args = ''
   for action in parser._actions:
     if not hasattr(args, action.dest):
       continue  # Ignore options such as --help that aren't included in args
     # Ignore parameters such as paths to the binary or the list of tests
-    if action.dest in ('tests', 'update_only', 'opt_binary', 'llc_binary',
-                       'clang', 'opt', 'llvm_bin', 'verbose'):
+    if action.dest in ('tests', 'update_only', 'tool_binary', 'opt_binary',
+                       'llc_binary', 'clang', 'opt', 'llvm_bin', 'verbose'):
       continue
     value = getattr(args, action.dest)
     if action.const is not None:  # action stores a constant (usually True/False)
       # Skip actions with different constant values (this happens with boolean
       # --foo/--no-foo options)
       if value != action.const:
         continue
     if parser.get_default(action.dest) == value:
       continue  # Don't add default values
     if action.dest == 'filters':
diff --git a/llvm/utils/update_test_checks.py b/llvm/utils/update_test_checks.py
index f16103b892b0..626633aaa882 100755
--- a/llvm/utils/update_test_checks.py
+++ b/llvm/utils/update_test_checks.py
@@ -30,43 +30,47 @@ import argparse
 import os  # Used to advertise this file's name ("autogenerated_note").
 import re
 import sys
 
 from UpdateTestChecks import common
 
 
 def main():
   from argparse import RawTextHelpFormatter
   parser = argparse.ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
-  parser.add_argument('--opt-binary', default='opt',
-                      help='The opt binary used to generate the test case')
+  parser.add_argument('--tool', default='opt',
+                      help='The name of the tool used to generate the test case (defaults to "opt")')
+  parser.add_argument('--tool-binary', '--opt-binary',
+                      help='The tool binary used to generate the test case')
   parser.add_argument(
       '--function', help='The function in the test file to update')
   parser.add_argument('-p', '--preserve-names', action='store_true',
                       help='Do not scrub IR names')
   parser.add_argument('--function-signature', action='store_true',
                       help='Keep function signature information around for the check line')
   parser.add_argument('--scrub-attributes', action='store_true',
                       help='Remove attribute annotations (#0) from the end of check line')
   parser.add_argument('--check-attributes', action='store_true',
                       help='Check "Function Attributes" for functions')
   parser.add_argument('--check-globals', action='store_true',
                       help='Check global entries (global variables, metadata, attribute sets, ...) for functions')
   parser.add_argument('tests', nargs='+')
   initial_args = common.parse_commandline_args(parser)
 
   script_name = os.path.basename(__file__)
-  opt_basename = os.path.basename(initial_args.opt_binary)
-  if not re.match(r'^opt(-\d+)?(\.exe)?$', opt_basename):
-    common.error('Unexpected opt name: ' + opt_basename)
-    sys.exit(1)
-  opt_basename = 'opt'
+
+  if initial_args.tool_binary:
+    tool_basename = os.path.basename(initial_args.tool_binary)
+    if not re.match(r'^%s(-\d+)?(\.exe)?$' % (initial_args.tool), tool_basename):
+      common.error('Unexpected tool name: ' + tool_basename)
+      sys.exit(1)
+  tool_basename = initial_args.tool
 
   for ti in common.itertests(initial_args.tests, parser,
                              script_name='utils/' + script_name):
     # If requested we scrub trailing attribute annotations, e.g., '#0', together with whitespaces
     if ti.args.scrub_attributes:
       common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_AND_ATTRIBUTES_RE
     else:
       common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_RE
 
     prefix_list = []
@@ -76,53 +80,57 @@ def main():
         continue
 
       commands = [cmd.strip() for cmd in l.split('|')]
       assert len(commands) >= 2
       preprocess_cmd = None
       if len(commands) > 2:
         preprocess_cmd = " | ".join(commands[:-2])
       tool_cmd = commands[-2]
       filecheck_cmd = commands[-1]
       common.verify_filecheck_prefixes(filecheck_cmd)
-      if not tool_cmd.startswith(opt_basename + ' '):
-        common.warn('Skipping non-%s RUN line: %s' % (opt_basename, l))
+      if not tool_cmd.startswith(tool_basename + ' '):
+        common.warn('Skipping non-%s RUN line: %s' % (tool_basename, l))
         continue
 
       if not filecheck_cmd.startswith('FileCheck '):
         common.warn('Skipping non-FileChecked RUN line: ' + l)
         continue
 
-      tool_cmd_args = tool_cmd[len(opt_basename):].strip()
+      tool_cmd_args = tool_cmd[len(tool_basename):].strip()
       tool_cmd_args = tool_cmd_args.replace('< %s', '').replace('%s', '').strip()
 
       check_prefixes = [item for m in
                         common.CHECK_PREFIX_RE.finditer(filecheck_cmd)
                         for item in m.group(1).split(',')]
       if not check_prefixes:
         check_prefixes = ['CHECK']
 
       # FIXME: We should use multiple check prefixes to common check lines. For
       # now, we just ignore all but the last.
       prefix_list.append((check_prefixes, tool_cmd_args, preprocess_cmd))
 
     global_vars_seen_dict = {}
     builder = common.FunctionTestBuilder(
       run_list=prefix_list,
       flags=ti.args,
       scrubber_args=[],
       path=ti.path)
 
+    tool_binary = ti.args.tool_binary
+    if not tool_binary:
+      tool_binary = tool_basename
+
     for prefixes, opt_args, preprocess_cmd in prefix_list:
-      common.debug('Extracted opt cmd: ' + opt_basename + ' ' + opt_args)
+      common.debug('Extracted opt cmd: ' + tool_basename + ' ' + opt_args)
       common.debug('Extracted FileCheck prefixes: ' + str(prefixes))
 
-      raw_tool_output = common.invoke_tool(ti.args.opt_binary, opt_args,
+      raw_tool_output = common.invoke_tool(tool_binary, opt_args,
                                            ti.path, preprocess_cmd=preprocess_cmd,
                                            verbose=ti.args.verbose)
       builder.process_run_line(common.OPT_FUNCTION_RE, common.scrub_body,
               raw_tool_output, prefixes, False)
       builder.processed_prefixes(prefixes)
 
     func_dict = builder.finish_and_get_func_dict()
     is_in_function = False
     is_in_function_start = False
     has_checked_pre_function_globals = False
