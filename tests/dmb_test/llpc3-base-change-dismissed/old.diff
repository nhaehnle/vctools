diff --git a/lgc/builder/BuilderReplayer.cpp b/lgc/builder/BuilderReplayer.cpp
index 67cedd8b3..952bfc2a7 100644
--- a/lgc/builder/BuilderReplayer.cpp
+++ b/lgc/builder/BuilderReplayer.cpp
@@ -34,56 +34,20 @@
 #include "lgc/builder/BuilderRecorder.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/util/Internal.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-builder-replayer"
 
 using namespace lgc;
 using namespace llvm;
 
-namespace {
-
-// =====================================================================================================================
-// Pass to replay Builder calls recorded by BuilderRecorder
-class LegacyBuilderReplayer final : public ModulePass, BuilderRecorderMetadataKinds {
-public:
-  LegacyBuilderReplayer() : ModulePass(ID), m_impl(nullptr) {}
-  LegacyBuilderReplayer(Pipeline *pipeline);
-
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  bool runOnModule(Module &module) override;
-
-  static char ID;
-
-private:
-  LegacyBuilderReplayer(const LegacyBuilderReplayer &) = delete;
-  LegacyBuilderReplayer &operator=(const LegacyBuilderReplayer &) = delete;
-
-  BuilderReplayer m_impl;
-};
-
-} // namespace
-
-char LegacyBuilderReplayer::ID = 0;
-
-// =====================================================================================================================
-// Create BuilderReplayer pass
-//
-// @param pipeline : Pipeline object
-ModulePass *lgc::createLegacyBuilderReplayer(Pipeline *pipeline) {
-  return new LegacyBuilderReplayer(pipeline);
-}
-
 // =====================================================================================================================
 // Constructor
 //
 // @param pipeline : Pipeline object
 BuilderReplayer::BuilderReplayer(Pipeline *pipeline)
     : BuilderRecorderMetadataKinds(static_cast<LLVMContext &>(pipeline->getContext())) {
 }
 
 // =====================================================================================================================
 // Parser callback for adding this pass from a textually described pass pipeline.
@@ -91,37 +55,20 @@ BuilderReplayer::BuilderReplayer(Pipeline *pipeline)
 // @param params : Parameters to the pass (in angle brackets)
 // @param passMgr : The pass manager to which the pass should be added
 bool BuilderReplayer::parsePass(llvm::StringRef params, llvm::ModulePassManager &passMgr) {
   if (!params.empty())
     return false;
 
   passMgr.addPass(BuilderReplayer(nullptr));
   return true;
 }
 
-// =====================================================================================================================
-// Constructor
-//
-// @param pipeline : Pipeline object
-LegacyBuilderReplayer::LegacyBuilderReplayer(Pipeline *pipeline) : ModulePass(ID), m_impl(pipeline) {
-}
-
-// =====================================================================================================================
-// Run the BuilderReplayer pass on a module
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyBuilderReplayer::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the BuilderReplayer pass on a module
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses BuilderReplayer::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   runImpl(module, pipelineState);
   return PreservedAnalyses::none();
@@ -915,14 +862,10 @@ Value *BuilderReplayer::processCall(unsigned opcode, CallInst *call) {
     return m_builder->CreateSubgroupSwizzleMask(args[0], args[1]);
   }
   case BuilderRecorder::Opcode::SubgroupWriteInvocation: {
     return m_builder->CreateSubgroupWriteInvocation(args[0], args[1], args[2]);
   }
   case BuilderRecorder::Opcode::SubgroupMbcnt: {
     return m_builder->CreateSubgroupMbcnt(args[0]);
   }
   }
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyBuilderReplayer, DEBUG_TYPE, "Replay LLPC builder calls", false, false)
diff --git a/lgc/docs/LgcOverview.md b/lgc/docs/LgcOverview.md
index c2c48dc5e..12bc82add 100644
--- a/lgc/docs/LgcOverview.md
+++ b/lgc/docs/LgcOverview.md
@@ -107,21 +107,21 @@ The front-end flow is:
   shader compiles):
   - First use `Builder::Set*ShaderMode` calls to set shader modes (FP modes, useSubgroupSize flag,
     tessellation modes, geometry modes, fragment modes, workgroup size) that come from
     the input language.
   - Then create or process an IR module, using Builder calls to generate new IR.
   - For a shader compile, call `Builder::RecordShaderModes` to ensure the modes are recorded
     into IR.
   - Where the front-end creates a pass manager for its own passes, it should call
     `BuilderContext::PreparePassManager` to ensure it is suitably set up. It can optionally
     use `PassManager::Create` to create the middle-end's subclass pass manager instead of
-    using the standard `legacy::PassManager`.
+    using the standard `PassManager`.
   - For a shader compile, you're done: The IR module at this point is the result of
     the compile, and can be stored away and kept for later linking with other shaders.
 
 * Call `Pipeline::Link` to link the shader IR modules into a pipeline IR module. (This needs to be
   done even if the pipeline only has a single shader, such as a compute pipeline.)
   This also records the pipeline state into IR metadata.
 
 * Call `Pipeline::Generate` to run middle-end and back-end passes and generate the ELF.
   (Global options such as `-filetype` and `-emit-llvm` can cause the output to be something other than ELF.)
   The front-end can pass a call-back function into `Pipeline::Generate` to check a shader cache
diff --git a/lgc/elfLinker/GlueShader.cpp b/lgc/elfLinker/GlueShader.cpp
index faf9674d2..8da23c383 100644
--- a/lgc/elfLinker/GlueShader.cpp
+++ b/lgc/elfLinker/GlueShader.cpp
@@ -27,20 +27,21 @@
  * @file  GlueShader.cpp
  * @brief LGC source file: The abstract class for glue shaders (fetch shader, parameter/color export shader) generated
  *        while linking.
  ***********************************************************************************************************************
  */
 #include "GlueShader.h"
 #include "ColorExportShader.h"
 #include "FetchShader.h"
 #include "NullFragmentShader.h"
 #include "lgc/state/PassManagerCache.h"
+#include "llvm/IR/LegacyPassManager.h"
 
 using namespace lgc;
 using namespace llvm;
 
 // =====================================================================================================================
 // Compile the glue shader
 //
 // @param [in/out] outStream : Stream to write ELF to
 void GlueShader::compile(raw_pwrite_stream &outStream) {
   // Generate the glue shader IR module.
diff --git a/lgc/include/lgc/builder/BuilderRecorder.h b/lgc/include/lgc/builder/BuilderRecorder.h
index 31e2cf508..05d1da8de 100644
--- a/lgc/include/lgc/builder/BuilderRecorder.h
+++ b/lgc/include/lgc/builder/BuilderRecorder.h
@@ -28,29 +28,20 @@
  * @brief LLPC header file: declaration of lgc::BuilderRecorder
  ***********************************************************************************************************************
  */
 #pragma once
 
 #include "lgc/Builder.h"
 #ifndef NDEBUG
 #include "llvm/IR/ValueHandle.h"
 #endif
 
-namespace llvm {
-
-class ModulePass;
-class PassRegistry;
-
-void initializeLegacyBuilderReplayerPass(PassRegistry &);
-
-} // namespace llvm
-
 namespace lgc {
 
 class PipelineState;
 
 // Prefix of all recorded Create* calls.
 static const char BuilderCallPrefix[] = "lgc.create.";
 
 // LLPC call opcode metadata name.
 static const char BuilderCallOpcodeMetadataName[] = "lgc.create.opcode";
 
@@ -611,14 +602,11 @@ protected:
 private:
   // Record one Builder call
   llvm::Instruction *record(Opcode opcode, llvm::Type *returnTy, llvm::ArrayRef<llvm::Value *> args,
                             const llvm::Twine &instName);
 
   PipelineState *m_pipelineState;             // PipelineState; nullptr for shader compile
   std::unique_ptr<ShaderModes> m_shaderModes; // ShaderModes for a shader compile
   bool m_omitOpcodes;                         // Omit opcodes on lgc.create.* function declarations
 };
 
-// Create BuilderReplayer pass
-llvm::ModulePass *createLegacyBuilderReplayer(Pipeline *pipeline);
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/FragColorExport.h b/lgc/include/lgc/patch/FragColorExport.h
index c3ba29837..0d9db0519 100644
--- a/lgc/include/lgc/patch/FragColorExport.h
+++ b/lgc/include/lgc/patch/FragColorExport.h
@@ -119,31 +119,11 @@ private:
   llvm::Value *generateValueForOutput(llvm::Value *value, llvm::Type *outputTy, BuilderBase &builder);
   llvm::Value *generateReturn(llvm::Function *fragEntryPoint, BuilderBase &builder);
 
   llvm::LLVMContext *m_context;                        // The context the pass is being run in.
   PipelineState *m_pipelineState;                      // The pipeline state
   ResourceUsage *m_resUsage;                           // The resource usage object from the pipeline state.
   llvm::SmallVector<ColorExportInfo, 8> m_info;        // The color export information for each export.
   llvm::SmallVector<llvm::Value *, 10> m_exportValues; // The value to be exported indexed by the hw render target.
 };
 
-// =====================================================================================================================
-// Pass to lower color export calls
-class LegacyLowerFragColorExport : public llvm::ModulePass {
-public:
-  LegacyLowerFragColorExport();
-  LegacyLowerFragColorExport(const LegacyLowerFragColorExport &) = delete;
-  LegacyLowerFragColorExport &operator=(const LegacyLowerFragColorExport &) = delete;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-  }
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-private:
-  LowerFragColorExport m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/Patch.h b/lgc/include/lgc/patch/Patch.h
index 2672cf410..e1bdbaf76 100644
--- a/lgc/include/lgc/patch/Patch.h
+++ b/lgc/include/lgc/patch/Patch.h
@@ -30,112 +30,25 @@
  */
 #pragma once
 
 #include "lgc/Pipeline.h"
 #include "llvm/Analysis/LoopPass.h"
 #include "llvm/Pass.h"
 
 namespace llvm {
 
 class PassBuilder;
-class PassRegistry;
 
-namespace legacy {
-
-class PassManager;
-
-} // namespace legacy
-
-void initializeLegacyLowerFragColorExportPass(PassRegistry &);
-void initializeLegacyLowerVertexFetchPass(PassRegistry &);
-void initializeLegacyPatchBufferOpPass(PassRegistry &);
-void initializeLegacyPatchCheckShaderCachePass(PassRegistry &);
-void initializeLegacyPatchCopyShaderPass(PassRegistry &);
-void initializeLegacyPatchEntryPointMutatePass(PassRegistry &);
-void initializeLegacyPatchInOutImportExportPass(PassRegistry &);
-void initializeLegacyPatchLlvmIrInclusionPass(PassRegistry &);
-void initializeLegacyPatchLoadScalarizerPass(PassRegistry &);
-void initializeLegacyPatchLoopMetadataPass(PassRegistry &);
-void initializeLegacyPatchNullFragShaderPass(PassRegistry &);
-void initializeLegacyPatchPeepholeOptPass(PassRegistry &);
-void initializeLegacyPatchPreparePipelineAbiPass(PassRegistry &);
-void initializeLegacyPatchResourceCollectPass(PassRegistry &);
-void initializeLegacyPatchSetupTargetFeaturesPass(PassRegistry &);
-void initializeLegacyPatchWorkaroundsPass(PassRegistry &);
-void initializeLegacyPatchReadFirstLanePass(PassRegistry &);
-void initializeLegacyPatchWaveSizeAdjustPass(PassRegistry &);
-void initializeLegacyPatchImageDerivativesPass(PassRegistry &);
-void initializeLegacyPatchInitializeWorkgroupMemoryPass(PassRegistry &);
-void initializeLegacyPatchInvariantLoadsPass(PassRegistry &);
-#if LLPC_BUILD_GFX11
-void initializeLegacyPatchImageOpCollectPass(PassRegistry &);
-#endif
 } // namespace llvm
 
 namespace lgc {
 
-class LegacyPatchCheckShaderCache;
-
-// Initialize passes for patching
-//
-// @param passRegistry : Pass registry
-inline void initializePatchPasses(llvm::PassRegistry &passRegistry) {
-  initializeLegacyLowerFragColorExportPass(passRegistry);
-  initializeLegacyLowerVertexFetchPass(passRegistry);
-  initializeLegacyPatchBufferOpPass(passRegistry);
-  initializeLegacyPatchCheckShaderCachePass(passRegistry);
-  initializeLegacyPatchCopyShaderPass(passRegistry);
-  initializeLegacyPatchEntryPointMutatePass(passRegistry);
-  initializeLegacyPatchInOutImportExportPass(passRegistry);
-  initializeLegacyPatchLlvmIrInclusionPass(passRegistry);
-  initializeLegacyPatchLoadScalarizerPass(passRegistry);
-  initializeLegacyPatchLoopMetadataPass(passRegistry);
-  initializeLegacyPatchNullFragShaderPass(passRegistry);
-  initializeLegacyPatchPeepholeOptPass(passRegistry);
-  initializeLegacyPatchPreparePipelineAbiPass(passRegistry);
-  initializeLegacyPatchResourceCollectPass(passRegistry);
-  initializeLegacyPatchSetupTargetFeaturesPass(passRegistry);
-  initializeLegacyPatchWorkaroundsPass(passRegistry);
-  initializeLegacyPatchReadFirstLanePass(passRegistry);
-  initializeLegacyPatchWaveSizeAdjustPass(passRegistry);
-  initializeLegacyPatchImageDerivativesPass(passRegistry);
-  initializeLegacyPatchInitializeWorkgroupMemoryPass(passRegistry);
-  initializeLegacyPatchInvariantLoadsPass(passRegistry);
-#if LLPC_BUILD_GFX11
-  initializeLegacyPatchImageOpCollectPass(passRegistry);
-#endif
-}
-
-llvm::ModulePass *createLegacyLowerFragColorExport();
-llvm::ModulePass *createLegacyLowerVertexFetch();
-llvm::FunctionPass *createLegacyPatchBufferOp();
-#if LLPC_BUILD_GFX11
-llvm::ModulePass *createLegacyPatchImageOpCollect();
-#endif
-LegacyPatchCheckShaderCache *createLegacyPatchCheckShaderCache();
-llvm::ModulePass *createLegacyPatchCopyShader();
-llvm::ModulePass *createLegacyPatchEntryPointMutate();
-llvm::ModulePass *createLegacyPatchInOutImportExport();
-llvm::ModulePass *createLegacyPatchLlvmIrInclusion();
-llvm::FunctionPass *createLegacyPatchLoadScalarizer();
-llvm::LoopPass *createLegacyPatchLoopMetadata();
-llvm::ModulePass *createLegacyPatchNullFragShader();
-llvm::FunctionPass *createLegacyPatchPeepholeOpt();
-llvm::ModulePass *createLegacyPatchPreparePipelineAbi();
-llvm::ModulePass *createLegacyPatchResourceCollect();
-llvm::ModulePass *createLegacyPatchSetupTargetFeatures();
-llvm::ModulePass *createLegacyPatchWorkarounds();
-llvm::FunctionPass *createLegacyPatchReadFirstLane();
-llvm::ModulePass *createLegacyPatchWaveSizeAdjust();
-llvm::ModulePass *createLegacyPatchImageDerivatives();
-llvm::ModulePass *createLegacyPatchInitializeWorkgroupMemory();
-llvm::FunctionPass *createLegacyPatchInvariantLoads();
 class PipelineState;
 class PassManager;
 
 // =====================================================================================================================
 // Represents the pass of LLVM patching operations, as the base class.
 class Patch {
 public:
   Patch() : m_module(nullptr), m_context(nullptr), m_shaderStage(ShaderStageInvalid), m_entryPoint(nullptr) {}
   virtual ~Patch() {}
 
@@ -155,30 +68,11 @@ protected:
   static void addOptimizationPasses(lgc::PassManager &passMgr, llvm::CodeGenOpt::Level optLevel);
 
   void init(llvm::Module *module);
 
   llvm::Module *m_module;       // LLVM module to be run on
   llvm::LLVMContext *m_context; // Associated LLVM context of the LLVM module that passes run on
   ShaderStage m_shaderStage;    // Shader stage
   llvm::Function *m_entryPoint; // Entry-point
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations, as the base class.
-class LegacyPatch : public llvm::ModulePass, public Patch {
-public:
-  explicit LegacyPatch(char &pid) : llvm::ModulePass(pid) {}
-  virtual ~LegacyPatch() {}
-
-  static void addPasses(PipelineState *pipelineState, llvm::legacy::PassManager &passMgr,
-                        llvm::ModulePass *replayerPass, llvm::Timer *patchTimer, llvm::Timer *optTimer,
-                        Pipeline::CheckShaderCacheFunc checkShaderCacheFunc, llvm::CodeGenOpt::Level optLevel);
-
-private:
-  static void addOptimizationPasses(llvm::legacy::PassManager &passMgr, llvm::CodeGenOpt::Level optLevel);
-
-  LegacyPatch() = delete;
-  LegacyPatch(const LegacyPatch &) = delete;
-  LegacyPatch &operator=(const LegacyPatch &) = delete;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchBufferOp.h b/lgc/include/lgc/patch/PatchBufferOp.h
index 624247375..cb2663d73 100644
--- a/lgc/include/lgc/patch/PatchBufferOp.h
+++ b/lgc/include/lgc/patch/PatchBufferOp.h
@@ -95,30 +95,11 @@ private:
   llvm::SmallVector<llvm::Instruction *, 16> m_postVisitInsts; // The post process instruction set.
   llvm::IRBuilder<> *m_builder;                                // The IRBuilder.
   llvm::LLVMContext *m_context;                                // The LLVM context.
   PipelineState *m_pipelineState;                              // The pipeline state
 
   std::function<bool(const llvm::Value &)> m_isDivergent;
 
   static constexpr unsigned MinMemOpLoopBytes = 256;
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for buffer operations
-class LegacyPatchBufferOp final : public llvm::FunctionPass, public llvm::InstVisitor<LegacyPatchBufferOp> {
-public:
-  LegacyPatchBufferOp();
-
-  bool runOnFunction(llvm::Function &function) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-
-  static char ID; // NOLINT
-
-private:
-  LegacyPatchBufferOp(const LegacyPatchBufferOp &) = delete;
-  LegacyPatchBufferOp &operator=(const LegacyPatchBufferOp &) = delete;
-
-  PatchBufferOp m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchCheckShaderCache.h b/lgc/include/lgc/patch/PatchCheckShaderCache.h
index 4b082f070..248c05bd7 100644
--- a/lgc/include/lgc/patch/PatchCheckShaderCache.h
+++ b/lgc/include/lgc/patch/PatchCheckShaderCache.h
@@ -33,61 +33,31 @@
 #include "lgc/patch/Patch.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 
 namespace lgc {
 
 // =====================================================================================================================
 // Represents the pass of LLVM patching operations for checking shader cache
 class PatchCheckShaderCache : public Patch, public llvm::PassInfoMixin<PatchCheckShaderCache> {
 public:
-  // NOTE: This constructor is only used by the LegacyPatchCheckShaderCache class and can be removed once
-  // the switch to the new pass manager is completed.
   PatchCheckShaderCache() {}
 
   PatchCheckShaderCache(Pipeline::CheckShaderCacheFunc callbackFunc);
 
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch LLVM for checking shader cache"; }
 
   // Set the callback function that this pass uses to ask the front-end whether it wants to remove
   // any shader stages. The function takes the LLVM IR module and a per-shader-stage array of input/output
   // usage checksums, and it returns the shader stage mask with bits removed for shader stages that it wants
   // removed.
   void setCallbackFunction(Pipeline::CheckShaderCacheFunc callbackFunc) { m_callbackFunc = callbackFunc; }
 
 private:
   Pipeline::CheckShaderCacheFunc m_callbackFunc;
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for checking shader cache
-class LegacyPatchCheckShaderCache : public llvm::ModulePass {
-public:
-  LegacyPatchCheckShaderCache();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-  }
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  // Set the callback function that this pass uses to ask the front-end whether it wants to remove
-  // any shader stages. The function takes the LLVM IR module and a per-shader-stage array of input/output
-  // usage checksums, and it returns the shader stage mask with bits removed for shader stages that it wants
-  // removed.
-  void setCallbackFunction(Pipeline::CheckShaderCacheFunc callbackFunc) { m_impl.setCallbackFunction(callbackFunc); }
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchCheckShaderCache(const LegacyPatchCheckShaderCache &) = delete;
-  LegacyPatchCheckShaderCache &operator=(const LegacyPatchCheckShaderCache &) = delete;
-
-  PatchCheckShaderCache m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchCopyShader.h b/lgc/include/lgc/patch/PatchCopyShader.h
index dbbe9228c..11b43ded1 100644
--- a/lgc/include/lgc/patch/PatchCopyShader.h
+++ b/lgc/include/lgc/patch/PatchCopyShader.h
@@ -64,33 +64,11 @@ private:
   // Low part of global internal table pointer
   static const unsigned EntryArgIdxInternalTablePtrLow = 0;
 
   PipelineState *m_pipelineState;                                             // Pipeline state
   llvm::GlobalVariable *m_lds = nullptr;                                      // Global variable representing LDS
   llvm::Value *m_gsVsRingBufDesc = nullptr;                                   // Descriptor for GS-VS ring
   llvm::DenseMap<unsigned, unsigned> m_newLocByteSizesMapArray[MaxGsStreams]; // The byte sizes of the output value at
                                                                               // the mapped location for each stream
 };
 
-// =====================================================================================================================
-// Pass to generate copy shader if required
-class LegacyPatchCopyShader : public llvm::ModulePass {
-public:
-  static char ID;
-  LegacyPatchCopyShader();
-
-  bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    // Pass does not preserve PipelineShaders as it adds a new shader.
-  }
-
-private:
-  LegacyPatchCopyShader(const LegacyPatchCopyShader &) = delete;
-  LegacyPatchCopyShader &operator=(const LegacyPatchCopyShader &) = delete;
-
-  PatchCopyShader m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchEntryPointMutate.h b/lgc/include/lgc/patch/PatchEntryPointMutate.h
index cf5b113db..bf0b16d8d 100644
--- a/lgc/include/lgc/patch/PatchEntryPointMutate.h
+++ b/lgc/include/lgc/patch/PatchEntryPointMutate.h
@@ -145,32 +145,11 @@ private:
   bool isComputeWithCalls() const;
 
   bool m_hasTs;                             // Whether the pipeline has tessllation shader
   bool m_hasGs;                             // Whether the pipeline has geometry shader
   PipelineState *m_pipelineState = nullptr; // Pipeline state from PipelineStateWrapper pass
   bool m_computeWithCalls = false;          // Whether this is compute pipeline with calls or compute library
   // Per-HW-shader-stage gathered user data usage information.
   llvm::SmallVector<std::unique_ptr<UserDataUsage>, ShaderStageCount> m_userDataUsage;
 };
 
-// =====================================================================================================================
-// The entry-point mutation pass
-class LegacyPatchEntryPointMutate : public llvm::ModulePass {
-public:
-  LegacyPatchEntryPointMutate();
-  LegacyPatchEntryPointMutate(const LegacyPatchEntryPointMutate &) = delete;
-  LegacyPatchEntryPointMutate &operator=(const LegacyPatchEntryPointMutate &) = delete;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    // Does not preserve PipelineShaders because it replaces the entrypoints.
-  }
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-private:
-  PatchEntryPointMutate m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchImageDerivatives.h b/lgc/include/lgc/patch/PatchImageDerivatives.h
index 4c8de1dd5..268b39a41 100644
--- a/lgc/include/lgc/patch/PatchImageDerivatives.h
+++ b/lgc/include/lgc/patch/PatchImageDerivatives.h
@@ -40,30 +40,11 @@ namespace lgc {
 // Represents the pass of LLVM patching operations for image operations
 class PatchImageDerivatives : public llvm::PassInfoMixin<PatchImageDerivatives> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch attributes when image derivatives dependent on discard"; }
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for image operations
-class LegacyPatchImageDerivatives : public llvm::ModulePass {
-public:
-  LegacyPatchImageDerivatives();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-
-  bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchImageDerivatives(const LegacyPatchImageDerivatives &) = delete;
-  LegacyPatchImageDerivatives &operator=(const LegacyPatchImageDerivatives &) = delete;
-
-  PatchImageDerivatives m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchImageOpCollect.h b/lgc/include/lgc/patch/PatchImageOpCollect.h
index 1cc9291ba..a8b30a588 100644
--- a/lgc/include/lgc/patch/PatchImageOpCollect.h
+++ b/lgc/include/lgc/patch/PatchImageOpCollect.h
@@ -40,30 +40,11 @@ namespace lgc {
 // Represents the pass of LLVM patching operations for image operations
 class PatchImageOpCollect : public llvm::PassInfoMixin<PatchImageOpCollect> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch LLVM for image operation collecting"; }
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for image operations
-class LegacyPatchImageOpCollect : public llvm::ModulePass {
-public:
-  LegacyPatchImageOpCollect();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-
-  bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchImageOpCollect(const LegacyPatchImageOpCollect &) = delete;
-  LegacyPatchImageOpCollect &operator=(const LegacyPatchImageOpCollect &) = delete;
-
-  PatchImageOpCollect m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchInOutImportExport.h b/lgc/include/lgc/patch/PatchInOutImportExport.h
index 2a48b12f3..bcda02814 100644
--- a/lgc/include/lgc/patch/PatchInOutImportExport.h
+++ b/lgc/include/lgc/patch/PatchInOutImportExport.h
@@ -231,36 +231,11 @@ private:
   std::vector<llvm::CallInst *> m_importCalls; // List of "call" instructions to import inputs
   std::vector<llvm::CallInst *> m_exportCalls; // List of "call" instructions to export outputs
   llvm::SmallDenseMap<unsigned, std::array<llvm::Value *, 4>>
       m_attribExports;                      // Export info of vertex attributes: <attrib loc, attrib values>
   PipelineState *m_pipelineState = nullptr; // Pipeline state from PipelineStateWrapper pass
 
   std::set<unsigned> m_expLocs; // The locations that already have an export instruction for the vertex shader.
   const std::array<unsigned char, 4> *m_buffFormats; // The format of MTBUF instructions for specified GFX
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for input import and output export.
-class LegacyPatchInOutImportExport : public llvm::ModulePass {
-public:
-  LegacyPatchInOutImportExport();
-  ~LegacyPatchInOutImportExport();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    analysisUsage.addRequired<llvm::PostDominatorTreeWrapperPass>();
-    analysisUsage.addPreserved<LegacyPipelineShaders>();
-  }
-
-  bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchInOutImportExport(const LegacyPatchInOutImportExport &) = delete;
-  LegacyPatchInOutImportExport &operator=(const LegacyPatchInOutImportExport &) = delete;
-
-  PatchInOutImportExport m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchInitializeWorkgroupMemory.h b/lgc/include/lgc/patch/PatchInitializeWorkgroupMemory.h
index 783cc3508..97d1f25f3 100644
--- a/lgc/include/lgc/patch/PatchInitializeWorkgroupMemory.h
+++ b/lgc/include/lgc/patch/PatchInitializeWorkgroupMemory.h
@@ -48,33 +48,11 @@ public:
   static llvm::StringRef name() { return "Patch for initialize workgroup memory"; }
 
 private:
   void initializeWithZero(llvm::GlobalVariable *lds, BuilderBase &builder);
   unsigned getTypeSizeInDwords(llvm::Type *inputTy);
 
   llvm::DenseMap<llvm::GlobalVariable *, llvm::Value *> m_globalLdsOffsetMap;
   PipelineState *m_pipelineState = nullptr;
 };
 
-// =====================================================================================================================
-// Represents the pass of setting up the value for workgroup global variables.
-class LegacyPatchInitializeWorkgroupMemory final : public llvm::ModulePass {
-public:
-  LegacyPatchInitializeWorkgroupMemory();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchInitializeWorkgroupMemory(const LegacyPatchInitializeWorkgroupMemory &) = delete;
-  LegacyPatchInitializeWorkgroupMemory &operator=(const LegacyPatchInitializeWorkgroupMemory &) = delete;
-
-  PatchInitializeWorkgroupMemory m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchInvariantLoads.h b/lgc/include/lgc/patch/PatchInvariantLoads.h
index d3714f687..1a841e76b 100644
--- a/lgc/include/lgc/patch/PatchInvariantLoads.h
+++ b/lgc/include/lgc/patch/PatchInvariantLoads.h
@@ -40,29 +40,11 @@ namespace lgc {
 // Represents the pass of LLVM patching operations for image operations
 class PatchInvariantLoads : public llvm::PassInfoMixin<PatchInvariantLoads> {
 public:
   llvm::PreservedAnalyses run(llvm::Function &function, llvm::FunctionAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Function &function, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch metadata for invariant loads"; }
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for image operations
-class LegacyPatchInvariantLoads : public llvm::FunctionPass {
-public:
-  LegacyPatchInvariantLoads();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-  bool runOnFunction(llvm::Function &function) override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchInvariantLoads(const LegacyPatchInvariantLoads &) = delete;
-  LegacyPatchInvariantLoads &operator=(const LegacyPatchInvariantLoads &) = delete;
-
-  PatchInvariantLoads m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchLlvmIrInclusion.h b/lgc/include/lgc/patch/PatchLlvmIrInclusion.h
index 539c8c49a..66b4d60d3 100644
--- a/lgc/include/lgc/patch/PatchLlvmIrInclusion.h
+++ b/lgc/include/lgc/patch/PatchLlvmIrInclusion.h
@@ -39,30 +39,11 @@ namespace lgc {
 // Represents the pass of LLVM patch operations of including LLVM IR as a separate section in the ELF binary.
 class PatchLlvmIrInclusion : public Patch, public llvm::PassInfoMixin<PatchLlvmIrInclusion> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Include LLVM IR as a separate section in the ELF binary"; }
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patch operations of including LLVM IR as a separate section in the ELF binary.
-class LegacyPatchLlvmIrInclusion : public LegacyPatch {
-public:
-  LegacyPatchLlvmIrInclusion();
-
-  bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override { analysisUsage.setPreservesAll(); }
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchLlvmIrInclusion(const LegacyPatchLlvmIrInclusion &) = delete;
-  LegacyPatchLlvmIrInclusion &operator=(const LegacyPatchLlvmIrInclusion &) = delete;
-
-  PatchLlvmIrInclusion m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchLoadScalarizer.h b/lgc/include/lgc/patch/PatchLoadScalarizer.h
index 80f8f9db5..2b6b863f5 100644
--- a/lgc/include/lgc/patch/PatchLoadScalarizer.h
+++ b/lgc/include/lgc/patch/PatchLoadScalarizer.h
@@ -52,29 +52,11 @@ public:
   static llvm::StringRef name() { return "Patch LLVM for load scalarizer optimization"; }
 
   void visitLoadInst(llvm::LoadInst &loadInst);
 
 private:
   llvm::SmallVector<llvm::Instruction *, 8> m_instsToErase; // Instructions to erase
   std::unique_ptr<llvm::IRBuilder<>> m_builder;             // The IRBuilder.
   unsigned m_scalarThreshold;                               // The threshold for load scalarizer
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for scalarize load.
-class LegacyPatchLoadScalarizer final : public llvm::FunctionPass {
-public:
-  explicit LegacyPatchLoadScalarizer();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-  bool runOnFunction(llvm::Function &function) override;
-
-  static char ID; // NOLINT
-
-private:
-  LegacyPatchLoadScalarizer(const LegacyPatchLoadScalarizer &) = delete;
-  LegacyPatchLoadScalarizer &operator=(const LegacyPatchLoadScalarizer &) = delete;
-
-  PatchLoadScalarizer m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchLoopMetadata.h b/lgc/include/lgc/patch/PatchLoopMetadata.h
index 1565cb07b..1085566e0 100644
--- a/lgc/include/lgc/patch/PatchLoopMetadata.h
+++ b/lgc/include/lgc/patch/PatchLoopMetadata.h
@@ -55,29 +55,11 @@ public:
 private:
   llvm::LLVMContext *m_context;       // Associated LLVM context of the LLVM module that passes run on
   unsigned m_forceLoopUnrollCount;    // Force loop unroll count
   bool m_disableLoopUnroll;           // Forcibly disable loop unroll
   unsigned m_disableLicmThreshold;    // Disable LLVM LICM pass loop block count threshold
   unsigned m_unrollHintThreshold;     // Unroll hint threshold
   unsigned m_dontUnrollHintThreshold; // DontUnroll hint threshold
   GfxIpVersion m_gfxIp;
 };
 
-// =====================================================================================================================
-// Represents the LLVM pass for patching loop metadata.
-class LegacyPatchLoopMetadata : public llvm::LoopPass {
-public:
-  LegacyPatchLoopMetadata();
-
-  bool runOnLoop(llvm::Loop *loop, llvm::LPPassManager &loopPassMgr) override;
-
-  static char ID; // ID of this pass
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-private:
-  PatchLoopMetadata m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchPeepholeOpt.h b/lgc/include/lgc/patch/PatchPeepholeOpt.h
index 757026438..145434ad7 100644
--- a/lgc/include/lgc/patch/PatchPeepholeOpt.h
+++ b/lgc/include/lgc/patch/PatchPeepholeOpt.h
@@ -51,34 +51,11 @@ public:
   bool runImpl(llvm::Function &function);
 
   static llvm::StringRef name() { return "Patch LLVM for peephole optimizations"; }
 
   void visitIntToPtr(llvm::IntToPtrInst &intToPtr);
 
 private:
   llvm::SmallVector<llvm::Instruction *, 8> m_instsToErase;
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for peephole optimizations, with the following patterns covered:
-//
-// - Change inttoptr ( add x, const ) -> gep ( inttoptr x, const ) to improve value tracking and load/store
-//   vectorization.
-//
-class LegacyPatchPeepholeOpt final : public llvm::FunctionPass {
-public:
-  LegacyPatchPeepholeOpt();
-
-  bool runOnFunction(llvm::Function &function) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchPeepholeOpt(const LegacyPatchPeepholeOpt &) = delete;
-  LegacyPatchPeepholeOpt &operator=(const LegacyPatchPeepholeOpt &) = delete;
-
-  PatchPeepholeOpt m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchPreparePipelineAbi.h b/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
index 4c3e2df5b..603b94f42 100644
--- a/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
+++ b/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
@@ -83,32 +83,11 @@ private:
   bool m_hasVs;   // Whether the pipeline has vertex shader
   bool m_hasTcs;  // Whether the pipeline has tessellation control shader
   bool m_hasTes;  // Whether the pipeline has tessellation evaluation shader
   bool m_hasGs;   // Whether the pipeline has geometry shader
   bool m_hasTask; // Whether the pipeline has task shader
   bool m_hasMesh; // Whether the pipeline has mesh shader
 
   GfxIpVersion m_gfxIp; // Graphics IP version info
 };
 
-// =====================================================================================================================
-// Pass to prepare the pipeline ABI
-class LegacyPatchPreparePipelineAbi final : public llvm::ModulePass {
-public:
-  static char ID; // NOLINT
-  LegacyPatchPreparePipelineAbi();
-
-  bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-  }
-
-private:
-  LegacyPatchPreparePipelineAbi(const LegacyPatchPreparePipelineAbi &) = delete;
-  LegacyPatchPreparePipelineAbi &operator=(const LegacyPatchPreparePipelineAbi &) = delete;
-
-  PatchPreparePipelineAbi m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchReadFirstLane.h b/lgc/include/lgc/patch/PatchReadFirstLane.h
index 7fbb13dfa..89ca6f065 100644
--- a/lgc/include/lgc/patch/PatchReadFirstLane.h
+++ b/lgc/include/lgc/patch/PatchReadFirstLane.h
@@ -24,23 +24,28 @@
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  PatchReadFirstLane.h
  * @brief LLPC header file: contains declaration of class lgc::PatchReadFirstLane.
  ***********************************************************************************************************************
  */
 #pragma once
 
 #include "lgc/util/BuilderBase.h"
-#include "llvm/Analysis/LegacyDivergenceAnalysis.h"
 #include "llvm/IR/PassManager.h"
 
+namespace llvm {
+
+class TargetTransformInfo;
+
+} // namespace llvm
+
 namespace lgc {
 
 class PatchReadFirstLane final : public llvm::PassInfoMixin<PatchReadFirstLane> {
 public:
   PatchReadFirstLane();
   llvm::PreservedAnalyses run(llvm::Function &function, llvm::FunctionAnalysisManager &analysisManager);
 
   // NOTE: Once the switch to the new pass manager is completed, the isDivergentUse and TTI arguments can be removed and
   // put back as class attributes.
   bool runImpl(llvm::Function &function, std::function<bool(const llvm::Use &)> isDivergentUse,
diff --git a/lgc/include/lgc/patch/PatchResourceCollect.h b/lgc/include/lgc/patch/PatchResourceCollect.h
index 6ae062175..268745c23 100644
--- a/lgc/include/lgc/patch/PatchResourceCollect.h
+++ b/lgc/include/lgc/patch/PatchResourceCollect.h
@@ -110,43 +110,20 @@ private:
   std::vector<llvm::CallInst *> m_outputCalls;         // The output export calls
 
   ResourceUsage *m_resUsage; // Pointer to shader resource usage
   std::unique_ptr<InOutLocationInfoMapManager>
       m_locationInfoMapManager; // Pointer to InOutLocationInfoMapManager instance
 
   bool m_tcsInputHasDynamicIndexing = false; // Whether there is a dynamically indexed TCS input.
   bool m_processMissingFs = false;           // Whether to process a missing FS (part-pipeline compilation).
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for resource collecting
-class LegacyPatchResourceCollect : public llvm::ModulePass {
-public:
-  LegacyPatchResourceCollect();
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    analysisUsage.addPreserved<LegacyPipelineShaders>();
-  }
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchResourceCollect(const LegacyPatchResourceCollect &) = delete;
-  LegacyPatchResourceCollect &operator=(const LegacyPatchResourceCollect &) = delete;
-
-  PatchResourceCollect m_impl;
-};
-
 // Represents the compatibility info of input/output
 union InOutCompatibilityInfo {
   struct {
     uint16_t halfComponentCount : 9; // The number of components measured in times of 16-bits.
                                      // A single 32-bit component will be halfComponentCount=2
     uint16_t is16Bit : 1;            // 16-bit (i8/i16/f16, i8 is treated as 16-bit) or not
   };
   uint16_t u16All;
 };
 
diff --git a/lgc/include/lgc/patch/PatchWaveSizeAdjust.h b/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
index a1b6fc6a0..2263920b2 100644
--- a/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
+++ b/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
@@ -44,34 +44,11 @@ public:
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch LLVM for per-shader wave size adjustment"; }
 #if LLPC_BUILD_GFX11
 private:
   bool is16BitArithmeticOp(llvm::Instruction *inst);
 #endif
 };
 
-// =====================================================================================================================
-// Pass to adjust wave size per shader stage heuristically.
-class LegacyPatchWaveSizeAdjust final : public llvm::ModulePass {
-public:
-  LegacyPatchWaveSizeAdjust();
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineShaders>();
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-    analysisUsage.setPreservesAll();
-  }
-
-  bool runOnModule(llvm::Module &module) override;
-
-  static char ID;
-
-private:
-  LegacyPatchWaveSizeAdjust(const LegacyPatchWaveSizeAdjust &) = delete;
-  LegacyPatchWaveSizeAdjust &operator=(const LegacyPatchWaveSizeAdjust &) = delete;
-
-  PatchWaveSizeAdjust m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchWorkarounds.h b/lgc/include/lgc/patch/PatchWorkarounds.h
index 5fec1e0b2..34594d603 100644
--- a/lgc/include/lgc/patch/PatchWorkarounds.h
+++ b/lgc/include/lgc/patch/PatchWorkarounds.h
@@ -60,32 +60,11 @@ private:
   PipelineState *m_pipelineState;               // The pipeline state
 
   llvm::SmallPtrSet<llvm::Value *, 8> m_processed; // Track rsrc-desc args already processed
 
   bool m_changed;
 
   void applyImageDescWorkaround(void);
   void processImageDescWorkaround(llvm::CallInst &callInst, bool isLastUse);
 };
 
-// =====================================================================================================================
-// Represents the pass of LLVM patching operations for applying workarounds:
-//
-// - fix up issues when buffer descriptor is incorrectly given when it should be an image descriptor. Some architectures
-//   require a fix so the hardware will ignore this difference (actually an app error, but common enough to require
-//   handling)
-//
-class LegacyPatchWorkarounds final : public llvm::ModulePass {
-public:
-  LegacyPatchWorkarounds();
-
-  bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override;
-
-  static char ID; // ID of this pass
-
-private:
-  PatchWorkarounds m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/VertexFetch.h b/lgc/include/lgc/patch/VertexFetch.h
index 721985ead..6a4dc52cb 100644
--- a/lgc/include/lgc/patch/VertexFetch.h
+++ b/lgc/include/lgc/patch/VertexFetch.h
@@ -58,30 +58,11 @@ public:
 // Pass to lower vertex fetch calls
 class LowerVertexFetch : public llvm::PassInfoMixin<LowerVertexFetch> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Lower vertex fetch calls"; }
 };
 
-// =====================================================================================================================
-// Pass to lower vertex fetch calls
-class LegacyLowerVertexFetch : public llvm::ModulePass {
-public:
-  LegacyLowerVertexFetch();
-  LegacyLowerVertexFetch(const LegacyLowerVertexFetch &) = delete;
-  LegacyLowerVertexFetch &operator=(const LegacyLowerVertexFetch &) = delete;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  virtual bool runOnModule(llvm::Module &module) override;
-
-  static char ID; // ID of this pass
-private:
-  LowerVertexFetch m_impl;
-};
-
 } // namespace lgc
diff --git a/lgc/include/lgc/state/PipelineShaders.h b/lgc/include/lgc/state/PipelineShaders.h
index ccd032474..21e69cc49 100644
--- a/lgc/include/lgc/state/PipelineShaders.h
+++ b/lgc/include/lgc/state/PipelineShaders.h
@@ -53,34 +53,11 @@ private:
 // =====================================================================================================================
 // Simple analysis pass that finds the shaders in the pipeline module
 class PipelineShaders : public llvm::AnalysisInfoMixin<PipelineShaders> {
 public:
   using Result = PipelineShadersResult;
   PipelineShadersResult run(llvm::Module &module, llvm::ModuleAnalysisManager &);
   PipelineShadersResult runImpl(llvm::Module &module);
   static llvm::AnalysisKey Key;
 };
 
-// =====================================================================================================================
-// Simple analysis pass that finds the shaders in the pipeline module
-class LegacyPipelineShaders : public llvm::ModulePass {
-public:
-  static char ID;
-  LegacyPipelineShaders() : llvm::ModulePass(ID) {}
-
-  PipelineShadersResult &getResult() { return m_result; }
-
-  bool runOnModule(llvm::Module &module) override;
-
-  void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override { analysisUsage.setPreservesAll(); }
-
-private:
-  LegacyPipelineShaders(const LegacyPipelineShaders &) = delete;
-  LegacyPipelineShaders &operator=(const LegacyPipelineShaders &) = delete;
-
-  PipelineShaders m_impl;
-  PipelineShadersResult m_result;
-};
-
-llvm::ModulePass *createLegacyPipelineShaders();
-
 } // namespace lgc
diff --git a/lgc/include/lgc/state/PipelineState.h b/lgc/include/lgc/state/PipelineState.h
index abfba4bb2..42b4dc7f9 100644
--- a/lgc/include/lgc/state/PipelineState.h
+++ b/lgc/include/lgc/state/PipelineState.h
@@ -38,49 +38,32 @@
 #include "lgc/state/ShaderStage.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/PassManager.h"
 #include "llvm/Pass.h"
 #include <map>
 
 namespace llvm {
 
 class MDString;
-class ModulePass;
 class NamedMDNode;
-class PassRegistry;
 class Timer;
 
-void initializeLegacyPipelineShadersPass(PassRegistry &);
-void initializeLegacyPipelineStateClearerPass(PassRegistry &);
-void initializeLegacyPipelineStateWrapperPass(PassRegistry &);
-
 } // namespace llvm
 
 namespace lgc {
 
 class ElfLinker;
 class PalMetadata;
 class PipelineState;
 class TargetInfo;
 
-llvm::ModulePass *createLegacyPipelineStateClearer();
-
-// Initialize passes in state directory
-//
-// @param passRegistry : Pass registry
-inline static void initializeStatePasses(llvm::PassRegistry &passRegistry) {
-  initializeLegacyPipelineShadersPass(passRegistry);
-  initializeLegacyPipelineStateClearerPass(passRegistry);
-  initializeLegacyPipelineStateWrapperPass(passRegistry);
-}
-
 // Resource node type used to ask to find any buffer node, whether constant or not.
 static constexpr ResourceNodeType DescriptorAnyBuffer = ResourceNodeType::Count;
 
 // =====================================================================================================================
 // Represents NGG (implicit primitive shader) control settings (valid for GFX10+)
 
 // Enumerates compaction modes after culling operations for NGG primitive shader.
 enum NggCompactMode : unsigned {
   NggCompactDisable,  // Compaction is disabled
   NggCompactVertices, // Compaction is based on vertices
@@ -173,22 +156,21 @@ public:
   void setDepthStencilState(const DepthStencilState &dsState) override final;
 
   // Set the finalized 128-bit cache hash that is used to find this pipeline in the cache for the given version of LLPC.
   void set128BitCacheHash(const Hash128 &finalizedCacheHash, const llvm::VersionTuple &version) override final;
 
   // Link the individual shader IR modules into a single pipeline module
   llvm::Module *irLink(llvm::ArrayRef<llvm::Module *> modules, PipelineLink pipelineLink) override final;
 
   // Generate pipeline module
   bool generate(std::unique_ptr<llvm::Module> pipelineModule, llvm::raw_pwrite_stream &outStream,
-                CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers,
-                bool newPassManager) override final;
+                CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers) override final;
 
   // Create an ELF linker object for linking unlinked shader/part-pipeline ELFs into a pipeline ELF using the
   // pipeline state
   ElfLinker *createElfLinker(llvm::ArrayRef<llvm::MemoryBufferRef> elfs) override final;
 
   // Do an early check for ability to use unlinked shader compilation then ELF linking.
   bool checkElfLinkable() override final;
 
   // Get a textual error message for the last recoverable error
   llvm::StringRef getLastError() override final;
@@ -473,31 +455,20 @@ public:
   // @param [out] value : Value to write into (caller must zero initialize)
   template <typename T>
   static unsigned readNamedMetadataArrayOfInt32(llvm::Module *module, llvm::StringRef metaName, T &value) {
     auto namedMetaNode = module->getNamedMetadata(metaName);
     if (!namedMetaNode || namedMetaNode->getNumOperands() == 0)
       return 0;
     return readArrayOfInt32MetaNode(namedMetaNode->getOperand(0), value);
   }
 
 private:
-  // NOTE: These two functions are temporarily used to generate pipeline modules
-  // with and without using the new pass manager. Once the switch to the new pass
-  // manager is done, these functions will be removed and we'll use a single
-  // generate function.
-  // Generate pipeline module
-  void generateWithNewPassManager(std::unique_ptr<llvm::Module> pipelineModule, llvm::raw_pwrite_stream &outStream,
-                                  CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers);
-  // Generate pipeline module
-  void generateWithLegacyPassManager(std::unique_ptr<llvm::Module> pipelineModule, llvm::raw_pwrite_stream &outStream,
-                                     CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers);
-
   // Read shaderStageMask from IR
   void readShaderStageMask(llvm::Module *module);
 
   // Options handling
   void recordOptions(llvm::Module *module);
   void readOptions(llvm::Module *module);
 
   // User data nodes handling
   void setUserDataNodesTable(llvm::ArrayRef<ResourceNode> nodes, ResourceNode *destTable,
                              ResourceNode *&destInnerTable);
@@ -587,42 +558,20 @@ public:
   PipelineStateWrapper(PipelineState *pipelineState);
   Result run(llvm::Module &module, llvm::ModuleAnalysisManager &);
   static llvm::AnalysisKey Key; // NOLINT
 
 private:
   LgcContext *m_builderContext = nullptr;                  // LgcContext for allocating PipelineState
   PipelineState *m_pipelineState = nullptr;                // Cached pipeline state
   std::unique_ptr<PipelineState> m_allocatedPipelineState; // Pipeline state allocated by this pass
 };
 
-// =====================================================================================================================
-// Wrapper pass for the pipeline state in the middle-end
-class LegacyPipelineStateWrapper : public llvm::ImmutablePass {
-public:
-  LegacyPipelineStateWrapper(LgcContext *builderContext = nullptr);
-
-  bool doFinalization(llvm::Module &module) override;
-
-  // Get (create if necessary) the PipelineState from this wrapper pass.
-  PipelineState *getPipelineState(llvm::Module *module);
-
-  // Set the PipelineState.
-  void setPipelineState(PipelineState *pipelineState) { m_pipelineState = pipelineState; }
-
-  static char ID; // ID of this pass
-
-private:
-  LgcContext *m_builderContext = nullptr;                  // LgcContext for allocating PipelineState
-  PipelineState *m_pipelineState = nullptr;                // Cached pipeline state
-  std::unique_ptr<PipelineState> m_allocatedPipelineState; // Pipeline state allocated by this pass
-};
-
 // =====================================================================================================================
 // Pass to clear pipeline state out of the IR
 class PipelineStateClearer : public llvm::PassInfoMixin<PipelineStateClearer> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "LLPC pipeline state clearer"; }
 };
 
diff --git a/lgc/interface/lgc/LgcContext.h b/lgc/interface/lgc/LgcContext.h
index 6d00a32d3..5280558ad 100644
--- a/lgc/interface/lgc/LgcContext.h
+++ b/lgc/interface/lgc/LgcContext.h
@@ -35,26 +35,20 @@
 #include "llvm/Support/raw_ostream.h"
 
 namespace llvm {
 
 class LLVMContext;
 class ModulePass;
 class raw_pwrite_stream;
 class TargetMachine;
 class Timer;
 
-namespace legacy {
-
-class PassManager;
-
-} // namespace legacy
-
 } // namespace llvm
 
 namespace lgc {
 
 class Builder;
 class LegacyPassManager;
 class PassManager;
 class PassManagerCache;
 class Pipeline;
 class TargetInfo;
@@ -109,26 +103,20 @@ public:
   unsigned getPalAbiVersion() const { return m_palAbiVersion; }
 
   // Create a Pipeline object for a pipeline compile
   Pipeline *createPipeline();
 
   // Create a Builder object
   //
   // @param pipeline : Pipeline object for pipeline compile, nullptr for shader compile
   Builder *createBuilder(Pipeline *pipeline);
 
-  // Prepare a legacy pass manager. This manually adds a target-aware TLI pass, so middle-end optimizations do not
-  // think that we have library functions.
-  //
-  // @param [in/out] passMgr : Pass manager
-  void preparePassManager(llvm::legacy::PassManager *passMgr);
-
   // Prepare a pass manager. This manually adds a target-aware TLI pass, so middle-end optimizations do not
   // think that we have library functions.
   //
   // @param [in/out] passMgr : Pass manager
   void preparePassManager(lgc::PassManager &passMgr);
 
   // Adds target passes to pass manager, depending on "-filetype" and "-emit-llvm" options
   void addTargetPasses(lgc::LegacyPassManager &passMgr, llvm::Timer *codeGenTimer, llvm::raw_pwrite_stream &outStream);
 
   // Returns the optimization level for the context.
diff --git a/lgc/interface/lgc/Pipeline.h b/lgc/interface/lgc/Pipeline.h
index 394b8eb10..26f1e1013 100644
--- a/lgc/interface/lgc/Pipeline.h
+++ b/lgc/interface/lgc/Pipeline.h
@@ -795,30 +795,27 @@ public:
   // Like other LGC and LLVM library functions, an internal compiler error could cause an assert or report_fatal_error.
   //
   // @param pipelineModule : IR pipeline module
   // @param [in/out] outStream : Stream to write ELF or IR disassembly output
   // @param checkShaderCacheFunc : Function to check shader cache in graphics pipeline
   // @param timers : Optional timers for 0 or more of:
   //                 timers[0]: patch passes
   //                 timers[1]: LLVM optimizations
   //                 timers[2]: codegen
   // @param otherElf : Optional ELF for the other part-pipeline when compiling an unlinked part-pipeline ELF.
-  // @param newPassManager : Whether to use the new pass manager or not
   // @returns : True for success.
   //           False if irLink asked for an "unlinked" shader or part-pipeline, and there is some reason why the
   //           module cannot be compiled that way.  The client typically then does a whole-pipeline compilation
   //           instead. The client can call getLastError() to get a textual representation of the error, for
   //           use in logging or in error reporting in a command-line utility.
-  // NOTE: The newPassManager argument will be removed once the switch to the new pass manager is completed.
   virtual bool generate(std::unique_ptr<llvm::Module> pipelineModule, llvm::raw_pwrite_stream &outStream,
-                        CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers,
-                        bool newPassManager) = 0;
+                        CheckShaderCacheFunc checkShaderCacheFunc, llvm::ArrayRef<llvm::Timer *> timers) = 0;
 
   // Create an ELF linker object for linking unlinked shader or part-pipeline ELFs into a pipeline ELF using
   // the pipeline state. This needs to be deleted after use.
   virtual ElfLinker *createElfLinker(llvm::ArrayRef<llvm::MemoryBufferRef> elfs) = 0;
 
   // Get a textual error message for the last recoverable error caused by generate() or one of the ElfLinker
   // methods finding something about the shaders or pipeline state that means that shader compilation then
   // linking cannot be done. This error message is intended only for logging or command-line error reporting.
   //
   // @returns : Error message from last such recoverable error; remains valid until next time generate() or
diff --git a/lgc/patch/FragColorExport.cpp b/lgc/patch/FragColorExport.cpp
index bb05de129..da0534523 100644
--- a/lgc/patch/FragColorExport.cpp
+++ b/lgc/patch/FragColorExport.cpp
@@ -54,24 +54,20 @@ namespace lgc {
 // @param context : LLVM context
 // @param pipelineState : Pipeline state
 FragColorExport::FragColorExport(LLVMContext *context, PipelineState *pipelineState)
     : m_context(context), m_pipelineState(pipelineState) {
 }
 
 // =====================================================================================================================
 LowerFragColorExport::LowerFragColorExport() : m_exportValues(MaxColorTargets + 1, nullptr) {
 }
 
-// =====================================================================================================================
-LegacyLowerFragColorExport::LegacyLowerFragColorExport() : ModulePass(ID) {
-}
-
 // =====================================================================================================================
 // Extract all the scalar elements of a scalar or vector type (with at-most four elements) input. Return an array of
 // elements, padded with null values at the end when the input vector has less than 4 elements.
 //
 // @param input : The value we want to extract elements from
 // @param builder : The IR builder for inserting instructions
 // @param [out] results : The returned elements
 static void extractElements(Value *input, BuilderBase &builder, SmallVectorImpl<Value *> &results) {
   Type *valueTy = input->getType();
   unsigned compCount = valueTy->isVectorTy() ? cast<FixedVectorType>(valueTy)->getNumElements() : 1;
@@ -428,39 +424,20 @@ Value *FragColorExport::convertToInt(Value *value, bool signedness, BuilderBase
       // %value = bitcast float %value to i32
       value = builder.CreateBitCast(value, int32Ty);
     }
   }
 
   return value;
 }
 
 } // namespace lgc
 
-char LegacyLowerFragColorExport::ID = 0;
-
-// =====================================================================================================================
-// Create the color export pass
-ModulePass *lgc::createLegacyLowerFragColorExport() {
-  return new LegacyLowerFragColorExport();
-}
-
-// =====================================================================================================================
-// Run the lower color export pass on a module
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyLowerFragColorExport::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  return m_impl.runImpl(module, pipelineShaders, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the lower color export pass on a module
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses LowerFragColorExport::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   if (runImpl(module, pipelineShaders, pipelineState))
@@ -1027,14 +1004,10 @@ Function *FragColorExport::generateNullFragmentEntryPoint(Module &module, String
 
 // =====================================================================================================================
 // Generate the body of the null fragment shader.
 //
 // @param [in/out] entryPoint : The function in which the code will be inserted.
 void FragColorExport::generateNullFragmentShaderBody(llvm::Function *entryPoint) {
   BasicBlock *block = BasicBlock::Create(entryPoint->getContext(), "", entryPoint);
   BuilderBase builder(block);
   builder.CreateRetVoid();
 }
-
-// =====================================================================================================================
-// Initialize the lower fragment color export pass
-INITIALIZE_PASS(LegacyLowerFragColorExport, DEBUG_TYPE, "Lower fragment color export calls", false, false)
diff --git a/lgc/patch/Patch.cpp b/lgc/patch/Patch.cpp
index 961a453c4..1fb102e1b 100644
--- a/lgc/patch/Patch.cpp
+++ b/lgc/patch/Patch.cpp
@@ -51,21 +51,20 @@
 #include "lgc/patch/PatchReadFirstLane.h"
 #include "lgc/patch/PatchResourceCollect.h"
 #include "lgc/patch/PatchSetupTargetFeatures.h"
 #include "lgc/patch/PatchWaveSizeAdjust.h"
 #include "lgc/patch/PatchWorkarounds.h"
 #include "lgc/patch/VertexFetch.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "lgc/util/Debug.h"
 #include "llvm/IR/IRPrintingPasses.h"
-#include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
 #if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
 // Old version of the code
 #else
 // New version of the code (also handles unknown version, which we treat as latest)
 #include "llvm/IRPrinter/IRPrintingPasses.h"
 #endif
 #include "llvm/Passes/PassBuilder.h"
 #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
 #include "llvm/Transforms/IPO.h"
@@ -320,180 +319,20 @@ void Patch::registerPasses(PassBuilder &passBuilder) {
 #define LLPC_LOOP_PASS_WITH_PARSER HANDLE_PASS_WITH_PARSER
 #include "PassRegistry.inc"
 
         return false;
       });
 
 #undef HANDLE_PASS
 #undef HANDLE_PASS_WITH_PARSER
 }
 
-// =====================================================================================================================
-// Add whole-pipeline patch passes to pass manager
-//
-// @param pipelineState : Pipeline state
-// @param [in/out] passMgr : Pass manager to add passes to
-// @param replayerPass : BuilderReplayer pass, or nullptr if not needed
-// @param patchTimer : Timer to time patch passes with, nullptr if not timing
-// @param optTimer : Timer to time LLVM optimization passes with, nullptr if not timing
-// @param checkShaderCacheFunc : Callback function to check shader cache
-// @param optLevel : The optimization level uses to adjust the aggressiveness of
-//                   passes and which passes to add.
-void LegacyPatch::addPasses(PipelineState *pipelineState, legacy::PassManager &passMgr, ModulePass *replayerPass,
-                            Timer *patchTimer, Timer *optTimer, Pipeline::CheckShaderCacheFunc checkShaderCacheFunc,
-                            CodeGenOpt::Level optLevel)
-// Callback function to check shader cache
-{
-  // Start timer for patching passes.
-  if (patchTimer)
-    passMgr.add(LgcContext::createStartStopTimer(patchTimer, true));
-
-  // If using BuilderRecorder rather than BuilderImpl, replay the Builder calls now
-  if (replayerPass)
-    passMgr.add(replayerPass);
-
-  if (raw_ostream *outs = getLgcOuts()) {
-    passMgr.add(
-        createPrintModulePass(*outs, "===============================================================================\n"
-                                     "// LLPC pipeline before-patching results\n"));
-  }
-
-  // Build null fragment shader if necessary
-  passMgr.add(createLegacyPatchNullFragShader());
-
-  // Patch resource collecting, remove inactive resources (should be the first preliminary pass)
-  passMgr.add(createLegacyPatchResourceCollect());
-
-  // Patch wave size adjusting heuristic
-  passMgr.add(createLegacyPatchWaveSizeAdjust());
-
-  // Patch workarounds
-  passMgr.add(createLegacyPatchWorkarounds());
-
-  // Generate copy shader if necessary.
-  passMgr.add(createLegacyPatchCopyShader());
-
-  // Lower vertex fetch operations.
-  passMgr.add(createLegacyLowerVertexFetch());
-
-  // Lower fragment export operations.
-  passMgr.add(createLegacyLowerFragColorExport());
-
-  // Run IPSCCP before EntryPointMutate to avoid adding unnecessary arguments to an entry point.
-  passMgr.add(createIPSCCPPass());
-
-  // Patch entry-point mutation (should be done before external library link)
-  passMgr.add(createLegacyPatchEntryPointMutate());
-
-  // Patch workgroup memory initialization.
-  passMgr.add(createLegacyPatchInitializeWorkgroupMemory());
-
-  // Patch input import and output export operations
-  passMgr.add(createLegacyPatchInOutImportExport());
-
-  // Prior to general optimization, do function inlining and dead function removal
-  passMgr.add(createAlwaysInlinerLegacyPass());
-  passMgr.add(createGlobalDCEPass());
-
-  // Patch invariant load metadata before optimizations.
-  passMgr.add(createLegacyPatchInvariantLoads());
-
-  // Patch loop metadata
-  passMgr.add(createLegacyPatchLoopMetadata());
-
-  // Check shader cache
-  auto checkShaderCachePass = createLegacyPatchCheckShaderCache();
-  passMgr.add(checkShaderCachePass);
-  checkShaderCachePass->setCallbackFunction(std::move(checkShaderCacheFunc));
-
-  // Stop timer for patching passes and start timer for optimization passes.
-  if (patchTimer) {
-    passMgr.add(LgcContext::createStartStopTimer(patchTimer, false));
-    passMgr.add(LgcContext::createStartStopTimer(optTimer, true));
-  }
-
-  // Add some optimization passes
-  addOptimizationPasses(passMgr, optLevel);
-
-  // Stop timer for optimization passes and restart timer for patching passes.
-  if (patchTimer) {
-    passMgr.add(LgcContext::createStartStopTimer(optTimer, false));
-    passMgr.add(LgcContext::createStartStopTimer(patchTimer, true));
-  }
-
-  // Patch buffer operations (must be after optimizations)
-  passMgr.add(createLegacyPatchBufferOp());
-  passMgr.add(createInstructionCombiningPass(2));
-
-#if LLPC_BUILD_GFX11
-  // Collect image operations
-  passMgr.add(createLegacyPatchImageOpCollect());
-#endif
-
-  // Fully prepare the pipeline ABI (must be after optimizations)
-  passMgr.add(createLegacyPatchPreparePipelineAbi());
-
-#if LLPC_BUILD_GFX11
-  const bool canUseNgg = pipelineState->isGraphics() &&
-                         ((pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
-                           (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0) ||
-                          pipelineState->getTargetInfo().getGfxIpVersion().major >= 11); // Must enable NGG on GFX11+
-#else
-  const bool canUseNgg = pipelineState->isGraphics() && pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
-                         (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0;
-#endif
-  if (canUseNgg) {
-    // Stop timer for patching passes and restart timer for optimization passes.
-    if (patchTimer) {
-      passMgr.add(LgcContext::createStartStopTimer(patchTimer, false));
-      passMgr.add(LgcContext::createStartStopTimer(optTimer, true));
-    }
-
-    // Extra optimizations after NGG primitive shader creation
-    passMgr.add(createAlwaysInlinerLegacyPass());
-    passMgr.add(createGlobalDCEPass());
-    passMgr.add(createPromoteMemoryToRegisterPass());
-    passMgr.add(createAggressiveDCEPass());
-    passMgr.add(createInstructionCombiningPass());
-    passMgr.add(createCFGSimplificationPass());
-
-    // Stop timer for optimization passes and restart timer for patching passes.
-    if (patchTimer) {
-      passMgr.add(LgcContext::createStartStopTimer(optTimer, false));
-      passMgr.add(LgcContext::createStartStopTimer(patchTimer, true));
-    }
-  }
-
-  passMgr.add(createLegacyPatchImageDerivatives());
-
-  // Set up target features in shader entry-points.
-  // NOTE: Needs to be done after post-NGG function inlining, because LLVM refuses to inline something
-  // with conflicting attributes. Attributes could conflict on GFX10 because PatchSetupTargetFeatures
-  // adds a target feature to determine wave32 or wave64.
-  passMgr.add(createLegacyPatchSetupTargetFeatures());
-
-  // Include LLVM IR as a separate section in the ELF binary
-  if (pipelineState->getOptions().includeIr)
-    passMgr.add(createLegacyPatchLlvmIrInclusion());
-
-  // Stop timer for patching passes.
-  if (patchTimer)
-    passMgr.add(LgcContext::createStartStopTimer(patchTimer, false));
-
-  // Dump the result
-  if (raw_ostream *outs = getLgcOuts()) {
-    passMgr.add(
-        createPrintModulePass(*outs, "===============================================================================\n"
-                                     "// LLPC pipeline patching results\n"));
-  }
-}
-
 // =====================================================================================================================
 // Add optimization passes to pass manager
 //
 // @param [in/out] passMgr : Pass manager to add passes to
 // @param optLevel : The optimization level uses to adjust the aggressiveness of
 //                   passes and which passes to add.
 void Patch::addOptimizationPasses(lgc::PassManager &passMgr, CodeGenOpt::Level optLevel) {
   LLPC_OUTS("PassManager optimization level = " << optLevel << "\n");
 
   passMgr.addPass(ForceFunctionAttrsPass());
@@ -549,79 +388,20 @@ void Patch::addOptimizationPasses(lgc::PassManager &passMgr, CodeGenOpt::Level o
   fpm.addPass(PatchReadFirstLane());
   fpm.addPass(InstCombinePass(1));
   passMgr.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
   passMgr.addPass(ConstantMergePass());
   FunctionPassManager fpm2;
   fpm2.addPass(DivRemPairsPass());
   fpm2.addPass(SimplifyCFGPass());
   passMgr.addPass(createModuleToFunctionPassAdaptor(std::move(fpm2)));
 }
 
-// =====================================================================================================================
-// Add optimization passes to pass manager
-//
-// @param [in/out] passMgr : Pass manager to add passes to
-// @param optLevel : The optimization level uses to adjust the aggressiveness of
-//                   passes and which passes to add.
-void LegacyPatch::addOptimizationPasses(legacy::PassManager &passMgr, CodeGenOpt::Level optLevel) {
-  LLPC_OUTS("PassManager optimization level = " << optLevel << "\n");
-
-  passMgr.add(createForceFunctionAttrsLegacyPass());
-  passMgr.add(createInstructionCombiningPass(1));
-  passMgr.add(createCFGSimplificationPass());
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
-  // Old version of the code
-  passMgr.add(createSROAPass());
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
-  passMgr.add(createSROAPass(false));
-#endif
-  passMgr.add(createEarlyCSEPass(true));
-  passMgr.add(createSpeculativeExecutionIfHasBranchDivergencePass());
-  passMgr.add(createCorrelatedValuePropagationPass());
-  passMgr.add(createCFGSimplificationPass());
-  passMgr.add(createInstructionCombiningPass(1));
-  passMgr.add(createLegacyPatchPeepholeOpt());
-  passMgr.add(createCFGSimplificationPass());
-  passMgr.add(createReassociatePass());
-  passMgr.add(createLoopRotatePass());
-  passMgr.add(createLICMPass());
-  passMgr.add(createCFGSimplificationPass());
-  passMgr.add(createInstructionCombiningPass(1));
-  passMgr.add(createIndVarSimplifyPass());
-  passMgr.add(createLoopIdiomPass());
-  passMgr.add(createLoopDeletionPass());
-  passMgr.add(createSimpleLoopUnrollPass(optLevel));
-  passMgr.add(createScalarizerPass());
-  passMgr.add(createLegacyPatchLoadScalarizer());
-  passMgr.add(createInstSimplifyLegacyPass());
-  passMgr.add(createNewGVNPass());
-  passMgr.add(createBitTrackingDCEPass());
-  passMgr.add(createInstructionCombiningPass(1));
-  passMgr.add(createCorrelatedValuePropagationPass());
-  passMgr.add(createAggressiveDCEPass());
-  passMgr.add(createLoopRotatePass());
-  passMgr.add(createCFGSimplificationPass(SimplifyCFGOptions()
-                                              .bonusInstThreshold(1)
-                                              .forwardSwitchCondToPhi(true)
-                                              .convertSwitchToLookupTable(true)
-                                              .needCanonicalLoops(true)
-                                              .sinkCommonInsts(true)));
-  passMgr.add(createLoopUnrollPass(optLevel));
-  // uses DivergenceAnalysis
-  passMgr.add(createLegacyPatchReadFirstLane());
-  passMgr.add(createInstructionCombiningPass(1));
-  passMgr.add(createConstantMergePass());
-  passMgr.add(createDivRemPairsPass());
-  passMgr.add(createCFGSimplificationPass());
-}
-
 // =====================================================================================================================
 // Initializes the pass according to the specified module.
 //
 // NOTE: This function should be called at the beginning of "runOnModule()".
 //
 // @param module : LLVM module
 void Patch::init(Module *module) {
   m_module = module;
   m_context = &m_module->getContext();
   m_shaderStage = ShaderStageInvalid;
diff --git a/lgc/patch/PatchBufferOp.cpp b/lgc/patch/PatchBufferOp.cpp
index 8fac26363..2ab920c4b 100644
--- a/lgc/patch/PatchBufferOp.cpp
+++ b/lgc/patch/PatchBufferOp.cpp
@@ -29,73 +29,35 @@
  ***********************************************************************************************************************
  */
 #include "lgc/patch/PatchBufferOp.h"
 #include "lgc/Builder.h"
 #include "lgc/LgcContext.h"
 #include "lgc/state/IntrinsDefs.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/Analysis/DivergenceAnalysis.h"
-#include "llvm/Analysis/LegacyDivergenceAnalysis.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
 
 #define DEBUG_TYPE "lgc-patch-buffer-op"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchBufferOp::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching for buffer operations
-FunctionPass *createLegacyPatchBufferOp() {
-  return new LegacyPatchBufferOp();
-}
-
-// =====================================================================================================================
-LegacyPatchBufferOp::LegacyPatchBufferOp() : FunctionPass(ID) {
-}
-
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchBufferOp::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyDivergenceAnalysis>();
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  analysisUsage.addRequired<TargetTransformInfoWrapperPass>();
-  analysisUsage.addPreserved<TargetTransformInfoWrapperPass>();
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM function.
-//
-// @param [in/out] function : LLVM function to be run on
-// @returns : True if the function was modified by the transformation and false otherwise
-bool LegacyPatchBufferOp::runOnFunction(Function &function) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(function.getParent());
-  LegacyDivergenceAnalysis *divergenceAnalysis = &getAnalysis<LegacyDivergenceAnalysis>();
-  auto isDivergent = [divergenceAnalysis](const Value &value) { return divergenceAnalysis->isDivergent(&value); };
-  return m_impl.runImpl(function, pipelineState, isDivergent);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM function.
 //
 // @param [in/out] function : LLVM function to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchBufferOp::run(Function &function, FunctionAnalysisManager &analysisManager) {
   const auto &moduleAnalysisManager = analysisManager.getResult<ModuleAnalysisManagerFunctionProxy>(function);
   PipelineState *pipelineState =
       moduleAnalysisManager.getCachedResult<PipelineStateWrapper>(*function.getParent())->getPipelineState();
@@ -1810,17 +1772,10 @@ void PatchBufferOp::fixIncompletePhis() {
     if (phiNode->getType()->isVectorTy())
       // It is a buffer descriptor
       phiNode->setIncomingValueForBlock(incomingBlock, m_replacementMap[incoming].first);
     else
       // It is an index
       phiNode->setIncomingValueForBlock(incomingBlock, m_replacementMap[incoming].second);
   }
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch operations for buffer operations.
-INITIALIZE_PASS_BEGIN(LegacyPatchBufferOp, DEBUG_TYPE, "Patch LLVM for buffer operations", false, false)
-INITIALIZE_PASS_DEPENDENCY(LegacyDivergenceAnalysis)
-INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)
-INITIALIZE_PASS_END(LegacyPatchBufferOp, DEBUG_TYPE, "Patch LLVM for buffer operations", false, false)
diff --git a/lgc/patch/PatchCheckShaderCache.cpp b/lgc/patch/PatchCheckShaderCache.cpp
index cb92c6131..c027bd20c 100644
--- a/lgc/patch/PatchCheckShaderCache.cpp
+++ b/lgc/patch/PatchCheckShaderCache.cpp
@@ -31,34 +31,20 @@
 #include "lgc/patch/PatchCheckShaderCache.h"
 #include "lgc/CommonDefs.h"
 #include "lgc/state/PipelineShaders.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-check-shader-cache"
 
 using namespace llvm;
 using namespace lgc;
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchCheckShaderCache::ID = 0;
-
-namespace lgc {
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for checking shader cache
-LegacyPatchCheckShaderCache *createLegacyPatchCheckShaderCache() {
-  return new LegacyPatchCheckShaderCache();
-}
-
-} // namespace lgc
-
 namespace {
 
 // =====================================================================================================================
 // Stream each map key and value for later inclusion in a hash
 //
 // @param map : Map to stream
 // @param [in/out] stream : Stream to output map entries to
 template <class MapType> static void streamMapEntries(MapType &map, raw_ostream &stream) {
   size_t mapCount = map.size();
   stream << StringRef(reinterpret_cast<const char *>(&mapCount), sizeof(mapCount));
@@ -68,34 +54,20 @@ template <class MapType> static void streamMapEntries(MapType &map, raw_ostream
   }
 }
 
 } // namespace
 
 // =====================================================================================================================
 PatchCheckShaderCache::PatchCheckShaderCache(Pipeline::CheckShaderCacheFunc callbackFunc)
     : m_callbackFunc(std::move(callbackFunc)) {
 }
 
-// =====================================================================================================================
-LegacyPatchCheckShaderCache::LegacyPatchCheckShaderCache() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchCheckShaderCache::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchCheckShaderCache::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::none();
@@ -173,14 +145,10 @@ bool PatchCheckShaderCache::runImpl(Module &module, PipelineState *pipelineState
     if (isShaderEntryPoint(&func)) {
       auto stage = getShaderStage(&func);
       if (stage != ShaderStageInvalid && (shaderStageToMask(stage) & ~stagesLeftToCompile) != 0) {
         func.deleteBody();
         func.setDLLStorageClass(GlobalValue::DefaultStorageClass);
       }
     }
   }
   return true;
 }
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch operations for checking shader cache
-INITIALIZE_PASS(LegacyPatchCheckShaderCache, DEBUG_TYPE, "Patch LLVM for checking shader cache", false, false)
diff --git a/lgc/patch/PatchCopyShader.cpp b/lgc/patch/PatchCopyShader.cpp
index ddee1c6d4..8025a5aa7 100644
--- a/lgc/patch/PatchCopyShader.cpp
+++ b/lgc/patch/PatchCopyShader.cpp
@@ -49,43 +49,20 @@ namespace llvm {
 namespace cl {
 
 extern opt<bool> InRegEsGsLdsSize;
 
 } // namespace cl
 } // namespace llvm
 
 using namespace lgc;
 using namespace llvm;
 
-char LegacyPatchCopyShader::ID = 0;
-
-// =====================================================================================================================
-// Create pass to generate copy shader if required.
-ModulePass *lgc::createLegacyPatchCopyShader() {
-  return new LegacyPatchCopyShader();
-}
-
-// =====================================================================================================================
-LegacyPatchCopyShader::LegacyPatchCopyShader() : llvm::ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchCopyShader::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  return m_impl.runImpl(module, pipelineShaders, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchCopyShader::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   if (runImpl(module, pipelineShaders, pipelineState))
@@ -778,14 +755,10 @@ void PatchCopyShader::exportBuiltInOutput(Value *outputValue, BuiltInKind builtI
   }
 
   if (resUsage->inOutUsage.gs.rasterStream == streamId) {
     std::string callName = lgcName::OutputExportBuiltIn;
     callName += PipelineState::getBuiltInName(builtInId);
     Value *args[] = {builder.getInt32(builtInId), outputValue};
     addTypeMangling(nullptr, args, callName);
     builder.CreateNamedCall(callName, builder.getVoidTy(), args, {});
   }
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPatchCopyShader, DEBUG_TYPE, "Patch LLVM for copy shader generation", false, false)
diff --git a/lgc/patch/PatchEntryPointMutate.cpp b/lgc/patch/PatchEntryPointMutate.cpp
index 687ae72ac..84632ccdc 100644
--- a/lgc/patch/PatchEntryPointMutate.cpp
+++ b/lgc/patch/PatchEntryPointMutate.cpp
@@ -78,65 +78,40 @@ using namespace lgc;
 namespace llvm {
 namespace cl {
 
 // -inreg-esgs-lds-size: Add a dummy "inreg" argument for ES-GS LDS size, this is to keep consistent with PAL's
 // GS on-chip behavior. In the future, if PAL allows hardcoded ES-GS LDS size, this option could be deprecated.
 opt<bool> InRegEsGsLdsSize("inreg-esgs-lds-size", desc("For GS on-chip, add esGsLdsSize in user data"), init(true));
 
 } // namespace cl
 } // namespace llvm
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchEntryPointMutate::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for entry-point mutation
-ModulePass *lgc::createLegacyPatchEntryPointMutate() {
-  return new LegacyPatchEntryPointMutate();
-}
-
 // =====================================================================================================================
 PatchEntryPointMutate::PatchEntryPointMutate() : m_hasTs(false), m_hasGs(false) {
 }
 
 // =====================================================================================================================
 PatchEntryPointMutate::UserDataArg::UserDataArg(llvm::Type *argTy, const llvm::Twine &name, unsigned userDataValue,
                                                 unsigned *argIndex)
     : argTy(argTy), name(name.str()), userDataValue(userDataValue), argIndex(argIndex) {
   if (llvm::isa<llvm::PointerType>(argTy))
     argDwordSize = argTy->getPointerAddressSpace() == ADDR_SPACE_CONST_32BIT ? 1 : 2;
   else
     argDwordSize = argTy->getPrimitiveSizeInBits() / 32;
 }
 
 // =====================================================================================================================
 PatchEntryPointMutate::UserDataArg::UserDataArg(llvm::Type *argTy, const llvm::Twine &name,
                                                 UserDataMapping userDataValue, unsigned *argIndex)
     : UserDataArg(argTy, name, static_cast<unsigned>(userDataValue), argIndex) {
 }
 
-// =====================================================================================================================
-LegacyPatchEntryPointMutate::LegacyPatchEntryPointMutate() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchEntryPointMutate::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  return m_impl.runImpl(module, pipelineShaders, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchEntryPointMutate::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   runImpl(module, pipelineShaders, pipelineState);
@@ -1686,14 +1661,10 @@ ShaderStage PatchEntryPointMutate::getMergedShaderStage(ShaderStage stage) const
 // =====================================================================================================================
 bool PatchEntryPointMutate::isComputeWithCalls() const {
   return m_computeWithCalls;
 }
 
 // =====================================================================================================================
 bool PatchEntryPointMutate::UserDataUsage::isSpecialUserDataUsed(UserDataMapping kind) {
   unsigned index = static_cast<unsigned>(kind) - static_cast<unsigned>(UserDataMapping::GlobalTable);
   return specialUserData.size() > index && !specialUserData[index].users.empty();
 }
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for entry-point mutation.
-INITIALIZE_PASS(LegacyPatchEntryPointMutate, DEBUG_TYPE, "Patch LLVM for entry-point mutation", false, false)
diff --git a/lgc/patch/PatchImageDerivatives.cpp b/lgc/patch/PatchImageDerivatives.cpp
index b9ab6edba..10e24acf4 100644
--- a/lgc/patch/PatchImageDerivatives.cpp
+++ b/lgc/patch/PatchImageDerivatives.cpp
@@ -37,52 +37,20 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-image-derivatives"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchImageDerivatives::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass
-ModulePass *createLegacyPatchImageDerivatives() {
-  return new LegacyPatchImageDerivatives();
-}
-
-// =====================================================================================================================
-LegacyPatchImageDerivatives::LegacyPatchImageDerivatives() : llvm::ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchImageDerivatives::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchImageDerivatives::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchImageDerivatives::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::all(); // Note: this patching never invalidates analysis data
@@ -188,14 +156,10 @@ bool PatchImageDerivatives::runImpl(llvm::Module &module, PipelineState *pipelin
     }
 
     append_range(worklist, successors(testBlock));
   }
 
   // No paths from kills to derivatives exist.
   return false;
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch image derivative operations dependent on discards.
-INITIALIZE_PASS(LegacyPatchImageDerivatives, DEBUG_TYPE, "Patch image derivatives after discards", false, false)
diff --git a/lgc/patch/PatchImageOpCollect.cpp b/lgc/patch/PatchImageOpCollect.cpp
index 57c996598..0319e57c6 100644
--- a/lgc/patch/PatchImageOpCollect.cpp
+++ b/lgc/patch/PatchImageOpCollect.cpp
@@ -34,52 +34,20 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-image-op-collect"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchImageOpCollect::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching for image operation collecting
-ModulePass *createLegacyPatchImageOpCollect() {
-  return new LegacyPatchImageOpCollect();
-}
-
-// =====================================================================================================================
-LegacyPatchImageOpCollect::LegacyPatchImageOpCollect() : llvm::ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchImageOpCollect::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchImageOpCollect::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchImageOpCollect::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::none();
@@ -104,14 +72,10 @@ bool PatchImageOpCollect::runImpl(llvm::Module &module, PipelineState *pipelineS
         ShaderStage stage = getShaderStage(call->getFunction());
         ResourceUsage *resUsage = pipelineState->getShaderResourceUsage(stage);
         resUsage->useImageOp = true;
       }
     }
   }
   return false;
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch operations for image operation collecting.
-INITIALIZE_PASS(LegacyPatchImageOpCollect, DEBUG_TYPE, "Patch LLVM for image operation collecting", false, false)
diff --git a/lgc/patch/PatchInOutImportExport.cpp b/lgc/patch/PatchInOutImportExport.cpp
index 992891b65..ea60f9bea 100644
--- a/lgc/patch/PatchInOutImportExport.cpp
+++ b/lgc/patch/PatchInOutImportExport.cpp
@@ -1,11 +1,11 @@
-﻿/*
+/*
  ***********************************************************************************************************************
  *
  *  Copyright (c) 2017-2022 Advanced Micro Devices, Inc. All Rights Reserved.
  *
  *  Permission is hereby granted, free of charge, to any person obtaining a copy
  *  of this software and associated documentation files (the "Software"), to deal
  *  in the Software without restriction, including without limitation the rights
  *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  *  copies of the Software, and to permit persons to whom the Software is
  *  furnished to do so, subject to the following conditions:
@@ -43,75 +43,43 @@
 #include "llvm/Support/raw_ostream.h"
 #include <cmath>
 
 #define DEBUG_TYPE "lgc-patch-in-out-import-export"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchInOutImportExport::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for input import and output export
-ModulePass *createLegacyPatchInOutImportExport() {
-  return new LegacyPatchInOutImportExport();
-}
-
 // =====================================================================================================================
 PatchInOutImportExport::PatchInOutImportExport() : m_lds(nullptr) {
   memset(&m_gfxIp, 0, sizeof(m_gfxIp));
   initPerShader();
 }
 
-// =====================================================================================================================
-LegacyPatchInOutImportExport::LegacyPatchInOutImportExport() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-LegacyPatchInOutImportExport::~LegacyPatchInOutImportExport() {
-}
-
 // =====================================================================================================================
 // Initialize per-shader members
 void PatchInOutImportExport::initPerShader() {
   m_clipDistance = nullptr;
   m_cullDistance = nullptr;
   m_primitiveId = nullptr;
   m_fragDepth = nullptr;
   m_fragStencilRef = nullptr;
   m_sampleMask = nullptr;
   m_viewportIndex = nullptr;
   m_layer = nullptr;
   m_viewIndex = nullptr;
   m_threadId = nullptr;
 
   m_attribExports.clear();
 }
 
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchInOutImportExport::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  auto getPDT = [&](Function &f) -> PostDominatorTree & {
-    return getAnalysis<PostDominatorTreeWrapperPass>(f).getPostDomTree();
-  };
-  return m_impl.runImpl(module, pipelineShaders, pipelineState, getPDT);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchInOutImportExport::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   auto getPDT = [&](Function &f) -> PostDominatorTree & {
@@ -6154,15 +6122,10 @@ void PatchInOutImportExport::exportVertexAttribs(Instruction *insertPos) {
                 attribValue},
                {}, insertPos);
 #else
       llvm_unreachable("Not implemented!");
 #endif
     }
   }
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for input import and output export.
-INITIALIZE_PASS(LegacyPatchInOutImportExport, DEBUG_TYPE, "Patch LLVM for input import and output export operations",
-                false, false)
diff --git a/lgc/patch/PatchInitializeWorkgroupMemory.cpp b/lgc/patch/PatchInitializeWorkgroupMemory.cpp
index 9b4752945..c7aa62cab 100644
--- a/lgc/patch/PatchInitializeWorkgroupMemory.cpp
+++ b/lgc/patch/PatchInitializeWorkgroupMemory.cpp
@@ -41,45 +41,20 @@
 
 using namespace lgc;
 using namespace llvm;
 
 static cl::opt<bool>
     ForceInitWorkgroupMemory("force-init-workgroup-memory",
                              cl::desc("Force to initialize the workgroup memory with zero for internal use"),
                              cl::init(false));
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchInitializeWorkgroupMemory::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of setting up the value for workgroup global variables.
-ModulePass *createLegacyPatchInitializeWorkgroupMemory() {
-  return new LegacyPatchInitializeWorkgroupMemory();
-}
-
-// =====================================================================================================================
-LegacyPatchInitializeWorkgroupMemory::LegacyPatchInitializeWorkgroupMemory() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchInitializeWorkgroupMemory::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  return m_impl.runImpl(module, pipelineShaders, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchInitializeWorkgroupMemory::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   if (runImpl(module, pipelineShaders, pipelineState))
@@ -293,14 +268,10 @@ unsigned PatchInitializeWorkgroupMemory::getTypeSizeInDwords(Type *inputTy) {
   }
   assert(inputTy->isStructTy());
   const unsigned memberCount = inputTy->getStructNumElements();
   unsigned memberSize = 0;
   for (unsigned idx = 0; idx < memberCount; ++idx)
     memberSize += getTypeSizeInDwords(inputTy->getStructElementType(idx));
   return memberSize;
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of initialize workgroup memory with zero.
-INITIALIZE_PASS(LegacyPatchInitializeWorkgroupMemory, DEBUG_TYPE, "Patch for initialize workgroup memory", false, false)
diff --git a/lgc/patch/PatchInvariantLoads.cpp b/lgc/patch/PatchInvariantLoads.cpp
index 27962ddd4..2a836d1c8 100644
--- a/lgc/patch/PatchInvariantLoads.cpp
+++ b/lgc/patch/PatchInvariantLoads.cpp
@@ -37,52 +37,20 @@
 #include "llvm/InitializePasses.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-invariant-loads"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchInvariantLoads::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass
-FunctionPass *createLegacyPatchInvariantLoads() {
-  return new LegacyPatchInvariantLoads();
-}
-
-// =====================================================================================================================
-LegacyPatchInvariantLoads::LegacyPatchInvariantLoads() : llvm::FunctionPass(ID) {
-}
-
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchInvariantLoads::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-}
-
-// =====================================================================================================================
-// Executes this LLVM pass on the specified LLVM function.
-//
-// @param [in/out] function : Function that we will patch.
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchInvariantLoads::runOnFunction(Function &function) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(function.getParent());
-  return m_impl.runImpl(function, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM pass on the specified LLVM function.
 //
 // @param [in/out] function : Function that we will patch.
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchInvariantLoads::run(Function &function, FunctionAnalysisManager &analysisManager) {
   const auto &moduleAnalysisManager = analysisManager.getResult<ModuleAnalysisManagerFunctionProxy>(function);
   PipelineState *pipelineState =
       moduleAnalysisManager.getCachedResult<PipelineStateWrapper>(*function.getParent())->getPipelineState();
@@ -254,14 +222,10 @@ bool PatchInvariantLoads::runImpl(Function &function, PipelineState *pipelineSta
 
     LLVM_DEBUG(dbgs() << "Marking load invariant: " << *inst << "\n");
     inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(context, {}));
     changed = true;
   }
 
   return changed;
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch image derivative operations dependent on discards.
-INITIALIZE_PASS(LegacyPatchInvariantLoads, DEBUG_TYPE, "Patch invariant loads", false, false)
diff --git a/lgc/patch/PatchLlvmIrInclusion.cpp b/lgc/patch/PatchLlvmIrInclusion.cpp
index 9b4005ec1..1b73c0cf6 100644
--- a/lgc/patch/PatchLlvmIrInclusion.cpp
+++ b/lgc/patch/PatchLlvmIrInclusion.cpp
@@ -32,43 +32,20 @@
 #include "lgc/state/Abi.h"
 #include "llvm/IR/Constants.h"
 
 #define DEBUG_TYPE "lgc-patch-llvm-ir-inclusion"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchLlvmIrInclusion::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations of including LLVM IR as a separate section in the ELF.
-ModulePass *createLegacyPatchLlvmIrInclusion() {
-  return new LegacyPatchLlvmIrInclusion();
-}
-
-// =====================================================================================================================
-LegacyPatchLlvmIrInclusion::LegacyPatchLlvmIrInclusion() : LegacyPatch(ID) {
-}
-
-// =====================================================================================================================
-// Executes this patching pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchLlvmIrInclusion::runOnModule(Module &module) {
-  return m_impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchLlvmIrInclusion::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
@@ -95,15 +72,10 @@ bool PatchLlvmIrInclusion::runImpl(Module &module) {
                                    nullptr, GlobalValue::NotThreadLocal, false);
   assert(global);
 
   std::string namePrefix = Util::Abi::AmdGpuCommentName;
   global->setSection(namePrefix + "llvmir");
 
   return true;
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations of including LLVM IR as a separate section in the ELF binary.
-INITIALIZE_PASS(LegacyPatchLlvmIrInclusion, DEBUG_TYPE, "Include LLVM IR as a separate section in the ELF binary",
-                false, false)
diff --git a/lgc/patch/PatchLoadScalarizer.cpp b/lgc/patch/PatchLoadScalarizer.cpp
index 9dccac421..dd1d21615 100644
--- a/lgc/patch/PatchLoadScalarizer.cpp
+++ b/lgc/patch/PatchLoadScalarizer.cpp
@@ -36,59 +36,25 @@
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "lgc-patch-load-scalarizer"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Define static members (no initializer needed as LLVM only cares about the address of ID, never its value).
-char LegacyPatchLoadScalarizer::ID;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for load scalarizer optimizations.
-FunctionPass *createLegacyPatchLoadScalarizer() {
-  return new LegacyPatchLoadScalarizer();
-}
-
 // =====================================================================================================================
 PatchLoadScalarizer::PatchLoadScalarizer() {
   m_scalarThreshold = 0;
 }
 
-// =====================================================================================================================
-LegacyPatchLoadScalarizer::LegacyPatchLoadScalarizer() : FunctionPass(ID) {
-}
-
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchLoadScalarizer::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  analysisUsage.addRequired<LegacyPipelineShaders>();
-  analysisUsage.addPreserved<LegacyPipelineShaders>();
-}
-
-// =====================================================================================================================
-// Executes this LLVM pass on the specified LLVM function.
-//
-// @param [in/out] function : Function that we will peephole optimize.
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchLoadScalarizer::runOnFunction(Function &function) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(function.getParent());
-  return m_impl.runImpl(function, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM pass on the specified LLVM function.
 //
 // @param [in/out] function : Function that we will peephole optimize.
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchLoadScalarizer::run(Function &function, FunctionAnalysisManager &analysisManager) {
   const auto &moduleAnalysisManager = analysisManager.getResult<ModuleAnalysisManagerFunctionProxy>(function);
   PipelineState *pipelineState =
       moduleAnalysisManager.getCachedResult<PipelineStateWrapper>(*function.getParent())->getPipelineState();
@@ -196,14 +162,10 @@ void PatchLoadScalarizer::visitLoadInst(LoadInst &loadInst) {
                                                  loadInst.getName() + ".u" + Twine(i));
     }
 
     loadValue->takeName(&loadInst);
     loadInst.replaceAllUsesWith(loadValue);
     m_instsToErase.push_back(&loadInst);
   }
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for load scalarizer optimization.
-INITIALIZE_PASS(LegacyPatchLoadScalarizer, DEBUG_TYPE, "Patch LLVM for load scalarizer optimization", false, false)
diff --git a/lgc/patch/PatchLoopMetadata.cpp b/lgc/patch/PatchLoopMetadata.cpp
index 338e26eeb..426279ffd 100644
--- a/lgc/patch/PatchLoopMetadata.cpp
+++ b/lgc/patch/PatchLoopMetadata.cpp
@@ -39,24 +39,20 @@
 
 using namespace llvm;
 using namespace lgc;
 
 namespace llvm {
 // A proxy from a ModuleAnalysisManager to a loop.
 typedef OuterAnalysisManagerProxy<ModuleAnalysisManager, Loop, LoopStandardAnalysisResults &>
     ModuleAnalysisManagerLoopProxy;
 } // namespace llvm
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchLoopMetadata::ID = 0;
-
 // =====================================================================================================================
 // Update metadata by removing any existing metadata with the specified prefix, and then adding the new metadata if
 // existing metadata was removed or conditional is false.
 //
 // @param loopId : loop
 // @param prefixesToRemove : metadata prefixes to be removed
 // @param newMetadata : the new metadata to be added
 // @param conditional : true if the new metadata is only to be added if one or more prefixes was removed
 MDNode *PatchLoopMetadata::updateMetadata(MDNode *loopId, ArrayRef<StringRef> prefixesToRemove, Metadata *newMetadata,
                                           bool conditional) {
@@ -80,50 +76,26 @@ MDNode *PatchLoopMetadata::updateMetadata(MDNode *loopId, ArrayRef<StringRef> pr
   if (!conditional || found) {
     mds.push_back(newMetadata);
     MDNode *newLoopId = MDNode::getDistinct(*m_context, mds);
     return newLoopId;
   }
 
   // Return the metadata unmodified
   return loopId;
 };
 
-// =====================================================================================================================
-// Pass creator, creates the pass for patching loop metadata
-LoopPass *lgc::createLegacyPatchLoopMetadata() {
-  return new LegacyPatchLoopMetadata();
-}
-
 // =====================================================================================================================
 PatchLoopMetadata::PatchLoopMetadata()
     : m_context(nullptr), m_forceLoopUnrollCount(0), m_disableLoopUnroll(false), m_disableLicmThreshold(0),
       m_unrollHintThreshold(0), m_dontUnrollHintThreshold(0) {
 }
 
-// =====================================================================================================================
-LegacyPatchLoopMetadata::LegacyPatchLoopMetadata() : LoopPass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM patching pass on the specified LLVM module.
-//
-// @param [in/out] loop : LLVM loop to be run on
-// @param [in/out] loopPassMgr : Legacy loop pass pass manager
-// @returns : True if the loop was modified by the transformation and false otherwise
-bool LegacyPatchLoopMetadata::runOnLoop(Loop *loop, LPPassManager &loopPassMgr) {
-  if (skipLoop(loop))
-    return false;
-  Module *module = loop->getHeader()->getModule();
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(module);
-  return m_impl.runImpl(*loop, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] loop : LLVM loop to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @param [in/out] loopAnalysisResult : Loop standard analysis results
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchLoopMetadata::run(Loop &loop, LoopAnalysisManager &analysisManager,
                                          LoopStandardAnalysisResults &loopAnalysisResults, LPMUpdater &) {
   Module *module = loop.getHeader()->getModule();
@@ -232,14 +204,10 @@ bool PatchLoopMetadata::runImpl(Loop &loop, PipelineState *pipelineState) {
     loopMetaNode = MDNode::concatenate(loopMetaNode, MDNode::get(*m_context, licmDisableNode));
     changed = true;
   }
   if (changed) {
     loopMetaNode->replaceOperandWith(0, loopMetaNode);
     loop.setLoopID(loopMetaNode);
   }
 
   return changed;
 }
-
-// =====================================================================================================================
-// Initializes the pass for patching Loop metadata.
-INITIALIZE_PASS(LegacyPatchLoopMetadata, DEBUG_TYPE, "Set or amend metadata to control loop unrolling", false, false)
diff --git a/lgc/patch/PatchNullFragShader.cpp b/lgc/patch/PatchNullFragShader.cpp
index 69b2680b2..db197f97a 100644
--- a/lgc/patch/PatchNullFragShader.cpp
+++ b/lgc/patch/PatchNullFragShader.cpp
@@ -39,62 +39,20 @@
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-null-frag-shader"
 
 using namespace lgc;
 using namespace llvm;
 
-namespace lgc {
-
-// =====================================================================================================================
-// Pass to generate null fragment shader if required
-class LegacyPatchNullFragShader : public ModulePass {
-public:
-  static char ID;
-  LegacyPatchNullFragShader() : ModulePass(ID) {}
-
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  bool runOnModule(Module &module) override;
-
-private:
-  LegacyPatchNullFragShader(const LegacyPatchNullFragShader &) = delete;
-  LegacyPatchNullFragShader &operator=(const LegacyPatchNullFragShader &) = delete;
-
-  PatchNullFragShader m_impl;
-};
-
-char LegacyPatchNullFragShader::ID = 0;
-
-} // namespace lgc
-
-// =====================================================================================================================
-// Create the pass that generates a null fragment shader if required.
-ModulePass *lgc::createLegacyPatchNullFragShader() {
-  return new LegacyPatchNullFragShader();
-}
-
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchNullFragShader::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchNullFragShader::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::none();
@@ -134,14 +92,10 @@ void PatchNullFragShader::updatePipelineState(PipelineState *pipelineState) cons
   pipelineState->setShaderStageMask(pipelineState->getShaderStageMask() | shaderStageToMask(ShaderStageFragment));
 
   // Add usage info for dummy output
   resUsage->inOutUsage.fs.cbShaderMask = 0;
   resUsage->inOutUsage.fs.isNullFs = true;
   InOutLocationInfo origLocInfo;
   origLocInfo.setLocation(0);
   auto &newOutLocInfo = resUsage->inOutUsage.outputLocInfoMap[origLocInfo];
   newOutLocInfo.setData(InvalidValue);
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPatchNullFragShader, DEBUG_TYPE, "Patch LLVM for null fragment shader generation", false, false)
diff --git a/lgc/patch/PatchPeepholeOpt.cpp b/lgc/patch/PatchPeepholeOpt.cpp
index 13be9a535..05862bd78 100644
--- a/lgc/patch/PatchPeepholeOpt.cpp
+++ b/lgc/patch/PatchPeepholeOpt.cpp
@@ -36,42 +36,20 @@
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "lgc-patch-peephole-opt"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Define static members (no initializer needed as LLVM only cares about the address of ID, never its value).
-char LegacyPatchPeepholeOpt::ID;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for peephole optimizations.
-FunctionPass *createLegacyPatchPeepholeOpt() {
-  return new LegacyPatchPeepholeOpt();
-}
-
-LegacyPatchPeepholeOpt::LegacyPatchPeepholeOpt() : FunctionPass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM pass on the specified LLVM function.
-//
-// @param [in/out] function : Function that we will peephole optimize.
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchPeepholeOpt::runOnFunction(Function &function) {
-  return m_impl.runImpl(function);
-}
-
 // =====================================================================================================================
 // Executes this LLVM pass on the specified LLVM function.
 //
 // @param [in/out] function : Function that we will peephole optimize.
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchPeepholeOpt::run(Function &function, FunctionAnalysisManager &analysisManager) {
   if (runImpl(function))
     return PreservedAnalyses::none();
   return PreservedAnalyses::all();
@@ -91,28 +69,20 @@ bool PatchPeepholeOpt::runImpl(Function &function) {
 
   for (Instruction *const inst : m_instsToErase) {
     // Lastly delete any instructions we replaced.
     inst->eraseFromParent();
   }
   m_instsToErase.clear();
 
   return changed;
 }
 
-// =====================================================================================================================
-// Specify what analysis passes this pass depends on.
-//
-// @param [in/out] analysisUsage : The place to record our analysis pass usage requirements.
-void LegacyPatchPeepholeOpt::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.setPreservesCFG();
-}
-
 // =====================================================================================================================
 // Visit an inttoptr instruction.
 //
 // Change inttoptr ( add x, const ) -> gep ( inttoptr x, const ) to improve value tracking and load/store vectorization.
 //
 // Note: we decided to implement this transformation here and not in LLVM. From the point of view of alias analysis, the
 // pointer returned by inttoptr ( add x, const ) is different from the pointer returned by gep ( inttoptr x, const ):
 // the former is associated with whatever x AND const point to; the latter is associated ONLY with whatever x points to.
 //
 // In LLPC/LGC, we can assume that const does not point to any object (which makes this transformation valid) but that's
@@ -169,14 +139,10 @@ void PatchPeepholeOpt::visitIntToPtr(IntToPtrInst &intToPtr) {
 
   // Set every instruction to use the newly calculated pointer.
   intToPtr.replaceAllUsesWith(getElementPtr);
 
   // If the add instruction has no other users then mark to erase.
   if (binaryOperator->getNumUses() == 0)
     m_instsToErase.push_back(binaryOperator);
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for peephole optimizations.
-INITIALIZE_PASS(LegacyPatchPeepholeOpt, DEBUG_TYPE, "Patch LLVM for peephole optimizations", false, false)
diff --git a/lgc/patch/PatchPreparePipelineAbi.cpp b/lgc/patch/PatchPreparePipelineAbi.cpp
index 1a7c7d150..faf101a88 100644
--- a/lgc/patch/PatchPreparePipelineAbi.cpp
+++ b/lgc/patch/PatchPreparePipelineAbi.cpp
@@ -36,61 +36,24 @@
 #include "lgc/state/PalMetadata.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-prepare-pipeline-abi"
 
 using namespace llvm;
 using namespace lgc;
 
-char LegacyPatchPreparePipelineAbi::ID = 0;
-
-// =====================================================================================================================
-// Create pass to prepare the pipeline ABI
-//
-// @param onlySetCallingConvs : Should we only set the calling conventions, or do the full prepare.
-ModulePass *lgc::createLegacyPatchPreparePipelineAbi() {
-  return new LegacyPatchPreparePipelineAbi;
-}
-
 // =====================================================================================================================
 PatchPreparePipelineAbi::PatchPreparePipelineAbi() {
 }
 
-// =====================================================================================================================
-LegacyPatchPreparePipelineAbi::LegacyPatchPreparePipelineAbi() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchPreparePipelineAbi::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-
-  auto getPostDomTree = [&](Function &func) -> PostDominatorTree & {
-    return getAnalysis<PostDominatorTreeWrapperPass>(func).getPostDomTree();
-  };
-  auto getCycleInfo = [&](Function &func) -> CycleInfo & {
-    return getAnalysis<CycleInfoWrapperPass>(func).getCycleInfo();
-  };
-
-  PatchPreparePipelineAbi::FunctionAnalysisHandlers analysisHandlers = {};
-  analysisHandlers.getPostDomTree = getPostDomTree;
-  analysisHandlers.getCycleInfo = getCycleInfo;
-
-  return m_impl.runImpl(module, pipelineShaders, pipelineState, analysisHandlers);
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchPreparePipelineAbi::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
 
@@ -549,14 +512,10 @@ void PatchPreparePipelineAbi::storeTessFactors(Function *entryPoint) {
   const auto tfBufferBase = getFunctionArgument(entryPoint, entryArgIdxs.tfBufferBase);
   const auto relPatchId = pipelineSysValues.get(entryPoint)->getRelativeId();
 
   // Read back tessellation factors and write them to TF buffer
   auto tessFactors = readTessFactors(m_pipelineState, relPatchId, builder);
   writeTessFactors(m_pipelineState, tfBufferDesc, tfBufferBase, relPatchId, tessFactors.first, tessFactors.second,
                    builder);
 
   pipelineSysValues.clear();
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPatchPreparePipelineAbi, DEBUG_TYPE, "Patch LLVM for preparing pipeline ABI", false, false)
diff --git a/lgc/patch/PatchReadFirstLane.cpp b/lgc/patch/PatchReadFirstLane.cpp
index 5085675f4..8fae96bfd 100644
--- a/lgc/patch/PatchReadFirstLane.cpp
+++ b/lgc/patch/PatchReadFirstLane.cpp
@@ -25,65 +25,35 @@
 /**
  ***********************************************************************************************************************
  * @file  PatchReadFirstLane.cpp
  * @brief LLPC source file: contains declaration and implementation of class lgc::PatchReadFirstLane.
  ***********************************************************************************************************************
  */
 #include "lgc/patch/PatchReadFirstLane.h"
 #include "lgc/patch/Patch.h"
 #include "lgc/state/PipelineState.h"
 #include "llvm/Analysis/DivergenceAnalysis.h"
-#include "llvm/Analysis/LegacyDivergenceAnalysis.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/InstVisitor.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Debug.h"
 #include <deque>
 
 #define DEBUG_TYPE "lgc-patch-read-first-lane"
 
 using namespace lgc;
 using namespace llvm;
 
-namespace {
-class LegacyPatchReadFirstLane final : public FunctionPass {
-public:
-  LegacyPatchReadFirstLane();
-
-  virtual bool runOnFunction(Function &function) override;
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override;
-
-  static char ID; // ID of this pass
-
-private:
-  LegacyPatchReadFirstLane(const LegacyPatchReadFirstLane &) = delete;
-  LegacyPatchReadFirstLane &operator=(const LegacyPatchReadFirstLane &) = delete;
-
-  PatchReadFirstLane m_impl;
-};
-
-} // anonymous namespace
-
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchReadFirstLane::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for readfirstlane optimizations.
-FunctionPass *lgc::createLegacyPatchReadFirstLane() {
-  return new LegacyPatchReadFirstLane();
-}
-
 // =====================================================================================================================
 // Returns true if all users of the given instruction defined in the given block.
 //
 // @param inst : The given instruction
 // @param block : The given block
 static bool isAllUsersDefinedInBlock(Instruction *inst, BasicBlock *block) {
   for (auto user : inst->users()) {
     if (auto userInst = dyn_cast<Instruction>(user))
       if (userInst->getParent() != block)
         return false;
@@ -103,42 +73,20 @@ static bool areAllUserReadFirstLane(Instruction *inst) {
     if (!intrinsic || intrinsic->getIntrinsicID() != Intrinsic::amdgcn_readfirstlane)
       return false;
   }
   return true;
 }
 
 // =====================================================================================================================
 PatchReadFirstLane::PatchReadFirstLane() : m_targetTransformInfo(nullptr) {
 }
 
-// =====================================================================================================================
-LegacyPatchReadFirstLane::LegacyPatchReadFirstLane() : FunctionPass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM pass on the specified LLVM function.
-//
-// @param [in/out] function : Function that we will peephole optimize.
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchReadFirstLane::runOnFunction(Function &function) {
-  auto *targetTransformInfoWrapperPass = getAnalysisIfAvailable<TargetTransformInfoWrapperPass>();
-  TargetTransformInfo *targetTransformInfo;
-  if (targetTransformInfoWrapperPass)
-    targetTransformInfo = &targetTransformInfoWrapperPass->getTTI(function);
-  else
-    llvm_unreachable("TTI should be available");
-
-  LegacyDivergenceAnalysis *divergenceAnalysis = &getAnalysis<LegacyDivergenceAnalysis>();
-  auto isDivergentUse = [divergenceAnalysis](const Use &use) { return divergenceAnalysis->isDivergentUse(&use); };
-  return m_impl.runImpl(function, isDivergentUse, targetTransformInfo);
-}
-
 // =====================================================================================================================
 // Executes this LLVM pass on the specified LLVM function.
 //
 // @param [in/out] function : Function that we will peephole optimize.
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchReadFirstLane::run(Function &function, FunctionAnalysisManager &analysisManager) {
   TargetTransformInfo &targetTransformInfo = analysisManager.getResult<TargetIRAnalysis>(function);
 
   DivergenceInfo &divergenceInfo = analysisManager.getResult<DivergenceAnalysis>(function);
@@ -160,29 +108,20 @@ bool PatchReadFirstLane::runImpl(Function &function, std::function<bool(const Us
   LLVM_DEBUG(dbgs() << "Run the pass Patch-Read-First-Lane\n");
 
   m_isDivergentUse = std::move(isDivergentUse);
   m_targetTransformInfo = targetTransformInfo;
 
   bool changed = promoteEqualUniformOps(function);
   changed |= liftReadFirstLane(function);
   return changed;
 }
 
-// =====================================================================================================================
-// Specify what analysis passes this pass depends on.
-//
-// @param [in,out] analysisUsage : The place to record our analysis pass usage requirements.
-void LegacyPatchReadFirstLane::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyDivergenceAnalysis>();
-  analysisUsage.setPreservesCFG();
-}
-
 // =====================================================================================================================
 // Use the uniform (non-divergent) node instead of a divergent one if they are equal.
 //
 // Detect a case where a branch condition tests two nodes for equality where one of them
 // is divergent and the other uniform. In the true block replace the divergent
 // use with the uniform one as it helps instruction selection decide what to put in an SGPR.
 //
 // For example, in the code snippet below in BB1, %divergent can be replaced with %uniform.
 //
 // BB0:
@@ -550,17 +489,10 @@ void PatchReadFirstLane::applyReadFirstLane(Instruction *inst, BuilderBase &buil
 
   Value *replaceInst = nullptr;
   if (isFloat) {
     replaceInst = builder.CreateBitCast(readFirstLane, instTy);
   } else {
     newInst = readFirstLane;
     replaceInst = readFirstLane;
   }
   inst->replaceUsesWithIf(replaceInst, [newInst](Use &U) { return U.getUser() != newInst; });
 }
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for readfirstlane optimizations.
-INITIALIZE_PASS_BEGIN(LegacyPatchReadFirstLane, DEBUG_TYPE, "Patch LLVM for readfirstlane optimizations", false, false)
-INITIALIZE_PASS_DEPENDENCY(LegacyDivergenceAnalysis)
-INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)
-INITIALIZE_PASS_END(LegacyPatchReadFirstLane, DEBUG_TYPE, "Patch LLVM for readfirstlane optimizations", false, false)
diff --git a/lgc/patch/PatchResourceCollect.cpp b/lgc/patch/PatchResourceCollect.cpp
index 845f9ea95..cbdd39593 100644
--- a/lgc/patch/PatchResourceCollect.cpp
+++ b/lgc/patch/PatchResourceCollect.cpp
@@ -52,49 +52,24 @@
 #define DEBUG_TYPE "lgc-patch-resource-collect"
 
 using namespace llvm;
 using namespace lgc;
 
 // -disable-gs-onchip: disable geometry shader on-chip mode
 cl::opt<bool> DisableGsOnChip("disable-gs-onchip", cl::desc("Disable geometry shader on-chip mode"), cl::init(false));
 
 namespace lgc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacyPatchResourceCollect::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for resource collecting
-ModulePass *createLegacyPatchResourceCollect() {
-  return new LegacyPatchResourceCollect();
-}
-
 // =====================================================================================================================
 PatchResourceCollect::PatchResourceCollect() : m_resUsage(nullptr) {
 }
 
-// =====================================================================================================================
-LegacyPatchResourceCollect::LegacyPatchResourceCollect() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchResourceCollect::runOnModule(Module &module) {
-  PipelineShadersResult &pipelineShaders = getAnalysis<LegacyPipelineShaders>().getResult();
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineShaders, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchResourceCollect::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineShadersResult &pipelineShaders = analysisManager.getResult<PipelineShaders>(module);
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   runImpl(module, pipelineShaders, pipelineState);
@@ -3659,14 +3634,10 @@ void InOutLocationInfoMapManager::buildMap(ShaderStage shaderStage) {
 //
 // @param origLocInfo : The original InOutLocationInfo
 // @param [out] mapIt : Iterator to an element of m_locationInfoMap with key equivalent to the given InOutLocationInfo
 bool InOutLocationInfoMapManager::findMap(const InOutLocationInfo &origLocInfo,
                                           InOutLocationInfoMap::const_iterator &mapIt) {
   mapIt = m_locationInfoMap.find(origLocInfo);
   return mapIt != m_locationInfoMap.end();
 }
 
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patch operations for resource collecting.
-INITIALIZE_PASS(LegacyPatchResourceCollect, DEBUG_TYPE, "Patch LLVM for resource collecting", false, false)
diff --git a/lgc/patch/PatchSetupTargetFeatures.cpp b/lgc/patch/PatchSetupTargetFeatures.cpp
index 4c5bb74c9..d9ae4c952 100644
--- a/lgc/patch/PatchSetupTargetFeatures.cpp
+++ b/lgc/patch/PatchSetupTargetFeatures.cpp
@@ -33,62 +33,20 @@
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-setup-target-features"
 
 using namespace llvm;
 using namespace lgc;
 
-namespace lgc {
-
-// =====================================================================================================================
-// Pass to set up target features on shader entry-points
-class LegacyPatchSetupTargetFeatures : public LegacyPatch {
-public:
-  static char ID;
-  LegacyPatchSetupTargetFeatures() : LegacyPatch(ID) {}
-
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  bool runOnModule(Module &module) override;
-
-  LegacyPatchSetupTargetFeatures(const LegacyPatchSetupTargetFeatures &) = delete;
-  LegacyPatchSetupTargetFeatures &operator=(const LegacyPatchSetupTargetFeatures &) = delete;
-
-private:
-  PatchSetupTargetFeatures m_impl;
-};
-
-char LegacyPatchSetupTargetFeatures::ID = 0;
-
-} // namespace lgc
-
-// =====================================================================================================================
-// Create pass to set up target features
-ModulePass *lgc::createLegacyPatchSetupTargetFeatures() {
-  return new LegacyPatchSetupTargetFeatures();
-}
-
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchSetupTargetFeatures::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchSetupTargetFeatures::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   runImpl(module, pipelineState);
   return PreservedAnalyses::none();
@@ -224,14 +182,10 @@ void PatchSetupTargetFeatures::setupTargetFeatures(Module *module) {
                  shaderMode.fp32DenormMode == FpDenormMode::FlushInOut) {
         builder.addAttribute("denormal-fp-math-f32", "preserve-sign");
       }
     }
 
     builder.addAttribute("target-features", targetFeatures);
 
     func->addFnAttrs(builder);
   }
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPatchSetupTargetFeatures, DEBUG_TYPE, "Patch LLVM to set up target features", false, false)
diff --git a/lgc/patch/PatchWaveSizeAdjust.cpp b/lgc/patch/PatchWaveSizeAdjust.cpp
index 1d6a94f16..fc1df605e 100644
--- a/lgc/patch/PatchWaveSizeAdjust.cpp
+++ b/lgc/patch/PatchWaveSizeAdjust.cpp
@@ -36,47 +36,20 @@
 #include "llvm/IR/IntrinsicInst.h"
 #endif
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-wave-size-adjust"
 
 using namespace lgc;
 using namespace llvm;
 
-char LegacyPatchWaveSizeAdjust::ID = 0;
-
-// =====================================================================================================================
-// Create PatchWaveSizeAdjust pass
-//
-// @param pipeline : Pipeline object
-ModulePass *lgc::createLegacyPatchWaveSizeAdjust() {
-  return new LegacyPatchWaveSizeAdjust();
-}
-
-// =====================================================================================================================
-// Constructor
-//
-// @param pipeline : Pipeline object
-LegacyPatchWaveSizeAdjust::LegacyPatchWaveSizeAdjust() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Run the PatchWaveSizeAdjust pass on a module
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchWaveSizeAdjust::runOnModule(Module &module) {
-  auto pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the PatchWaveSizeAdjust pass on a module
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchWaveSizeAdjust::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   runImpl(module, pipelineState);
   return PreservedAnalyses::all();
@@ -166,14 +139,10 @@ bool PatchWaveSizeAdjust::is16BitArithmeticOp(Instruction *inst) {
     case Intrinsic::amdgcn_fmed3:
     case Intrinsic::amdgcn_ldexp:
       return true;
     default:
       return false;
     }
   }
   return false;
 }
 #endif
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPatchWaveSizeAdjust, DEBUG_TYPE, "Patch LLVM for per-shader wave size adjustment", false, false)
diff --git a/lgc/patch/PatchWorkarounds.cpp b/lgc/patch/PatchWorkarounds.cpp
index 1f9d42d8c..f78e2db10 100644
--- a/lgc/patch/PatchWorkarounds.cpp
+++ b/lgc/patch/PatchWorkarounds.cpp
@@ -39,43 +39,20 @@
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-workarounds"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace lgc {
 
-// =====================================================================================================================
-// Define static members (no initializer needed as LLVM only cares about the address of ID, never its value).
-char LegacyPatchWorkarounds::ID;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of LLVM patching operations for peephole optimizations.
-ModulePass *createLegacyPatchWorkarounds() {
-  return new LegacyPatchWorkarounds();
-}
-
-LegacyPatchWorkarounds::LegacyPatchWorkarounds() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this LLVM pass on the specified LLVM function.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPatchWorkarounds::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Executes this LLVM pass on the specified LLVM function.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PatchWorkarounds::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::none();
@@ -235,25 +212,11 @@ void PatchWorkarounds::processImageDescWorkaround(CallInst &callInst, bool isLas
         if (isLastUse)
           m_processed.insert(&callInst);
 
         m_changed = true;
         break;
       }
     }
   }
 }
 
-// =====================================================================================================================
-// Get the analysis usage of this pass.
-//
-// @param [out] analysisUsage : The analysis usage.
-void LegacyPatchWorkarounds::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
-  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  analysisUsage.addRequired<LegacyPipelineShaders>();
-  analysisUsage.addPreserved<LegacyPipelineShaders>();
-}
-
 } // namespace lgc
-
-// =====================================================================================================================
-// Initializes the pass of LLVM patching operations for workarounds
-INITIALIZE_PASS(LegacyPatchWorkarounds, DEBUG_TYPE, "Patch LLVM for workarounds", false, false)
diff --git a/lgc/patch/ShaderMerger.cpp b/lgc/patch/ShaderMerger.cpp
index d0bc5daf1..3ed6bf207 100644
--- a/lgc/patch/ShaderMerger.cpp
+++ b/lgc/patch/ShaderMerger.cpp
@@ -35,21 +35,20 @@
 #include "lgc/patch/SystemValues.h"
 #include "lgc/state/PalMetadata.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/util/BuilderBase.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/InlineAsm.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
-#include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
 
 #define DEBUG_TYPE "lgc-shader-merger"
 
 using namespace llvm;
 using namespace lgc;
 
 // =====================================================================================================================
 //
 // @param pipelineState : Pipeline state
diff --git a/lgc/patch/VertexFetch.cpp b/lgc/patch/VertexFetch.cpp
index 6ff60646c..c76a064b9 100644
--- a/lgc/patch/VertexFetch.cpp
+++ b/lgc/patch/VertexFetch.cpp
@@ -518,42 +518,20 @@ const unsigned char VertexFetchImpl::m_vertexFormatMapGfx11[][8] = {
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID},
 };
 // clang-format on
 #endif
 
-char LegacyLowerVertexFetch::ID = 0;
-
-// =====================================================================================================================
-// Create the vertex fetch pass
-ModulePass *lgc::createLegacyLowerVertexFetch() {
-  return new LegacyLowerVertexFetch();
-}
-
-// =====================================================================================================================
-LegacyLowerVertexFetch::LegacyLowerVertexFetch() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Run the lower vertex fetch pass on a module
-//
-// @param [in/out] module : Module
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyLowerVertexFetch::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run the lower vertex fetch pass on a module
 //
 // @param [in/out] module : Module
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses LowerVertexFetch::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   if (runImpl(module, pipelineState))
     return PreservedAnalyses::none();
@@ -1821,14 +1799,10 @@ bool VertexFetchImpl::needPatchA2S(const VertexInputDescription *inputDesc) cons
   return needPatch;
 }
 
 // =====================================================================================================================
 // Checks whether the second vertex fetch operation is required (particularly for certain 64-bit typed formats).
 //
 // @param inputDesc : Vertex input description
 bool VertexFetchImpl::needSecondVertexFetch(const VertexInputDescription *inputDesc) const {
   return inputDesc->dfmt == BufDataFormat64_64_64 || inputDesc->dfmt == BufDataFormat64_64_64_64;
 }
-
-// =====================================================================================================================
-// Initialize the lower vertex fetch pass
-INITIALIZE_PASS(LegacyLowerVertexFetch, DEBUG_TYPE, "Lower vertex fetch calls", false, false)
diff --git a/lgc/state/Compiler.cpp b/lgc/state/Compiler.cpp
index 1b9f81907..7bafd21f8 100644
--- a/lgc/state/Compiler.cpp
+++ b/lgc/state/Compiler.cpp
@@ -45,22 +45,21 @@
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Target/TargetMachine.h"
 
 #define DEBUG_TYPE "lgc-compiler"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace lgc {
-// Create BuilderReplayer pass
-ModulePass *createLegacyBuilderReplayer(Pipeline *pipeline);
+
 ElfLinker *createElfLinkerImpl(PipelineState *pipelineState, llvm::ArrayRef<llvm::MemoryBufferRef> elfs);
 
 } // namespace lgc
 
 // =====================================================================================================================
 // Mark a function as a shader entry-point. This must be done before linking shader modules into a pipeline
 // with irLink(). This is a static method in Pipeline, as it does not need a Pipeline object, and can be used
 // in the front-end before a shader is associated with a pipeline.
 //
 // @param func : Shader entry-point function
@@ -184,43 +183,29 @@ Module *PipelineState::irLink(ArrayRef<Module *> modules, PipelineLink pipelineL
 //
 // Like other LGC and LLVM library functions, an internal compiler error could cause an assert or report_fatal_error.
 //
 // @param pipelineModule : IR pipeline module
 // @param [in/out] outStream : Stream to write ELF or IR disassembly output
 // @param checkShaderCacheFunc : Function to check shader cache in graphics pipeline
 // @param timers : Optional timers for 0 or more of:
 //                 timers[0]: patch passes
 //                 timers[1]: LLVM optimizations
 //                 timers[2]: codegen
-// @param newPassManager : Whether to use the new pass manager or not.
 // @returns : True for success.
 //           False if irLink asked for an "unlinked" shader or part-pipeline, and there is some reason why the
 //           module cannot be compiled that way.  The client typically then does a whole-pipeline compilation
 //           instead. The client can call getLastError() to get a textual representation of the error, for
 //           use in logging or in error reporting in a command-line utility.
 bool PipelineState::generate(std::unique_ptr<Module> pipelineModule, raw_pwrite_stream &outStream,
-                             Pipeline::CheckShaderCacheFunc checkShaderCacheFunc, ArrayRef<Timer *> timers,
-                             bool newPassManager) {
+                             Pipeline::CheckShaderCacheFunc checkShaderCacheFunc, ArrayRef<Timer *> timers) {
   m_lastError.clear();
 
-  if (newPassManager)
-    generateWithNewPassManager(std::move(pipelineModule), outStream, std::move(checkShaderCacheFunc), timers);
-  else
-    generateWithLegacyPassManager(std::move(pipelineModule), outStream, std::move(checkShaderCacheFunc), timers);
-
-  // See if there was a recoverable error.
-  return getLastError() == "";
-}
-
-void PipelineState::generateWithNewPassManager(std::unique_ptr<Module> pipelineModule, raw_pwrite_stream &outStream,
-                                               Pipeline::CheckShaderCacheFunc checkShaderCacheFunc,
-                                               ArrayRef<Timer *> timers) {
   unsigned passIndex = 1000;
   Timer *patchTimer = timers.size() >= 1 ? timers[0] : nullptr;
   Timer *optTimer = timers.size() >= 2 ? timers[1] : nullptr;
   Timer *codeGenTimer = timers.size() >= 3 ? timers[2] : nullptr;
 
   // Set up "whole pipeline" passes, where we have a single module representing the whole pipeline.
   std::unique_ptr<lgc::PassManager> passMgr(lgc::PassManager::Create(getLgcContext()));
   passMgr->setPassIndex(&passIndex);
   Patch::registerPasses(*passMgr);
   passMgr->registerFunctionAnalysis([&] { return getLgcContext()->getTargetMachine()->getTargetIRAnalysis(); });
@@ -251,67 +236,23 @@ void PipelineState::generateWithNewPassManager(std::unique_ptr<Module> pipelineM
     // Code generation.
     std::unique_ptr<LegacyPassManager> codegenPassMgr(LegacyPassManager::Create());
     unsigned passIndex = 2000;
     codegenPassMgr->setPassIndex(&passIndex);
     getLgcContext()->addTargetPasses(*codegenPassMgr, codeGenTimer, outStream);
     // Run the pipeline passes until codegen.
     passMgr->run(*pipelineModule);
     // Run the codegen passes
     codegenPassMgr->run(*pipelineModule);
   }
-}
-
-void PipelineState::generateWithLegacyPassManager(std::unique_ptr<Module> pipelineModule, raw_pwrite_stream &outStream,
-                                                  Pipeline::CheckShaderCacheFunc checkShaderCacheFunc,
-                                                  ArrayRef<Timer *> timers) {
-
-  unsigned passIndex = 1000;
-  Timer *patchTimer = timers.size() >= 1 ? timers[0] : nullptr;
-  Timer *optTimer = timers.size() >= 2 ? timers[1] : nullptr;
-  Timer *codeGenTimer = timers.size() >= 3 ? timers[2] : nullptr;
-
-  // Set up "whole pipeline" passes, where we have a single module representing the whole pipeline.
-  std::unique_ptr<LegacyPassManager> passMgr(LegacyPassManager::Create());
-  passMgr->setPassIndex(&passIndex);
-  passMgr->add(createTargetTransformInfoWrapperPass(getLgcContext()->getTargetMachine()->getTargetIRAnalysis()));
-
-  // Manually add a target-aware TLI pass, so optimizations do not think that we have library functions.
-  getLgcContext()->preparePassManager(&*passMgr);
-
-  // Manually add a PipelineStateWrapper pass.
-  // We were not using BuilderRecorder, so we do not give our PipelineState to it.
-  // (The first time PipelineStateWrapper is used, it allocates its own PipelineState and populates
-  // it by reading IR metadata.)
-  LegacyPipelineStateWrapper *pipelineStateWrapper = new LegacyPipelineStateWrapper(getLgcContext());
-  passMgr->add(pipelineStateWrapper);
-
-  if (m_emitLgc) {
-    // -emit-lgc: Just write the module.
-    passMgr->add(createPrintModulePass(outStream));
-    passMgr->stop();
-  }
-
-  // Get a BuilderReplayer pass.
-  ModulePass *replayerPass = createLegacyBuilderReplayer(this);
-
-  // Patching.
-  LegacyPatch::addPasses(this, *passMgr, replayerPass, patchTimer, optTimer, std::move(checkShaderCacheFunc),
-                         getLgcContext()->getOptimizationLevel());
 
-  // Add pass to clear pipeline state from IR
-  passMgr->add(createLegacyPipelineStateClearer());
-
-  // Code generation.
-  getLgcContext()->addTargetPasses(*passMgr, codeGenTimer, outStream);
-
-  // Run the "whole pipeline" passes.
-  passMgr->run(*pipelineModule);
+  // See if there was a recoverable error.
+  return getLastError() == "";
 }
 
 // =====================================================================================================================
 // Create an ELF linker object for linking unlinked shader/part-pipeline ELFs into a pipeline ELF using the pipeline
 // state. This needs to be deleted after use.
 ElfLinker *PipelineState::createElfLinker(llvm::ArrayRef<llvm::MemoryBufferRef> elfs) {
   return createElfLinkerImpl(this, elfs);
 }
 
 // =====================================================================================================================
diff --git a/lgc/state/LgcContext.cpp b/lgc/state/LgcContext.cpp
index 3e641f3c8..bae62d84d 100644
--- a/lgc/state/LgcContext.cpp
+++ b/lgc/state/LgcContext.cpp
@@ -47,24 +47,20 @@
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/TargetSelect.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
 
 #define DEBUG_TYPE "lgc-context"
 
 using namespace lgc;
 using namespace llvm;
 
-namespace llvm {
-void initializeLegacyBuilderReplayerPass(PassRegistry &);
-} // namespace llvm
-
 static codegen::RegisterCodeGenFlags CGF;
 
 #ifndef NDEBUG
 static bool Initialized;
 #endif
 
 raw_ostream *LgcContext::m_llpcOuts;
 
 // -emit-llvm: emit LLVM assembly instead of ISA
 static cl::opt<bool> EmitLlvm("emit-llvm", cl::desc("Emit LLVM assembly instead of AMD GPU ISA"), cl::init(false));
@@ -109,47 +105,44 @@ static void setOptionDefault(const char *name, StringRef value) {
 // =====================================================================================================================
 // Initialize the middle-end. This must be called before the first LgcContext::create, although you are
 // allowed to call it again after that. It must also be called before LLVM command-line processing, so
 // that you can use a pass name in an option such as -print-after. If multiple concurrent compiles are
 // possible, this should be called in a thread-safe way.
 void LgcContext::initialize() {
 #ifndef NDEBUG
   Initialized = true;
 #endif
 
-  auto &passRegistry = *PassRegistry::getPassRegistry();
-
   // Initialize LLVM target: AMDGPU
   LLVMInitializeAMDGPUTargetInfo();
   LLVMInitializeAMDGPUTarget();
   LLVMInitializeAMDGPUTargetMC();
   LLVMInitializeAMDGPUAsmPrinter();
   LLVMInitializeAMDGPUAsmParser();
   LLVMInitializeAMDGPUDisassembler();
 
+  auto &passRegistry = *PassRegistry::getPassRegistry();
+
   // Initialize core LLVM passes so they can be referenced by -stop-before etc.
   initializeCore(passRegistry);
   initializeTransformUtils(passRegistry);
   initializeScalarOpts(passRegistry);
   initializeVectorization(passRegistry);
   initializeInstCombine(passRegistry);
   initializeIPO(passRegistry);
   initializeCodeGen(passRegistry);
   initializeShadowStackGCLoweringPass(passRegistry);
   initializeExpandReductionsPass(passRegistry);
   initializeRewriteSymbolsLegacyPassPass(passRegistry);
 
   // Initialize LGC passes so they can be referenced by -stop-before etc.
   initializeUtilPasses(passRegistry);
-  initializeStatePasses(passRegistry);
-  initializeLegacyBuilderReplayerPass(passRegistry);
-  initializePatchPasses(passRegistry);
 
   // Initialize some command-line option defaults.
   setOptionDefault("filetype", "obj");
   setOptionDefault("amdgpu-unroll-max-block-to-analyze", "20");
   setOptionDefault("unroll-max-percent-threshold-boost", "1000");
   setOptionDefault("unroll-allow-partial", "1");
   // TODO: phi-of-ops optimization in NewGVN has some problems, we temporarily
   // disable this to avoid miscompilation, see (https://github.com/GPUOpen-Drivers/llpc/issues/1206).
   setOptionDefault("enable-phi-of-ops", "0");
   setOptionDefault("simplifycfg-sink-common", "0");
@@ -280,40 +273,20 @@ Pipeline *LgcContext::createPipeline() {
 }
 
 // =====================================================================================================================
 // Create a Builder object.
 //
 // @param pipeline : Pipeline object for pipeline compile, nullptr for shader compile
 Builder *LgcContext::createBuilder(Pipeline *pipeline) {
   return Builder::createBuilderRecorder(this, pipeline, EmitLgc);
 }
 
-// =====================================================================================================================
-// Prepare a pass manager. This manually adds a target-aware TLI pass, so middle-end optimizations do not think that
-// we have library functions.
-//
-// @param [in/out] passMgr : Pass manager
-void LgcContext::preparePassManager(legacy::PassManager *passMgr) {
-  TargetLibraryInfoImpl targetLibInfo(getTargetMachine()->getTargetTriple());
-
-  // Adjust it to allow memcpy and memset.
-  // TODO: Investigate why the latter is necessary. I found that
-  // test/shaderdb/ObjStorageBlock_TestMemCpyInt32.comp
-  // got unrolled far too much, and at too late a stage for the descriptor loads to be commoned up. It might
-  // be an unfortunate interaction between LoopIdiomRecognize and fat pointer laundering.
-  targetLibInfo.setAvailable(LibFunc_memcpy);
-  targetLibInfo.setAvailable(LibFunc_memset);
-
-  auto targetLibInfoPass = new TargetLibraryInfoWrapperPass(targetLibInfo);
-  passMgr->add(targetLibInfoPass);
-}
-
 // =====================================================================================================================
 // Prepare a pass manager. This manually adds a target-aware TLI pass, so middle-end optimizations do not think that
 // we have library functions.
 //
 // @param [in/out] passMgr : Pass manager
 void LgcContext::preparePassManager(lgc::PassManager &passMgr) {
   TargetLibraryInfoImpl targetLibInfo(getTargetMachine()->getTargetTriple());
 
   // Adjust it to allow memcpy and memset.
   // TODO: Investigate why the latter is necessary. I found that
diff --git a/lgc/state/PipelineShaders.cpp b/lgc/state/PipelineShaders.cpp
index 87c902f98..5b336cac4 100644
--- a/lgc/state/PipelineShaders.cpp
+++ b/lgc/state/PipelineShaders.cpp
@@ -32,47 +32,29 @@
 #include "lgc/state/PipelineState.h"
 #include "lgc/util/Internal.h"
 #include "llvm/IR/Module.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-pipeline-shaders"
 
 using namespace lgc;
 using namespace llvm;
 
-char LegacyPipelineShaders::ID = 0;
-
-// =====================================================================================================================
-// Create an instance of the pass.
-ModulePass *createLegacyPipelineShaders() {
-  return new LegacyPipelineShaders();
-}
-
 // =====================================================================================================================
 AnalysisKey PipelineShaders::Key;
 
 // =====================================================================================================================
 PipelineShadersResult::PipelineShadersResult() {
   for (auto &entryPoint : m_entryPoints)
     entryPoint = nullptr;
 }
 
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPipelineShaders::runOnModule(Module &module) {
-  m_result = m_impl.runImpl(module);
-  return false;
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : Result object of the PipelineShaders pass
 PipelineShadersResult PipelineShaders::run(Module &module, ModuleAnalysisManager &analysisManager) {
   return runImpl(module);
 }
 
@@ -114,14 +96,10 @@ Function *PipelineShadersResult::getEntryPoint(ShaderStage shaderStage) const {
 // =====================================================================================================================
 // Get the ABI shader stage for a particular function, or ShaderStageInvalid if not a shader entrypoint.
 //
 // @param func : Function to look up
 ShaderStage PipelineShadersResult::getShaderStage(const Function *func) const {
   auto entryMapIt = m_entryPointMap.find(func);
   if (entryMapIt == m_entryPointMap.end())
     return ShaderStageInvalid;
   return entryMapIt->second;
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacyPipelineShaders, DEBUG_TYPE, "LLVM pass for getting pipeline shaders", false, true)
diff --git a/lgc/state/PipelineState.cpp b/lgc/state/PipelineState.cpp
index 4caafc8f8..9e0fc6bd4 100644
--- a/lgc/state/PipelineState.cpp
+++ b/lgc/state/PipelineState.cpp
@@ -206,25 +206,20 @@ static CompSetting computeCompSetting(BufDataFormat dfmt) {
     compSetting = CompSetting::OneCompRed;
     break;
   case 2:
     compSetting = CompSetting::TwoCompGreenRed;
     break;
   }
   return compSetting;
 }
 } // namespace
 
-namespace lgc {
-// Create BuilderReplayer pass
-ModulePass *createLegacyBuilderReplayer(Pipeline *pipeline);
-} // namespace lgc
-
 // =====================================================================================================================
 // Constructor
 //
 // @param builderContext : LGC builder context
 // @param emitLgc : Whether the option -emit-lgc is on
 PipelineState::PipelineState(LgcContext *builderContext, bool emitLgc)
     : Pipeline(builderContext), m_emitLgc(emitLgc), m_meshRowExport(EnableRowExport) {
 }
 
 // =====================================================================================================================
@@ -1760,85 +1755,36 @@ void PipelineState::setXfbStateMetadata(Module *module) {
             streamXfbBuffers[streamId] |= 1 << xfbBuffer; // Bit mask of used xfbBuffers in a stream
           // Get the stride from metadata
           metaOp = cast<ConstantAsMetadata>(xfbStateMetaNode->getOperand(2 * xfbBuffer + 1));
           xfbStrides[xfbBuffer] = cast<ConstantInt>(metaOp->getValue())->getZExtValue();
         }
       }
     }
   }
 }
 
-// =====================================================================================================================
-// Get (create if necessary) the PipelineState from this wrapper pass.
-//
-// @param module : IR module
-PipelineState *LegacyPipelineStateWrapper::getPipelineState(Module *module) {
-  if (!m_pipelineState) {
-    m_allocatedPipelineState = std::make_unique<PipelineState>(m_builderContext);
-    m_pipelineState = &*m_allocatedPipelineState;
-    m_pipelineState->readState(module);
-    m_pipelineState->initializeInOutPackState();
-  }
-  return m_pipelineState;
-}
-
 // =====================================================================================================================
 // Execute this analysis on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this analysis
 // @returns : PipelineStateWrapper result object
 PipelineStateWrapper::Result PipelineStateWrapper::run(Module &module, ModuleAnalysisManager &analysisManager) {
   if (!m_pipelineState) {
     m_allocatedPipelineState = std::make_unique<PipelineState>(m_builderContext);
     m_pipelineState = &*m_allocatedPipelineState;
     m_pipelineState->readState(&module);
     m_pipelineState->initializeInOutPackState();
   }
   return Result(m_pipelineState);
 }
 
-// =====================================================================================================================
-// Pass to clear pipeline state out of the IR
-class LegacyPipelineStateClearer : public ModulePass {
-public:
-  LegacyPipelineStateClearer() : ModulePass(ID) {}
-
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<LegacyPipelineStateWrapper>();
-  }
-
-  bool runOnModule(Module &module) override;
-
-  static char ID; // ID of this pass
-private:
-  PipelineStateClearer m_impl;
-};
-
-char LegacyPipelineStateClearer::ID = 0;
-
-// =====================================================================================================================
-// Create pipeline state clearer pass
-ModulePass *lgc::createLegacyPipelineStateClearer() {
-  return new LegacyPipelineStateClearer();
-}
-
-// =====================================================================================================================
-// Run PipelineStateClearer pass to clear the pipeline state out of the IR
-//
-// @param [in/out] module : IR module
-// @returns : True if the module was modified by the transformation and false otherwise
-bool LegacyPipelineStateClearer::runOnModule(Module &module) {
-  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
-  return m_impl.runImpl(module, pipelineState);
-}
-
 // =====================================================================================================================
 // Run PipelineStateClearer pass to clear the pipeline state out of the IR
 //
 // @param [in/out] module : IR module
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 // @returns : The preserved analyses (The analyses that are still valid after this pass)
 PreservedAnalyses PipelineStateClearer::run(Module &module, ModuleAnalysisManager &analysisManager) {
   PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
   runImpl(module, pipelineState);
   return PreservedAnalyses::none();
@@ -1848,56 +1794,30 @@ PreservedAnalyses PipelineStateClearer::run(Module &module, ModuleAnalysisManage
 // Run PipelineStateClearer pass to clear the pipeline state out of the IR
 //
 // @param [in/out] module : IR module
 // @param : PipelineState object to clear
 // @returns : True if the module was modified by the transformation and false otherwise
 bool PipelineStateClearer::runImpl(Module &module, PipelineState *pipelineState) {
   pipelineState->clear(&module);
   return true;
 }
 
-// =====================================================================================================================
-// Initialize the pipeline state clearer pass
-INITIALIZE_PASS(LegacyPipelineStateClearer, "llpc-pipeline-state-clearer", "LLPC pipeline state clearer", false, true)
-
-// =====================================================================================================================
-char LegacyPipelineStateWrapper::ID = 0;
-
 // =====================================================================================================================
 AnalysisKey PipelineStateWrapper::Key;
 
 // =====================================================================================================================
 //
 // @param pipelineState : Pipeline state to wrap
 PipelineStateWrapperResult::PipelineStateWrapperResult(PipelineState *pipelineState) : m_pipelineState(pipelineState) {
 }
 
 // =====================================================================================================================
 //
 // @param builderContext : LgcContext
 PipelineStateWrapper::PipelineStateWrapper(LgcContext *builderContext) : m_builderContext(builderContext) {
 }
 
 // =====================================================================================================================
 //
 // @param pipelineState : Pipeline state to wrap
 PipelineStateWrapper::PipelineStateWrapper(PipelineState *pipelineState) : m_pipelineState(pipelineState) {
 }
-
-// =====================================================================================================================
-//
-// @param builderContext : LgcContext
-LegacyPipelineStateWrapper::LegacyPipelineStateWrapper(LgcContext *builderContext)
-    : ImmutablePass(ID), m_builderContext(builderContext) {
-}
-
-// =====================================================================================================================
-// Clean-up of LegacyPipelineStateWrapper at end of pass manager run
-//
-// @param module : Module
-bool LegacyPipelineStateWrapper::doFinalization(Module &module) {
-  return false;
-}
-
-// =====================================================================================================================
-// Initialize the pipeline state wrapper pass
-INITIALIZE_PASS(LegacyPipelineStateWrapper, DEBUG_TYPE, "LLPC pipeline state wrapper", false, true)
diff --git a/lgc/test/InOutPackingNonZeroBase.lgc b/lgc/test/InOutPackingNonZeroBase.lgc
index a0af07d37..c58d285bf 100644
--- a/lgc/test/InOutPackingNonZeroBase.lgc
+++ b/lgc/test/InOutPackingNonZeroBase.lgc
@@ -1,12 +1,12 @@
 ; Check that input-output packing works with non-zero-based vector components.
-; RUN: lgc -mcpu=gfx900 --stop-after=lgc-patch-resource-collect %s -v --emit-llvm --verify-ir -o=- 2>&1 \
+; RUN: lgc -mcpu=gfx900 --print-after=lgc-patch-resource-collect %s -v --emit-llvm --verify-ir -o=/dev/null 2>&1 \
 ; RUN:   | FileCheck %s
 
 ; ModuleID = 'lgcPipeline'
 source_filename = "lgcPipeline"
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; CHECK-LABEL: {{^//}} LLPC location input/output mapping results (FS shader)
 ;
 ; CHECK:      (FS) Input:  loc = 0, comp = 0 =>  Mapped = 0, 0
diff --git a/lgc/tool/lgc/lgc.cpp b/lgc/tool/lgc/lgc.cpp
index ba052fb3c..bbde49b7d 100644
--- a/lgc/tool/lgc/lgc.cpp
+++ b/lgc/tool/lgc/lgc.cpp
@@ -409,21 +409,21 @@ int main(int argc, char **argv) {
             err = pipeline->getLastError();
         }
       } else if (Passes.getNumOccurrences() > 0) {
         // Run a pass pipeline.
         pipeline->setStateFromModule(&*module);
 
         if (!runPassPipeline(*pipeline, *module, outStream))
           return 1;
       } else {
         // Run the middle-end compiler.
-        if (!pipeline->generate(std::move(module), outStream, nullptr, {}, true))
+        if (!pipeline->generate(std::move(module), outStream, nullptr, {}))
           err = pipeline->getLastError();
       }
 
       if (err != "") {
         // Link or compile reported recoverable error.
         errs() << err << "\n";
         return 1;
       }
 
       if (!outputToFile) {
diff --git a/llpc/context/llpcCompiler.cpp b/llpc/context/llpcCompiler.cpp
index 1c2863f9f..1b84fa779 100644
--- a/llpc/context/llpcCompiler.cpp
+++ b/llpc/context/llpcCompiler.cpp
@@ -364,22 +364,20 @@ Result VKAPI_CALL ICompiler::Create(GfxIpVersion gfxIp, unsigned optionCount, co
   Result result = Result::Success;
 
   const char *client = options[0];
   bool ignoreErrors = (strcmp(client, VkIcdName) == 0);
 
   raw_null_ostream nullStream;
 
   std::lock_guard<sys::Mutex> lock(*SCompilerMutex);
   MetroHash::Hash optionHash = Compiler::generateHashForCompileOptions(optionCount, options);
 
-  // Initialize passes so they can be referenced by -print-after etc.
-  initializeLowerPasses(*PassRegistry::getPassRegistry());
   LgcContext::initialize();
 
   bool parseCmdOption = true;
   if (HaveParsedOptions) {
     bool isSameOption = memcmp(&optionHash, &SOptionHash, sizeof(optionHash)) == 0;
 
     parseCmdOption = false;
     if (!isSameOption) {
       if (Compiler::getOutRedirectCount() == 0) {
         // All compiler instances are destroyed, we can reset LLVM options
@@ -1260,21 +1258,21 @@ Result Compiler::buildPipelineInternal(Context *context, ArrayRef<const Pipeline
     result = Result::ErrorInvalidShader;
     try
 #endif
     {
       Timer *timers[] = {
           timerProfiler.getTimer(TimerPatch),
           timerProfiler.getTimer(TimerOpt),
           timerProfiler.getTimer(TimerCodeGen),
       };
 
-      pipeline->generate(std::move(pipelineModule), elfStream, checkShaderCacheFunc, timers, true);
+      pipeline->generate(std::move(pipelineModule), elfStream, checkShaderCacheFunc, timers);
 #if LLPC_ENABLE_EXCEPTION
       result = Result::Success;
 #endif
     }
 #if LLPC_ENABLE_EXCEPTION
     catch (const char *) {
     }
 #endif
   }
   if (checkPerStageCache) {
@@ -2182,21 +2180,21 @@ Result Compiler::buildRayTracingPipelineElf(Context *context, Module *module, El
 #if LLPC_ENABLE_EXCEPTION
   try
 #endif
   {
     Timer *timers[] = {
         timerProfiler.getTimer(TimerPatch),
         timerProfiler.getTimer(TimerOpt),
         timerProfiler.getTimer(TimerCodeGen),
     };
 
-    pipeline->generate(std::move(pipelineModule), elfStream, nullptr, timers, true);
+    pipeline->generate(std::move(pipelineModule), elfStream, nullptr, timers);
   }
 #if LLPC_ENABLE_EXCEPTION
   catch (const char *) {
     return Result::ErrorInvalidShader;
   }
 #endif
 
   if (moduleIndex > 0)
     addRayTracingIndirectPipelineMetadata(elfPackage);
 
@@ -2801,42 +2799,20 @@ Context *Compiler::acquireContext() const {
     freeContext = new Context(m_gfxIp);
     m_contextPool->push_back(freeContext);
   }
 
   assert(freeContext);
   freeContext->setInUse(true);
 
   return freeContext;
 }
 
-// =====================================================================================================================
-// Run legacy pass manager's passes on a module, catching any LLVM fatal error and returning a success indication
-//
-// @param passMgr : Pass manager
-// @param [in/out] module : Module
-bool Compiler::runPasses(lgc::LegacyPassManager *passMgr, Module *module) const {
-  bool success = false;
-#if LLPC_ENABLE_EXCEPTION
-  try
-#endif
-  {
-    passMgr->run(*module);
-    success = true;
-  }
-#if LLPC_ENABLE_EXCEPTION
-  catch (const char *) {
-    success = false;
-  }
-#endif
-  return success;
-}
-
 // =====================================================================================================================
 // Run pass manager's passes on a module, catching any LLVM fatal error and returning a success indication
 //
 // @param passMgr : Pass manager
 // @param [in/out] module : Module
 bool Compiler::runPasses(lgc::PassManager *passMgr, Module *module) const {
   bool success = false;
 #if LLPC_ENABLE_EXCEPTION
   try
 #endif
diff --git a/llpc/context/llpcCompiler.h b/llpc/context/llpcCompiler.h
index fadf59d8b..07b815c26 100644
--- a/llpc/context/llpcCompiler.h
+++ b/llpc/context/llpcCompiler.h
@@ -39,21 +39,20 @@
 #include "lgc/CommonDefs.h"
 
 namespace llvm {
 
 class Module;
 
 } // namespace llvm
 
 namespace lgc {
 
-class LegacyPassManager;
 class PassManager;
 class Pipeline;
 enum class PipelineLink : unsigned;
 
 } // namespace lgc
 
 namespace Llpc {
 
 using Vkgc::ElfPackage;
 using Vkgc::findVkStructInChain;
@@ -180,21 +179,20 @@ public:
 
 #endif
 
 private:
   Compiler() = delete;
   Compiler(const Compiler &) = delete;
   Compiler &operator=(const Compiler &) = delete;
 
   Result validatePipelineShaderInfo(const PipelineShaderInfo *shaderInfo) const;
 
-  bool runPasses(lgc::LegacyPassManager *passMgr, llvm::Module *module) const;
   bool runPasses(lgc::PassManager *passMgr, llvm::Module *module) const;
   bool linkRelocatableShaderElf(ElfPackage *shaderElfs, ElfPackage *pipelineElf, Context *context);
   bool canUseRelocatableGraphicsShaderElf(const llvm::ArrayRef<const PipelineShaderInfo *> &shaderInfo,
                                           const GraphicsPipelineBuildInfo *pipelineInfo);
   bool canUseRelocatableComputeShaderElf(const ComputePipelineBuildInfo *pipelineInfo);
 #if VKI_RAY_TRACING
   Result buildRayTracingPipelineInternal(Context *context, llvm::ArrayRef<const PipelineShaderInfo *> shaderInfo,
                                          bool unlinked, std::vector<ElfPackage> &pipelineElfs,
                                          std::vector<Vkgc::RayTracingShaderProperty> &shaderProps,
                                          IHelperThreadProvider *helperThreadProvider);
diff --git a/llpc/lower/llpcSpirvLower.cpp b/llpc/lower/llpcSpirvLower.cpp
index b90ec58d3..0496d66bd 100644
--- a/llpc/lower/llpcSpirvLower.cpp
+++ b/llpc/lower/llpcSpirvLower.cpp
@@ -284,117 +284,20 @@ void SpirvLower::replaceGlobal(Context *context, GlobalVariable *original, Globa
   for (User *user : users) {
     Instruction *inst = cast<Instruction>(user);
     builder->SetInsertPoint(inst);
     Value *replacedValue = builder->CreateBitCast(replacement, original->getType());
     user->replaceUsesOfWith(original, replacedValue);
   }
   original->dropAllReferences();
   original->eraseFromParent();
 }
 
-// =====================================================================================================================
-// Add per-shader lowering passes to pass manager
-//
-// @param context : LLPC context
-// @param stage : Shader stage
-// @param [in/out] passMgr : Pass manager to add passes to
-// @param lowerTimer : Timer to time lower passes with, nullptr if not timing
-#if VKI_RAY_TRACING
-// @param rayTracing : Whether we are lowering a ray tracing pipeline shader
-// @param rayQuery : Whether we are lowering a ray query library
-// @param isInternalRtShader : Whether we are lowering an internal ray tracing shader
-#endif
-void LegacySpirvLower::addPasses(Context *context, ShaderStage stage, legacy::PassManager &passMgr, Timer *lowerTimer
-#if VKI_RAY_TRACING
-                                 ,
-                                 bool rayTracing, bool rayQuery, bool isInternalRtShader
-#endif
-) {
-  // Manually add a target-aware TLI pass, so optimizations do not think that we have library functions.
-  context->getLgcContext()->preparePassManager(&passMgr);
-
-  // Start timer for lowering passes.
-  if (lowerTimer)
-    passMgr.add(LgcContext::createStartStopTimer(lowerTimer, true));
-
-#if VKI_RAY_TRACING
-  if (isInternalRtShader)
-    passMgr.add(createLegacySpirvLowerRayTracingIntrinsics());
-#endif
-
-  // Lower SPIR-V CFG merges before inlining
-  passMgr.add(createLegacySpirvLowerCfgMerges());
-
-  // Function inlining. Use the "always inline" pass, since we want to inline all functions, and
-  // we marked (non-entrypoint) functions as "always inline" just after SPIR-V reading.
-  passMgr.add(createAlwaysInlinerLegacyPass());
-  passMgr.add(createGlobalDCEPass());
-
-  // Lower SPIR-V access chain
-  passMgr.add(createLegacySpirvLowerAccessChain());
-
-#if VKI_RAY_TRACING
-  if (rayTracing)
-    passMgr.add(createLegacySpirvLowerRayTracingBuiltIn());
-  if (rayQuery)
-    passMgr.add(createLegacySpirvLowerRayQueryPostInline());
-#endif
-
-  // Lower SPIR-V terminators
-  passMgr.add(createLegacySpirvLowerTerminator());
-
-  // Lower SPIR-V global variables, inputs, and outputs
-  passMgr.add(createLegacySpirvLowerGlobal());
-
-  // Lower SPIR-V constant immediate store.
-  passMgr.add(createLegacySpirvLowerConstImmediateStore());
-
-  // Lower SPIR-V constant folding - must be done before instruction combining pass.
-  passMgr.add(createLegacySpirvLowerMathConstFolding());
-
-  // Lower SPIR-V memory operations
-  passMgr.add(createLegacySpirvLowerMemoryOp());
-
-  // Remove redundant load/store operations and do minimal optimization
-  // It is required by SpirvLowerImageOp.
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
-  // Old version of the code
-  passMgr.add(createSROAPass());
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
-  passMgr.add(createSROAPass(false));
-#endif
-  passMgr.add(createGlobalOptimizerPass());
-  passMgr.add(createAggressiveDCEPass());
-  passMgr.add(createInstructionCombiningPass(2));
-  passMgr.add(createCFGSimplificationPass());
-  passMgr.add(createEarlyCSEPass());
-
-  // Lower SPIR-V floating point optimisation
-  passMgr.add(createLegacySpirvLowerMathFloatOp());
-
-  // Lower SPIR-V instruction metadata remove
-  passMgr.add(createLegacySpirvLowerInstMetaRemove());
-
-  // Stop timer for lowering passes.
-  if (lowerTimer)
-    passMgr.add(LgcContext::createStartStopTimer(lowerTimer, false));
-
-  // Dump the result
-  if (EnableOuts()) {
-    passMgr.add(createPrintModulePass(
-        outs(), "\n"
-                "===============================================================================\n"
-                "// LLPC SPIR-V lowering results\n"));
-  }
-}
-
 // =====================================================================================================================
 // Initializes the pass according to the specified module.
 //
 // NOTE: This function should be called at the beginning of "runOnModule()".
 //
 // @param module : LLVM module
 void SpirvLower::init(Module *module) {
   m_module = module;
   m_context = static_cast<Context *>(&m_module->getContext());
   if (m_module->empty()) {
diff --git a/llpc/lower/llpcSpirvLower.h b/llpc/lower/llpcSpirvLower.h
index 412c6f31c..d33d2d15e 100644
--- a/llpc/lower/llpcSpirvLower.h
+++ b/llpc/lower/llpcSpirvLower.h
@@ -33,99 +33,33 @@
 #include "llpc.h"
 #include "llpcUtil.h"
 #include "llvm/Pass.h"
 
 namespace llvm {
 
 class Constant;
 class GlobalVariable;
 class Timer;
 
-namespace legacy {
-
-class PassManager;
-
-} // namespace legacy
-
-class PassRegistry;
-void initializeLegacySpirvLowerAccessChainPass(PassRegistry &);
-void initializeLegacySpirvLowerCfgMergesPass(PassRegistry &);
-void initializeLegacySpirvLowerMathConstFoldingPass(PassRegistry &);
-void initializeLegacySpirvLowerMathFloatOpPass(PassRegistry &);
-void initializeLegacySpirvLowerConstImmediateStorePass(PassRegistry &);
-void initializeLegacySpirvLowerMemoryOpPass(PassRegistry &);
-void initializeLegacySpirvLowerGlobalPass(PassRegistry &);
-void initializeLegacySpirvLowerInstMetaRemovePass(PassRegistry &);
-#if VKI_RAY_TRACING
-void initializeLegacySpirvLowerRayTracingPass(PassRegistry &);
-void initializeLegacySpirvLowerRayTracingBuiltInPass(PassRegistry &);
-void initializeLegacySpirvLowerRayQueryPass(PassRegistry &);
-void initializeLegacySpirvLowerRayQueryPostInlinePass(PassRegistry &);
-void initializeLegacySpirvLowerRayTracingIntrinsicsPass(PassRegistry &);
-#endif
-void initializeLegacySpirvLowerTerminatorPass(PassRegistry &);
-void initializeLegacySpirvLowerTranslatorPass(PassRegistry &);
 } // namespace llvm
 
 namespace lgc {
 
 class Builder;
 class PassManager;
 
 } // namespace lgc
 
 namespace Llpc {
 
-// Initialize passes for SPIR-V lowering
-//
-// @param passRegistry : Pass registry
-inline void initializeLowerPasses(llvm::PassRegistry &passRegistry) {
-  initializeLegacySpirvLowerAccessChainPass(passRegistry);
-  initializeLegacySpirvLowerCfgMergesPass(passRegistry);
-  initializeLegacySpirvLowerConstImmediateStorePass(passRegistry);
-  initializeLegacySpirvLowerMathConstFoldingPass(passRegistry);
-  initializeLegacySpirvLowerMathFloatOpPass(passRegistry);
-  initializeLegacySpirvLowerMemoryOpPass(passRegistry);
-  initializeLegacySpirvLowerGlobalPass(passRegistry);
-  initializeLegacySpirvLowerInstMetaRemovePass(passRegistry);
-#if VKI_RAY_TRACING
-  initializeLegacySpirvLowerRayTracingPass(passRegistry);
-  initializeLegacySpirvLowerRayTracingBuiltInPass(passRegistry);
-  initializeLegacySpirvLowerRayQueryPass(passRegistry);
-  initializeLegacySpirvLowerRayQueryPostInlinePass(passRegistry);
-  initializeLegacySpirvLowerRayTracingIntrinsicsPass(passRegistry);
-#endif
-  initializeLegacySpirvLowerTerminatorPass(passRegistry);
-  initializeLegacySpirvLowerTranslatorPass(passRegistry);
-}
-
 class Context;
 
-llvm::ModulePass *createLegacySpirvLowerAccessChain();
-llvm::ModulePass *createLegacySpirvLowerCfgMerges();
-llvm::ModulePass *createLegacySpirvLowerConstImmediateStore();
-llvm::ModulePass *createLegacySpirvLowerMathConstFolding();
-llvm::ModulePass *createLegacySpirvLowerMathFloatOp();
-llvm::ModulePass *createLegacySpirvLowerMemoryOp();
-llvm::ModulePass *createLegacySpirvLowerGlobal();
-llvm::ModulePass *createLegacySpirvLowerInstMetaRemove();
-#if VKI_RAY_TRACING
-llvm::ModulePass *createLegacySpirvLowerRayTracing(bool rayQueryLibrary);
-llvm::ModulePass *createLegacySpirvLowerRayTracingBuiltIn();
-llvm::ModulePass *createLegacySpirvLowerRayQuery(bool rayQueryLibrary);
-llvm::ModulePass *createLegacySpirvLowerRayQueryPostInline();
-llvm::ModulePass *createLegacySpirvLowerRayTracingIntrinsics();
-#endif
-llvm::ModulePass *createSpirvLowerResourceCollect(bool collectDetailUsage);
-llvm::ModulePass *createLegacySpirvLowerTerminator();
-llvm::ModulePass *createSpirvLowerTranslator(ShaderStage stage, const PipelineShaderInfo *shaderInfo);
-
 // =====================================================================================================================
 // Represents the pass of SPIR-V lowering operations, as the base class.
 class SpirvLower {
 public:
   explicit SpirvLower() {}
 
   // Add per-shader lowering passes to pass manager
   static void addPasses(Context *context, ShaderStage stage, lgc::PassManager &passMgr, llvm::Timer *lowerTimer
 #if VKI_RAY_TRACING
                         ,
@@ -142,32 +76,11 @@ public:
 protected:
   void init(llvm::Module *module);
 
   llvm::Module *m_module = nullptr;               // LLVM module to be run on
   Context *m_context = nullptr;                   // Associated LLPC context of the LLVM module that passes run on
   ShaderStage m_shaderStage = ShaderStageInvalid; // Shader stage
   llvm::Function *m_entryPoint = nullptr;         // Entry point of input module
   lgc::Builder *m_builder = nullptr;              // LGC builder object
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class. Used as the base class for the legacy
-// lower passes.
-class LegacySpirvLower : public llvm::ModulePass, public SpirvLower {
-public:
-  explicit LegacySpirvLower(char &pid) : llvm::ModulePass(pid) {}
-
-  // Add per-shader lowering passes to pass manager
-  static void addPasses(Context *context, ShaderStage stage, llvm::legacy::PassManager &passMgr, llvm::Timer *lowerTimer
-#if VKI_RAY_TRACING
-                        ,
-                        bool rayTracing, bool rayQuery, bool isInternalRtShader
-#endif
-  );
-
-private:
-  LegacySpirvLower() = delete;
-  LegacySpirvLower(const LegacySpirvLower &) = delete;
-  LegacySpirvLower &operator=(const LegacySpirvLower &) = delete;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerAccessChain.cpp b/llpc/lower/llpcSpirvLowerAccessChain.cpp
index 5bf221f13..4c9a020e4 100644
--- a/llpc/lower/llpcSpirvLowerAccessChain.cpp
+++ b/llpc/lower/llpcSpirvLowerAccessChain.cpp
@@ -37,42 +37,20 @@
 #include <stack>
 
 #define DEBUG_TYPE "llpc-spirv-lower-access-chain"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerAccessChain::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering operations for access chain
-ModulePass *createLegacySpirvLowerAccessChain() {
-  return new LegacySpirvLowerAccessChain();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerAccessChain::LegacySpirvLowerAccessChain() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerAccessChain::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerAccessChain::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -245,14 +223,10 @@ void SpirvLowerAccessChain::appendZeroIndexToMatchTypes(SmallVectorImpl<Value *>
     else if (unpackType->isArrayTy())
       unpackType = unpackType->getArrayElementType();
     else if (unpackType->isVectorTy())
       unpackType = cast<VectorType>(unpackType)->getElementType();
     else
       llvm_unreachable("Should never be called!");
   }
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering operations for access chain.
-INITIALIZE_PASS(LegacySpirvLowerAccessChain, DEBUG_TYPE, "Lower SPIR-V access chain", false, false)
diff --git a/llpc/lower/llpcSpirvLowerAccessChain.h b/llpc/lower/llpcSpirvLowerAccessChain.h
index 886a170e2..922d20923 100644
--- a/llpc/lower/llpcSpirvLowerAccessChain.h
+++ b/llpc/lower/llpcSpirvLowerAccessChain.h
@@ -48,28 +48,11 @@ public:
   bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V access chain"; }
 
 private:
   llvm::GetElementPtrInst *tryToCoalesceChain(llvm::GetElementPtrInst *getElemPtr, unsigned addrSpace);
   void appendZeroIndexToMatchTypes(llvm::SmallVectorImpl<llvm::Value *> &indexOperands, llvm::Type *typeToMatch,
                                    llvm::Type *baseType);
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering operations for access chain.
-class LegacySpirvLowerAccessChain : public llvm::ModulePass {
-public:
-  LegacySpirvLowerAccessChain();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerAccessChain(const LegacySpirvLowerAccessChain &) = delete;
-  LegacySpirvLowerAccessChain &operator=(const LegacySpirvLowerAccessChain &) = delete;
-
-  SpirvLowerAccessChain Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerCfgMerges.cpp b/llpc/lower/llpcSpirvLowerCfgMerges.cpp
index 025f837f6..ed472eb65 100644
--- a/llpc/lower/llpcSpirvLowerCfgMerges.cpp
+++ b/llpc/lower/llpcSpirvLowerCfgMerges.cpp
@@ -62,42 +62,20 @@
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 // -enable-loop-reconvergence: force enable loop reconvergence transform
 static cl::opt<bool> EnableLoopReconvergence("enable-loop-reconvergence",
                                              cl::desc("Force enable loop reconvergence transform"), cl::init(false));
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerCfgMerges::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering terminator operations
-ModulePass *createLegacySpirvLowerCfgMerges() {
-  return new LegacySpirvLowerCfgMerges();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerCfgMerges::LegacySpirvLowerCfgMerges() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerCfgMerges::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerCfgMerges::run(Module &module, ModuleAnalysisManager &analysisManager) {
   bool changed = runImpl(module);
   // In practice there are unlikely to be any analyses this early, but report accurate status anyway.
   return changed ? PreservedAnalyses::none() : PreservedAnalyses::all();
 }
@@ -663,14 +641,10 @@ bool SpirvLowerCfgMerges::runImpl(Module &module) {
         }
       }
     }
   }
 
   m_convergentValues.clear();
   return true;
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering terminator operations..
-INITIALIZE_PASS(LegacySpirvLowerCfgMerges, DEBUG_TYPE, "Lower SPIR-V CFG merges", false, false)
diff --git a/llpc/lower/llpcSpirvLowerCfgMerges.h b/llpc/lower/llpcSpirvLowerCfgMerges.h
index c72a355fd..3c6973c71 100644
--- a/llpc/lower/llpcSpirvLowerCfgMerges.h
+++ b/llpc/lower/llpcSpirvLowerCfgMerges.h
@@ -43,28 +43,11 @@ public:
   bool runImpl(llvm::Module &module);
 
   void mapConvergentValues(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V CFG merges"; }
 
 private:
   llvm::DenseSet<llvm::Value *> m_convergentValues;
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerCfgMerges : public llvm::ModulePass {
-public:
-  LegacySpirvLowerCfgMerges();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerCfgMerges(const LegacySpirvLowerCfgMerges &) = delete;
-  LegacySpirvLowerCfgMerges &operator=(const LegacySpirvLowerCfgMerges &) = delete;
-
-  SpirvLowerCfgMerges Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerConstImmediateStore.cpp b/llpc/lower/llpcSpirvLowerConstImmediateStore.cpp
index c05b7b98e..5db4826a0 100644
--- a/llpc/lower/llpcSpirvLowerConstImmediateStore.cpp
+++ b/llpc/lower/llpcSpirvLowerConstImmediateStore.cpp
@@ -36,42 +36,20 @@
 #include <vector>
 
 #define DEBUG_TYPE "llpc-spirv-lower-const-immediate-store"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerConstImmediateStore::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering operations for constant immediate store
-ModulePass *createLegacySpirvLowerConstImmediateStore() {
-  return new LegacySpirvLowerConstImmediateStore();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerConstImmediateStore::LegacySpirvLowerConstImmediateStore() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerConstImmediateStore::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerConstImmediateStore::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -212,14 +190,10 @@ void SpirvLowerConstImmediateStore::convertAllocaToReadOnlyGlobal(StoreInst *sto
         *useIt = UndefValue::get(allocaInst->getType());
       } else
         *useIt = global;
     }
     // Visit next map pair.
   } while (!allocaToGlobalMap.empty());
   storeInst->eraseFromParent();
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering operations for constant immediate store.
-INITIALIZE_PASS(LegacySpirvLowerConstImmediateStore, DEBUG_TYPE, "Lower SPIR-V constant immediate store", false, false)
diff --git a/llpc/lower/llpcSpirvLowerConstImmediateStore.h b/llpc/lower/llpcSpirvLowerConstImmediateStore.h
index b0c60dc44..dd89c8513 100644
--- a/llpc/lower/llpcSpirvLowerConstImmediateStore.h
+++ b/llpc/lower/llpcSpirvLowerConstImmediateStore.h
@@ -48,28 +48,11 @@ public:
   bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V constant immediate store"; }
 
 private:
   void processAllocaInsts(llvm::Function *func);
   llvm::StoreInst *findSingleStore(llvm::AllocaInst *allocaInst);
   void convertAllocaToReadOnlyGlobal(llvm::StoreInst *storeInst);
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerConstImmediateStore : public llvm::ModulePass {
-public:
-  LegacySpirvLowerConstImmediateStore();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerConstImmediateStore(const LegacySpirvLowerConstImmediateStore &) = delete;
-  LegacySpirvLowerConstImmediateStore &operator=(const LegacySpirvLowerConstImmediateStore &) = delete;
-
-  SpirvLowerConstImmediateStore Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerGlobal.cpp b/llpc/lower/llpcSpirvLowerGlobal.cpp
index bce62a9a3..31e3aff4e 100644
--- a/llpc/lower/llpcSpirvLowerGlobal.cpp
+++ b/llpc/lower/llpcSpirvLowerGlobal.cpp
@@ -172,46 +172,24 @@ static_assert(lgc::ShadingRateVertical2Pixels ==
 static_assert(lgc::ShadingRateVertical4Pixels ==
                   static_cast<lgc::ShadingRateFlags>(spv::FragmentShadingRateVertical4PixelsMask),
               "Shading rate flag mismatch");
 static_assert(lgc::ShadingRateHorizontal2Pixels ==
                   static_cast<lgc::ShadingRateFlags>(spv::FragmentShadingRateHorizontal2PixelsMask),
               "Shading rate flag mismatch");
 static_assert(lgc::ShadingRateHorizontal4Pixels ==
                   static_cast<lgc::ShadingRateFlags>(spv::FragmentShadingRateHorizontal4PixelsMask),
               "Shading rate flag mismatch");
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerGlobal::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering operations for globals
-ModulePass *createLegacySpirvLowerGlobal() {
-  return new LegacySpirvLowerGlobal();
-}
-
 // =====================================================================================================================
 SpirvLowerGlobal::SpirvLowerGlobal() : m_retBlock(nullptr), m_lowerInputInPlace(false), m_lowerOutputInPlace(false) {
 }
 
-// =====================================================================================================================
-LegacySpirvLowerGlobal::LegacySpirvLowerGlobal() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerGlobal::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerGlobal::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -2720,15 +2698,10 @@ void SpirvLowerGlobal::interpolateInputElement(unsigned interpLoc, Value *auxInt
     callInst.replaceAllUsesWith(interpElemValue);
 
     if (callInst.user_empty()) {
       callInst.dropAllReferences();
       callInst.eraseFromParent();
     }
   }
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering operations for globals.
-INITIALIZE_PASS(LegacySpirvLowerGlobal, DEBUG_TYPE, "Lower SPIR-V globals (global variables, inputs, and outputs)",
-                false, false)
diff --git a/llpc/lower/llpcSpirvLowerGlobal.h b/llpc/lower/llpcSpirvLowerGlobal.h
index f9d5c9432..58bbbcb6a 100644
--- a/llpc/lower/llpcSpirvLowerGlobal.h
+++ b/llpc/lower/llpcSpirvLowerGlobal.h
@@ -132,28 +132,11 @@ private:
 
   std::unordered_set<llvm::ReturnInst *> m_retInsts;     // "Return" instructions to be removed
   std::unordered_set<llvm::CallInst *> m_emitCalls;      // "Call" instructions to emit vertex (geometry shader)
   std::unordered_set<llvm::LoadInst *> m_loadInsts;      // "Load" instructions to be removed
   std::unordered_set<llvm::StoreInst *> m_storeInsts;    // "Store" instructions to be removed
   std::unordered_set<llvm::Instruction *> m_atomicInsts; // "Atomicrwm" or "cmpxchg" instructions to be removed
   std::unordered_set<llvm::CallInst *> m_interpCalls;    // "Call" instruction to do input interpolation
                                                          // (fragment shader)
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerGlobal : public llvm::ModulePass {
-public:
-  LegacySpirvLowerGlobal();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerGlobal(const LegacySpirvLowerGlobal &) = delete;
-  LegacySpirvLowerGlobal &operator=(const LegacySpirvLowerGlobal &) = delete;
-
-  SpirvLowerGlobal Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerInstMetaRemove.cpp b/llpc/lower/llpcSpirvLowerInstMetaRemove.cpp
index 9cf488bf9..68e11c349 100644
--- a/llpc/lower/llpcSpirvLowerInstMetaRemove.cpp
+++ b/llpc/lower/llpcSpirvLowerInstMetaRemove.cpp
@@ -35,38 +35,24 @@
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "llpc-spirv-lower-inst-meta-remove"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerInstMetaRemove::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering operations for removing the instruction metadata
-ModulePass *createLegacySpirvLowerInstMetaRemove() {
-  return new LegacySpirvLowerInstMetaRemove();
-}
-
 // =====================================================================================================================
 SpirvLowerInstMetaRemove::SpirvLowerInstMetaRemove() : m_changed(false) {
 }
 
-// =====================================================================================================================
-LegacySpirvLowerInstMetaRemove::LegacySpirvLowerInstMetaRemove() : ModulePass(ID) {
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerInstMetaRemove::run(Module &module, ModuleAnalysisManager &analysisManager) {
   if (runImpl(module))
     return PreservedAnalyses::none();
   return PreservedAnalyses::all();
 }
@@ -106,24 +92,11 @@ bool SpirvLowerInstMetaRemove::runImpl(Module &module) {
       nodesToRemove.push_back(&namedMdNode);
   }
   for (NamedMDNode *namedMdNode : nodesToRemove) {
     namedMdNode->eraseFromParent();
     m_changed = true;
   }
 
   return m_changed;
 }
 
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerInstMetaRemove::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering operations for removing instruction metadata.
-INITIALIZE_PASS(LegacySpirvLowerInstMetaRemove, DEBUG_TYPE,
-                "Lower SPIR-V instruction metadata by removing those targeted", false, false)
diff --git a/llpc/lower/llpcSpirvLowerInstMetaRemove.h b/llpc/lower/llpcSpirvLowerInstMetaRemove.h
index f3469435c..8833823a5 100644
--- a/llpc/lower/llpcSpirvLowerInstMetaRemove.h
+++ b/llpc/lower/llpcSpirvLowerInstMetaRemove.h
@@ -43,28 +43,11 @@ public:
 
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
   bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V instruction metadata by removing those targeted"; }
 
 private:
   bool m_changed; // Whether the module is changed
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerInstMetaRemove : public llvm::ModulePass {
-public:
-  LegacySpirvLowerInstMetaRemove();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerInstMetaRemove(const LegacySpirvLowerInstMetaRemove &) = delete;
-  LegacySpirvLowerInstMetaRemove &operator=(const LegacySpirvLowerInstMetaRemove &) = delete;
-
-  SpirvLowerInstMetaRemove Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerMath.cpp b/llpc/lower/llpcSpirvLowerMath.cpp
index b047ad65f..4b006d41a 100644
--- a/llpc/lower/llpcSpirvLowerMath.cpp
+++ b/llpc/lower/llpcSpirvLowerMath.cpp
@@ -45,67 +45,20 @@
 #include "llvm/Transforms/Utils/Local.h"
 
 #define DEBUG_TYPE_CONST_FOLDING "llpc-spirv-lower-math-const-folding"
 #define DEBUG_TYPE_FLOAT_OP "llpc-spirv-lower-math-float-op"
 
 using namespace lgc;
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
-namespace Llpc {
-
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerMathConstFolding : public ModulePass {
-public:
-  LegacySpirvLowerMathConstFolding() : ModulePass(ID) {}
-
-  void getAnalysisUsage(AnalysisUsage &analysisUsage) const override {
-    analysisUsage.addRequired<TargetLibraryInfoWrapperPass>();
-  }
-
-  virtual bool runOnModule(Module &module) override;
-
-  static char ID;
-
-  LegacySpirvLowerMathConstFolding(const LegacySpirvLowerMathConstFolding &) = delete;
-  LegacySpirvLowerMathConstFolding &operator=(const LegacySpirvLowerMathConstFolding &) = delete;
-
-private:
-  SpirvLowerMathConstFolding m_impl;
-};
-
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerMathFloatOp : public ModulePass {
-public:
-  LegacySpirvLowerMathFloatOp() : ModulePass(ID) {}
-
-  virtual bool runOnModule(Module &module) override;
-
-  static char ID;
-
-  LegacySpirvLowerMathFloatOp(const LegacySpirvLowerMathFloatOp &) = delete;
-  LegacySpirvLowerMathFloatOp &operator=(const LegacySpirvLowerMathFloatOp &) = delete;
-
-private:
-  SpirvLowerMathFloatOp m_impl;
-};
-
-} // namespace Llpc
-
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerMathConstFolding::ID = 0;
-char LegacySpirvLowerMathFloatOp::ID = 0;
-
 // =====================================================================================================================
 SpirvLowerMath::SpirvLowerMath()
     : m_changed(false), m_fp16DenormFlush(false), m_fp32DenormFlush(false), m_fp64DenormFlush(false),
       m_fp16RoundToZero(false) {
 }
 
 // =====================================================================================================================
 // Initialise transform class.
 //
 // @param [in/out] module : LLVM module to be run on
@@ -195,30 +148,20 @@ void SpirvLowerMath::disableFastMath(Value *value) {
         }
       }
     }
 
     it = workSet.erase(it);
   }
 }
 
 #define DEBUG_TYPE DEBUG_TYPE_CONST_FOLDING
 
-// =====================================================================================================================
-// Executes constant folding SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerMathConstFolding::runOnModule(Module &module) {
-  return m_impl.runImpl(module, [&]() -> TargetLibraryInfo & {
-    return getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(*(m_impl.getEntryPoint()));
-  });
-}
-
 // =====================================================================================================================
 // Executes constant folding SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerMathConstFolding::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module, [&]() -> TargetLibraryInfo & {
     FunctionAnalysisManager &functionAnalysisManager =
         analysisManager.getResult<FunctionAnalysisManagerModuleProxy>(module).getManager();
     return functionAnalysisManager.getResult<TargetLibraryAnalysis>(*m_entryPoint);
@@ -308,28 +251,20 @@ PreservedAnalyses SpirvLowerMathFloatOp::run(Module &module, ModuleAnalysisManag
 // @param [in/out] module : LLVM module to be run on
 bool SpirvLowerMathFloatOp::runImpl(Module &module) {
   LLVM_DEBUG(dbgs() << "Run the pass Spirv-Lower-Math-Float-Op\n");
 
   SpirvLowerMath::init(module);
   visit(m_module);
 
   return m_changed;
 }
 
-// =====================================================================================================================
-// Executes floating point optimisation SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerMathFloatOp::runOnModule(Module &module) {
-  return m_impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Visits unary operator instruction.
 //
 // @param unaryOp : Unary operator instruction
 void SpirvLowerMathFloatOp::visitUnaryOperator(UnaryOperator &unaryOp) {
   if (unaryOp.getOpcode() == Instruction::FNeg)
     flushDenormIfNeeded(&unaryOp);
 }
 
 // =====================================================================================================================
@@ -484,36 +419,10 @@ void SpirvLowerMathFloatOp::visitFPTruncInst(FPTruncInst &fptruncInst) {
       fptruncInst.replaceAllUsesWith(dest);
       fptruncInst.dropAllReferences();
       fptruncInst.eraseFromParent();
 
       m_changed = true;
     }
   }
 }
 
 #undef DEBUG_TYPE // DEBUG_TYPE_FLOAT_OP
-
-// =====================================================================================================================
-// Initializes SPIR-V lowering - math constant folding.
-INITIALIZE_PASS(LegacySpirvLowerMathConstFolding, DEBUG_TYPE_CONST_FOLDING, "Lower SPIR-V math constant folding", false,
-                false)
-
-// =====================================================================================================================
-// Initializes SPIR-V lowering - math constant folding.
-INITIALIZE_PASS(LegacySpirvLowerMathFloatOp, DEBUG_TYPE_FLOAT_OP, "Lower SPIR-V math floating point optimisation",
-                false, false)
-
-namespace Llpc {
-
-// =====================================================================================================================
-// Pass creator, SPIR-V lowering for math constant folding.
-ModulePass *createLegacySpirvLowerMathConstFolding() {
-  return new LegacySpirvLowerMathConstFolding();
-}
-
-// =====================================================================================================================
-// Pass creator, SPIR-V lowering for math floating point optimisation.
-ModulePass *createLegacySpirvLowerMathFloatOp() {
-  return new LegacySpirvLowerMathFloatOp();
-}
-
-} // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerMemoryOp.cpp b/llpc/lower/llpcSpirvLowerMemoryOp.cpp
index 119dd6ebd..e317fd8ed 100644
--- a/llpc/lower/llpcSpirvLowerMemoryOp.cpp
+++ b/llpc/lower/llpcSpirvLowerMemoryOp.cpp
@@ -37,34 +37,20 @@
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "llpc-spirv-lower-memory-op"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerMemoryOp::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering memory operations.
-ModulePass *createLegacySpirvLowerMemoryOp() {
-  return new LegacySpirvLowerMemoryOp();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerMemoryOp::LegacySpirvLowerMemoryOp() : ModulePass(ID) {
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerMemoryOp::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -98,28 +84,20 @@ bool SpirvLowerMemoryOp::runImpl(Module &module) {
     inst->dropAllReferences();
     inst->eraseFromParent();
   }
   m_removeInsts.clear();
 
   LLVM_DEBUG(dbgs() << "After the pass Spirv-Lower-Memory-Op " << module);
 
   return true;
 }
 
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerMemoryOp::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Visits "extractelement" instruction.
 //
 // @param extractElementInst : "ExtractElement" instruction
 void SpirvLowerMemoryOp::visitExtractElementInst(ExtractElementInst &extractElementInst) {
   auto src = extractElementInst.getOperand(0);
   if (src->getType()->isVectorTy() && isa<LoadInst>(src) && src->hasOneUse()) {
     // NOTE: Optimize loading vector component for local variable and memory block
     // Original pattern:
     // %1 = load <4 x float> addrspace(7)* %0
@@ -432,14 +410,10 @@ void SpirvLowerMemoryOp::expandStoreInst(StoreInst *storeInst, ArrayRef<GetEleme
                                  : ConstantInt::get(Type::getInt32Ty(*m_context), i);
       auto cond = new ICmpInst(storeInst, ICmpInst::ICMP_EQ, dynIndex, constIndex);
       firstStoreDest = SelectInst::Create(cond, secondStoreDest, firstStoreDest, "", storeInst);
     }
 
     storeInst->setOperand(1, firstStoreDest);
   }
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the memory operations.
-INITIALIZE_PASS(LegacySpirvLowerMemoryOp, DEBUG_TYPE, "Lower SPIR-V memory operations", false, false)
diff --git a/llpc/lower/llpcSpirvLowerMemoryOp.h b/llpc/lower/llpcSpirvLowerMemoryOp.h
index 29fb32f6e..7110e9c6d 100644
--- a/llpc/lower/llpcSpirvLowerMemoryOp.h
+++ b/llpc/lower/llpcSpirvLowerMemoryOp.h
@@ -72,28 +72,11 @@ private:
   void recordStoreExpandInfo(llvm::StoreInst *storeInst, llvm::ArrayRef<llvm::GetElementPtrInst *> getElemPtrs,
                              llvm::Value *dynIndex);
   void expandStoreInst(llvm::StoreInst *storeInst, llvm::ArrayRef<llvm::GetElementPtrInst *> getElemPtrs,
                        llvm::Value *dynIndex);
 
   std::unordered_set<llvm::Instruction *> m_removeInsts;
   std::unordered_set<llvm::Instruction *> m_preRemoveInsts;
   llvm::SmallVector<StoreExpandInfo, 1> m_storeExpandInfo;
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering memory operations.
-class LegacySpirvLowerMemoryOp : public llvm::ModulePass, public llvm::InstVisitor<LegacySpirvLowerMemoryOp> {
-public:
-  LegacySpirvLowerMemoryOp();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerMemoryOp(const LegacySpirvLowerMemoryOp &) = delete;
-  LegacySpirvLowerMemoryOp &operator=(const LegacySpirvLowerMemoryOp &) = delete;
-
-  SpirvLowerMemoryOp Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerRayQuery.cpp b/llpc/lower/llpcSpirvLowerRayQuery.cpp
index 6b244abf4..c3dbf825c 100644
--- a/llpc/lower/llpcSpirvLowerRayQuery.cpp
+++ b/llpc/lower/llpcSpirvLowerRayQuery.cpp
@@ -288,55 +288,30 @@ Type *getRayQueryInternalTy(lgc::Builder *builder) {
       builder->getInt32Ty(), // 24, numIterations;
       builder->getInt32Ty(), // 25, maxStackDepth;
       builder->getInt32Ty(), // 26, clocks;
       builder->getInt32Ty(), // 27, numCandidateHits;
       builder->getInt32Ty(), // 28, instanceIntersections;
       builder->getInt32Ty(), // 29, rayqueryObj
   };
   return StructType::get(context, rayQueryInternalTys, false);
 }
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerRayQuery::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering ray query operations.
-//
-// @param rayQueryLibrary : ray query library
-ModulePass *createLegacySpirvLowerRayQuery(bool rayQueryLibrary) {
-  return new LegacySpirvLowerRayQuery(rayQueryLibrary);
-}
-
 // =====================================================================================================================
 SpirvLowerRayQuery::SpirvLowerRayQuery() : SpirvLowerRayQuery(false) {
 }
 
 // =====================================================================================================================
 SpirvLowerRayQuery::SpirvLowerRayQuery(bool rayQueryLibrary)
     : m_rayQueryLibrary(rayQueryLibrary), m_spirvOpMetaKindId(0), m_ldsStack(nullptr), m_prevRayQueryObj(nullptr),
       m_rayQueryObjGen(nullptr) {
 }
 
-// =====================================================================================================================
-LegacySpirvLowerRayQuery::LegacySpirvLowerRayQuery(bool rayQueryLibrary) : ModulePass(ID), Impl(rayQueryLibrary) {
-  initializeLegacySpirvLowerRayQueryPass(*PassRegistry::getPassRegistry());
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerRayQuery::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerRayQuery::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -1871,14 +1846,10 @@ void SpirvLowerRayQuery::createLdsStackStore(Function *func) {
 
   Value *result =
       m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_bvh_stack_rtn, {}, {stackAddrVal, lastVisited, data, offset});
 
   m_builder->CreateStore(m_builder->CreateExtractValue(result, 1), stackAddr);
   m_builder->CreateRet(m_builder->CreateExtractValue(result, 0));
 }
 #endif
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the ray query operations.
-INITIALIZE_PASS(LegacySpirvLowerRayQuery, DEBUG_TYPE, "Lower SPIR-V RayQuery operations", false, false)
diff --git a/llpc/lower/llpcSpirvLowerRayQuery.h b/llpc/lower/llpcSpirvLowerRayQuery.h
index ab726ee5b..6085155a7 100644
--- a/llpc/lower/llpcSpirvLowerRayQuery.h
+++ b/llpc/lower/llpcSpirvLowerRayQuery.h
@@ -158,28 +158,11 @@ private:
   llvm::Value *getDispatchId();
   llvm::Value *createGetBvhSrd(llvm::Value *expansion, llvm::Value *boxSortMode);
   bool stageNotSupportLds(ShaderStage stage);
   llvm::GlobalVariable *m_ldsStack;        // LDS to hold stack value
   llvm::GlobalVariable *m_ldsUsage;        // LDS usage
   llvm::GlobalVariable *m_stackArray;      // Stack array to hold stack value
   llvm::GlobalVariable *m_prevRayQueryObj; // Previous ray query Object
   llvm::GlobalVariable *m_rayQueryObjGen;  // Ray query Object Id generator
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering ray query.
-class LegacySpirvLowerRayQuery : public llvm::ModulePass {
-public:
-  LegacySpirvLowerRayQuery() : llvm::ModulePass(ID), Impl(false) {}
-  LegacySpirvLowerRayQuery(char &pid) : llvm::ModulePass(pid), Impl(false) {}
-  LegacySpirvLowerRayQuery(bool rayQueryLibrary);
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-private:
-  LegacySpirvLowerRayQuery(const LegacySpirvLowerRayQuery &) = delete;
-  LegacySpirvLowerRayQuery &operator=(const LegacySpirvLowerRayQuery &) = delete;
-
-  SpirvLowerRayQuery Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerRayQueryPostInline.cpp b/llpc/lower/llpcSpirvLowerRayQueryPostInline.cpp
index 5ebd149b4..ca241d0ee 100644
--- a/llpc/lower/llpcSpirvLowerRayQueryPostInline.cpp
+++ b/llpc/lower/llpcSpirvLowerRayQueryPostInline.cpp
@@ -35,42 +35,20 @@
 #include "lgc/Builder.h"
 #include "lgc/Pipeline.h"
 #include "llvm/IR/DerivedTypes.h"
 
 #define DEBUG_TYPE "llpc-spirv-lower-ray-query-post-inline"
 
 using namespace llvm;
 using namespace Llpc;
 
 namespace Llpc {
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerRayQueryPostInline::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering ray query post inline operations.
-ModulePass *createLegacySpirvLowerRayQueryPostInline() {
-  return new LegacySpirvLowerRayQueryPostInline();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerRayQueryPostInline::LegacySpirvLowerRayQueryPostInline() : ModulePass(ID) {
-  initializeLegacySpirvLowerRayQueryPostInlinePass(*PassRegistry::getPassRegistry());
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerRayQueryPostInline::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
 
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerRayQueryPostInline::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
@@ -97,15 +75,10 @@ bool SpirvLowerRayQueryPostInline::runImpl(Module &module) {
       if (!func->getName().startswith(m_entryPoint->getName())) {
         func->dropAllReferences();
         func->eraseFromParent();
       }
     }
   }
   return true;
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the ray query operations.
-INITIALIZE_PASS(LegacySpirvLowerRayQueryPostInline, DEBUG_TYPE, "Lower SPIR-V RayQueryPostInline operations", false,
-                false)
diff --git a/llpc/lower/llpcSpirvLowerRayQueryPostInline.h b/llpc/lower/llpcSpirvLowerRayQueryPostInline.h
index 52d5080bf..caef39444 100644
--- a/llpc/lower/llpcSpirvLowerRayQueryPostInline.h
+++ b/llpc/lower/llpcSpirvLowerRayQueryPostInline.h
@@ -37,26 +37,11 @@ namespace Llpc {
 
 // Represents the pass of SPIR-V lowering ray query post inline.
 class SpirvLowerRayQueryPostInline : public SpirvLower, public llvm::PassInfoMixin<SpirvLowerRayQueryPostInline> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
   virtual bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V RayQueryPostInline operations"; }
 };
 
-// Represents the pass of SPIR-V lowering ray query post inline.
-class LegacySpirvLowerRayQueryPostInline : public llvm::ModulePass {
-public:
-  LegacySpirvLowerRayQueryPostInline();
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerRayQueryPostInline(const LegacySpirvLowerRayQueryPostInline &) = delete;
-  LegacySpirvLowerRayQueryPostInline &operator=(const LegacySpirvLowerRayQueryPostInline &) = delete;
-
-  SpirvLowerRayQueryPostInline Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerRayTracing.cpp b/llpc/lower/llpcSpirvLowerRayTracing.cpp
index bbe413913..dc5676177 100644
--- a/llpc/lower/llpcSpirvLowerRayTracing.cpp
+++ b/llpc/lower/llpcSpirvLowerRayTracing.cpp
@@ -72,23 +72,20 @@ static const char *SetTraceParams = "AmdTraceRaySetTraceParams";
 static const char *CallClosestHitShader = "AmdTraceRayCallClosestHitShader";
 static const char *CallMissShader = "AmdTraceRayCallMissShader";
 static const char *CallTriangleAnyHitShader = "AmdTraceRayCallTriangleAnyHitShader";
 static const char *CallIntersectionShader = "AmdTraceRayCallIntersectionShader";
 static const char *CallAnyHitShader = "AmdTraceRayCallAnyHitShader";
 static const char *SetTriangleIntersectionAttributes = "AmdTraceRaySetTriangleIntersectionAttributes";
 static const char *RemapCapturedVaToReplayVa = "AmdTraceRayRemapCapturedVaToReplayVa";
 } // namespace RtName
 
 namespace Llpc {
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerRayTracing::ID = 0;
 
 // TraceParams Type size in DWORD
 static unsigned TraceParamsTySize[] = {
     1, // 1, rayFlags
     1, // 2, instanceInclusionMask
     3, // 3, origin
     1, // 4, tMin
     3, // 5, dir
     1, // 6, tMax
     1, // 7, tCurrent
@@ -101,32 +98,20 @@ static unsigned TraceParamsTySize[] = {
     1, // 14, geometryIndex
     8, // 15, hit attribute
 };
 
 // ====================================================================================================================
 // Get payload idx for TraceRayKHR instruction.
 unsigned getTraceRayParamPayloadIdx(void) {
   return TraceRayParam::Payload;
 }
 
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering ray operations.
-// @param rayQueryLibrary : ray query library
-ModulePass *createLegacySpirvLowerRayTracing(bool rayQueryLibrary) {
-  return new LegacySpirvLowerRayTracing(rayQueryLibrary);
-}
-
-// =====================================================================================================================
-LegacySpirvLowerRayTracing::LegacySpirvLowerRayTracing(bool rayQueryLibrary) : ModulePass(ID), Impl(rayQueryLibrary) {
-  initializeLegacySpirvLowerRayTracingPass(*PassRegistry::getPassRegistry());
-}
-
 // =====================================================================================================================
 SpirvLowerRayTracing::SpirvLowerRayTracing() : SpirvLowerRayTracing(false) {
 }
 
 // =====================================================================================================================
 SpirvLowerRayTracing::SpirvLowerRayTracing(bool rayQueryLibrary)
     : SpirvLowerRayQuery(rayQueryLibrary), m_funcRetFlag(nullptr), m_worldToObjMatrix(nullptr),
       m_globalPayload(nullptr), m_globalCallableData(nullptr) {
 }
 
@@ -444,28 +429,20 @@ template <> void SpirvLowerRayTracing::createRayTracingFunc<OpReportIntersection
   m_builder->CreateStore(m_builder->getFalse(), m_funcRetFlag);
   m_builder->CreateBr(endBlock);
 
   // Construct end block
   m_builder->SetInsertPoint(endBlock);
   Value *result =
       m_builder->CreateICmpNE(m_builder->CreateLoad(statusTy, status), m_builder->getInt32(RayHitStatus::Ignore));
   m_builder->CreateRet(result);
 }
 
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerRayTracing::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerRayTracing::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -2385,14 +2362,10 @@ Function *SpirvLowerRayTracing::getOrCreateRemapCapturedVaToReplayVaFunc() {
 
     // End block
     m_builder->SetInsertPoint(endBlock);
     m_builder->CreateRet(m_builder->getInt64(0));
   }
 
   return func;
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the ray tracing operations.
-INITIALIZE_PASS(LegacySpirvLowerRayTracing, DEBUG_TYPE, "Lower SPIR-V RayTracing operations", false, false)
diff --git a/llpc/lower/llpcSpirvLowerRayTracing.h b/llpc/lower/llpcSpirvLowerRayTracing.h
index ee367cc74..0a2e8fe1d 100644
--- a/llpc/lower/llpcSpirvLowerRayTracing.h
+++ b/llpc/lower/llpcSpirvLowerRayTracing.h
@@ -180,27 +180,11 @@ private:
   llvm::GlobalVariable *m_traceParams[TraceParam::Count];              // Trace ray set parameters
   llvm::GlobalVariable *m_shaderTable[ShaderTable::Count];             // Shader table variables
   llvm::GlobalVariable *m_funcRetFlag;                                 // Function return flag
   llvm::Value *m_worldToObjMatrix;                                     // World to Object matrix
   llvm::GlobalVariable *m_globalPayload;                               // Global payload variable
   llvm::GlobalVariable *m_globalCallableData;                          // Global callable data variable
   std::set<unsigned, std::less<unsigned>> m_builtInParams;             // Indirect max builtins;
   llvm::SmallVector<llvm::Type *, TraceParam::Count> m_traceParamsTys; // Trace Params types
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering ray tracing.
-class LegacySpirvLowerRayTracing : public llvm::ModulePass {
-public:
-  LegacySpirvLowerRayTracing() : ModulePass(ID) {}
-  LegacySpirvLowerRayTracing(bool rayQueryLibrary);
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerRayTracing(const LegacySpirvLowerRayTracing &) = delete;
-  LegacySpirvLowerRayTracing &operator=(const LegacySpirvLowerRayTracing &) = delete;
-
-  SpirvLowerRayTracing Impl;
-};
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
index 49676cf84..3695ae769 100644
--- a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
+++ b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
@@ -46,48 +46,25 @@ using namespace Llpc;
 using namespace spv;
 
 namespace RtName {
 extern const char *TraceRayHitAttributes;
 extern const char *TraceRaySetTraceParams;
 extern const char *ShaderTable;
 } // namespace RtName
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerRayTracingBuiltIn::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering memory operations.
-ModulePass *createLegacySpirvLowerRayTracingBuiltIn() {
-  return new LegacySpirvLowerRayTracingBuiltIn();
-}
-
 // =====================================================================================================================
 SpirvLowerRayTracingBuiltIn::SpirvLowerRayTracingBuiltIn() : m_dispatchRaysInfoDesc(nullptr) {
   memset(m_traceParams, 0, sizeof(m_traceParams));
 }
 
-// =====================================================================================================================
-LegacySpirvLowerRayTracingBuiltIn::LegacySpirvLowerRayTracingBuiltIn() : ModulePass(ID) {
-  initializeLegacySpirvLowerRayTracingBuiltInPass(*PassRegistry::getPassRegistry());
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerRayTracingBuiltIn::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerRayTracingBuiltIn::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -380,14 +357,10 @@ Value *SpirvLowerRayTracingBuiltIn::getDispatchRaysInfoDesc(Instruction *insertP
   if (!m_dispatchRaysInfoDesc) {
     m_builder->SetInsertPoint(insertPos);
     m_dispatchRaysInfoDesc =
         m_builder->CreateLoadBufferDesc(TraceRayDescriptorSet, RayTracingResourceIndexDispatchRaysInfo,
                                         m_builder->getInt32(0), 0, m_builder->getInt8Ty());
   }
   return m_dispatchRaysInfoDesc;
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the ray tracing built-ins.
-INITIALIZE_PASS(LegacySpirvLowerRayTracingBuiltIn, DEBUG_TYPE, "Lower SPIR-V ray tracing built-ins", false, false)
diff --git a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.h b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.h
index 511e7e318..6388a635f 100644
--- a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.h
+++ b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.h
@@ -65,27 +65,11 @@ public:
 
 private:
   llvm::Value *processBuiltIn(llvm::GlobalVariable *global, llvm::Instruction *insertPos);
   void setShaderTableVariables(llvm::GlobalValue *global, ShaderTable tableKind, llvm::Instruction *insertPos);
   llvm::Value *getDispatchRaysInfoDesc(llvm::Instruction *insertPos);
 
   llvm::GlobalValue *m_traceParams[TraceParam::Count]; // Trace ray set parameters
   llvm::Value *m_dispatchRaysInfoDesc;                 // Descriptor of the DispatchRaysInfo
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering ray tracing.
-class LegacySpirvLowerRayTracingBuiltIn : public llvm::ModulePass {
-public:
-  LegacySpirvLowerRayTracingBuiltIn();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerRayTracingBuiltIn(const LegacySpirvLowerRayTracingBuiltIn &) = delete;
-  LegacySpirvLowerRayTracingBuiltIn &operator=(const LegacySpirvLowerRayTracingBuiltIn &) = delete;
-
-  SpirvLowerRayTracingBuiltIn Impl;
-};
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.cpp b/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.cpp
index 35047d282..6c6c2eed1 100644
--- a/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.cpp
+++ b/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.cpp
@@ -42,37 +42,20 @@ using namespace Llpc;
 
 namespace RtName {
 const char *LoadDwordAtAddr = "AmdExtD3DShaderIntrinsics_LoadDwordAtAddr";
 const char *LoadDwordAtAddrx2 = "AmdExtD3DShaderIntrinsics_LoadDwordAtAddrx2";
 const char *LoadDwordAtAddrx4 = "AmdExtD3DShaderIntrinsics_LoadDwordAtAddrx4";
 const char *ConvertF32toF16NegInf = "AmdExtD3DShaderIntrinsics_ConvertF32toF16NegInf";
 const char *ConvertF32toF16PosInf = "AmdExtD3DShaderIntrinsics_ConvertF32toF16PosInf";
 } // namespace RtName
 
 namespace Llpc {
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerRayTracingIntrinsics::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering ray tracing intrinsics.
-ModulePass *createLegacySpirvLowerRayTracingIntrinsics() {
-  return new LegacySpirvLowerRayTracingIntrinsics();
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool LegacySpirvLowerRayTracingIntrinsics::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
 
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerRayTracingIntrinsics::run(Module &module, ModuleAnalysisManager &analysisManager) {
   if (runImpl(module))
     return PreservedAnalyses::none();
   return PreservedAnalyses::all();
@@ -194,14 +177,10 @@ void SpirvLowerRayTracingIntrinsics::createConvertF32toF16(Function *func, unsig
   Value *result = m_builder->CreateFpTruncWithRounding(inVec, FixedVectorType::get(m_builder->getHalfTy(), 3),
                                                        static_cast<RoundingMode>(roundingMode));
 
   result = m_builder->CreateBitCast(result, FixedVectorType::get(m_builder->getInt16Ty(), 3));
   result = m_builder->CreateZExt(result, FixedVectorType::get(m_builder->getInt32Ty(), 3));
 
   m_builder->CreateRet(result);
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering the ray tracing intrinsics.
-INITIALIZE_PASS(LegacySpirvLowerRayTracingIntrinsics, DEBUG_TYPE, "Lower SPIR-V RayTracing intrinsics", false, false)
diff --git a/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.h b/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.h
index a46c0a20a..4c22573ad 100644
--- a/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.h
+++ b/llpc/lower/llpcSpirvLowerRayTracingIntrinsics.h
@@ -47,28 +47,11 @@ public:
   static llvm::StringRef name() { return "Lower SPIR-V RayTracing intrinsics"; }
 
 protected:
   void createLoadDwordAtAddr(llvm::Function *func, llvm::Type *loadTy);
   void createConvertF32toF16(llvm::Function *func, unsigned roundingMode);
 
 private:
   bool processIntrinsicsFunction(llvm::Function *func);
 };
 
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering ray tracing intrinsics.
-class LegacySpirvLowerRayTracingIntrinsics : public llvm::ModulePass {
-public:
-  LegacySpirvLowerRayTracingIntrinsics() : ModulePass(ID) {}
-  LegacySpirvLowerRayTracingIntrinsics(char &pid) : ModulePass(pid) {}
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerRayTracingIntrinsics(const SpirvLowerRayTracingIntrinsics &) = delete;
-  LegacySpirvLowerRayTracingIntrinsics &operator=(const SpirvLowerRayTracingIntrinsics &) = delete;
-
-  SpirvLowerRayTracingIntrinsics Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerResourceCollect.cpp b/llpc/lower/llpcSpirvLowerResourceCollect.cpp
deleted file mode 100644
index 1a2e579ac..000000000
--- a/llpc/lower/llpcSpirvLowerResourceCollect.cpp
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
- ***********************************************************************************************************************
- *
- *  Copyright (c) 2017-2022 Advanced Micro Devices, Inc. All Rights Reserved.
- *
- *  Permission is hereby granted, free of charge, to any person obtaining a copy
- *  of this software and associated documentation files (the "Software"), to deal
- *  in the Software without restriction, including without limitation the rights
- *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- *  copies of the Software, and to permit persons to whom the Software is
- *  furnished to do so, subject to the following conditions:
- *
- *  The above copyright notice and this permission notice shall be included in all
- *  copies or substantial portions of the Software.
- *
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- *  SOFTWARE.
- *
- **********************************************************************************************************************/
-/**
- ***********************************************************************************************************************
- * @file  llpcSpirvLowerResourceCollect.cpp
- * @brief LLPC source file: contains implementation of class Llpc::SpirvLowerResourceCollect.
- ***********************************************************************************************************************
- */
-#include "SPIRVInternal.h"
-#include "lgc/Builder.h"
-#include "llvm/IR/Instructions.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/raw_ostream.h"
-#include <algorithm>
-// TODO: Fix the code in this file so it does not break the builder abstraction. It should
-// not be including files directly in the LGC directory tree like this.
-#include "../../lgc/include/lgc/builder/BuilderRecorder.h"
-#include "llpcContext.h"
-#include "llpcSpirvLowerResourceCollect.h"
-
-#define DEBUG_TYPE "llpc-spirv-lower-resource-collect"
-
-using namespace lgc;
-using namespace llvm;
-using namespace SPIRV;
-using namespace Llpc;
-
-namespace Llpc {
-
-// =====================================================================================================================
-// Initializes static members.
-char SpirvLowerResourceCollect::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering operations for resource collecting
-//
-// @param collectDetailUsage : Whether to collect detailed usages of resource node datas and FS output infos
-ModulePass *createSpirvLowerResourceCollect(bool collectDetailUsage) {
-  return new SpirvLowerResourceCollect(collectDetailUsage);
-}
-
-// =====================================================================================================================
-//
-// @param collectDetailUsage : Whether to collect detailed usages of resource node datas and FS output infos
-SpirvLowerResourceCollect::SpirvLowerResourceCollect(bool collectDetailUsage)
-    : LegacySpirvLower(ID), m_collectDetailUsage(collectDetailUsage), m_detailUsageValid(false) {
-}
-
-// =====================================================================================================================
-// Collect resource node data
-//
-// @param global : Global variable to collect resource node data
-void SpirvLowerResourceCollect::collectResourceNodeData(const GlobalVariable *global) {
-  auto globalTy = global->getValueType();
-
-  MDNode *metaNode = global->getMetadata(gSPIRVMD::Resource);
-  auto descSet = mdconst::dyn_extract<ConstantInt>(metaNode->getOperand(0))->getZExtValue();
-  auto binding = mdconst::dyn_extract<ConstantInt>(metaNode->getOperand(1))->getZExtValue();
-  auto spvOpCode = mdconst::dyn_extract<ConstantInt>(metaNode->getOperand(2))->getZExtValue();
-
-  // Map the SPIR-V opcode to descriptor type.
-  ResourceMappingNodeType nodeType = ResourceMappingNodeType::Unknown;
-  switch (spvOpCode) {
-  case OpTypeSampler: {
-    // Sampler descriptor.
-    nodeType = ResourceMappingNodeType::DescriptorSampler;
-    break;
-  }
-  case OpTypeImage: {
-    nodeType = ResourceMappingNodeType::DescriptorResource;
-    // Image descriptor.
-    Type *imageType = globalTy->getPointerElementType();
-    const std::string imageTypeName(imageType->getStructName());
-    // Format of image opaque type: ...[.SampledImage.<date type><dim>]...
-    if (imageTypeName.find(".SampledImage") != std::string::npos) {
-      auto pos = imageTypeName.find('_');
-      assert(pos != std::string::npos);
-
-      ++pos;
-      Dim dim = static_cast<Dim>(imageTypeName[pos] - '0');
-      nodeType = dim == DimBuffer ? ResourceMappingNodeType::DescriptorTexelBuffer
-                                  : ResourceMappingNodeType::DescriptorResource;
-    }
-    break;
-  }
-  case OpTypeSampledImage: {
-    // Combined image and sampler descriptors.
-    nodeType = ResourceMappingNodeType::DescriptorCombinedTexture;
-    break;
-  }
-  default: {
-    // Normal buffer.
-    nodeType = ResourceMappingNodeType::DescriptorBuffer;
-    break;
-  }
-  }
-
-  ResourceNodeDataKey nodeData = {};
-
-  nodeData.value.set = descSet;
-  nodeData.value.binding = binding;
-  nodeData.value.arraySize = getFlattenArrayElementCount(globalTy);
-  auto result = m_resNodeDatas.insert(std::pair<ResourceNodeDataKey, ResourceMappingNodeType>(nodeData, nodeType));
-
-  // Check if the node already had a different pair of node data/type. A DescriptorResource/DescriptorTexelBuffer
-  // and a DescriptorSampler can use the same set/binding, in which case it is
-  // DescriptorCombinedTexture.
-  if (!result.second) {
-    assert((nodeType == ResourceMappingNodeType::DescriptorCombinedTexture ||
-            nodeType == ResourceMappingNodeType::DescriptorResource ||
-            nodeType == ResourceMappingNodeType::DescriptorTexelBuffer ||
-            nodeType == ResourceMappingNodeType::DescriptorSampler) &&
-           (result.first->second == ResourceMappingNodeType::DescriptorCombinedTexture ||
-            result.first->second == ResourceMappingNodeType::DescriptorResource ||
-            result.first->second == ResourceMappingNodeType::DescriptorTexelBuffer ||
-            result.first->second == ResourceMappingNodeType::DescriptorSampler));
-    result.first->second = ResourceMappingNodeType::DescriptorCombinedTexture;
-  }
-}
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on
-bool SpirvLowerResourceCollect::runOnModule(Module &module) {
-  LLVM_DEBUG(dbgs() << "Run the pass Spirv-Lower-Resource-Collect\n");
-
-  SpirvLower::init(&module);
-
-  // Collect unused globals and remove them
-  std::unordered_set<GlobalVariable *> removedGlobals;
-  for (auto global = m_module->global_begin(), end = m_module->global_end(); global != end; ++global) {
-    if (global->user_empty()) {
-      Value *initializer = nullptr;
-      if (global->hasInitializer())
-        initializer = global->getInitializer();
-
-      if (!initializer || isa<UndefValue>(initializer))
-        removedGlobals.insert(&*global);
-    }
-  }
-
-  for (auto global : removedGlobals) {
-    global->dropAllReferences();
-    global->eraseFromParent();
-  }
-
-  // Collect resource usages from globals
-  for (auto global = m_module->global_begin(), end = m_module->global_end(); global != end; ++global) {
-    auto addrSpace = global->getType()->getAddressSpace();
-    switch (addrSpace) {
-    case SPIRAS_Constant: {
-      if (!global->hasMetadata(gSPIRVMD::PushConst)) {
-        // Non push constant, only collect resource node data when requested
-        if (m_collectDetailUsage)
-          collectResourceNodeData(&*global);
-      }
-      break;
-    }
-    case SPIRAS_Private:
-    case SPIRAS_Global:
-    case SPIRAS_Local:
-    case SPIRAS_Input: {
-      break;
-    }
-    case SPIRAS_Output: {
-      // Only collect FS out info when requested.
-      Type *globalTy = global->getValueType();
-      if (!m_collectDetailUsage || !globalTy->isSingleValueType())
-        break;
-
-      FsOutInfo fsOutInfo = {};
-      MDNode *metaNode = global->getMetadata(gSPIRVMD::InOut);
-      auto meta = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
-
-      ShaderInOutMetadata inOutMeta = {};
-      Constant *inOutMetaConst = cast<Constant>(meta);
-      inOutMeta.U64All[0] = cast<ConstantInt>(inOutMetaConst->getOperand(0))->getZExtValue();
-      inOutMeta.U64All[1] = cast<ConstantInt>(inOutMetaConst->getOperand(1))->getZExtValue();
-
-      const unsigned location = inOutMeta.Value;
-      const unsigned index = inOutMeta.Index;
-
-      // Collect basic types of fragment outputs
-      BasicType basicTy = BasicType::Unknown;
-
-      const auto compTy = globalTy->isVectorTy() ? cast<VectorType>(globalTy)->getElementType() : globalTy;
-      const unsigned bitWidth = compTy->getScalarSizeInBits();
-      const bool signedness = (inOutMeta.Signedness != 0);
-
-      if (compTy->isIntegerTy()) {
-        // Integer type
-        if (bitWidth == 8)
-          basicTy = signedness ? BasicType::Int8 : BasicType::Uint8;
-        else if (bitWidth == 16)
-          basicTy = signedness ? BasicType::Int16 : BasicType::Uint16;
-        else {
-          assert(bitWidth == 32);
-          basicTy = signedness ? BasicType::Int : BasicType::Uint;
-        }
-      } else if (compTy->isFloatingPointTy()) {
-        // Floating-point type
-        if (bitWidth == 16)
-          basicTy = BasicType::Float16;
-        else {
-          assert(bitWidth == 32);
-          basicTy = BasicType::Float;
-        }
-      } else
-        llvm_unreachable("Should never be called!");
-
-      fsOutInfo.location = location;
-      fsOutInfo.index = index;
-      fsOutInfo.componentCount = globalTy->isVectorTy() ? cast<FixedVectorType>(globalTy)->getNumElements() : 1;
-      fsOutInfo.basicType = basicTy;
-      m_fsOutInfos.push_back(fsOutInfo);
-      break;
-    }
-    case SPIRAS_Uniform: {
-      // Only collect resource node data when requested
-      if (m_collectDetailUsage)
-        collectResourceNodeData(&*global);
-      break;
-    }
-    default: {
-      llvm_unreachable("Should never be called!");
-      break;
-    }
-    }
-  }
-
-  if (m_collectDetailUsage)
-    visitCalls(module);
-  if (!m_fsOutInfos.empty() || !m_resNodeDatas.empty())
-    m_detailUsageValid = true;
-
-  return true;
-}
-
-// =====================================================================================================================
-// Gets element count if the specified type is an array (flattened for multi-dimension array).
-//
-// @param ty : Type to check
-unsigned SpirvLowerResourceCollect::getFlattenArrayElementCount(const Type *ty) const {
-  unsigned elemCount = 1;
-
-  auto arrayTy = dyn_cast<ArrayType>(ty);
-  while (arrayTy) {
-    elemCount *= arrayTy->getArrayNumElements();
-    arrayTy = dyn_cast<ArrayType>(arrayTy->getArrayElementType());
-  }
-  return elemCount;
-}
-
-// =====================================================================================================================
-// Gets element type if the specified type is an array (flattened for multi-dimension array).
-//
-// @param ty : Type to check
-const Type *SpirvLowerResourceCollect::getFlattenArrayElementType(const Type *ty) const {
-  const Type *elemType = ty;
-
-  auto arrayTy = dyn_cast<ArrayType>(ty);
-  while (arrayTy) {
-    elemType = arrayTy->getArrayElementType();
-    arrayTy = dyn_cast<ArrayType>(elemType);
-  }
-  return elemType;
-}
-
-// =====================================================================================================================
-// Find the specified target call and get the index value from corresponding argument
-//
-// @param module : LLVM module to be visited
-// @param targetCall : Builder call as search target
-Value *SpirvLowerResourceCollect::findCallAndGetIndexValue(Module &module, CallInst *const targetCall) {
-  // TODO: This code no longer compiles, because BuilderRecorder::Opcode::IndexDescPtr no longer exists.
-  // 1. The way it scans IR for LGC Builder calls is dodgy, because that breaks the Builder abstraction.
-  // 2. I don't know why it is doing this loop to find a use of targetCall. Surely it should just be doing
-  //    a loop on targetCall->users().
-  // 3. The Builder API for indexing a descriptor pointer has changed -- now the SPIR-V reader just does its
-  //    own regular IR, instead of calling a Builder method.
-  // 4. I think this code is being called in the hope of finding an index operation on a particular descriptor
-  //    pointer, for marking what size array the descriptor is. But what if the index is variable? What if the
-  //    same descriptor is used more than once with different indices?
-  // 5. I think all this code conditional on m_collectDetailUsage is experimental, and is not being used in anger
-  //    in the driver.
-#if 0
-  for (auto &func : module) {
-    // Skip non-declarations that are definitely not LLPC builder calls.
-    if (!func.isDeclaration())
-      continue;
-
-    const MDNode *const funcMeta = func.getMetadata(module.getMDKindID(BuilderCallOpcodeMetadataName));
-
-    // Skip builder calls that do not have the correct metadata to identify the opcode.
-    if (!funcMeta) {
-      // If the function had the LLPC builder call prefix, it means the metadata was not encoded correctly.
-      assert(func.getName().startswith(BuilderCallPrefix) == false);
-      continue;
-    }
-
-    const ConstantAsMetadata *const metaConst = cast<ConstantAsMetadata>(funcMeta->getOperand(0));
-    unsigned opcode = cast<ConstantInt>(metaConst->getValue())->getZExtValue();
-
-    if (opcode == BuilderRecorder::Opcode::IndexDescPtr) {
-      for (auto useIt = func.use_begin(), useItEnd = func.use_end(); useIt != useItEnd; ++useIt) {
-        CallInst *const call = dyn_cast<CallInst>(useIt->getUser());
-
-        // Get the args.
-        auto args = ArrayRef<Use>(&call->getOperandList()[0], call->arg_size());
-
-        if (args[0] == targetCall)
-          return args[1];
-      }
-    }
-  }
-#endif
-
-  return nullptr;
-}
-
-// =====================================================================================================================
-// Visit all LLPC builder calls in a module
-//
-// @param module : LLVM module to be visited
-void SpirvLowerResourceCollect::visitCalls(Module &module) {
-  for (auto &func : module) {
-    // Skip non-declarations that are definitely not LLPC builder calls.
-    if (!func.isDeclaration())
-      continue;
-
-    const MDNode *const funcMeta = func.getMetadata(module.getMDKindID(BuilderCallOpcodeMetadataName));
-
-    // Skip builder calls that do not have the correct metadata to identify the opcode.
-    if (!funcMeta) {
-      // If the function had the llpc builder call prefix, it means the metadata was not encoded correctly.
-      assert(func.getName().startswith(BuilderCallPrefix) == false);
-      continue;
-    }
-
-    const ConstantAsMetadata *const metaConst = cast<ConstantAsMetadata>(funcMeta->getOperand(0));
-    unsigned opcode = cast<ConstantInt>(metaConst->getValue())->getZExtValue();
-
-    for (auto useIt = func.use_begin(), useItEnd = func.use_end(); useIt != useItEnd; ++useIt) {
-      CallInst *const call = dyn_cast<CallInst>(useIt->getUser());
-
-      // Get the args.
-      auto args = ArrayRef<Use>(&call->getOperandList()[0], call->arg_size());
-
-      ResourceMappingNodeType nodeType = ResourceMappingNodeType::Unknown;
-      if (opcode == BuilderRecorder::Opcode::GetDescPtr)
-        nodeType = static_cast<ResourceMappingNodeType>(cast<ConstantInt>(args[0])->getZExtValue());
-
-      if (nodeType != ResourceMappingNodeType::Unknown) {
-        ResourceNodeDataKey nodeData = {};
-
-        nodeData.value.set = cast<ConstantInt>(args[1])->getZExtValue();
-        nodeData.value.binding = cast<ConstantInt>(args[2])->getZExtValue();
-        nodeData.value.arraySize = 1;
-        auto index = findCallAndGetIndexValue(module, call);
-        if (index)
-          nodeData.value.arraySize = cast<ConstantInt>(index)->getZExtValue();
-
-        auto result =
-            m_resNodeDatas.insert(std::pair<ResourceNodeDataKey, ResourceMappingNodeType>(nodeData, nodeType));
-
-        // Check if the node already had a different pair of node data/type. A DescriptorResource/DescriptorTexelBuffer
-        // and a DescriptorSampler can use the same set/binding, in which case it is
-        // DescriptorCombinedTexture.
-        if (!result.second) {
-          assert((nodeType == ResourceMappingNodeType::DescriptorCombinedTexture ||
-                  nodeType == ResourceMappingNodeType::DescriptorResource ||
-                  nodeType == ResourceMappingNodeType::DescriptorTexelBuffer ||
-                  nodeType == ResourceMappingNodeType::DescriptorSampler) &&
-                 (result.first->second == ResourceMappingNodeType::DescriptorCombinedTexture ||
-                  result.first->second == ResourceMappingNodeType::DescriptorResource ||
-                  result.first->second == ResourceMappingNodeType::DescriptorTexelBuffer ||
-                  result.first->second == ResourceMappingNodeType::DescriptorSampler));
-          result.first->second = ResourceMappingNodeType::DescriptorCombinedTexture;
-        }
-      }
-    }
-  }
-}
-
-} // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering operations for resource collecting.
-INITIALIZE_PASS(SpirvLowerResourceCollect, DEBUG_TYPE, "Lower SPIR-V resource collecting", false, false)
diff --git a/llpc/lower/llpcSpirvLowerResourceCollect.h b/llpc/lower/llpcSpirvLowerResourceCollect.h
deleted file mode 100644
index 166796e46..000000000
--- a/llpc/lower/llpcSpirvLowerResourceCollect.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- ***********************************************************************************************************************
- *
- *  Copyright (c) 2017-2022 Advanced Micro Devices, Inc. All Rights Reserved.
- *
- *  Permission is hereby granted, free of charge, to any person obtaining a copy
- *  of this software and associated documentation files (the "Software"), to deal
- *  in the Software without restriction, including without limitation the rights
- *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- *  copies of the Software, and to permit persons to whom the Software is
- *  furnished to do so, subject to the following conditions:
- *
- *  The above copyright notice and this permission notice shall be included in all
- *  copies or substantial portions of the Software.
- *
- *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- *  SOFTWARE.
- *
- **********************************************************************************************************************/
-/**
- ***********************************************************************************************************************
- * @file  llpcSpirvLowerResourceCollect.h
- * @brief LLPC header file: contains declaration of class Llpc::SpirvLowerResourceCollect.
- ***********************************************************************************************************************
- */
-#pragma once
-
-#include "SPIRVInternal.h"
-#include "llpc.h"
-#include "llpcSpirvLower.h"
-#include "llvm/IR/InstVisitor.h"
-
-namespace Llpc {
-
-struct DescriptorBinding;
-struct ResourceUsage;
-
-// Compact ResourceNodeData into an uint64 key
-union ResourceNodeDataKey {
-  struct {
-    uint64_t reserved : 16;
-    uint64_t arraySize : 16; // Resource array size
-    uint64_t binding : 16;   // Resource binding
-    uint64_t set : 16;       // Resource set
-  } value;
-  uint64_t u64All;
-};
-
-struct ResNodeDataSortingComparer {
-  bool operator()(const ResourceNodeDataKey &set1, const ResourceNodeDataKey &set2) const {
-    return set1.u64All < set2.u64All;
-  }
-};
-
-// =====================================================================================================================
-// Represents the pass of SPIR-V lowering operations for resource collecting.
-class SpirvLowerResourceCollect : public LegacySpirvLower, public llvm::InstVisitor<SpirvLowerResourceCollect> {
-public:
-  SpirvLowerResourceCollect(bool collectDetailUsage = false);
-  auto &getResourceNodeDatas() { return m_resNodeDatas; }
-  auto &getFsOutInfos() { return m_fsOutInfos; }
-  bool detailUsageValid() { return m_detailUsageValid; }
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  SpirvLowerResourceCollect(const SpirvLowerResourceCollect &) = delete;
-  SpirvLowerResourceCollect &operator=(const SpirvLowerResourceCollect &) = delete;
-
-  void visitCalls(llvm::Module &module);
-  llvm::Value *findCallAndGetIndexValue(llvm::Module &module, llvm::CallInst *const targetCall);
-
-  unsigned getFlattenArrayElementCount(const llvm::Type *ty) const;
-  const llvm::Type *getFlattenArrayElementType(const llvm::Type *ty) const;
-
-  void collectResourceNodeData(const GlobalVariable *global);
-
-  bool m_collectDetailUsage; // If enabled, collect detailed usages of resource node datas and FS output infos
-  std::map<ResourceNodeDataKey, ResourceMappingNodeType, ResNodeDataSortingComparer> m_resNodeDatas; // Resource
-                                                                                                     // node data
-  std::vector<FsOutInfo> m_fsOutInfos; // FS output info array
-  bool m_detailUsageValid;             // Indicate whether detailed usages (resource node datas
-                                       // or fragment shader output infos) are valid
-};
-
-} // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerTerminator.cpp b/llpc/lower/llpcSpirvLowerTerminator.cpp
index 34290cd55..5339d4168 100644
--- a/llpc/lower/llpcSpirvLowerTerminator.cpp
+++ b/llpc/lower/llpcSpirvLowerTerminator.cpp
@@ -43,42 +43,20 @@
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "llpc-spirv-lower-terminator"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
 namespace Llpc {
 
-// =====================================================================================================================
-// Initializes static members.
-char LegacySpirvLowerTerminator::ID = 0;
-
-// =====================================================================================================================
-// Pass creator, creates the pass of SPIR-V lowering terminator operations
-ModulePass *createLegacySpirvLowerTerminator() {
-  return new LegacySpirvLowerTerminator();
-}
-
-// =====================================================================================================================
-LegacySpirvLowerTerminator::LegacySpirvLowerTerminator() : ModulePass(ID) {
-}
-
-// =====================================================================================================================
-// Executes this SPIR-V lowering pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerTerminator::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Executes this SPIR-V lowering pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 PreservedAnalyses SpirvLowerTerminator::run(Module &module, ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return PreservedAnalyses::none();
 }
 
@@ -161,14 +139,10 @@ void SpirvLowerTerminator::visitCallInst(CallInst &callInst) {
 
   // Mark all other instructions for removal
   while (instIter != parentBlock->end()) {
     if (m_instsForRemoval.insert(&*instIter).second)
       m_removalStack.emplace_back(&*instIter);
     ++instIter;
   }
 }
 
 } // namespace Llpc
-
-// =====================================================================================================================
-// Initializes the pass of SPIR-V lowering terminator operations..
-INITIALIZE_PASS(LegacySpirvLowerTerminator, DEBUG_TYPE, "Lower SPIR-V terminator", false, false)
diff --git a/llpc/lower/llpcSpirvLowerTerminator.h b/llpc/lower/llpcSpirvLowerTerminator.h
index 619ce3e1d..7b66f57df 100644
--- a/llpc/lower/llpcSpirvLowerTerminator.h
+++ b/llpc/lower/llpcSpirvLowerTerminator.h
@@ -48,28 +48,11 @@ public:
   static llvm::StringRef name() { return "Lower SPIR-V terminator"; }
 
   virtual void visitCallInst(llvm::CallInst &callInst);
 
 private:
   // Instructions to be removed; set for tests, vector for order
   llvm::SmallPtrSet<llvm::Instruction *, 8> m_instsForRemoval;
   llvm::SmallVector<llvm::Instruction *, 8> m_removalStack;
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerTerminator : public llvm::ModulePass {
-public:
-  LegacySpirvLowerTerminator();
-
-  virtual bool runOnModule(llvm::Module &module);
-
-  static char ID; // ID of this pass
-
-private:
-  LegacySpirvLowerTerminator(const LegacySpirvLowerTerminator &) = delete;
-  LegacySpirvLowerTerminator &operator=(const LegacySpirvLowerTerminator &) = delete;
-
-  SpirvLowerTerminator Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerTranslator.cpp b/llpc/lower/llpcSpirvLowerTranslator.cpp
index 35f2926a4..883369f66 100644
--- a/llpc/lower/llpcSpirvLowerTranslator.cpp
+++ b/llpc/lower/llpcSpirvLowerTranslator.cpp
@@ -34,31 +34,20 @@
 #include "llpcContext.h"
 #include "lgc/Builder.h"
 #include <sstream>
 #include <string>
 
 #define DEBUG_TYPE "llpc-spirv-lower-translator"
 
 using namespace llvm;
 using namespace Llpc;
 
-char LegacySpirvLowerTranslator::ID = 0;
-
-// =====================================================================================================================
-// Creates the pass of translating SPIR-V to LLVM IR.
-//
-// @param stage : Shader stage
-// @param shaderInfo : Shader info for this shader
-ModulePass *Llpc::createSpirvLowerTranslator(ShaderStage stage, const PipelineShaderInfo *shaderInfo) {
-  return new LegacySpirvLowerTranslator(stage, shaderInfo);
-}
-
 // =====================================================================================================================
 // Run the pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on (empty on entry)
 // @param [in/out] analysisManager : Analysis manager to use for this transformation
 llvm::PreservedAnalyses SpirvLowerTranslator::run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager) {
   runImpl(module);
   return llvm::PreservedAnalyses::none();
 }
 
@@ -75,28 +64,20 @@ bool SpirvLowerTranslator::runImpl(Module &module) {
   InitSpvGen();
 #endif
 
   m_context = static_cast<Context *>(&module.getContext());
 
   // Translate SPIR-V binary to machine-independent LLVM module
   translateSpirvToLlvm(m_shaderInfo, &module);
   return true;
 }
 
-// =====================================================================================================================
-// Run the pass on the specified LLVM module.
-//
-// @param [in/out] module : LLVM module to be run on (empty on entry)
-bool LegacySpirvLowerTranslator::runOnModule(Module &module) {
-  return Impl.runImpl(module);
-}
-
 // =====================================================================================================================
 // Translates SPIR-V binary to machine-independent LLVM module.
 //
 // @param shaderInfo : Specialization info
 // @param [in/out] module : Module to translate into, initially empty
 void SpirvLowerTranslator::translateSpirvToLlvm(const PipelineShaderInfo *shaderInfo, Module *module) {
   BinaryData optimizedSpirvBin = {};
   const ShaderModuleData *moduleData = reinterpret_cast<const ShaderModuleData *>(shaderInfo->pModuleData);
   assert(moduleData->binType == BinaryType::Spirv);
   const BinaryData *spirvBin = &moduleData->binCode;
@@ -174,14 +155,10 @@ void SpirvLowerTranslator::translateSpirvToLlvm(const PipelineShaderInfo *shader
       lgc::Pipeline::markShaderEntryPoint(&func, getLgcShaderStage(entryStage));
       continue;
     }
     // Not shader entry-point.
     func.setLinkage(GlobalValue::InternalLinkage);
     if (func.hasFnAttribute(Attribute::NoInline))
       func.removeFnAttr(Attribute::NoInline);
     func.addFnAttr(Attribute::AlwaysInline);
   }
 }
-
-// =====================================================================================================================
-// Initializes the pass
-INITIALIZE_PASS(LegacySpirvLowerTranslator, DEBUG_TYPE, "LLPC translate SPIR-V binary to LLVM IR", false, false)
diff --git a/llpc/lower/llpcSpirvLowerTranslator.h b/llpc/lower/llpcSpirvLowerTranslator.h
index 091e811f6..105f6b103 100644
--- a/llpc/lower/llpcSpirvLowerTranslator.h
+++ b/llpc/lower/llpcSpirvLowerTranslator.h
@@ -52,35 +52,11 @@ public:
   static llvm::StringRef name() { return "LLPC translate SPIR-V binary to LLVM IR"; }
 
 private:
   void translateSpirvToLlvm(const PipelineShaderInfo *shaderInfo, llvm::Module *module);
 
   // -----------------------------------------------------------------------------------------------------------------
 
   const PipelineShaderInfo *m_shaderInfo; // Input shader info
 };
 
-// =====================================================================================================================
-// Legacy pass manager wrapper class
-class LegacySpirvLowerTranslator : public LegacySpirvLower {
-public:
-  static char ID;
-  LegacySpirvLowerTranslator() : LegacySpirvLower(ID) {}
-
-  //
-  // @param stage : Shader stage
-  // @param shaderInfo : Shader info for this shader
-  LegacySpirvLowerTranslator(ShaderStage stage, const PipelineShaderInfo *shaderInfo)
-      : LegacySpirvLower(ID), Impl(stage, shaderInfo) {}
-
-  bool runOnModule(llvm::Module &module) override;
-
-private:
-  LegacySpirvLowerTranslator(const LegacySpirvLowerTranslator &) = delete;
-  LegacySpirvLowerTranslator &operator=(const LegacySpirvLowerTranslator &) = delete;
-
-  // -----------------------------------------------------------------------------------------------------------------
-
-  SpirvLowerTranslator Impl;
-};
-
 } // namespace Llpc
diff --git a/llpc/translator/include/LLVMSPIRVLib.h b/llpc/translator/include/LLVMSPIRVLib.h
index 5476dae36..b1170ed7b 100644
--- a/llpc/translator/include/LLVMSPIRVLib.h
+++ b/llpc/translator/include/LLVMSPIRVLib.h
@@ -35,48 +35,26 @@
 ///
 /// This files declares functions and passes for translating between LLVM and
 /// SPIR-V.
 ///
 ///
 //===----------------------------------------------------------------------===//
 #ifndef LLVM_SUPPORT_SPIRV_H
 #define LLVM_SUPPORT_SPIRV_H
 
 #include "spirvExt.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Pass.h"
 #include <iostream>
 #include <map>
 #include <string>
 
-namespace llvm {
-// llvm::Pass initialization functions need to be declared before inclusion of
-// PassSupport.h.
-class PassRegistry;
-void initializeSPIRVLowerBoolPass(PassRegistry &);
-void initializeSPIRVLowerConstExprPass(PassRegistry &);
-void initializeSPIRVRegularizeLLVMPass(PassRegistry &);
-void initializeSPIRVLowerInputPass(PassRegistry &);
-void initializeSPIRVLowerOutputPass(PassRegistry &);
-void initializeSPIRVResourceCollectPass(PassRegistry &);
-void initializeLLVMInputPass(PassRegistry &);
-void initializeLLVMOutputPass(PassRegistry &);
-void initializeSPIRVLowerGlobalPass(PassRegistry &);
-void initializeSPIRVLowerBufferPass(PassRegistry &);
-void initializeSPIRVLowerFetchPass(PassRegistry &);
-void initializeLLVMDescriptorPass(PassRegistry &);
-void initializeLLVMBuiltInFuncPass(PassRegistry &);
-void initializeLLVMMutateEntryPass(PassRegistry &);
-void initializeSPIRVLowerMemmovePass(PassRegistry &);
-} // namespace llvm
-
-#include "llvm/IR/Module.h"
-#include "llvm/Pass.h"
-
 namespace SPIRV {
 class SPIRVModule;
 
 /// \brief Represents one entry in specialization constant map.
 struct SPIRVSpecConstEntry {
   uint32_t DataSize; // Data size of specilization constant (in bytes)
   const void *Data;  // Data of specilization constant
 };
 
 /// \brief Represents the map from SpecId to specialization constant data.
@@ -116,56 +94,13 @@ bool writeSpirv(llvm::Module *M, llvm::raw_ostream &OS, std::string &ErrMsg);
 /// @returns : True if succeeds.
 bool readSpirv(lgc::Builder *Builder, const Vkgc::ShaderModuleUsage *ModuleData,
                const Vkgc::PipelineShaderOptions *ShaderOptions, std::istream &IS, spv::ExecutionModel EntryExecModel,
                const char *EntryName, const SPIRV::SPIRVSpecConstMap &SpecConstMap,
                llvm::ArrayRef<SPIRV::ConvertingSampler> ConvertingSamplers, llvm::Module *M, std::string &ErrMsg);
 
 /// \brief Regularize LLVM module by removing entities not representable by
 /// SPIRV.
 bool regularizeLlvmForSpirv(llvm::Module *M, std::string &ErrMsg);
 
-/// Create a pass for lowering cast instructions of i1 type.
-llvm::ModulePass *createSPIRVLowerBool();
-
-/// Create a pass for lowering constant expressions to instructions.
-llvm::ModulePass *createSPIRVLowerConstExpr();
-
-/// Create a pass for regularize LLVM module to be translated to SPIR-V.
-llvm::ModulePass *createSPIRVRegularizeLLVM();
-
-/// Create a pass for lowering llvm.memmove to llvm.memcpys with a temporary variable.
-llvm::ModulePass *createSPIRVLowerMemmove();
-
-/// Create a pass for lowering GLSL inputs to function calls
-llvm::ModulePass *createSPIRVLowerInput();
-
-/// Create a pass for lowering GLSL outputs to function calls
-llvm::ModulePass *createSPIRVLowerOutput();
-
-/// Create a pass for translating GLSL generic global variables to function local variables
-llvm::ModulePass *createSPIRVLowerGlobal();
-
-/// Create a pass for lowering GLSL buffers (UBO and SSBO) to function calls
-llvm::ModulePass *createSPIRVLowerBuffer();
-
-/// Create a pass for lowering resource fetches to function calls
-llvm::ModulePass *createSPIRVLowerFetch();
-
-llvm::ModulePass *createSPIRVResourceCollect();
-
-/// Create a pass for translating input function call to real access input instruction
-llvm::ModulePass *createLLVMInput();
-
-/// Create a pass for translating input function call to real access output instruction
-llvm::ModulePass *createLLVMOutput();
-
-/// Create a pass for translating descriptor function call to real descriptor setup instruction
-llvm::ModulePass *createLLVMDescriptor();
-
-/// Create a pass for removing unused built-in functions
-llvm::ModulePass *createLLVMBuiltInFunc();
-
-llvm::ModulePass *createLLVMMutateEntry();
-
 } // namespace llvm
 
 #endif
diff --git a/llpc/translator/lib/SPIRV/SPIRVReader.cpp b/llpc/translator/lib/SPIRV/SPIRVReader.cpp
index 44c3968f7..a4f6c761a 100644
--- a/llpc/translator/lib/SPIRV/SPIRVReader.cpp
+++ b/llpc/translator/lib/SPIRV/SPIRVReader.cpp
@@ -54,21 +54,20 @@
 #include "llvm/Analysis/VectorUtils.h"
 #include "llvm/BinaryFormat/Dwarf.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DIBuilder.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
-#include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Metadata.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/Type.h"
 #include "llvm/IR/ValueMap.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Support/raw_ostream.h"
diff --git a/llpc/util/llpcTimerProfiler.cpp b/llpc/util/llpcTimerProfiler.cpp
index 9490a3202..5885b3adc 100644
--- a/llpc/util/llpcTimerProfiler.cpp
+++ b/llpc/util/llpcTimerProfiler.cpp
@@ -106,31 +106,20 @@ TimerProfiler::TimerProfiler(uint64_t hash64, const char *descriptionPrefix, uns
 }
 
 // =====================================================================================================================
 TimerProfiler::~TimerProfiler() {
   if (TimePassesIsEnabled || cl::EnableTimerProfile) {
     // Stop whole timer
     m_wholeTimer.stopTimer();
   }
 }
 
-// =====================================================================================================================
-// Adds pass to start or stop timer in PassManager
-//
-// @param passMgr : Pass Manager
-// @param timerKind : Kind of phase timer
-// @param start : Start or  stop timer
-void TimerProfiler::addTimerStartStopPass(lgc::LegacyPassManager *passMgr, TimerKind timerKind, bool start) {
-  if (TimePassesIsEnabled || cl::EnableTimerProfile)
-    passMgr->add(lgc::LgcContext::createStartStopTimer(&m_phaseTimers[timerKind], start));
-}
-
 // =====================================================================================================================
 // Adds pass to start or stop timer in PassManager
 //
 // @param passMgr : Pass Manager
 // @param timerKind : Kind of phase timer
 // @param start : Start or  stop timer
 void TimerProfiler::addTimerStartStopPass(lgc::PassManager &passMgr, TimerKind timerKind, bool start) {
   if (TimePassesIsEnabled || cl::EnableTimerProfile)
     lgc::LgcContext::createAndAddStartStopTimer(passMgr, &m_phaseTimers[timerKind], start);
 }
diff --git a/llpc/util/llpcTimerProfiler.h b/llpc/util/llpcTimerProfiler.h
index c37e6b61f..2e452c91d 100644
--- a/llpc/util/llpcTimerProfiler.h
+++ b/llpc/util/llpcTimerProfiler.h
@@ -30,21 +30,20 @@
  */
 
 #pragma once
 
 #include "llpc.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/Support/Timer.h"
 
 namespace lgc {
 
-class LegacyPassManager;
 class PassManager;
 
 } // namespace lgc
 
 namespace Llpc {
 
 // =====================================================================================================================
 // Enumerates the kinds of timer used to do profiling for LLPC compilation phases.
 enum TimerKind : unsigned {
   TimerTranslate, // Timer for translator
@@ -58,21 +57,20 @@ enum TimerKind : unsigned {
 };
 
 // =====================================================================================================================
 // Represents a utility class for time profile, it wraps LLVM Timer and TimerGroup in internal.
 class TimerProfiler {
 public:
   TimerProfiler(uint64_t hash64, const char *descriptionPrefix, unsigned enableMask);
 
   ~TimerProfiler();
 
-  void addTimerStartStopPass(lgc::LegacyPassManager *passMgr, TimerKind timerKind, bool start);
   void addTimerStartStopPass(lgc::PassManager &passMgr, TimerKind timerKind, bool start);
 
   void startStopTimer(TimerKind name, bool start);
 
   llvm::Timer *getTimer(TimerKind timerKind);
 
   static const llvm::StringMap<llvm::TimeRecord> &getDummyTimeRecords();
 
   static const unsigned PipelineTimerEnableMask = ((1 << TimerCount) - 1);
   static const unsigned ShaderModuleTimerEnableMask = ((1 << TimerTranslate) | (1 << TimerLower));
