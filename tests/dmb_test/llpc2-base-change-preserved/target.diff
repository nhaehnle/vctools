diff --git a/.github/workflows/build-amdvlk-docker.yml b/.github/workflows/build-amdvlk-docker.yml
index 0d1a4b3b7..7caaf5bbe 100644
--- a/.github/workflows/build-amdvlk-docker.yml
+++ b/.github/workflows/build-amdvlk-docker.yml
@@ -7,26 +7,27 @@ on:
 
 jobs:
   build-and-push-amdvlk:
     name: "Features: ${{ matrix.feature-set }}"
     if: github.repository == 'GPUOpen-Drivers/llpc'
     runs-on: ${{ matrix.host-os }}
     strategy:
       fail-fast: false
       matrix:
         host-os:        ["ubuntu-20.04"]
-        image-template: ["amdvlk_%s%s:nightly"]
+        image-template: ["amdvlkadmin/amdvlk_%s%s:nightly"]
         branch:         [dev]
         config:         [Release]
         feature-set:    ["+gcc", "+gcc+assertions",
-                         "+clang", "+clang+coverage",
-                         "+clang+shadercache+coverage+assertions",
+                         "+clang",
+                         "+clang+shadercache+ubsan+asan",
+                         "+clang+shadercache+ubsan+asan+assertions",
                          "+clang+shadercache+tsan"]
         generator:      [Ninja]
     steps:
       - name: Free up disk space
         run: |
           echo 'Before:' && df -h
           sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/hostedtoolcache/boost /opt/ghc \
                       /usr/lib/jvm /opt/hostedtoolcache/go /opt/hostedtoolcache/CodeQL /opt/az \
                       /usr/share/swift /usr/local/.ghcup /usr/local/graalvm /usr/local/lib/node_modules
           echo 'After:' && df -h
@@ -40,17 +41,17 @@ jobs:
           FEATURES_LOWER=$(echo "${{ matrix.feature-set }}" | tr "+" "_")
           TAG=$(printf "${{ matrix.image-template }}" "$CONFIG_LOWER" "$FEATURES_LOWER")
           echo "IMAGE_TAG=$TAG" | tee -a $GITHUB_ENV
       - name: Build and Test AMDVLK with Docker
         run: |
           docker build . --file docker/amdvlk.Dockerfile \
                          --build-arg BRANCH="${{ matrix.branch }}" \
                          --build-arg CONFIG="${{ matrix.config }}" \
                          --build-arg FEATURES="${{ matrix.feature-set }}" \
                          --build-arg GENERATOR="${{ matrix.generator }}" \
-                         --tag "${{secrets.DOCKER_USR}}/$IMAGE_TAG"
+                         --tag "$IMAGE_TAG"
       - name: Login Docker
         run: |
-          echo "${{ secrets.DOCKER_PWD }}" | docker login -u ${{ secrets.DOCKER_USR }} --password-stdin
+          echo "${{ secrets.DOCKER_PWD }}" | docker login -u amdvlkadmin --password-stdin
       - name: Push the new image
         run: |
-          docker push "${{secrets.DOCKER_USR}}/$IMAGE_TAG"
+          docker push "$IMAGE_TAG"
diff --git a/.github/workflows/check-amdllpc-docker.yml b/.github/workflows/check-amdllpc-docker.yml
index bb83eedfc..17ba853bf 100644
--- a/.github/workflows/check-amdllpc-docker.yml
+++ b/.github/workflows/check-amdllpc-docker.yml
@@ -8,24 +8,26 @@ on:
   pull_request:
 
 jobs:
   build-and-test:
     name: "Features: ${{ matrix.feature-set }}"
     runs-on: ${{ matrix.host-os }}
     strategy:
       fail-fast: false
       matrix:
         host-os:             ["ubuntu-20.04"]
-        image-template:      ["amdvlk_%s%s:nightly"]
+        image-template:      ["amdvlkadmin/amdvlk_%s%s:nightly"]
         config:              [Release]
         feature-set:         ["+gcc", "+gcc+assertions",
-                              "+clang", "+clang+coverage",
+                              "+clang",
+                              "+clang+shadercache+ubsan+asan",
+                              "+clang+shadercache+ubsan+asan+assertions",
                               "+clang+shadercache+tsan"]
     steps:
       - name: Free up disk space
         if: contains(matrix.feature-set, '+ubsan') || contains(matrix.feature-set, '+asan') || contains(matrix.feature-set, '+tsan') || contains(matrix.feature-set, '+coverage')
         run: |
           echo 'Before:' && df -h
           sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/hostedtoolcache/boost /opt/ghc \
                       /usr/lib/jvm /opt/hostedtoolcache/go /opt/hostedtoolcache/CodeQL /opt/az \
                       /usr/share/swift /usr/local/.ghcup /usr/local/graalvm /usr/local/lib/node_modules
           echo 'After:' && df -h
@@ -36,24 +38,24 @@ jobs:
           git checkout ${GITHUB_SHA}
       - name: Generate Docker base image tag string
         run: |
           CONFIG_LOWER=$(echo "${{ matrix.config }}" | tr "[:upper:]" "[:lower:]")
           FEATURES_LOWER=$(echo "${{ matrix.feature-set }}" | tr "+" "_")
           TAG=$(printf "${{ matrix.image-template }}" "$CONFIG_LOWER" "$FEATURES_LOWER")
           echo "IMAGE_TAG=$TAG" | tee -a $GITHUB_ENV
           CONFIG_TAG=$(printf "%s%s" "$CONFIG_LOWER" "$FEATURES_LOWER")
           echo "CONFIG_TAG=$CONFIG_TAG" | tee -a $GITHUB_ENV
       - name: Fetch the latest prebuilt AMDVLK
-        run: docker pull "amdvlkadmin/$IMAGE_TAG"
+        run: docker pull "$IMAGE_TAG"
       - name: Build and Test with Docker
         run: docker build . --file docker/llpc.Dockerfile
-                             --build-arg AMDVLK_IMAGE="amdvlkadmin/$IMAGE_TAG"
+                             --build-arg AMDVLK_IMAGE="$IMAGE_TAG"
                              --build-arg LLPC_REPO_NAME="${GITHUB_REPOSITORY}"
                              --build-arg LLPC_REPO_REF="${GITHUB_REF}"
                              --build-arg LLPC_REPO_SHA="${GITHUB_SHA}"
                              --build-arg FEATURES="${{ matrix.feature-set }}"
                              --tag llpc/ci-shaderdb
       - name: Copy code coverage report to host and save PR number
         if: contains(matrix.feature-set, '+coverage') && github.event.pull_request.number
         run: |
           docker run -v "$HOME:/host" llpc/ci-shaderdb 'bash' '-c' 'cp -r /vulkandriver/coverage_report /host/'
           sudo chown -R runner $HOME/coverage_report
diff --git a/.github/workflows/check-clang-tidy-llpc.yml b/.github/workflows/check-clang-tidy-llpc.yml
index f9533a909..6ede27ee8 100644
--- a/.github/workflows/check-clang-tidy-llpc.yml
+++ b/.github/workflows/check-clang-tidy-llpc.yml
@@ -8,22 +8,22 @@ jobs:
     name: clang-tidy
     runs-on: "ubuntu-20.04"
     steps:
       - name: Checkout LLPC
         run: |
           git clone https://github.com/${GITHUB_REPOSITORY}.git .
           git fetch origin +${GITHUB_SHA}:${GITHUB_REF} --update-head-ok
           git checkout ${GITHUB_SHA}
       - name: Generate Docker base image tag string
         run: |
-          echo "IMAGE_TAG=amdvlk_release_clang:nightly" \
+          echo "IMAGE_TAG=amdvlkadmin/amdvlk_release_clang:nightly" \
             | tee -a $GITHUB_ENV
       - name: Fetch the latest prebuilt AMDVLK
-        run: docker pull "amdvlkadmin/$IMAGE_TAG"
+        run: docker pull "$IMAGE_TAG"
       - name: Build and Test with Docker
         run: docker build . --file docker/llpc-clang-tidy.Dockerfile
-                            --build-arg AMDVLK_IMAGE="amdvlkadmin/$IMAGE_TAG"
+                            --build-arg AMDVLK_IMAGE="$IMAGE_TAG"
                             --build-arg LLPC_REPO_NAME="${GITHUB_REPOSITORY}"
                             --build-arg LLPC_REPO_REF="${GITHUB_REF}"
                             --build-arg LLPC_REPO_SHA="${GITHUB_SHA}"
                             --build-arg LLPC_BASE_REF="${{ github.base_ref }}"
                             --tag llpc/ci-shaderdb
diff --git a/.github/workflows/check-cppcheck-llpc.yml b/.github/workflows/check-cppcheck-llpc.yml
index b6f475531..c375d39d9 100644
--- a/.github/workflows/check-cppcheck-llpc.yml
+++ b/.github/workflows/check-cppcheck-llpc.yml
@@ -10,11 +10,11 @@ jobs:
     steps:
       - name: Setup environment
         run: |
           sudo apt-get install -yqq cppcheck
       - name: Checkout LLPC
         run: |
           git clone https://github.com/${GITHUB_REPOSITORY}.git .
           git fetch origin +${GITHUB_SHA}:${GITHUB_REF} --update-head-ok
           git checkout ${GITHUB_SHA}
       - name: Run cppcheck
-        run: cppcheck -q -j$(( $(nproc) * 4 )) --error-exitcode=1 --std=c++14 --inline-suppr .
+        run: cppcheck -q -j$(( $(nproc) * 4 )) --error-exitcode=1 --std=c++17 --inline-suppr .
diff --git a/.github/workflows/check-formatting-llpc.yml b/.github/workflows/check-formatting-llpc.yml
index 1939df2e6..4de07030e 100644
--- a/.github/workflows/check-formatting-llpc.yml
+++ b/.github/workflows/check-formatting-llpc.yml
@@ -11,28 +11,28 @@ jobs:
       - name: Setup environment
         run: |
           sudo apt-get install -yqq clang-format-11
       - name: Checkout LLPC
         run: |
           git clone https://github.com/${GITHUB_REPOSITORY}.git .
           git fetch origin +${GITHUB_SHA}:${GITHUB_REF} --update-head-ok
           git checkout ${GITHUB_SHA}
       - name: Run clang-format
         run: |
-          git diff ${{ github.base_ref }} -U0 --no-color -- '**/*.cpp' '**/*.cc' '**/*.h' '**/*.hh' \
+          git diff ${{ github.base_ref }} -U10 --no-color -- '**/*.cpp' '**/*.cc' '**/*.h' '**/*.hh' \
             | clang-format-diff-11 -p1 >not-formatted.diff 2>&1
       - name: Check formatting
         run: |
           if ! grep -q '[^[:space:]]' not-formatted.diff ; then
             echo "Code formatted. Success."
           else
             echo "Code not formatted."
             echo "Please run clang-format-diff on your changes and push again:"
-            echo "    git diff ${{ github.base_ref }} -U0 --no-color | clang-format-diff -p1 -i"
+            echo "    git diff ${{ github.base_ref }} -U10 --no-color | clang-format-diff -p1 -i"
             echo ""
             echo "Tip: you can disable clang-format checks: https://clang.llvm.org/docs/ClangFormatStyleOptions.html#disabling-formatting-on-a-piece-of-code"
             echo ""
             echo "Diff:"
             cat not-formatted.diff
             echo ""
             exit 3
           fi
diff --git a/CMakeLists.txt b/CMakeLists.txt
index f83014254..3997b7636 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -49,20 +49,32 @@ if(LLPC_ENABLE_SHADER_CACHE)
     target_compile_definitions(vkgc_headers INTERFACE LLPC_ENABLE_SHADER_CACHE)
 endif()
 
 if (LLPC_CLIENT_INTERFACE_MAJOR_VERSION)
     target_compile_definitions(vkgc_headers INTERFACE LLPC_CLIENT_INTERFACE_MAJOR_VERSION=${LLPC_CLIENT_INTERFACE_MAJOR_VERSION})
 else()
     # LLPC is not compiled, so fall back to the latest version
     target_compile_definitions(vkgc_headers INTERFACE LLPC_CLIENT_INTERFACE_MAJOR_VERSION=LLPC_INTERFACE_MAJOR_VERSION)
 endif()
 
+#if VKI_BUILD_GFX11
+if(LLPC_BUILD_GFX11)
+    target_compile_definitions(vkgc_headers INTERFACE VKI_BUILD_GFX11)
+endif()
+#endif
+
+#if VKI_BUILD_NAVI31
+if(LLPC_BUILD_NAVI31)
+    target_compile_definitions(vkgc_headers INTERFACE LLPC_BUILD_NAVI31)
+endif()
+#endif
+
 #if VKI_RAY_TRACING
 if(VKI_RAY_TRACING)
     target_compile_definitions(vkgc_headers INTERFACE VKI_RAY_TRACING)
     target_compile_definitions(vkgc_headers INTERFACE GPURT_CLIENT_INTERFACE_MAJOR_VERSION=${GPURT_CLIENT_INTERFACE_MAJOR_VERSION})
 endif()
 #endif
 
 target_link_libraries(vkgc INTERFACE vkgc_headers)
 
 ### Expose header files ################################################################################################
diff --git a/cmake/CompilerFlags.cmake b/cmake/CompilerFlags.cmake
index 5d39fa202..88522adef 100644
--- a/cmake/CompilerFlags.cmake
+++ b/cmake/CompilerFlags.cmake
@@ -1,11 +1,15 @@
 function(set_compiler_options PROJECT_NAME ENABLE_WERROR)
+    target_compile_features("${PROJECT_NAME}" PUBLIC cxx_std_17)
+    set_target_properties("${PROJECT_NAME}" PROPERTIES CXX_EXTENSIONS OFF)
+    set_target_properties("${PROJECT_NAME}" PROPERTIES POSITION_INDEPENDENT_CODE ON)
+
     if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
         if(ENABLE_WERROR)
             target_compile_options("${PROJECT_NAME}" PRIVATE
                 -Werror
                 -Wno-error=deprecated-declarations
             )
         endif()
 
         # SEE: https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Option-Summary.html#Option-Summary
         # for a list of all options and documentation.
@@ -25,22 +29,20 @@ function(set_compiler_options PROJECT_NAME ENABLE_WERROR)
             -Wno-unused-parameter
             -Wunused-variable
             -Werror=unused-variable
             -Wunused-function
             -Werror=unused-function
             -Werror=unused-result  # Error out on unused results of functions marked with LLPC_NODISCARD
         )
 
         target_compile_options("${PROJECT_NAME}" PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
             -fno-rtti
-            -fPIC
-            -std=c++17
             # Some of the games using old versions of the tcmalloc lib are
             # crashing when allocating aligned memory. C++17 enables aligned new
             # by default, so we need to disable it to prevent those crashes.
             -fno-aligned-new
             -Wno-ignored-qualifiers
             -Wno-missing-field-initializers
             -Wno-invalid-offsetof           # offsetof within non-standard-layout type 'x' is undefined
         >)
 
         if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
@@ -91,20 +93,17 @@ function(set_compiler_options PROJECT_NAME ENABLE_WERROR)
                 /wd4512 # assignment operator could not be generated
                 /wd4589 # ignored initialization of virtual base class
                 /wd4610 # struct 'X' can never be instantiated - user defined constructor required
                 /wd4624 # destructor could not be generated because a base class destructor is inaccessible or deleted
                 /wd4702 # unreachable code
                 /wd4706 # assignment within conditional expression
                 /wd4800 # forcing value to bool 'true' or 'false' (performance warning)
                 /wd6246 # Local declaration of 'S' hides declaration of the same name in outer scope
                 /wd6323 # Use of arithmetic operator on Boolean type(s)
         )
-        target_compile_options("${PROJECT_NAME}" PRIVATE
-          /std:c++17
-        )
 
         target_compile_definitions("${PROJECT_NAME}" PRIVATE _SCL_SECURE_NO_WARNINGS)
         target_compile_definitions("${PROJECT_NAME}" PRIVATE _CRT_SECURE_NO_WARNINGS)
     else()
         message(FATAL_ERROR "Using unknown compiler")
     endif()
 endfunction()
diff --git a/docker/amdvlk.Dockerfile b/docker/amdvlk.Dockerfile
index cb060eacc..a05c24a8b 100644
--- a/docker/amdvlk.Dockerfile
+++ b/docker/amdvlk.Dockerfile
@@ -86,21 +86,21 @@ RUN EXTRA_COMPILER_FLAGS=() \
          EXTRA_FLAGS+=("-DCMAKE_CXX_COMPILER=clang++"); \
          EXTRA_FLAGS+=("-DLLVM_USE_LINKER=lld"); \
          EXTRA_LINKER_FLAGS+=("-fuse-ld=lld"); \
        fi \
     && if echo "$FEATURES" | grep -q "+shadercache" ; then \
          EXTRA_FLAGS+=("-DLLPC_ENABLE_SHADER_CACHE=1"); \
        fi \
     && if echo "$FEATURES" | grep -q "+asan" ; then \
          SANITIZERS+=("Address"); \
          echo "export ASAN_OPTIONS=detect_leaks=0" >> /vulkandriver/env.sh; \
-         echo "export LD_PRELOAD=$(clang -print-file-name=libclang_rt.asan-x86_64.so)" >> /vulkandriver/env.sh; \
+         echo "export LD_LIBRARY_PATH=$(dirname $(clang -print-file-name=libclang_rt.asan-x86_64.so))" >> /vulkandriver/env.sh; \
        fi \
     && if echo "$FEATURES" | grep -q "+ubsan" ; then \
          SANITIZERS+=("Undefined"); \
        fi \
     && if echo "$FEATURES" | grep -q "+tsan" ; then \
          SANITIZERS+=("Thread"); \
        fi \
     && if [ ${#SANITIZERS[@]} -ne 0 ]; then  \
          SANITIZERS_SEPARATED_LIST="${SANITIZERS[@]}"; \
          SANITIZERS_SEPARATED_LIST="${SANITIZERS_SEPARATED_LIST// /;}"; \
diff --git a/docker/llpc-clang-tidy.Dockerfile b/docker/llpc-clang-tidy.Dockerfile
index 051c9c73c..99f10f0dd 100644
--- a/docker/llpc-clang-tidy.Dockerfile
+++ b/docker/llpc-clang-tidy.Dockerfile
@@ -1,16 +1,16 @@
 #
 # Dockerfile for LLPC Continuous Integration.
 # Sample invocation:
 #    docker build .                                                                                         \
 #      --file docker/llpc-clang-tidy.Dockerfile                                                             \
-#      --build-arg AMDVLK_IMAGE=***/amdvlk_release_clang:nightly                                            \
+#      --build-arg AMDVLK_IMAGE=amdvlkadmin/amdvlk_release_clang:nightly                                    \
 #      --build-arg LLPC_REPO_NAME=GPUOpen-Drivers/llpc                                                      \
 #      --build-arg LLPC_REPO_REF=<GIT_REF>                                                                  \
 #      --build-arg LLPC_REPO_SHA=<GIT_SHA>                                                                  \
 #      --tag llpc-ci/llpc
 #
 # Required arguments:
 # - AMDVLK_IMAGE: Base image name for prebuilt amdvlk
 # - LLPC_REPO_NAME: Name of the llpc repository to clone
 # - LLPC_REPO_REF: ref name to checkout
 # - LLPC_REPO_SHA: SHA of the commit to checkout
diff --git a/docker/llpc.Dockerfile b/docker/llpc.Dockerfile
index 6289fefe3..fbf743917 100644
--- a/docker/llpc.Dockerfile
+++ b/docker/llpc.Dockerfile
@@ -1,16 +1,16 @@
 #
 # Dockerfile for LLPC Continuous Integration.
 # Sample invocation:
 #    docker build .                                                                                       \
 #      --file docker/llpc.Dockerfile                                                                      \
-#      --build-arg AMDVLK_IMAGE=***/amdvlk_%s%s:nightly                                                   \
+#      --build-arg AMDVLK_IMAGE=amdvlkadmin/amdvlk_release_gcc_assertions:nightly                         \
 #      --build-arg LLPC_REPO_NAME=GPUOpen-Drivers/llpc                                                    \
 #      --build-arg LLPC_REPO_REF=<GIT_REF>                                                                \
 #      --build-arg LLPC_REPO_SHA=<GIT_SHA>                                                                \
 #      --build-arg FEATURES="+coverage"                                                                   \
 #      --tag llpc-ci/llpc
 #
 # Required arguments:
 # - AMDVLK_IMAGE: Base image name for prebuilt amdvlk
 # - LLPC_REPO_NAME: Name of the llpc repository to clone
 # - LLPC_REPO_REF: ref name to checkout
diff --git a/docker/update-llpc.sh b/docker/update-llpc.sh
index 444ab4651..3587473c8 100755
--- a/docker/update-llpc.sh
+++ b/docker/update-llpc.sh
@@ -1,12 +1,13 @@
 #!/usr/bin/env bash
 # Update the driver and clone a specified version of LLPC.
 # Shared code between docker containers.
-set -e
+set -euxo pipefail
 
 # Sync the repos. Replace the base LLPC with a freshly checked-out one.
 cat /vulkandriver/build_info.txt
 (cd /vulkandriver && repo sync -c --no-clone-bundle -j$(nproc))
-git -C /vulkandriver/drivers/llpc remote add origin https://github.com/"$LLPC_REPO_NAME".git
+git -C /vulkandriver/drivers/llpc remote rename vulkan-github origin
+git -C /vulkandriver/drivers/llpc/imported/llvm-dialects remote rename vulkan-github origin
 git -C /vulkandriver/drivers/llpc fetch origin +"$LLPC_REPO_SHA":"$LLPC_REPO_REF" --update-head-ok
 git -C /vulkandriver/drivers/llpc checkout "$LLPC_REPO_SHA"
 git -C /vulkandriver/drivers/llpc submodule update --init
diff --git a/docs/Contributing.md b/docs/Contributing.md
index 0432ca62b..ce1f1a061 100644
--- a/docs/Contributing.md
+++ b/docs/Contributing.md
@@ -144,20 +144,34 @@ The tests must exist in the LLPC repository. They can be
 
 * a [shaderdb test](../llpc/test/shaderdb),
 * an [LGC test](../lgc/test),
 * an [LLPC unit test](../llpc/unittests), or
 * an [LGC unit test](../lgc/unittests).
 
 We do not want to rely on the Vulkan CTS. Running the Vulkan CTS takes a long
 time, putting a *time-to-test* burden on all developers. The Vulkan CTS tests
 are also harder to debug because more components are involved and require a GPU.
 
+LIT tests (tests that are run using the `llvm-lit` tool) should provide good
+and reliable coverage, e.g. using `CHECK-NEXT` lines, while still being easy
+to maintain. Where reasonably possible, try to:
+
+* For passes in LGC, write an `.lgc` test that invokes `lgc` with the `-passes`
+  option to run a single pass. Use LLVM's `update_test_checks.py` with the
+  `--tool` option to automatically generate the check lines.
+* For frontend code, write a GLSL or `.spvasm` test (either standalone file or
+  inlined in a `.pipe` file) that invokes `amdllpc` with the `-emit-lgc` option
+  or with `-o - -filetype=asm`.
+  Use our [update_llpc_test_checks.py](../tool/update_llpc_test_checks.py) tool
+  to automatically generate the check lines. Where necessary, use options like
+  `--check-globals` to auto-generate additional checks.
+
 To help developers know if their tests are covering their code change, a code
 coverage analysis will be run on all PR before they are submitted. The PR
 should only be merged if the new code is covered. Exceptions can be made if
 there is a good reason like the PR adds error handling code for an error that
 cannot be reproduced consistently. Note that this is just a minimum requirement
 and does not mean that the tests are effective.   If an existing test already
 covers the new code, that test should be updated to test for the new behaviour
 or a new test should be added.
 
 ## Avoid binary data
diff --git a/include/vkgcDefs.h b/include/vkgcDefs.h
index 74a385648..5fed9948a 100644
--- a/include/vkgcDefs.h
+++ b/include/vkgcDefs.h
@@ -40,21 +40,21 @@
 #undef False
 #undef DestroyAll
 #undef Status
 #undef Bool
 #endif
 
 /// LLPC major interface version.
 #define LLPC_INTERFACE_MAJOR_VERSION 57
 
 /// LLPC minor interface version.
-#define LLPC_INTERFACE_MINOR_VERSION 0
+#define LLPC_INTERFACE_MINOR_VERSION 2
 
 #ifndef LLPC_CLIENT_INTERFACE_MAJOR_VERSION
 #error LLPC client version is not defined
 #endif
 
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION < 49
 #error LLPC client version is too old
 #endif
 
 #ifndef LLPC_ENABLE_SHADER_CACHE
@@ -75,20 +75,22 @@
 #else
 #define LLPC_NODISCARD
 #endif
 
 //
 // -------------------------------------------------------------------------------------------------------------------
 //  @page VersionHistory
 //  %Version History
 //  | %Version | Change Description                                                                                    |
 //  | -------- | ----------------------------------------------------------------------------------------------------- |
+//  |     57.2 | Move all internal resource binding id to enum InternalBinding.                                        |
+//  |     57.1 | Add forceNonUniformResourceIndexStageMask to PipelineOptions                                          |
 //  |     57.0 | Merge aggressiveInvariantLoads and disableInvariantLoads to an enumerated option                      |
 //  |     56.2 | Add aggressiveInvariantLoads and disableInvariantLoads to PipelineShaderOptions                       |
 //  |     56.1 | Add struct UberFetchShaderAttribInfo                                                                  |
 //  |     56.0 | Move maxRayLength to RtState                                                                          |
 //  |     55.2 | Add pipeline layout API hash to all PipelineBuildInfos                                                |
 //  |     55.1 | Add nsaThreshold to PipelineShaderOptions                                                             |
 //  |     55.0 | Remove isInternalRtShader from module options                                                         |
 //  |     54.9 | Add internalRtShaders to PipelineOptions to allow for dumping this data                               |
 //  |     54.6 | Add reverseThreadGroup to PipelineOptions                                                             |
 //  |     54.5 | Add forceLateZ to PipelineShaderOptions                                                               |
@@ -117,20 +119,23 @@
 //  |     50.2 | Add the member dsState to GraphicsPipelineBuildInfo                                                   |
 //  |     50.1 | Disclose ResourceMappingNodeType::InlineBuffer                                                        |
 //  |     50.0 | Removed the member 'enableOpt' of ShaderModuleOptions                                                 |
 //  |     49.1 | Added enableEarlyCompile to GraphicsPipelineBuildInfo                                                 |
 //  |     49.0 | Added DescriptorConstBuffer, DescriptorConstBufferCompact, DescriptorImage, DescriptorConstTexelBuffer|
 //  |          | to ResourceMappingNodeType                                                                            |
 //  |     48.1 | Added enableUberFetchShader to GraphicsPipelineBuildInfo                                              |
 //  |     48.0 | Removed the member 'polygonMode' of rsState                                                           |
 //  |     47.0 | Always get culling controls from primitive shader table                                               |
 //  |     46.3 | Added enableInterpModePatch to PipelineOptions                                                        |
+#if VKI_BUILD_GFX11
+//  |     46.2 | Added optimizeTessFactor to PipelineOptions for GFX11+                                                |
+#endif
 //  |     46.1 | Added dynamicVertexStride to GraphicsPipelineBuildInfo                                                |
 //  |     46.0 | Removed the member 'depthBiasEnable' of rsState                                                       |
 //  |     45.5 | Added new enum type ThreadGroupSwizzleMode for thread group swizzling for compute shaders             |
 //  |     45.4 | Added disableLicmThreshold, unrollHintThreshold, and dontUnrollHintThreshold to PipelineShaderOptions |
 //  |     45.3 | Add pipelinedump function to enable BeginPipelineDump and GetPipelineName                             |
 //  |     45.2 | Add GFX IP plus checker to GfxIpVersion                                                               |
 //  |     45.1 | Add pipelineCacheAccess, stageCacheAccess(es) to GraphicsPipelineBuildOut/ComputePipelineBuildOut     |
 //  |     45.0 | Remove the member 'enableFastLaunch' of NGG state                                                     |
 //  |     44.0 | Rename the member 'forceNonPassthrough' of NGG state to 'forceCullingMode'                            |
 //  |     43.1 | Add disableImageResourceCheck in PipelineOptions                                                      |
@@ -172,25 +177,20 @@
 //  LLPC is free to add new fields to such structures without increasing the client interface major version, as long
 //  as setting the newly added fields to a 0 (or false) value is safe, i.e. it preserves the old behavior.
 //
 
 namespace Vkgc {
 
 static const unsigned Version = LLPC_INTERFACE_MAJOR_VERSION;
 static const unsigned InternalDescriptorSetId = static_cast<unsigned>(-1);
 static const unsigned MaxVertexAttribs = 64;
 static const unsigned MaxColorTargets = 8;
-static const unsigned FetchShaderInternalBufferBinding = 5;
-static const unsigned ReverseThreadGroupControlBinding = 7;
-#if VKI_RAY_TRACING
-static const unsigned RtCaptureReplayInternalBufferBinding = 8;
-#endif
 static const unsigned MaxFetchShaderInternalBufferSize = 16 * MaxVertexAttribs;
 
 // Forward declarations
 class IShaderCache;
 class ICache;
 class EntryHandle;
 
 /// Enumerates result codes of LLPC operations.
 enum class Result : int {
   /// The operation completed successfully
@@ -302,20 +302,38 @@ enum UnlinkedShaderStage : unsigned {
 };
 
 #if VKI_RAY_TRACING
 static_assert((1 << (ShaderStageCount - 1)) == ShaderStageRayTracingCallableBit,
               "Vkgc::ShaderStage has been updated. Please update Vkgc::ShaderStageBit as well.");
 #else
 static_assert((1 << (ShaderStageCount - 1)) == ShaderStageComputeBit,
               "Vkgc::ShaderStage has been updated. Please update Vkgc::ShaderStageBit as well.");
 #endif
 
+/// Enumerates the binding ID of internal resource.
+enum InternalBinding : unsigned {
+  FetchShaderBinding = 0,     ///< Binding ID of vertex buffer table
+  ConstantBuffer0Binding = 1, ///< Binding ID of default uniform block
+  PushConstantBinding = 2,    ///< Binding ID of push constant buffer
+#if VKI_RAY_TRACING
+  ShaderRecordBufferBinding = 3, ///< Binding ID of ray-tracing shader record buffer
+#endif
+  TaskPayloadBinding = 4,               ///< Binding ID of payload buffer in task shader
+  FetchShaderInternalBufferBinding = 5, ///< Binding ID of uber-fetch shader internal buffer
+  ReverseThreadGroupControlBinding = 7, ///< Binding ID of internal buffer for reverseThreadGroup
+#if VKI_RAY_TRACING
+  RtCaptureReplayInternalBufferBinding = 8, ///< Binding ID of ray-tracing capture replay internal buffer
+#endif
+  SpecConstInternalBufferBindingId = 9, ///< Binding ID of internal buffer for specialized constant.
+  SpecConstInternalBufferBindingIdEnd = SpecConstInternalBufferBindingId + ShaderStageCount,
+};
+
 /// Enumerates the function of a particular node in a shader's resource mapping graph.
 enum class ResourceMappingNodeType : unsigned {
   Unknown,                   ///< Invalid type
   DescriptorResource,        ///< Generic descriptor: resource, including texture resource,
   DescriptorSampler,         ///< Generic descriptor: sampler
   DescriptorCombinedTexture, ///< Generic descriptor: combined texture, combining resource descriptor with
                              ///  sampler descriptor of the same texture, starting with resource descriptor
   DescriptorTexelBuffer,     ///< Generic descriptor: texel buffer
   DescriptorFmask,           ///< Generic descriptor: F-mask
   DescriptorBuffer,          ///< Generic descriptor: buffer, including shader storage buffer
@@ -482,39 +500,45 @@ struct PipelineOptions {
   ShadowDescriptorTableUsage shadowDescriptorTableUsage; ///< Controls shadow descriptor table.
   unsigned shadowDescriptorTablePtrHigh;                 ///< Sets high part of VA ptr for shadow descriptor table.
   ExtendedRobustness extendedRobustness;                 ///< ExtendedRobustness is intended to correspond to the
                                                          ///  features of VK_EXT_robustness2.
 #if VKI_RAY_TRACING
   bool enableRayQuery; ///< If set, ray query is enabled
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION < 56
   float rtMaxRayLength; ///< Overrides the rayTMax value
 #endif
 #endif
-  bool reserved1f;            /// Reserved for future functionality
+#if VKI_BUILD_GFX11
+  bool optimizeTessFactor; ///< If set, we can determine either send HT_TessFactor message or write to TF buffer
+                           ///< depending the values of tessellation factors.
+#else
+  bool reserved1f; /// Reserved for future functionality
+#endif
   bool enableInterpModePatch; ///< If set, per-sample interpolation for nonperspective and smooth input is enabled
   bool pageMigrationEnabled;  ///< If set, page migration is enabled
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 53
   uint32_t optimizationLevel; ///< The higher the number the more optimizations will be performed.  Valid values are
                               ///< between 0 and 3.
 #endif
   unsigned overrideThreadGroupSizeX;             ///< Override value for ThreadGroupSizeX
   unsigned overrideThreadGroupSizeY;             ///< Override value for ThreadGroupSizeY
   unsigned overrideThreadGroupSizeZ;             ///< Override value for ThreadGroupSizeZ
   ResourceLayoutScheme resourceLayoutScheme;     ///< Resource layout scheme
   ThreadGroupSwizzleMode threadGroupSwizzleMode; ///< Controls thread group swizzle mode for compute shader.
   bool reverseThreadGroup;                       ///< If set, enable thread group reversing
 
 #if VKI_RAY_TRACING
   bool internalRtShaders; ///< Whether this pipeline has internal raytracing shaders
 #else
   bool reserved15;
 #endif
+  unsigned forceNonUniformResourceIndexStageMask; ///< Mask of the stage to force using non-uniform resource index.
 };
 
 /// Prototype of allocator for output data buffer, used in shader-specific operations.
 typedef void *(VKAPI_CALL *OutputAllocFunc)(void *pInstance, void *pUserData, size_t size);
 
 /// Enumerates types of shader binary.
 enum class BinaryType : unsigned {
   Unknown = 0, ///< Invalid type
   Spirv,       ///< SPIR-V binary
   LlvmBc,      ///< LLVM bitcode
@@ -953,20 +977,21 @@ enum RAYTRACING_ENTRY_FUNC : unsigned {
   RT_ENTRY_TRACE_RAY_INLINE,
   RT_ENTRY_TRACE_RAY_HIT_TOKEN,
   RT_ENTRY_RAY_QUERY_PROCEED,
   RT_ENTRY_INSTANCE_INDEX,
   RT_ENTRY_INSTANCE_ID,
   RT_ENTRY_OBJECT_TO_WORLD_TRANSFORM,
   RT_ENTRY_WORLD_TO_OBJECT_TRANSFORM,
   RT_ENTRY_RESERVE1,
   RT_ENTRY_RESERVE2,
   RT_ENTRY_RESERVE3,
+  RT_ENTRY_RESERVE4,
   RT_ENTRY_FUNC_COUNT,
 };
 
 // =====================================================================================================================
 // raytracing system value usage flags
 union RayTracingSystemValueUsage {
   struct {
     union {
       struct {
         uint16_t flags : 1;             // Shader calls gl_IncomingRayFlagsEXT
@@ -1061,22 +1086,25 @@ struct RtState {
                                                  ///  Shader may need to inverse the mapping if launch ID is used.
   RayTracingShaderExportConfig exportConfig;     ///< Ray tracing shader export config
   bool enableRayQueryCsSwizzle;                  ///< Determine if performs thread group swizzling
                                                  ///  for computer shaders use ray query feature
   bool enableDispatchRaysInnerSwizzle;           ///< Perform swizzling logic on the thread indices inside ray tracing
                                                  ///  thread groups
   bool enableDispatchRaysOuterSwizzle;           ///< Perform swizzling logic on the thread group indices used for ray
                                                  ///  tracing shaders
   bool forceInvalidAccelStruct;                  ///< Force ray tracing invalid acceleration structure
   bool enableRayTracingCounters;                 ///< Enable using ray tracing counters
-  bool enableOptimalLdsStackSizeForIndirect;     ///< Enable optimal LDS stack size for indirect shaders
-  bool enableOptimalLdsStackSizeForUnified;      ///< Enable optimal LDS stack size for unified shaders
+#if VKI_BUILD_GFX11
+  bool enableRayTracingHwTraversalStack; ///< Enable using hardware accelerated traversal stack
+#endif
+  bool enableOptimalLdsStackSizeForIndirect; ///< Enable optimal LDS stack size for indirect shaders
+  bool enableOptimalLdsStackSizeForUnified;  ///< Enable optimal LDS stack size for unified shaders
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 56
   float maxRayLength; ///< Raytracing rayDesc.tMax override
 #endif
 
   GpurtFuncTable gpurtFuncTable; ///< GPURT function table
 };
 #endif
 
 /// Represents info to build a graphics pipeline.
 struct GraphicsPipelineBuildInfo {
diff --git a/lgc/CMakeLists.txt b/lgc/CMakeLists.txt
index cd1847947..41c3971fb 100644
--- a/lgc/CMakeLists.txt
+++ b/lgc/CMakeLists.txt
@@ -46,20 +46,26 @@ add_llvm_library(LLVMlgc LINK_COMPONENTS
     ScalarOpts
     SelectionDAG
     Support
     Target
     TransformUtils
     Vectorize
 )
 
 ### Cached Project Options #############################################################################################
 option(LLPC_BUILD_NAVI12 "LLPC support for NAVI12?" OFF)
+#if VKI_BUILD_GFX11
+option(LLPC_BUILD_GFX11 "LLPC support for GFX11?" OFF)
+#endif
+#if VKI_BUILD_NAVI31
+option(LLPC_BUILD_NAVI31 "LLPC support for NAVI31?" OFF)
+#endif
 option(LLPC_ENABLE_WERROR "Build LLPC with more errors" OFF)
 
 ### Compiler Options ###################################################################################################
 include(../cmake/CompilerFlags.cmake)
 set_compiler_options(LLVMlgc ${LLPC_ENABLE_WERROR})
 
 ### Defines/Includes/Sources ###########################################################################################
 target_compile_definitions(LLVMlgc PRIVATE ${TARGET_ARCHITECTURE_ENDIANESS}ENDIAN_CPU)
 if (LLPC_CLIENT_INTERFACE_MAJOR_VERSION)
     target_compile_definitions(LLVMlgc PRIVATE LLPC_CLIENT_INTERFACE_MAJOR_VERSION=${LLPC_CLIENT_INTERFACE_MAJOR_VERSION})
@@ -74,20 +80,35 @@ target_compile_definitions(LLVMlgc PRIVATE
         )
 
 target_compile_definitions(LLVMlgc PRIVATE CHIP_HDR_RENOIR)
 
   if(LLPC_BUILD_NAVI12)
     target_compile_definitions(LLVMlgc PRIVATE
         LLPC_BUILD_NAVI12
         CHIP_HDR_NAVI12
     )
   endif()
+#if VKI_BUILD_GFX11
+  if(LLPC_BUILD_GFX11)
+    target_compile_definitions(LLVMlgc PUBLIC
+        LLPC_BUILD_GFX11
+    )
+  endif()
+#endif
+#if VKI_BUILD_NAVI31
+  if(LLPC_BUILD_NAVI31)
+    target_compile_definitions(LLVMlgc PRIVATE
+        LLPC_BUILD_NAVI31
+        CHIP_HDR_NAVI31
+    )
+  endif()
+#endif
 
 if(WIN32)
     target_compile_definitions(LLVMlgc PRIVATE
         NOMINMAX    # windows.h defines min/max which conflicts with the use of std::min / max
         UNICODE     # CMAKE-TODO: What is this used for?
         _UNICODE
     )
 endif()
 
 target_include_directories(LLVMlgc
@@ -163,20 +184,28 @@ target_sources(LLVMlgc PRIVATE
     patch/PatchSetupTargetFeatures.cpp
     patch/PatchInitializeWorkgroupMemory.cpp
     patch/PatchWorkarounds.cpp
     patch/ShaderInputs.cpp
     patch/ShaderMerger.cpp
     patch/SystemValues.cpp
     patch/VertexFetch.cpp
     patch/PatchWaveSizeAdjust.cpp
 )
 
+#if LLPC_BUILD_GFX11
+if(LLPC_BUILD_GFX11)
+  target_sources(LLVMlgc PRIVATE
+    patch/PatchImageOpCollect.cpp
+  )
+endif()
+#endif
+
 # lgc/state
 target_sources(LLVMlgc PRIVATE
     state/Compiler.cpp
     state/LgcContext.cpp
     state/PalMetadata.cpp
     state/PassManagerCache.cpp
     state/PipelineShaders.cpp
     state/PipelineState.cpp
     state/ResourceUsage.cpp
     state/ShaderModes.cpp
diff --git a/lgc/builder/ArithBuilder.cpp b/lgc/builder/ArithBuilder.cpp
index df23793cc..1fc053d06 100644
--- a/lgc/builder/ArithBuilder.cpp
+++ b/lgc/builder/ArithBuilder.cpp
@@ -1351,22 +1351,20 @@ Value *ArithBuilder::createFMix(Value *x, Value *y, Value *a, const Twine &instN
 }
 
 // =====================================================================================================================
 // Ensure result is canonicalized if the shader's FP mode is flush denorms. This is called on an FP result of an
 // instruction that does not honor the hardware's FP mode, such as fmin/fmax/fmed on GFX8 and earlier.
 //
 // @param value : Value to canonicalize
 Value *ArithBuilder::canonicalize(Value *value) {
   const auto &shaderMode = getShaderModes()->getCommonShaderMode(m_shaderStage);
   auto destTy = value->getType();
-  FpDenormMode denormMode =
-      destTy->getScalarType()->isHalfTy()
-          ? shaderMode.fp16DenormMode
-          : destTy->getScalarType()->isFloatTy()
-                ? shaderMode.fp32DenormMode
-                : destTy->getScalarType()->isDoubleTy() ? shaderMode.fp64DenormMode : FpDenormMode::DontCare;
+  FpDenormMode denormMode = destTy->getScalarType()->isHalfTy()     ? shaderMode.fp16DenormMode
+                            : destTy->getScalarType()->isFloatTy()  ? shaderMode.fp32DenormMode
+                            : destTy->getScalarType()->isDoubleTy() ? shaderMode.fp64DenormMode
+                                                                    : FpDenormMode::DontCare;
   if (denormMode == FpDenormMode::FlushOut || denormMode == FpDenormMode::FlushInOut) {
     // Has to flush denormals, insert canonicalize to make a MUL (* 1.0) forcibly
     value = CreateUnaryIntrinsic(Intrinsic::canonicalize, value);
   }
   return value;
 }
diff --git a/lgc/builder/Builder.cpp b/lgc/builder/Builder.cpp
index 797772e82..1d862633c 100644
--- a/lgc/builder/Builder.cpp
+++ b/lgc/builder/Builder.cpp
@@ -449,11 +449,12 @@ CallInst *Builder::CreateIntrinsic(Intrinsic::ID id, ArrayRef<Type *> types, Arr
 // @param instName : Name to give instruction(s)
 Value *Builder::CreateImageBvhIntersectRay(Value *nodePtr, Value *extent, Value *origin, Value *direction,
                                            Value *invDirection, Value *imageDesc, const Twine &instName) {
   if (m_isBuilderRecorder) {
     return static_cast<BuilderRecorder *>(this)->CreateImageBvhIntersectRay(nodePtr, extent, origin, direction,
                                                                             invDirection, imageDesc, instName);
   }
   return static_cast<BuilderImplBase *>(this)->CreateImageBvhIntersectRay(nodePtr, extent, origin, direction,
                                                                           invDirection, imageDesc, instName);
 }
+
 #endif
diff --git a/lgc/builder/BuilderBase.cpp b/lgc/builder/BuilderBase.cpp
index c46b0f766..06c17f3f2 100644
--- a/lgc/builder/BuilderBase.cpp
+++ b/lgc/builder/BuilderBase.cpp
@@ -54,22 +54,36 @@ CallInst *BuilderCommon::CreateNamedCall(StringRef funcName, Type *retTy, ArrayR
     argTys.reserve(args.size());
     for (auto arg : args)
       argTys.push_back(arg->getType());
 
     auto funcTy = FunctionType::get(retTy, argTys, false);
     func = Function::Create(funcTy, GlobalValue::ExternalLinkage, funcName, module);
 
     func->setCallingConv(CallingConv::C);
     func->addFnAttr(Attribute::NoUnwind);
 
-    for (auto attrib : attribs)
-      func->addFnAttr(attrib);
+    for (auto attrib : attribs) {
+      switch (attrib) {
+      default:
+        func->addFnAttr(attrib);
+        break;
+      case Attribute::ReadNone:
+        func->setDoesNotAccessMemory();
+        break;
+      case Attribute::ReadOnly:
+        func->setOnlyReadsMemory();
+        break;
+      case Attribute::WriteOnly:
+        func->setOnlyWritesMemory();
+        break;
+      }
+    }
   }
 
   auto call = CreateCall(func, args, instName);
   call->setCallingConv(CallingConv::C);
   call->setAttributes(func->getAttributes());
 
   return call;
 }
 
 // =====================================================================================================================
diff --git a/lgc/builder/BuilderImpl.cpp b/lgc/builder/BuilderImpl.cpp
index bd3764524..43affdfa5 100644
--- a/lgc/builder/BuilderImpl.cpp
+++ b/lgc/builder/BuilderImpl.cpp
@@ -119,55 +119,80 @@ Value *BuilderImplBase::CreateIntegerDotProduct(Value *vector1, Value *vector2,
   const bool isSupportCompBitwidth = (supportIntegerDotFlag.compBitwidth16 && compBitWidth == 16) ||
                                      (supportIntegerDotFlag.compBitwidth8 && compBitWidth == 8) ||
                                      (supportIntegerDotFlag.compBitwidth4 && compBitWidth == 4);
   const bool isSupportSignedness =
       isMixedSigned ? supportIntegerDotFlag.diffSignedness : supportIntegerDotFlag.sameSignedness;
   const bool isDot2 = (compCount == 2 && compBitWidth == 16);
   const bool isDot4 = (compCount <= 4 && compBitWidth == 8);
   const bool isDot8 = (compCount <= 8 && compBitWidth == 4);
   const bool hasNativeIntrinsic =
       isSupportCompBitwidth && isSupportSignedness && (isDot2 || isDot4 || isDot8) && (expectedWidth <= 32);
+#if LLPC_BUILD_GFX11
+  const bool hasSudot = getPipelineState()->getTargetInfo().getGfxIpVersion().major >= 11;
+#endif
 
   auto input1 = vector1;
   auto input2 = vector2;
   Value *computedResult = nullptr;
   if (hasNativeIntrinsic) {
     int supportedN = InvalidValue;
     int intrinsic = InvalidValue;
     if (isDot2) {
       intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot2 : Intrinsic::amdgcn_udot2;
       supportedN = 2;
     } else if (isDot4) {
-      intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot4 : Intrinsic::amdgcn_udot4;
+#if LLPC_BUILD_GFX11
+      if (hasSudot) {
+        intrinsic = isSigned ? Intrinsic::amdgcn_sudot4 : Intrinsic::amdgcn_udot4;
+      } else
+#endif
+      {
+        intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot4 : Intrinsic::amdgcn_udot4;
+      }
       supportedN = 4;
     } else {
       assert(isDot8);
-      intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot8 : Intrinsic::amdgcn_udot8;
+#if LLPC_BUILD_GFX11
+      if (hasSudot) {
+        intrinsic = isSigned ? Intrinsic::amdgcn_sudot8 : Intrinsic::amdgcn_udot8;
+      } else
+#endif
+      {
+        intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot8 : Intrinsic::amdgcn_udot8;
+      }
       supportedN = 8;
     }
     assert(intrinsic != InvalidValue);
     // Do null-extension
     SmallVector<int, 8> shuffleMask;
     for (int i = 0; i < supportedN; ++i)
       shuffleMask.push_back(std::min(i, static_cast<int>(compCount)));
     input1 = CreateShuffleVector(input1, Constant::getNullValue(inputTy), shuffleMask);
     input2 = CreateShuffleVector(input2, Constant::getNullValue(inputTy), shuffleMask);
 
     // Cast to i32 for dot4 and dot8
     if (compBitWidth == 4 || compBitWidth == 8) {
       input1 = CreateBitCast(input1, getInt32Ty());
       input2 = CreateBitCast(input2, getInt32Ty());
     }
 
     Value *clamp = hasAccumulator ? getTrue() : getFalse();
     accumulator = isSigned ? CreateSExt(accumulator, getInt32Ty()) : CreateZExt(accumulator, getInt32Ty());
-    computedResult = CreateIntrinsic(intrinsic, {}, {input1, input2, accumulator, clamp}, nullptr, instName);
+#if LLPC_BUILD_GFX11
+    if (hasSudot && isSigned) {
+      computedResult = CreateIntrinsic(
+          intrinsic, {}, {getTrue(), input1, getInt1(isBothSigned), input2, accumulator, clamp}, nullptr, instName);
+    } else
+#endif
+    {
+      computedResult = CreateIntrinsic(intrinsic, {}, {input1, input2, accumulator, clamp}, nullptr, instName);
+    }
   } else {
     Value *sum = nullptr;
     const bool canUseDot2 = isSupportCompBitwidth && isSupportSignedness && !isDot4 && !isDot8;
     if (canUseDot2) {
       sum = getInt32(0);
       // Iterator over two components at a time and perform shuffle vectors and then use the intrinsic
       unsigned intrinsic = isBothSigned ? Intrinsic::amdgcn_sdot2 : Intrinsic::amdgcn_udot2;
       for (int compIdx = 0; compIdx < compCount; compIdx += 2) {
         input1 = CreateShuffleVector(vector1, Constant::getNullValue(inputTy), ArrayRef<int>{compIdx, compIdx + 1});
         input2 = CreateShuffleVector(vector2, Constant::getNullValue(inputTy), ArrayRef<int>{compIdx, compIdx + 1});
diff --git a/lgc/builder/BuilderImpl.h b/lgc/builder/BuilderImpl.h
index 1e4597d39..605d17e2a 100644
--- a/lgc/builder/BuilderImpl.h
+++ b/lgc/builder/BuilderImpl.h
@@ -41,21 +41,21 @@ namespace lgc {
 class BuilderImplBase : public Builder {
 public:
   BuilderImplBase(LgcContext *builderContext) : Builder(builderContext) {}
 
   // Create scalar from dot product of vector
   llvm::Value *CreateDotProduct(llvm::Value *const vector1, llvm::Value *const vector2,
                                 const llvm::Twine &instName = "") override final;
 
   // Create scalar from integer dot product of vector
   llvm::Value *CreateIntegerDotProduct(llvm::Value *vector1, llvm::Value *vector2, llvm::Value *accumulator,
-                                          unsigned flags, const llvm::Twine &instName = "") override final;
+                                       unsigned flags, const llvm::Twine &instName = "") override final;
 
 protected:
   // Get the ShaderModes object.
   ShaderModes *getShaderModes() override final;
 
   // Get the PipelineState object.
   PipelineState *getPipelineState() const { return m_pipelineState; }
 
   // Get whether the context we are building in supports DPP operations.
   bool supportDpp() const;
@@ -403,20 +403,21 @@ public:
   // Create a get of the LOD that would be used for an image sample with the given coordinates
   // and implicit LOD.
   llvm::Value *CreateImageGetLod(unsigned dim, unsigned flags, llvm::Value *imageDesc, llvm::Value *samplerDesc,
                                  llvm::Value *coord, const llvm::Twine &instName = "") override final;
 
 #if VKI_RAY_TRACING
   // Create a ray intersect result with specified node in BVH buffer
   llvm::Value *CreateImageBvhIntersectRay(llvm::Value *nodePtr, llvm::Value *extent, llvm::Value *origin,
                                           llvm::Value *direction, llvm::Value *invDirection, llvm::Value *imageDesc,
                                           const llvm::Twine &instName = "") override final;
+
 #endif
 
 private:
   ImageBuilder() = delete;
   ImageBuilder(const ImageBuilder &) = delete;
   ImageBuilder &operator=(const ImageBuilder &) = delete;
 
   // Implement pre-GFX9 integer gather workaround to patch descriptor or coordinate before the gather
   llvm::Value *preprocessIntegerImageGather(unsigned dim, llvm::Value *&imageDesc, llvm::Value *&coord);
 
@@ -468,20 +469,28 @@ private:
     IMG_DATA_FORMAT_GB_GR__CORE = 32,
     IMG_DATA_FORMAT_BG_RG__CORE = 33,
   };
 
   enum ImgFmtGfx10 {
     IMG_FMT_8_8_8_8_UNORM__GFX10CORE = 56,
     IMG_FMT_GB_GR_UNORM__GFX10CORE = 147,
     IMG_FMT_BG_RG_UNORM__GFX10CORE = 151,
   };
 
+#if LLPC_BUILD_GFX11
+  enum ImgFmtGfx11 {
+    IMG_FMT_8_8_8_8_UNORM__GFX104PLUS = 42,
+    IMG_FMT_GB_GR_UNORM__GFX104PLUS = 82,
+    IMG_FMT_BG_RG_UNORM__GFX104PLUS = 86,
+  };
+#endif
+
   static const unsigned AtomicOpCompareSwap = 1;
 };
 
 // =====================================================================================================================
 // Builder implementation subclass for input/output operations
 class InOutBuilder : virtual public BuilderImplBase {
 public:
   InOutBuilder(LgcContext *builderContext) : BuilderImplBase(builderContext) {}
 
   // Create a read of (part of) a user input value.
diff --git a/lgc/builder/BuilderRecorder.cpp b/lgc/builder/BuilderRecorder.cpp
index e9e8c5bf1..07b2a130e 100644
--- a/lgc/builder/BuilderRecorder.cpp
+++ b/lgc/builder/BuilderRecorder.cpp
@@ -240,23 +240,27 @@ StringRef BuilderRecorder::getCallName(Opcode opcode) {
     return "image.atomic.compare.swap";
   case Opcode::ImageQueryLevels:
     return "image.query.levels";
   case Opcode::ImageQuerySamples:
     return "image.query.samples";
   case Opcode::ImageQuerySize:
     return "image.query.size";
   case Opcode::ImageGetLod:
     return "image.get.lod";
 #if VKI_RAY_TRACING
-  case Opcode::ImageBvhIntersectRayAMD:
+  case Opcode::ImageBvhIntersectRay:
     return "image.bvh.intersect.ray";
+  case Opcode::Reserved2:
+    return "reserved2";
 #else
+  case Opcode::Reserved2:
+    return "reserved2";
   case Opcode::Reserved1:
     return "reserved1";
 #endif
   case GetWaveSize:
     return "get.wave.size";
   case GetSubgroupSize:
     return "get.subgroup.size";
   case SubgroupElect:
     return "subgroup.elect";
   case SubgroupAll:
@@ -1650,21 +1654,21 @@ Instruction *BuilderRecorder::CreateWriteBuiltInOutput(Value *valueToWrite, Buil
 //
 // @param nodePtr : BVH node pointer
 // @param extent : The valid range on which intersections can occur
 // @param origin : Intersect ray origin
 // @param direction : Intersect ray direction
 // @param invDirection : The inverse of direction
 // @param imageDesc : Image descriptor
 // @param instName : Name to give instruction(s)
 Value *BuilderRecorder::CreateImageBvhIntersectRay(Value *nodePtr, Value *extent, Value *origin, Value *direction,
                                                    Value *invDirection, Value *imageDesc, const Twine &instName) {
-  return record(Opcode::ImageBvhIntersectRayAMD, FixedVectorType::get(getInt32Ty(), 4),
+  return record(Opcode::ImageBvhIntersectRay, FixedVectorType::get(getInt32Ty(), 4),
                 {nodePtr, extent, origin, direction, invDirection, imageDesc}, instName);
 }
 
 #endif
 // =====================================================================================================================
 // Create a read from (part of) a task payload.
 // The result type is as specified by resultTy, a scalar or vector type with no more than four elements.
 //
 // @param resultTy : Type of value to read
 // @param byteOffset : Byte offset within the payload structure
@@ -2144,44 +2148,44 @@ Instruction *BuilderRecorder::record(BuilderRecorder::Opcode opcode, Type *resul
     case Sinh:
     case Tan:
     case Tanh:
     case Opcode::SubgroupBallotBitCount:
     case Opcode::SubgroupBallotBitExtract:
     case Opcode::SubgroupBallotExclusiveBitCount:
     case Opcode::SubgroupBallotFindLsb:
     case Opcode::SubgroupBallotFindMsb:
     case Opcode::SubgroupBallotInclusiveBitCount:
       // Functions that don't access memory.
-      func->addFnAttr(Attribute::ReadNone);
+      func->setDoesNotAccessMemory();
       break;
     case Opcode::ImageGather:
     case Opcode::ImageLoad:
     case Opcode::ImageLoadWithFmask:
     case Opcode::ImageSample:
     case Opcode::ImageSampleConvert:
     case Opcode::LoadBufferDesc:
     case Opcode::LoadPushConstantsPtr:
     case Opcode::ReadBaryCoord:
     case Opcode::ReadBuiltInInput:
     case Opcode::ReadBuiltInOutput:
     case Opcode::ReadGenericInput:
     case Opcode::ReadGenericOutput:
     case Opcode::ReadPerVertexInput:
     case Opcode::ReadTaskPayload:
       // Functions that only read memory.
-      func->addFnAttr(Attribute::ReadOnly);
+      func->setOnlyReadsMemory();
       // Must be marked as returning for DCE.
       func->addFnAttr(Attribute::WillReturn);
       break;
     case Opcode::ImageStore:
       // Functions that only write memory.
-      func->addFnAttr(Attribute::WriteOnly);
+      func->setOnlyWritesMemory();
       break;
     case Opcode::ImageAtomic:
     case Opcode::ImageAtomicCompareSwap:
     case Opcode::WriteXfbOutput:
     case Opcode::WriteTaskPayload:
     case Opcode::TaskPayloadAtomic:
     case Opcode::TaskPayloadAtomicCompareSwap:
       // Functions that read and write memory.
       break;
     case Opcode::SubgroupAll:
@@ -2221,21 +2225,21 @@ Instruction *BuilderRecorder::record(BuilderRecorder::Opcode opcode, Type *resul
     case Opcode::ImageQuerySamples:
     case Opcode::ImageQuerySize:
     case Opcode::IsHelperInvocation:
     case Opcode::EmitMeshTasks:
     case Opcode::SetMeshOutputs:
     case Opcode::Kill:
     case Opcode::ReadClock:
     case Opcode::WriteBuiltInOutput:
     case Opcode::WriteGenericOutput:
 #if VKI_RAY_TRACING
-    case Opcode::ImageBvhIntersectRayAMD:
+    case Opcode::ImageBvhIntersectRay:
 #endif
       // TODO: These functions have not been classified yet.
       break;
     default:
       llvm_unreachable("Should never be called!");
       break;
     }
   }
 
   // Create the call.
diff --git a/lgc/builder/BuilderReplayer.cpp b/lgc/builder/BuilderReplayer.cpp
index 39c0a0c2d..67cedd8b3 100644
--- a/lgc/builder/BuilderReplayer.cpp
+++ b/lgc/builder/BuilderReplayer.cpp
@@ -710,21 +710,21 @@ Value *BuilderReplayer::processCall(unsigned opcode, CallInst *call) {
     auto builtIn = static_cast<BuiltInKind>(cast<ConstantInt>(args[1])->getZExtValue());
     InOutInfo outputInfo(cast<ConstantInt>(args[2])->getZExtValue());
     return m_builder->CreateWriteBuiltInOutput(args[0],                                         // Val to write
                                                builtIn,                                         // BuiltIn
                                                outputInfo,                                      // Output info
                                                isa<UndefValue>(args[3]) ? nullptr : &*args[3],  // Vertex index
                                                isa<UndefValue>(args[4]) ? nullptr : &*args[4]); // Index
   }
 
 #if VKI_RAY_TRACING
-  case BuilderRecorder::Opcode::ImageBvhIntersectRayAMD: {
+  case BuilderRecorder::Opcode::ImageBvhIntersectRay: {
     Value *bvhNodePtr = args[0];
     Value *extent = args[1];
     Value *origin = args[2];
     Value *direction = args[3];
     Value *invDirection = args[4];
     Value *imageDesc = args[5];
     return m_builder->CreateImageBvhIntersectRay(bvhNodePtr, extent, origin, direction, invDirection, imageDesc);
   }
 
 #endif
diff --git a/lgc/builder/DescBuilder.cpp b/lgc/builder/DescBuilder.cpp
index b28c29a5d..70854da68 100644
--- a/lgc/builder/DescBuilder.cpp
+++ b/lgc/builder/DescBuilder.cpp
@@ -531,27 +531,21 @@ Value *DescBuilder::CreateGetBufferDescLength(Value *const bufferDesc, Value *of
 //
 // @param ty : Element type of the pointers.
 // @param lhs : Left hand side of the subtraction.
 // @param rhs : Reft hand side of the subtraction.
 // @param instName : Name to give instruction(s)
 Value *DescBuilder::CreatePtrDiff(llvm::Type *ty, llvm::Value *lhs, llvm::Value *rhs, const llvm::Twine &instName) {
   Type *const lhsType = lhs->getType();
   Type *const rhsType = rhs->getType();
   if (!lhsType->isPointerTy() || lhsType->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER ||
       !rhsType->isPointerTy() || rhsType->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 412285
-    // Old version of the code
-    return IRBuilderBase::CreatePtrDiff(lhs, rhs, instName);
-#else
-    // New version of the code (also handles unknown version, which we treat as latest)
     return IRBuilderBase::CreatePtrDiff(ty, lhs, rhs, instName);
-#endif
 
   // Add a dummy value of the pointer element type so we can later determine its size
   Value *dummyValue = Constant::getNullValue(ty);
   std::string callName = lgcName::LateBufferPtrDiff;
   addTypeMangling(getVoidTy(), {dummyValue, lhs, rhs}, callName);
   return CreateNamedCall(callName, getInt64Ty(), {dummyValue, lhs, rhs}, Attribute::ReadNone);
 }
 
 // =====================================================================================================================
 // Calculate a buffer descriptor for an inline buffer
@@ -600,17 +594,23 @@ Value *DescBuilder::buildBufferCompactDesc(Value *desc) {
   sqBufRsrcWord3.bits.dstSelW = BUF_DST_SEL_W;
   if (gfxIp.major < 10) {
     sqBufRsrcWord3.gfx6.numFormat = BUF_NUM_FORMAT_UINT;
     sqBufRsrcWord3.gfx6.dataFormat = BUF_DATA_FORMAT_32;
     assert(sqBufRsrcWord3.u32All == 0x24FAC);
   } else if (gfxIp.major == 10) {
     sqBufRsrcWord3.gfx10.format = BUF_FORMAT_32_UINT;
     sqBufRsrcWord3.gfx10.resourceLevel = 1;
     sqBufRsrcWord3.gfx10.oobSelect = 2;
     assert(sqBufRsrcWord3.u32All == 0x21014FAC);
+#if LLPC_BUILD_GFX11
+  } else if (gfxIp.major == 11) {
+    sqBufRsrcWord3.gfx11.format = BUF_FORMAT_32_UINT;
+    sqBufRsrcWord3.gfx11.oobSelect = 2;
+    assert(sqBufRsrcWord3.u32All == 0x20014FAC);
+#endif
   } else {
     llvm_unreachable("Not implemented!");
   }
   bufDesc = CreateInsertElement(bufDesc, getInt32(sqBufRsrcWord3.u32All), 3);
 
   return bufDesc;
 }
diff --git a/lgc/builder/ImageBuilder.cpp b/lgc/builder/ImageBuilder.cpp
index f35511d72..12b7da3ca 100644
--- a/lgc/builder/ImageBuilder.cpp
+++ b/lgc/builder/ImageBuilder.cpp
@@ -1563,20 +1563,21 @@ Value *ImageBuilder::CreateImageBvhIntersectRay(Value *nodePtr, Value *extent, V
   args.push_back(invDirection);
   args.push_back(imageDesc);
 
   // NOTE: llvm.amdgcn.image.bvh.intersect.ray* intrinsics are define in amd-vulkan-npi
   // Use hardcode to avoid compile-error when using non-npi llvm
   std::string callName = "llvm.amdgcn.image.bvh.intersect.ray";
   addTypeMangling(nullptr, {nodePtr, direction}, callName);
 
   return CreateNamedCall(callName, FixedVectorType::get(getInt32Ty(), 4), args, {});
 }
+
 #endif
 
 // =====================================================================================================================
 // Change 1D or 1DArray dimension to 2D or 2DArray if needed as a workaround on GFX9+
 //
 // @param dim : Image dimension
 unsigned ImageBuilder::change1DTo2DIfNeeded(unsigned dim) {
   if (getPipelineState()->getTargetInfo().getGpuWorkarounds().gfx9.treat1dImagesAs2d) {
     switch (dim) {
     case Dim1D:
@@ -1973,26 +1974,32 @@ Value *ImageBuilder::handleFragCoordViewIndex(Value *coord, unsigned flags, unsi
 
   if (useViewIndex) {
     // Get ViewIndex and use it as the z coordinate.
     // For now, this just generates a call to lgc.input.import.builtin. A future commit will
     // change it to use a Builder call to read the built-in.
     auto &builtInUsage = getPipelineState()->getShaderResourceUsage(m_shaderStage)->builtInUsage;
     switch (m_shaderStage) {
     case ShaderStageVertex:
       builtInUsage.vs.viewIndex = true;
       break;
+    case ShaderStageTessControl:
+      builtInUsage.tcs.viewIndex = true;
+      break;
     case ShaderStageTessEval:
       builtInUsage.tes.viewIndex = true;
       break;
     case ShaderStageGeometry:
       builtInUsage.gs.viewIndex = true;
       break;
+    case ShaderStageMesh:
+      builtInUsage.mesh.viewIndex = true;
+      break;
     case ShaderStageFragment:
       builtInUsage.fs.viewIndex = true;
       break;
     default:
       llvm_unreachable("Should never be called!");
       break;
     }
 
     const static unsigned BuiltInViewIndex = 4440;
     std::string callName = lgcName::InputImportBuiltIn;
diff --git a/lgc/builder/InOutBuilder.cpp b/lgc/builder/InOutBuilder.cpp
index 8e8f95c15..4f876798f 100644
--- a/lgc/builder/InOutBuilder.cpp
+++ b/lgc/builder/InOutBuilder.cpp
@@ -732,69 +732,74 @@ Instruction *InOutBuilder::CreateWriteXfbOutput(Value *valueToWrite, bool isBuil
   auto stagesAfterThisOneMask = -shaderStageToMask(static_cast<ShaderStage>(m_shaderStage + 1));
   if ((getPipelineState()->getShaderStageMask() & ~shaderStageToMask(ShaderStageFragment) &
        ~shaderStageToMask(ShaderStageCopyShader) & stagesAfterThisOneMask) != 0)
     return nullptr;
 
   // Mark the usage of the XFB buffer.
   auto resUsage = getPipelineState()->getShaderResourceUsage(m_shaderStage);
   unsigned streamId = outputInfo.hasStreamId() ? outputInfo.getStreamId() : 0;
   assert(xfbBuffer < MaxTransformFeedbackBuffers);
   assert(streamId < MaxGsStreams);
-  resUsage->inOutUsage.xfbStrides[xfbBuffer] = xfbStride;
-  resUsage->inOutUsage.enableXfb = true;
-  resUsage->inOutUsage.streamXfbBuffers[streamId] |= 1 << xfbBuffer;
-
-  if (m_shaderStage == ShaderStageGeometry) {
-
-    // Mark the XFB output for copy shader generation.
-    XfbOutInfo xfbOutInfo = {};
-    xfbOutInfo.streamId = streamId;
-    xfbOutInfo.xfbBuffer = xfbBuffer;
-    xfbOutInfo.xfbOffset = cast<ConstantInt>(xfbOffset)->getZExtValue();
-    xfbOutInfo.is16bit = valueToWrite->getType()->getScalarSizeInBits() == 16;
-
-    // For packed generic GS output, the XFB output should be scalarized to align with the scalarized GS output
-    if (getPipelineState()->canPackOutput(m_shaderStage) && !isBuiltIn) {
-      Type *elementTy = valueToWrite->getType();
-      unsigned scalarizeBy = 1;
-      if (auto vectorTy = dyn_cast<FixedVectorType>(elementTy)) {
-        scalarizeBy = vectorTy->getNumElements();
-        elementTy = vectorTy->getElementType();
-      }
-      if (elementTy->getPrimitiveSizeInBits() == 64)
-        scalarizeBy *= 2;
-      unsigned xfbOffset = xfbOutInfo.xfbOffset;
-      for (unsigned i = 0; i < scalarizeBy; ++i) {
-        InOutLocationInfo outLocInfo;
-        outLocInfo.setLocation(location);
-        outLocInfo.setStreamId(streamId);
-        outLocInfo.setComponent(i);
-        outLocInfo.setBuiltIn(isBuiltIn);
-        if (i >= 4) {
-          outLocInfo.setLocation(location + 1);
-          outLocInfo.setComponent(i - 4);
-          xfbOutInfo.xfbOffset = xfbOffset + 16;
-        }
-        resUsage->inOutUsage.gs.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
-      }
-    } else {
+
+#if LLPC_BUILD_GFX11
+  if (m_shaderStage == ShaderStageGeometry && getPipelineState()->enableSwXfb()) {
+    // NOTE: For SW-emulated stream-out, we disable GS output packing. This is because
+    // the packing operation might cause a vector components belong to different vectors after the
+    // packing. In handling of SW-emulated stream-out, we expect components of the same vector
+    // should stay in it corresponding to a location all the time.
+    getPipelineState()->setPackOutput(ShaderStageGeometry, false);
+    getPipelineState()->setPackInput(ShaderStageFragment, false);
+  }
+#endif
+
+  // Collect the XFB output.
+  XfbOutInfo xfbOutInfo = {};
+  xfbOutInfo.streamId = streamId;
+  xfbOutInfo.xfbBuffer = xfbBuffer;
+  xfbOutInfo.xfbOffset = cast<ConstantInt>(xfbOffset)->getZExtValue();
+  xfbOutInfo.is16bit = valueToWrite->getType()->getScalarSizeInBits() == 16;
+
+  // For packed generic GS output, the XFB output should be scalarized to align with the scalarized GS output
+  if (getPipelineState()->canPackOutput(m_shaderStage) && !isBuiltIn) {
+    Type *elementTy = valueToWrite->getType();
+    unsigned scalarizeBy = 1;
+    if (auto vectorTy = dyn_cast<FixedVectorType>(elementTy)) {
+      scalarizeBy = vectorTy->getNumElements();
+      elementTy = vectorTy->getElementType();
+    }
+    if (elementTy->getPrimitiveSizeInBits() == 64)
+      scalarizeBy *= 2;
+    unsigned xfbOffset = xfbOutInfo.xfbOffset;
+    for (unsigned i = 0; i < scalarizeBy; ++i) {
       InOutLocationInfo outLocInfo;
       outLocInfo.setLocation(location);
-      outLocInfo.setBuiltIn(isBuiltIn);
       outLocInfo.setStreamId(streamId);
-      resUsage->inOutUsage.gs.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
-
-      if (valueToWrite->getType()->getPrimitiveSizeInBits() > 128) {
+      outLocInfo.setComponent(i);
+      outLocInfo.setBuiltIn(isBuiltIn);
+      if (i >= 4) {
         outLocInfo.setLocation(location + 1);
-        xfbOutInfo.xfbOffset += 32;
-        resUsage->inOutUsage.gs.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
+        outLocInfo.setComponent(i - 4);
+        xfbOutInfo.xfbOffset = xfbOffset + 16;
       }
+      resUsage->inOutUsage.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
+    }
+  } else {
+    InOutLocationInfo outLocInfo;
+    outLocInfo.setLocation(location);
+    outLocInfo.setBuiltIn(isBuiltIn);
+    outLocInfo.setStreamId(streamId);
+    resUsage->inOutUsage.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
+
+    if (valueToWrite->getType()->getPrimitiveSizeInBits() > 128) {
+      outLocInfo.setLocation(location + 1);
+      xfbOutInfo.xfbOffset += 32;
+      resUsage->inOutUsage.locInfoXfbOutInfoMap[outLocInfo] = xfbOutInfo;
     }
   }
 
   // XFB: @lgc.output.export.xfb.%Type%(i32 xfbBuffer, i32 xfbOffset, i32 streamId, %Type% outputValue)
   SmallVector<Value *, 4> args;
   std::string instName = lgcName::OutputExportXfb;
   args.push_back(getInt32(xfbBuffer));
   args.push_back(xfbOffset);
   args.push_back(getInt32(streamId));
   args.push_back(valueToWrite);
@@ -1184,20 +1189,43 @@ Value *InOutBuilder::readCsBuiltIn(BuiltInKind builtIn, const Twine &instName) {
 
     return workgroupId;
   }
 
   case BuiltInLocalInvocationId:
   case BuiltInHwLocalInvocationId: {
     // LocalInvocationId is a v3i32 shader input (three VGPRs set up in hardware).
     Value *localInvocationId =
         ShaderInputs::getInput(ShaderInput::LocalInvocationId, BuilderBase::get(*this), *getLgcContext());
 
+#if LLPC_BUILD_GFX11
+    // On GFX11, it is a single VGPR and we need to extract the three components.
+    if (getPipelineState()->getTargetInfo().getGfxIpVersion().major >= 11) {
+      static const unsigned mask = 0x3ff;
+      Value *unpackedLocalInvocationId = UndefValue::get(FixedVectorType::get(getInt32Ty(), 3));
+
+      // X = PackedId[9:0]
+      unpackedLocalInvocationId =
+          CreateInsertElement(unpackedLocalInvocationId, CreateAnd(localInvocationId, getInt32(mask)), uint64_t(0));
+
+      // Y = PackedId[19:10]
+      localInvocationId = CreateLShr(localInvocationId, getInt32(10));
+      unpackedLocalInvocationId =
+          CreateInsertElement(unpackedLocalInvocationId, CreateAnd(localInvocationId, getInt32(mask)), 1);
+
+      // Z = PackedId[29:20], PackedId[31:30] set to 0 by hardware
+      localInvocationId = CreateLShr(localInvocationId, getInt32(10));
+      unpackedLocalInvocationId = CreateInsertElement(unpackedLocalInvocationId, localInvocationId, 2);
+
+      localInvocationId = unpackedLocalInvocationId;
+    }
+#endif
+
     // Unused dimensions need zero-initializing.
     if (shaderMode.workgroupSizeZ <= 1) {
       if (shaderMode.workgroupSizeY <= 1)
         localInvocationId = CreateInsertElement(localInvocationId, getInt32(0), 1);
       localInvocationId = CreateInsertElement(localInvocationId, getInt32(0), 2);
     }
 
     if (builtIn == BuiltInLocalInvocationId) {
       // If the option is enabled, we might want to reconfigure the workgroup layout later, which
       // means the value of LocalInvocationId needs modifying. We can't do that now, as we need to
@@ -1303,20 +1331,24 @@ Value *InOutBuilder::readVsBuiltIn(BuiltInKind builtIn, const Twine &instName) {
   case BuiltInBaseVertex:
     return ShaderInputs::getSpecialUserData(UserDataMapping::BaseVertex, builder);
   case BuiltInBaseInstance:
     return ShaderInputs::getSpecialUserData(UserDataMapping::BaseInstance, builder);
   case BuiltInDrawIndex:
     return ShaderInputs::getSpecialUserData(UserDataMapping::DrawIndex, builder);
   case BuiltInVertexIndex:
     return ShaderInputs::getVertexIndex(builder, *getLgcContext());
   case BuiltInInstanceIndex:
     return ShaderInputs::getInstanceIndex(builder, *getLgcContext());
+  case BuiltInViewIndex:
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      return ShaderInputs::getSpecialUserData(UserDataMapping::ViewId, builder);
+    return builder.getInt32(0);
   default:
     // Not handled; caller will handle with lgc.input.import.builtin, which is then lowered in PatchInOutImportExport.
     return nullptr;
   }
 }
 
 // =====================================================================================================================
 // Create a write of (part of) a built-in output value.
 // The type of the value to write must be the fixed type of the specified built-in (see BuiltInDefs.h),
 // or the element type if index is not nullptr.
diff --git a/lgc/builder/MiscBuilder.cpp b/lgc/builder/MiscBuilder.cpp
index 9cf964489..e471a4749 100644
--- a/lgc/builder/MiscBuilder.cpp
+++ b/lgc/builder/MiscBuilder.cpp
@@ -145,30 +145,29 @@ Instruction *MiscBuilder::CreateSetMeshOutputs(Value *vertexCount, Value *primit
 }
 
 // =====================================================================================================================
 // Create a "readclock".
 //
 // @param realtime : Whether to read real-time clock counter
 // @param instName : Name to give instruction(s)
 Instruction *MiscBuilder::CreateReadClock(bool realtime, const Twine &instName) {
   CallInst *readClock = nullptr;
   if (realtime) {
-    readClock = CreateIntrinsic(Intrinsic::amdgcn_s_memrealtime, {}, {}, nullptr, instName);
+#if LLPC_BUILD_GFX11
+    if (getPipelineState()->getTargetInfo().getGfxIpVersion().major >= 11)
+      readClock = CreateNamedCall("llvm.amdgcn.s.sendmsg.rtn", getInt64Ty(), getInt32(GetRealTime), {}, instName);
+    else
+#endif
+      readClock = CreateIntrinsic(Intrinsic::amdgcn_s_memrealtime, {}, {}, nullptr, instName);
   } else
     readClock = CreateIntrinsic(Intrinsic::readcyclecounter, {}, {}, nullptr, instName);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-  // Old version of the code
-  readClock->addAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
-  readClock->addFnAttr(Attribute::ReadOnly);
-#endif
+  readClock->setOnlyReadsMemory();
 
   // NOTE: The inline ASM is to prevent optimization of backend compiler.
   InlineAsm *asmFunc = InlineAsm::get(FunctionType::get(getInt64Ty(), {getInt64Ty()}, false), "; %1", "=r,0", true);
 
   readClock = CreateCall(asmFunc, {readClock});
 
   return readClock;
 }
 
 // =====================================================================================================================
diff --git a/lgc/builder/SubgroupBuilder.cpp b/lgc/builder/SubgroupBuilder.cpp
index 0aaf6156e..11ea5af6f 100644
--- a/lgc/builder/SubgroupBuilder.cpp
+++ b/lgc/builder/SubgroupBuilder.cpp
@@ -261,21 +261,22 @@ Value *SubgroupBuilder::CreateSubgroupBallotInclusiveBitCount(Value *const value
   return CreateSelect(inverseBallot, inclusiveBitCount, exclusiveBitCount);
 }
 
 // =====================================================================================================================
 // Create a subgroup ballotexclusivebitcount call.
 //
 // @param value : The ballot value to exclusively bit count. Must be an <4 x i32> type.
 // @param instName : Name to give final instruction.
 Value *SubgroupBuilder::CreateSubgroupBallotExclusiveBitCount(Value *const value, const Twine &instName) {
   if (getShaderSubgroupSize() <= 32)
-    return CreateSubgroupMbcnt(CreateExtractElement(value, getInt32(0)), "");
+    // Directly invoke the required mbcnt_lo intrinsic since CreateSubgroupMbcnt expects a 64-bit mask
+    return CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {CreateExtractElement(value, getInt32(0)), getInt32(0)});
   Value *result = CreateShuffleVector(value, UndefValue::get(value->getType()), ArrayRef<int>{0, 1});
   result = CreateBitCast(result, getInt64Ty());
   return CreateSubgroupMbcnt(result, "");
 }
 
 // =====================================================================================================================
 // Create a subgroup ballotfindlsb call.
 //
 // @param value : The ballot value to find the least significant bit of. Must be an <4 x i32> type.
 // @param instName : Name to give final instruction.
@@ -508,20 +509,26 @@ Value *SubgroupBuilder::CreateSubgroupClusteredReduction(GroupArithOp groupArith
         result);
 
     if (supportPermLaneDpp()) {
       // Use a permute lane to cross rows (row 1 <-> row 0, row 3 <-> row 2).
       result = CreateSelect(
           CreateICmpUGE(clusterSize, getInt32(32)),
           createGroupArithmeticOperation(groupArithOp, result,
                                          createPermLaneX16(result, result, UINT32_MAX, UINT32_MAX, true, false)),
           result);
 
+#if LLPC_BUILD_GFX11
+      if (supportPermLane64Dpp()) {
+        result = CreateSelect(CreateICmpEQ(clusterSize, getInt32(64)),
+                              createGroupArithmeticOperation(groupArithOp, result, createPermLane64(result)), result);
+      } else
+#endif
       {
         Value *const broadcast31 = CreateSubgroupBroadcast(result, getInt32(31), instName);
         Value *const broadcast63 = CreateSubgroupBroadcast(result, getInt32(63), instName);
 
         // Combine broadcast from the 31st and 63rd for the final result.
         result = CreateSelect(CreateICmpEQ(clusterSize, getInt32(64)),
                               createGroupArithmeticOperation(groupArithOp, broadcast31, broadcast63), result);
       }
     } else {
       // Use a row broadcast to move the 15th element in each cluster of 16 to the next cluster. The row mask is
@@ -1310,20 +1317,34 @@ Value *SubgroupBuilder::createPermLaneX16(Value *const origValue, Value *const u
 
   return CreateMapToInt32(
       mapFunc,
       {
           origValue,
           updateValue,
       },
       {getInt32(selectBitsLow), getInt32(selectBitsHigh), getInt1(fetchInactive), getInt1(boundCtrl)});
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Create a call to permute lane 64.
+//
+// @param updateValue : The value to update with.
+Value *SubgroupBuilder::createPermLane64(Value *const updateValue) {
+  auto mapFunc = [](BuilderBase &builder, ArrayRef<Value *> mappedArgs, ArrayRef<Value *> passthroughArgs) -> Value * {
+    return builder.CreateIntrinsic(Intrinsic::amdgcn_permlane64, {}, {mappedArgs[0]});
+  };
+
+  return CreateMapToInt32(mapFunc, updateValue, {});
+}
+#endif
+
 // =====================================================================================================================
 // Create a call to ds swizzle.
 //
 // @param value : The value to swizzle.
 // @param dsPattern : The pattern to swizzle with.
 Value *SubgroupBuilder::createDsSwizzle(Value *const value, uint16_t dsPattern) {
   auto mapFunc = [](BuilderBase &builder, ArrayRef<Value *> mappedArgs, ArrayRef<Value *> passthroughArgs) -> Value * {
     return builder.CreateIntrinsic(Intrinsic::amdgcn_ds_swizzle, {}, {mappedArgs[0], passthroughArgs[0]});
   };
 
diff --git a/lgc/builder/YCbCrAddressHandler.cpp b/lgc/builder/YCbCrAddressHandler.cpp
index dee4a384f..7dee07a04 100644
--- a/lgc/builder/YCbCrAddressHandler.cpp
+++ b/lgc/builder/YCbCrAddressHandler.cpp
@@ -53,20 +53,23 @@ void YCbCrAddressHandler::genBaseAddress(unsigned planeCount) {
   m_planeBaseAddresses.push_back(virtualAddrPlane0);
 
   Value *pipeBankXor1 = nullptr;
   Value *pipeBankXor2 = nullptr;
   Value *pipeBankXorNone = m_builder->getInt32(0);
 
   switch (m_gfxIp->major) {
   case 6:
   case 7:
   case 8:
+#if LLPC_BUILD_GFX11
+  case 11:
+#endif
   case 9: {
     pipeBankXor1 = pipeBankXorNone;
     pipeBankXor2 = pipeBankXorNone;
     break;
   }
   case 10: {
     // Judge if current swizzle mode is SW_64KB_R_X
     Value *isSw64KbRxMode =
         m_builder->CreateICmpEQ(m_swizzleMode, m_builder->getInt32(Pal::Gfx9::Chip::SWIZZLE_MODE_ENUM::SW_64KB_R_X));
 
@@ -159,20 +162,23 @@ void YCbCrAddressHandler::genHeightAndPitch(unsigned bits, unsigned bpp, unsigne
     Value *pitchHalf = m_builder->CreateLShr(pitch, m_one);
 
     // PitchY * (xBitCount >> 3)
     m_pitchY = m_builder->CreateMul(pitch, m_builder->CreateLShr(m_builder->getInt32(xBitCount), 3));
 
     // PitchCb = PitchCb * (xBitCount >> 3)
     m_pitchCb = m_builder->CreateMul(pitchHalf, m_builder->CreateLShr(m_builder->getInt32(xBitCount), 3));
 
     break;
   }
+#if LLPC_BUILD_GFX11
+  case 11:
+#endif
   case 10: {
     const unsigned elementBytes = bpp >> 3;
     const unsigned pitchAlign = (256 / elementBytes);
 
     // Height = SqRsrcRegs::Height
     Value *height = m_regHandler->getReg(SqRsrcRegs::Height);
     m_heightY = height;
 
     // Width = SqRsrcRegs::Width
     Value *width = m_regHandler->getReg(SqRsrcRegs::Width);
diff --git a/lgc/builder/YCbCrConverter.cpp b/lgc/builder/YCbCrConverter.cpp
index a8b9ede3d..cc343289b 100644
--- a/lgc/builder/YCbCrConverter.cpp
+++ b/lgc/builder/YCbCrConverter.cpp
@@ -387,20 +387,32 @@ void YCbCrConverter::genImgDescChroma() {
     case 10: {
       isGbGrFmt = m_builder->CreateICmpEQ(
           imgDataFmt, m_builder->getInt32(ImageBuilder::ImgFmtGfx10::IMG_FMT_BG_RG_UNORM__GFX10CORE));
       isBgRgFmt = m_builder->CreateICmpEQ(
           imgDataFmt, m_builder->getInt32(ImageBuilder::ImgFmtGfx10::IMG_FMT_GB_GR_UNORM__GFX10CORE));
 
       proxySqRsrcRegHelper.setReg(SqRsrcRegs::Format,
                                   m_builder->getInt32(ImageBuilder::ImgFmtGfx10::IMG_FMT_8_8_8_8_UNORM__GFX10CORE));
       break;
     }
+#if LLPC_BUILD_GFX11
+    case 11: {
+      isGbGrFmt = m_builder->CreateICmpEQ(
+          imgDataFmt, m_builder->getInt32(ImageBuilder::ImgFmtGfx11::IMG_FMT_BG_RG_UNORM__GFX104PLUS));
+      isBgRgFmt = m_builder->CreateICmpEQ(
+          imgDataFmt, m_builder->getInt32(ImageBuilder::ImgFmtGfx11::IMG_FMT_GB_GR_UNORM__GFX104PLUS));
+
+      proxySqRsrcRegHelper.setReg(SqRsrcRegs::Format,
+                                  m_builder->getInt32(ImageBuilder::ImgFmtGfx11::IMG_FMT_8_8_8_8_UNORM__GFX104PLUS));
+      break;
+    }
+#endif
     default:
       llvm_unreachable("GFX IP not supported!");
       break;
     }
 
     dstSelXYZW = m_builder->CreateSelect(isGbGrFmt, m_builder->getInt32(0x977), dstSelXYZW);
     dstSelXYZW = m_builder->CreateSelect(isBgRgFmt, m_builder->getInt32(0xF2E), dstSelXYZW);
 
     YCbCrAddressHandler addrHelper(m_builder, &proxySqRsrcRegHelper, m_gfxIp);
     addrHelper.genHeightAndPitch(m_metaData.word0.bitDepth.channelBitsR, 32, m_metaData.word2.bitCounts.xBitCount,
diff --git a/lgc/disassembler/Disassembler.cpp b/lgc/disassembler/Disassembler.cpp
index 942edfc62..b9dc4673b 100644
--- a/lgc/disassembler/Disassembler.cpp
+++ b/lgc/disassembler/Disassembler.cpp
@@ -36,46 +36,41 @@
 #include "llvm/MC/MCContext.h"
 #include "llvm/MC/MCDisassembler/MCDisassembler.h"
 #include "llvm/MC/MCInstPrinter.h"
 #include "llvm/MC/MCInstrInfo.h"
 #include "llvm/MC/MCObjectFileInfo.h"
 #include "llvm/MC/MCRegisterInfo.h"
 #include "llvm/MC/MCSectionELF.h"
 #include "llvm/MC/MCStreamer.h"
 #include "llvm/MC/MCSubtargetInfo.h"
 #include "llvm/MC/MCTargetOptions.h"
+#include "llvm/MC/TargetRegistry.h"
 #include "llvm/Object/ELFObjectFile.h"
 #include "llvm/Support/AMDGPUMetadata.h"
 #include "llvm/Support/StringSaver.h"
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 401324
-// Old version
-#include "llvm/Support/TargetRegistry.h"
-#else
-// New version (and unknown version)
-#include "llvm/MC/TargetRegistry.h"
-#endif
 #include "llvm/Support/TargetSelect.h"
+#include <optional>
 
 using namespace llvm;
 using namespace object;
 
 namespace lgc {
 // Get name of PAL metadata register, or "" if not known
 const char *getPalMetadataRegName(unsigned regNumber);
 } // namespace lgc
 
 namespace {
 
 // Represents an operand of a disassembler instruction.
 struct InstOp {
-  Optional<int64_t> imm;
-  Optional<unsigned> sReg;
+  std::optional<int64_t> imm;
+  std::optional<unsigned> sReg;
 };
 
 // Represents a disassembled instruction or directive.
 struct InstOrDirective {
   MCDisassembler::DecodeStatus status = MCDisassembler::Fail;
   uint64_t offset;
   ArrayRef<uint8_t> bytes;
   MCInst mcInst;
 
   StringRef mnemonic;
@@ -179,52 +174,51 @@ void ObjDisassembler::run() {
   SubtargetFeatures features = m_objFile->getFeatures();
 
   // Get the target specific parser.
   std::string error;
   m_tripleName = triple.getTriple();
   m_target = TargetRegistry::lookupTarget(m_tripleName, error);
   if (!m_target)
     report_fatal_error(m_objFile->getFileName() + ": '" + m_tripleName + "': " + error);
 
   // Get the CPU name.
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444152
   Optional<StringRef> mcpu = m_objFile->tryGetCPUName();
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  std::optional<StringRef> mcpu = m_objFile->tryGetCPUName();
+#endif
   if (!mcpu)
     report_fatal_error(m_objFile->getFileName() + ": Cannot get CPU name");
 
   // Output the required llvm-mc command as a comment.
   m_ostream << "// llvm-mc -triple=" << m_tripleName << " -mcpu=" << mcpu << "\n";
 
   // Set up other objects required for disassembly.
   std::unique_ptr<MCRegisterInfo> regInfo(m_target->createMCRegInfo(m_tripleName));
   if (!regInfo)
     report_fatal_error(m_data.getBufferIdentifier() + ": No register info for target");
   std::unique_ptr<MCAsmInfo> asmInfo(m_target->createMCAsmInfo(*regInfo, m_tripleName, MCTargetOptions()));
   if (!asmInfo)
     report_fatal_error(m_data.getBufferIdentifier() + ": No assembly info for target");
   m_subtargetInfo.reset(m_target->createMCSubtargetInfo(m_tripleName, *mcpu, features.getString()));
   if (!m_subtargetInfo)
     report_fatal_error(m_data.getBufferIdentifier() + ": No subtarget info for target");
   std::unique_ptr<MCInstrInfo> instrInfo(m_target->createMCInstrInfo());
   if (!instrInfo)
     report_fatal_error(m_data.getBufferIdentifier() + ": No instruction info for target");
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 389223
-  MCObjectFileInfo objFileInfo;
-  MCContext context(triple, asmInfo.get(), regInfo.get(), &objFileInfo, m_subtargetInfo.get());
-  objFileInfo.initMCObjectFileInfo(context, false);
-#else
   MCContext context(triple, asmInfo.get(), regInfo.get(), m_subtargetInfo.get());
   std::unique_ptr<MCObjectFileInfo> objFileInfo(m_target->createMCObjectFileInfo(context, /*PIC=*/false));
   if (!objFileInfo)
     report_fatal_error("No MC object file info");
   context.setObjectFileInfo(objFileInfo.get());
-#endif
   m_context = &context;
 
   m_instDisassembler.reset(m_target->createMCDisassembler(*m_subtargetInfo, *m_context));
   if (!m_instDisassembler)
     report_fatal_error(m_data.getBufferIdentifier() + ": No disassembler for target");
   m_instPrinter = m_target->createMCInstPrinter(triple, asmInfo->getAssemblerDialect(), *asmInfo, *instrInfo, *regInfo);
   if (!m_instPrinter)
     report_fatal_error(m_data.getBufferIdentifier() + ": No instruction printer for target");
 
   auto fostream = std::make_unique<formatted_raw_ostream>(m_ostream);
@@ -240,37 +234,25 @@ void ObjDisassembler::run() {
 // Disassemble one section.
 //
 // @param sectionRef : The section to disassemble
 void ObjDisassembler::processSection(ELFSectionRef sectionRef) {
   // Omit certain ELF sections.
   unsigned sectType = sectionRef.getType();
   if (sectType == ELF::SHT_NULL || sectType == ELF::SHT_STRTAB || sectType == ELF::SHT_SYMTAB ||
       sectType == ELF::SHT_REL || sectType == ELF::SHT_RELA)
     return;
 
-    // Switch the streamer to the section.
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 425813
-  // Old version of code
-  m_streamer->AddBlankLine();
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
+  // Switch the streamer to the section.
   m_streamer->addBlankLine();
-#endif
   unsigned sectFlags = sectionRef.getFlags();
   MCSection *sect = m_context->getELFSection(cantFail(sectionRef.getName()), sectType, sectFlags);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 425813
-  // Old version of code
-  m_streamer->SwitchSection(sect);
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
   m_streamer->switchSection(sect);
-#endif
 
   // Create all symbols in this section. Also emit directives for symbol type and size,
   // adding a synthesized label for the end of the symbol.
   SymbolPool symbols;
   gatherSectionSymbols(sectionRef, symbols);
 
   // Collect and sort the relocs for the section.
   std::vector<object::RelocationRef> relocs;
   gatherRelocs(sectionRef, relocs);
 
diff --git a/lgc/disassembler/PalMetadataRegs.cpp b/lgc/disassembler/PalMetadataRegs.cpp
index 3bd0cf7f4..87c044be1 100644
--- a/lgc/disassembler/PalMetadataRegs.cpp
+++ b/lgc/disassembler/PalMetadataRegs.cpp
@@ -327,20 +327,24 @@ const PalMetadataReg PalMetadataRegs[] = {
     {0xA287, "VGT_HOS_MIN_TESS_LEVEL"},
     {0xA290, "VGT_GS_MODE"},
     {0xA291, "VGT_GS_ONCHIP_CNTL"},
     {0xA293, "PA_SC_MODE_CNTL_1"},
     {0xA295, "VGT_GS_PER_ES"},
     {0xA296, "VGT_ES_PER_GS"},
     {0xA297, "VGT_GS_PER_VS"},
     {0xA298, "VGT_GSVS_RING_OFFSET_1"},
     {0xA299, "VGT_GSVS_RING_OFFSET_2"},
     {0xA29A, "VGT_GSVS_RING_OFFSET_3"},
+#if LLPC_BUILD_GFX11
+// TODO: VGT_GS_OUT_PRIM_TYPE is here only up to gfx10. A different
+// register number takes over the name in gfx11+.
+#endif
     {0xA29B, "VGT_GS_OUT_PRIM_TYPE"},
     {0xA2A1, "VGT_PRIMITIVEID_EN"},
     {0xA2A5, "VGT_GS_MAX_PRIMS_PER_SUBGROUP"},
     {0xA2A6, "VGT_DRAW_PAYLOAD_CNTL"},
     {0xA2AA, "IA_MULTI_VGT_PARAM"}, // TODO: Known as IA_MULTI_VGT_PARAM_BC in gfx9.1
     {0xA2AB, "VGT_ESGS_RING_ITEMSIZE"},
     {0xA2AC, "VGT_GSVS_RING_ITEMSIZE"},
     {0xA2AD, "VGT_REUSE_OFF"},
     {0xA2B5, "VGT_STRMOUT_VTX_STRIDE_0"},
     {0xA2B9, "VGT_STRMOUT_VTX_STRIDE_1"},
@@ -358,20 +362,23 @@ const PalMetadataReg PalMetadataRegs[] = {
     {0xA2E4, "VGT_GS_INSTANCE_CNT"},
     {0xA2E5, "VGT_STRMOUT_CONFIG"},
     {0xA2E6, "VGT_STRMOUT_BUFFER_CONFIG"},
     {0xA2F8, "PA_SC_AA_CONFIG"},
     {0xA2F9, "PA_SU_VTX_CNTL"},
     {0xA310, "PA_SC_SHADER_CONTROL"},
     {0xA316, "VGT_VERTEX_REUSE_BLOCK_CNTL"},
     {0xC258, "IA_MULTI_VGT_PARAM_PIPED"}, // TODO: Known as IA_MULTI_VGT_PARAM on gfx9 only (not present <=gfx8)
     {0xC25F, "GE_STEREO_CNTL"},
     {0xC262, "GE_USER_VGPR_EN"},
+#if LLPC_BUILD_GFX11
+    {0xC266, "VGT_GS_OUT_PRIM_TYPE"}, // TODO: gfx11+. A different register number has the same name up to gfx10.
+#endif
 };
 
 } // anonymous namespace
 
 namespace lgc {
 // =====================================================================================================================
 // Get name of PAL metadata register, or "" if not known
 //
 // @param regNumber : Register number
 const char *getPalMetadataRegName(unsigned regNumber) {
diff --git a/lgc/elfLinker/ElfLinker.cpp b/lgc/elfLinker/ElfLinker.cpp
index e21299c3b..074eb63c0 100644
--- a/lgc/elfLinker/ElfLinker.cpp
+++ b/lgc/elfLinker/ElfLinker.cpp
@@ -1101,20 +1101,24 @@ void OutputSection::write(raw_pwrite_stream &outStream, ELF::Elf64_Shdr *shdr) {
     // Write the input section
     StringRef contents = cantFail(inputSection.sectionRef.getContents());
     outStream << contents.slice(0, inputSection.size);
     size += inputSection.size;
   }
 
   if (endPadding) {
     // On GFX10 in .text, also add padding at the end of the section: align to an instruction cache line
     // boundary, then add another 3 cache lines worth of padding.
     uint64_t cacheLineSize = 64;
+#if LLPC_BUILD_GFX11
+    if (m_linker->getPipelineState()->getTargetInfo().getGfxIpVersion().major >= 11)
+      cacheLineSize = 128;
+#endif
     uint64_t alignmentGap = (-size & (cacheLineSize - 1)) + 3 * cacheLineSize;
     while (alignmentGap != 0) {
       size_t thisSize = std::min(alignmentGap, paddingUnit - (size & (paddingUnit - 1)));
       outStream << StringRef(&endPadding[size & (paddingUnit - 1)], thisSize);
       alignmentGap -= thisSize;
       size += thisSize;
     }
   }
 
   shdr->sh_size = size;
diff --git a/lgc/imported/chip/gfx9/gfx9_plus_merged_enum.h b/lgc/imported/chip/gfx9/gfx9_plus_merged_enum.h
index d9a1e3e4b..4cf157cf4 100644
--- a/lgc/imported/chip/gfx9/gfx9_plus_merged_enum.h
+++ b/lgc/imported/chip/gfx9/gfx9_plus_merged_enum.h
@@ -44,20 +44,24 @@ typedef enum BinMapMode {
     BIN_MAP_MODE_NONE                                  = 0x00000000,
     BIN_MAP_MODE_RTA_INDEX                             = 0x00000001,
     BIN_MAP_MODE_POPS__GFX10COREPLUS                   = 0x00000002,
 } BinMapMode;
 
 typedef enum BinningMode {
     BINNING_ALLOWED                                    = 0x00000000,
     FORCE_BINNING_ON                                   = 0x00000001,
     DISABLE_BINNING_USE_NEW_SC__GFX09_10               = 0x00000002,
     DISABLE_BINNING_USE_LEGACY_SC__GFX09_10            = 0x00000003,
+#if CHIP_HDR_NAVI31
+    BINNING_ONE_PRIM_PER_BATCH__GFX11                  = 0x00000002,
+    BINNING_DISABLED__GFX11                            = 0x00000003,
+#endif
 } BinningMode;
 
 typedef enum BinSizeExtend {
     BIN_SIZE_32_PIXELS                                 = 0x00000000,
     BIN_SIZE_64_PIXELS                                 = 0x00000001,
     BIN_SIZE_128_PIXELS                                = 0x00000002,
     BIN_SIZE_256_PIXELS                                = 0x00000003,
     BIN_SIZE_512_PIXELS                                = 0x00000004,
 } BinSizeExtend;
 
@@ -76,20 +80,30 @@ typedef enum BlendOp {
     BLEND_BOTH_SRC_ALPHA__GFX09_10                     = 0x0000000b,
     BLEND_BOTH_INV_SRC_ALPHA__GFX09_10                 = 0x0000000c,
     BLEND_CONSTANT_COLOR__GFX09_10                     = 0x0000000d,
     BLEND_ONE_MINUS_CONSTANT_COLOR__GFX09_10           = 0x0000000e,
     BLEND_SRC1_COLOR__GFX09_10                         = 0x0000000f,
     BLEND_INV_SRC1_COLOR__GFX09_10                     = 0x00000010,
     BLEND_SRC1_ALPHA__GFX09_10                         = 0x00000011,
     BLEND_INV_SRC1_ALPHA__GFX09_10                     = 0x00000012,
     BLEND_CONSTANT_ALPHA__GFX09_10                     = 0x00000013,
     BLEND_ONE_MINUS_CONSTANT_ALPHA__GFX09_10           = 0x00000014,
+#if CHIP_HDR_NAVI31
+    BLEND_CONSTANT_COLOR__GFX11                        = 0x0000000b,
+    BLEND_ONE_MINUS_CONSTANT_COLOR__GFX11              = 0x0000000c,
+    BLEND_SRC1_COLOR__GFX11                            = 0x0000000d,
+    BLEND_INV_SRC1_COLOR__GFX11                        = 0x0000000e,
+    BLEND_SRC1_ALPHA__GFX11                            = 0x0000000f,
+    BLEND_INV_SRC1_ALPHA__GFX11                        = 0x00000010,
+    BLEND_CONSTANT_ALPHA__GFX11                        = 0x00000011,
+    BLEND_ONE_MINUS_CONSTANT_ALPHA__GFX11              = 0x00000012,
+#endif
 } BlendOp;
 
 typedef enum BlendOpt {
     FORCE_OPT_AUTO                                     = 0x00000000,
     FORCE_OPT_DISABLE                                  = 0x00000001,
     FORCE_OPT_ENABLE_IF_SRC_A_0                        = 0x00000002,
     FORCE_OPT_ENABLE_IF_SRC_RGB_0                      = 0x00000003,
     FORCE_OPT_ENABLE_IF_SRC_ARGB_0                     = 0x00000004,
     FORCE_OPT_ENABLE_IF_SRC_A_1                        = 0x00000005,
     FORCE_OPT_ENABLE_IF_SRC_RGB_1                      = 0x00000006,
@@ -139,20 +153,56 @@ typedef enum BUF_FMT {
     BUF_FMT_32_UINT                                    = 0x00000014,
     BUF_FMT_32_SINT                                    = 0x00000015,
     BUF_FMT_32_FLOAT                                   = 0x00000016,
     BUF_FMT_16_16_UNORM                                = 0x00000017,
     BUF_FMT_16_16_SNORM                                = 0x00000018,
     BUF_FMT_16_16_USCALED                              = 0x00000019,
     BUF_FMT_16_16_SSCALED                              = 0x0000001a,
     BUF_FMT_16_16_UINT                                 = 0x0000001b,
     BUF_FMT_16_16_SINT                                 = 0x0000001c,
     BUF_FMT_16_16_FLOAT                                = 0x0000001d,
+#if CHIP_HDR_NAVI31
+    BUF_FMT_10_11_11_FLOAT__GFX104PLUS                 = 0x0000001e,
+    BUF_FMT_11_11_10_FLOAT__GFX104PLUS                 = 0x0000001f,
+    BUF_FMT_10_10_10_2_UNORM__GFX104PLUS               = 0x00000020,
+    BUF_FMT_10_10_10_2_SNORM__GFX104PLUS               = 0x00000021,
+    BUF_FMT_10_10_10_2_UINT__GFX104PLUS                = 0x00000022,
+    BUF_FMT_10_10_10_2_SINT__GFX104PLUS                = 0x00000023,
+    BUF_FMT_2_10_10_10_UNORM__GFX104PLUS               = 0x00000024,
+    BUF_FMT_2_10_10_10_SNORM__GFX104PLUS               = 0x00000025,
+    BUF_FMT_2_10_10_10_USCALED__GFX104PLUS             = 0x00000026,
+    BUF_FMT_2_10_10_10_SSCALED__GFX104PLUS             = 0x00000027,
+    BUF_FMT_2_10_10_10_UINT__GFX104PLUS                = 0x00000028,
+    BUF_FMT_2_10_10_10_SINT__GFX104PLUS                = 0x00000029,
+    BUF_FMT_8_8_8_8_UNORM__GFX104PLUS                  = 0x0000002a,
+    BUF_FMT_8_8_8_8_SNORM__GFX104PLUS                  = 0x0000002b,
+    BUF_FMT_8_8_8_8_USCALED__GFX104PLUS                = 0x0000002c,
+    BUF_FMT_8_8_8_8_SSCALED__GFX104PLUS                = 0x0000002d,
+    BUF_FMT_8_8_8_8_UINT__GFX104PLUS                   = 0x0000002e,
+    BUF_FMT_8_8_8_8_SINT__GFX104PLUS                   = 0x0000002f,
+    BUF_FMT_32_32_UINT__GFX104PLUS                     = 0x00000030,
+    BUF_FMT_32_32_SINT__GFX104PLUS                     = 0x00000031,
+    BUF_FMT_32_32_FLOAT__GFX104PLUS                    = 0x00000032,
+    BUF_FMT_16_16_16_16_UNORM__GFX104PLUS              = 0x00000033,
+    BUF_FMT_16_16_16_16_SNORM__GFX104PLUS              = 0x00000034,
+    BUF_FMT_16_16_16_16_USCALED__GFX104PLUS            = 0x00000035,
+    BUF_FMT_16_16_16_16_SSCALED__GFX104PLUS            = 0x00000036,
+    BUF_FMT_16_16_16_16_UINT__GFX104PLUS               = 0x00000037,
+    BUF_FMT_16_16_16_16_SINT__GFX104PLUS               = 0x00000038,
+    BUF_FMT_16_16_16_16_FLOAT__GFX104PLUS              = 0x00000039,
+    BUF_FMT_32_32_32_UINT__GFX104PLUS                  = 0x0000003a,
+    BUF_FMT_32_32_32_SINT__GFX104PLUS                  = 0x0000003b,
+    BUF_FMT_32_32_32_FLOAT__GFX104PLUS                 = 0x0000003c,
+    BUF_FMT_32_32_32_32_UINT__GFX104PLUS               = 0x0000003d,
+    BUF_FMT_32_32_32_32_SINT__GFX104PLUS               = 0x0000003e,
+    BUF_FMT_32_32_32_32_FLOAT__GFX104PLUS              = 0x0000003f,
+#endif
     BUF_FMT_10_11_11_UNORM__GFX10CORE                  = 0x0000001e,
     BUF_FMT_10_11_11_SNORM__GFX10CORE                  = 0x0000001f,
     BUF_FMT_10_11_11_USCALED__GFX10CORE                = 0x00000020,
     BUF_FMT_10_11_11_SSCALED__GFX10CORE                = 0x00000021,
     BUF_FMT_10_11_11_UINT__GFX10CORE                   = 0x00000022,
     BUF_FMT_10_11_11_SINT__GFX10CORE                   = 0x00000023,
     BUF_FMT_10_11_11_FLOAT__GFX10CORE                  = 0x00000024,
     BUF_FMT_11_11_10_UNORM__GFX10CORE                  = 0x00000025,
     BUF_FMT_11_11_10_SNORM__GFX10CORE                  = 0x00000026,
     BUF_FMT_11_11_10_USCALED__GFX10CORE                = 0x00000027,
@@ -260,20 +310,24 @@ typedef enum BUF_NUM_FORMAT {
 
 typedef enum CBMode {
     CB_DISABLE                                         = 0x00000000,
     CB_NORMAL                                          = 0x00000001,
     CB_ELIMINATE_FAST_CLEAR                            = 0x00000002,
     CB_RESOLVE__GFX09_10                               = 0x00000003,
     CB_DECOMPRESS__GFX09_10                            = 0x00000004,
     CB_FMASK_DECOMPRESS__GFX09_10                      = 0x00000005,
     CB_DCC_DECOMPRESS__GFX09_10                        = 0x00000006,
     CB_RESERVED__GFX10                                 = 0x00000007,
+#if CHIP_HDR_NAVI31
+    CB_DCC_DECOMPRESS__GFX11                           = 0x00000003,
+    CB_RESERVED__GFX11                                 = 0x00000004,
+#endif
 } CBMode;
 
 typedef enum CBPerfClearFilterSel {
     CB_PERF_CLEAR_FILTER_SEL_NONCLEAR                  = 0x00000000,
     CB_PERF_CLEAR_FILTER_SEL_CLEAR                     = 0x00000001,
 } CBPerfClearFilterSel;
 
 typedef enum CBPerfOpFilterSel {
     CB_PERF_OP_FILTER_SEL_WRITE_ONLY                   = 0x00000000,
     CB_PERF_OP_FILTER_SEL_NEEDS_DESTINATION            = 0x00000001,
@@ -803,37 +857,317 @@ typedef enum CBPerfSel {
     CB_PERF_SEL_MERGE_PIXELS_WITH_BLEND_ENABLED__GFX10CORE = 0x000001b1,
     CB_PERF_SEL_TQ_STUTTER_STALL__GFX10CORE            = 0x000001bc,
     CB_PERF_SEL_FC_TILE_STUTTER_STALL__GFX10CORE       = 0x000001bd,
     CB_PERF_SEL_FC_QUAD_STUTTER_STALL__GFX10CORE       = 0x000001be,
     CB_PERF_SEL_FC_KEYID_STUTTER_STALL__GFX10CORE      = 0x000001bf,
     CB_PERF_SEL_CC_EVENFIFO_STUTTER_STALL__GFX10CORE   = 0x000001c0,
     CB_PERF_SEL_CC_ODDFIFO_STUTTER_STALL__GFX10CORE    = 0x000001c1,
     CB_PERF_SEL_CC_CACHE_256BS_SAVED_DUE_TO_QSB__GFX10CORE = 0x000001c2,
     CB_PERF_SEL_FC_CACHE_FMASK_NO_FETCH__GFX10CORE     = 0x000001c3,
     CB_PERF_SEL_CC_CACHE_SECTOR_HIT__GFX10CORE         = 0x000001c4,
+#if CHIP_HDR_NAVI31
+    CB_PERF_SEL_DRAWN_BUSY__GFX11                      = 0x00000002,
+    CB_PERF_SEL_DRAWN_PIXEL__GFX11                     = 0x00000003,
+    CB_PERF_SEL_DRAWN_QUAD__GFX11                      = 0x00000004,
+    CB_PERF_SEL_DRAWN_QUAD_FRAGMENT__GFX11             = 0x00000005,
+    CB_PERF_SEL_CC_DCC_DECOMPRESS_TIDS_IN__GFX11       = 0x0000000b,
+    CB_PERF_SEL_CC_DCC_DECOMPRESS_TIDS_OUT__GFX11      = 0x0000000c,
+    CB_PERF_SEL_CC_DCC_COMPRESS_TIDS_IN__GFX11         = 0x0000000d,
+    CB_PERF_SEL_CC_DCC_COMPRESS_TIDS_OUT__GFX11        = 0x0000000e,
+    CB_PERF_SEL_DB_CB_EXPORT_VALID_READY__GFX11        = 0x0000000f,
+    CB_PERF_SEL_DB_CB_EXPORT_VALID_READYB__GFX11       = 0x00000010,
+    CB_PERF_SEL_DB_CB_EXPORT_VALIDB_READY__GFX11       = 0x00000011,
+    CB_PERF_SEL_DB_CB_EXPORT_VALIDB_READYB__GFX11      = 0x00000012,
+    CB_PERF_SEL_CC_MA_WRITE_REQUEST__GFX11             = 0x00000013,
+    CB_PERF_SEL_CC_MA_WRITE_REQUESTS_IN_FLIGHT__GFX11  = 0x00000014,
+    CB_PERF_SEL_CC_MA_READ_REQUEST__GFX11              = 0x00000015,
+    CB_PERF_SEL_CC_MA_READ_REQUESTS_IN_FLIGHT__GFX11   = 0x00000016,
+    CB_PERF_SEL_FDCC_FMASK_DECOMPRESS_BYTES_OUT__GFX11 = 0x00000017,
+    CB_PERF_SEL_FDCC_FMASK_COMPRESS_BYTES_IN__GFX11    = 0x00000018,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_FRAG_TIDS_IN__GFX11   = 0x00000019,
+    CB_PERF_SEL_CC_FDCC_DECOMPRESS_FRAG_TIDS_OUT__GFX11 = 0x0000001a,
+    CB_PERF_SEL_DC_MA_WRITE_REQUEST__GFX11             = 0x0000001e,
+    CB_PERF_SEL_DC_MA_WRITE_REQUESTS_IN_FLIGHT__GFX11  = 0x0000001f,
+    CB_PERF_SEL_DC_MA_READ_REQUEST__GFX11              = 0x00000020,
+    CB_PERF_SEL_DC_MA_READ_REQUESTS_IN_FLIGHT__GFX11   = 0x00000021,
+    CB_PERF_SEL_CB_RMI_WRREQ_VALID_READY__GFX11        = 0x00000022,
+    CB_PERF_SEL_CB_RMI_WRREQ_VALID_READYB__GFX11       = 0x00000023,
+    CB_PERF_SEL_CB_RMI_WRREQ_VALIDB_READY__GFX11       = 0x00000024,
+    CB_PERF_SEL_CB_RMI_WRREQ_VALIDB_READYB__GFX11      = 0x00000025,
+    CB_PERF_SEL_CB_RMI_RDREQ_VALID_READY__GFX11        = 0x00000026,
+    CB_PERF_SEL_CB_RMI_RDREQ_VALID_READYB__GFX11       = 0x00000027,
+    CB_PERF_SEL_CB_RMI_RDREQ_VALIDB_READY__GFX11       = 0x00000028,
+    CB_PERF_SEL_CB_RMI_RDREQ_VALIDB_READYB__GFX11      = 0x00000029,
+    CB_PERF_SEL_NACK_CC_READ__GFX11                    = 0x0000002a,
+    CB_PERF_SEL_NACK_CC_WRITE__GFX11                   = 0x0000002b,
+    CB_PERF_SEL_DC_MA_EARLY_WRITE_RETURN__GFX11        = 0x0000002c,
+    CB_PERF_SEL_CC_MA_EARLY_WRITE_RETURN__GFX11        = 0x0000002d,
+    CB_PERF_SEL_DC_MA_EARLY_WRITE_REQUESTS_IN_FLIGHT__GFX11 = 0x0000002e,
+    CB_PERF_SEL_CC_MA_EARLY_WRITE_REQUESTS_IN_FLIGHT__GFX11 = 0x0000002f,
+    CB_PERF_SEL_CC_DCC_RDREQ_STALL__GFX11              = 0x00000030,
+    CB_PERF_SEL_EVENT__GFX11                           = 0x00000032,
+    CB_PERF_SEL_EVENT_CACHE_FLUSH_TS__GFX11            = 0x00000033,
+    CB_PERF_SEL_EVENT_CONTEXT_DONE__GFX11              = 0x00000034,
+    CB_PERF_SEL_EVENT_CACHE_FLUSH__GFX11               = 0x00000035,
+    CB_PERF_SEL_EVENT_CACHE_FLUSH_AND_INV_TS_EVENT__GFX11 = 0x00000036,
+    CB_PERF_SEL_EVENT_CACHE_FLUSH_AND_INV_EVENT__GFX11 = 0x00000037,
+    CB_PERF_SEL_EVENT_FLUSH_AND_INV_CB_DATA_TS__GFX11  = 0x00000038,
+    CB_PERF_SEL_EVENT_FLUSH_AND_INV_CB_META__GFX11     = 0x00000039,
+    CB_PERF_SEL_EVENT_BOTTOM_OF_PIPE_TS__GFX11         = 0x0000003a,
+    CB_PERF_SEL_STATIC_CLOCK_EN__GFX11                 = 0x0000003c,
+    CB_PERF_SEL_PERFMON_CLOCK_EN__GFX11                = 0x0000003d,
+    CB_PERF_SEL_BLEND_CLOCK_EN__GFX11                  = 0x0000003e,
+    CB_PERF_SEL_COLOR_STORE_CLOCK_EN__GFX11            = 0x0000003f,
+    CB_PERF_SEL_BACKEND_READ_CLOCK_EN__GFX11           = 0x00000040,
+    CB_PERF_SEL_GRBM_CLOCK_EN__GFX11                   = 0x00000041,
+    CB_PERF_SEL_MEMARB_CLOCK_EN__GFX11                 = 0x00000042,
+    CB_PERF_SEL_BACKEND_EVICT_PIPE_CLOCK_EN__GFX11     = 0x00000043,
+    CB_PERF_SEL_BACKEND_FRAGOP_CLOCK_EN__GFX11         = 0x00000044,
+    CB_PERF_SEL_BACKEND_SRC_FIFO_CLOCK_EN__GFX11       = 0x00000045,
+    CB_PERF_SEL_BACKEND_CACHE_CTL_CLOCK_EN__GFX11      = 0x00000046,
+    CB_PERF_SEL_FRONTEND_INPUT_CLOCK_EN__GFX11         = 0x00000047,
+    CB_PERF_SEL_FRONTEND_ADDR_CLOCK_EN__GFX11          = 0x00000048,
+    CB_PERF_SEL_FRONTEND_FDCC_CLOCK_EN__GFX11          = 0x00000049,
+    CB_PERF_SEL_FRONTEND_SAMPLE_MASK_TRACKER_CLOCK_EN__GFX11 = 0x0000004a,
+    CB_PERF_SEL_EVENTS_CLK_EN__GFX11                   = 0x0000004b,
+    CB_PERF_SEL_CC_TAG_HIT__GFX11                      = 0x00000050,
+    CB_PERF_SEL_CC_CACHE_TAG_MISS__GFX11               = 0x00000051,
+    CB_PERF_SEL_CC_CACHE_SECTOR_MISS__GFX11            = 0x00000052,
+    CB_PERF_SEL_CC_CACHE_SECTOR_HIT__GFX11             = 0x00000053,
+    CB_PERF_SEL_CC_CACHE_READ_OUTPUT_STALL__GFX11      = 0x00000058,
+    CB_PERF_SEL_CC_CACHE_WRITE_OUTPUT_STALL__GFX11     = 0x00000059,
+    CB_PERF_SEL_CC_CACHE_ACK_OUTPUT_STALL__GFX11       = 0x0000005a,
+    CB_PERF_SEL_CC_CACHE_STALL__GFX11                  = 0x0000005b,
+    CB_PERF_SEL_CC_CACHE_FLUSH__GFX11                  = 0x0000005c,
+    CB_PERF_SEL_CC_CACHE_SECTORS_FLUSHED__GFX11        = 0x0000005d,
+    CB_PERF_SEL_CC_CACHE_WA_TO_RMW_CONVERSION__GFX11   = 0x0000005e,
+    CB_PERF_SEL_CC_CACHE_QBLOCKS_FLUSHED__GFX11        = 0x0000005f,
+    CB_PERF_SEL_CC_CACHE_DIRTY_QBLOCKS_FLUSHED__GFX11  = 0x00000060,
+    CB_PERF_SEL_CC_CACHE_READS_SAVED_DUE_TO_DCC__GFX11 = 0x00000061,
+    CB_PERF_SEL_CCC_IN_EVICT_HAZARD_STALL__GFX11       = 0x00000062,
+    CB_PERF_SEL_CCC_COLOR_RESOURCE_PANIC__GFX11        = 0x00000063,
+    CB_PERF_SEL_CCC_FMASK_RESOURCE_PANIC__GFX11        = 0x00000064,
+    CB_PERF_SEL_CCC_FREE_WAYS_PANIC__GFX11             = 0x00000065,
+    CB_PERF_SEL_CCC_SKID_FIFO_FULL__GFX11              = 0x00000066,
+    CB_PERF_SEL_CCC_SKID_FIFO_STALL__GFX11             = 0x00000067,
+    CB_PERF_SEL_CCC_COLOR_RESOURCE_STALL__GFX11        = 0x00000068,
+    CB_PERF_SEL_CCC_FMASK_RESOURCE_STALL__GFX11        = 0x00000069,
+    CB_PERF_SEL_CCC_FREE_WAYS_STALL__GFX11             = 0x0000006a,
+    CB_PERF_SEL_CCC_KEY_XFR_RETURN_STALL__GFX11        = 0x0000006b,
+    CB_PERF_SEL_BE_SRCFIFO_FULL__GFX11                 = 0x0000006e,
+    CB_PERF_SEL_BE_RDLATFIFO_FULL__GFX11               = 0x0000006f,
+    CB_PERF_SEL_RDLAT_FIFO_QUAD_RESIDENCY_STALL__GFX11 = 0x00000070,
+    CB_PERF_SEL_CC_QUADFRAG_VALID_READY__GFX11         = 0x00000071,
+    CB_PERF_SEL_CC_QUADFRAG_VALID_READYB__GFX11        = 0x00000072,
+    CB_PERF_SEL_CC_QUADFRAG_VALIDB_READY__GFX11        = 0x00000073,
+    CB_PERF_SEL_CC_QUADFRAG_VALIDB_READYB__GFX11       = 0x00000074,
+    CB_PERF_SEL_CC_MA_WRITE_REQUEST_PARTIAL__GFX11     = 0x00000075,
+    CB_PERF_SEL_CC_BB_BLEND_PIXEL_VALID_READY__GFX11   = 0x00000076,
+    CB_PERF_SEL_CC_BB_BLEND_PIXEL_VALID_READYB__GFX11  = 0x00000077,
+    CB_PERF_SEL_CC_BB_BLEND_PIXEL_VALIDB_READY__GFX11  = 0x00000078,
+    CB_PERF_SEL_CC_BB_BLEND_PIXEL_VALIDB_READYB__GFX11 = 0x00000079,
+    CB_PERF_SEL_READ_REQ_PIPE3_STALL__GFX11            = 0x00000080,
+    CB_PERF_SEL_READ_REQ_PIPE1_STALL__GFX11            = 0x00000081,
+    CB_PERF_SEL_DCC_CACHE_TAG_HIT__GFX11               = 0x00000082,
+    CB_PERF_SEL_DCC_CACHE_TAG_MISS__GFX11              = 0x00000083,
+    CB_PERF_SEL_DCC_CACHE_SECTOR_MISS__GFX11           = 0x00000084,
+    CB_PERF_SEL_DCC_CACHE_REEVICTION_STALL__GFX11      = 0x00000085,
+    CB_PERF_SEL_DCC_CACHE_EVICT_NONZERO_INFLIGHT_STALL__GFX11 = 0x00000086,
+    CB_PERF_SEL_DCC_CACHE_REPLACE_PENDING_EVICT_STALL__GFX11 = 0x00000087,
+    CB_PERF_SEL_DCC_CACHE_INFLIGHT_COUNTER_MAXIMUM_STALL__GFX11 = 0x00000088,
+    CB_PERF_SEL_DCC_CACHE_READ_OUTPUT_STALL__GFX11     = 0x00000089,
+    CB_PERF_SEL_DCC_CACHE_WRITE_OUTPUT_STALL__GFX11    = 0x0000008a,
+    CB_PERF_SEL_DCC_CACHE_ACK_OUTPUT_STALL__GFX11      = 0x0000008b,
+    CB_PERF_SEL_DCC_CACHE_STALL__GFX11                 = 0x0000008c,
+    CB_PERF_SEL_DCC_CACHE_FLUSH__GFX11                 = 0x0000008d,
+    CB_PERF_SEL_DCC_CACHE_SECTORS_FLUSHED__GFX11       = 0x0000008e,
+    CB_PERF_SEL_DCC_CACHE_DIRTY_SECTORS_FLUSHED__GFX11 = 0x0000008f,
+    CB_PERF_SEL_DCC_CACHE_TAGS_FLUSHED__GFX11          = 0x00000090,
+    CB_PERF_SEL_DCC_COMP_SECTORS_IN__GFX11             = 0x00000091,
+    CB_PERF_SEL_KEYID_RDLAT_FIFO_FULL__GFX11           = 0x00000095,
+    CB_PERF_SEL_RBP_EXPORT_8PIX_LIT_BOTH__GFX11        = 0x00000096,
+    CB_PERF_SEL_RBP_EXPORT_8PIX_LIT_LEFT__GFX11        = 0x00000097,
+    CB_PERF_SEL_RBP_EXPORT_8PIX_LIT_RIGHT__GFX11       = 0x00000098,
+    CB_PERF_SEL_DCC_KEY_VALUE_CLEAR__GFX11             = 0x0000009b,
+    CB_PERF_SEL_SMT_OUT_XFR_FEA__GFX11                 = 0x000000a0,
+    CB_PERF_SEL_SMT_FULLY_ON_PROBE__GFX11              = 0x000000a1,
+    CB_PERF_SEL_SMT_PARTIAL_ON_PROBE__GFX11            = 0x000000a2,
+    CB_PERF_SEL_SMT_OUT_XFR__GFX11                     = 0x000000a3,
+    CB_PERF_SEL_SMT_OUT_GP_XFR__GFX11                  = 0x000000a4,
+    CB_PERF_SEL_SMT_IN_XFR__GFX11                      = 0x000000a5,
+    CB_PERF_SEL_SMT_CACHE_PROBE__GFX11                 = 0x000000a6,
+    CB_PERF_SEL_SMT_MISS_ON_PROBE__GFX11               = 0x000000a7,
+    CB_PERF_SEL_SMT_HIT_ON_PROBE__GFX11                = 0x000000a8,
+    CB_PERF_SEL_SMT_IS_STALLED__GFX11                  = 0x000000a9,
+    CB_PERF_SEL_SMT_QUAD_PTR_FIFO_IS_FULL__GFX11       = 0x000000aa,
+    CB_PERF_SEL_SMT_TOTAL_OVERWRITTEN_SECTORS__GFX11   = 0x000000ab,
+    CB_PERF_SEL_BLEND_QUAD_DST_READ_COULD_HAVE_BEEN_OPTIMIZED__GFX11 = 0x000000b4,
+    CB_PERF_SEL_BLEND_QUAD_BLENDING_COULD_HAVE_BEEN_BYPASSED__GFX11 = 0x000000b5,
+    CB_PERF_SEL_BLEND_QUAD_COULD_HAVE_BEEN_DISCARDED__GFX11 = 0x000000b6,
+    CB_PERF_SEL_BLEND_OPT_PIXELS_RESULT_EQ_DEST__GFX11 = 0x000000b7,
+    CB_PERF_SEL_BLEND_STALL_AT_OUTPUT__GFX11           = 0x000000b8,
+    CB_PERF_SEL_BLEND_STALL_ON_CACHE_ACCESS__GFX11     = 0x000000b9,
+    CB_PERF_SEL_BLEND_COLLISION_DUE_TO_CACHE_WRITE__GFX11 = 0x000000ba,
+    CB_PERF_SEL_BLEND_RAW_HAZARD_STALL__GFX11          = 0x000000bb,
+    CB_PERF_SEL_BE_CS_FILLRATE_1X2__GFX11              = 0x000000be,
+    CB_PERF_SEL_BE_CS_FILLRATE_2X1__GFX11              = 0x000000bf,
+    CB_PERF_SEL_BE_CS_FILLRATE_2X2__GFX11              = 0x000000c0,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_2TO1__GFX11      = 0x000000c8,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_2TO2__GFX11      = 0x000000c9,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_4TO1__GFX11      = 0x000000ca,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_4TO2__GFX11      = 0x000000cb,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_4TO3__GFX11      = 0x000000cc,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_4TO4__GFX11      = 0x000000cd,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO1__GFX11      = 0x000000ce,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO2__GFX11      = 0x000000cf,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO3__GFX11      = 0x000000d0,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO4__GFX11      = 0x000000d1,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO5__GFX11      = 0x000000d2,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_6TO6__GFX11      = 0x000000d3,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO1__GFX11      = 0x000000d4,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO2__GFX11      = 0x000000d5,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO3__GFX11      = 0x000000d6,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO4__GFX11      = 0x000000d7,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO5__GFX11      = 0x000000d8,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO6__GFX11      = 0x000000d9,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO7__GFX11      = 0x000000da,
+    CB_PERF_SEL_CC_DCC_COMPRESS_RATIO_8TO8__GFX11      = 0x000000db,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO1_1MAXFRAGS__GFX11 = 0x000000dc,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO2_1MAXFRAGS__GFX11 = 0x000000dd,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO3_1MAXFRAGS__GFX11 = 0x000000de,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO4_1MAXFRAGS__GFX11 = 0x000000df,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO1_2MAXFRAGS__GFX11 = 0x000000e0,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO2_2MAXFRAGS__GFX11 = 0x000000e1,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO3_2MAXFRAGS__GFX11 = 0x000000e2,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO4_2MAXFRAGS__GFX11 = 0x000000e3,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO1_3MAXFRAGS__GFX11 = 0x000000e4,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO2_3MAXFRAGS__GFX11 = 0x000000e5,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO3_3MAXFRAGS__GFX11 = 0x000000e6,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO4_3MAXFRAGS__GFX11 = 0x000000e7,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO1_4MAXFRAGS__GFX11 = 0x000000e8,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO2_4MAXFRAGS__GFX11 = 0x000000e9,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO3_4MAXFRAGS__GFX11 = 0x000000ea,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_RATIO_4TO4_4MAXFRAGS__GFX11 = 0x000000eb,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_1X1__GFX11            = 0x000000ec,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_1X2__GFX11            = 0x000000ed,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_2X1__GFX11            = 0x000000ee,
+    CB_PERF_SEL_CC_FDCC_COMPRESS_2X2__GFX11            = 0x000000ef,
+    CB_PERF_SEL_FORMAT_IS_32_R__GFX11                  = 0x000000fa,
+    CB_PERF_SEL_FORMAT_IS_32_AR__GFX11                 = 0x000000fb,
+    CB_PERF_SEL_FORMAT_IS_32_GR__GFX11                 = 0x000000fc,
+    CB_PERF_SEL_FORMAT_IS_32_ABGR__GFX11               = 0x000000fd,
+    CB_PERF_SEL_FORMAT_IS_FP16_ABGR__GFX11             = 0x000000fe,
+    CB_PERF_SEL_FORMAT_IS_SIGNED16_ABGR__GFX11         = 0x000000ff,
+    CB_PERF_SEL_FORMAT_IS_UNSIGNED16_ABGR__GFX11       = 0x00000100,
+    CB_PERF_SEL_FORMAT_IS_32BPP_8PIX__GFX11            = 0x00000101,
+    CB_PERF_SEL_FORMAT_IS_16_16_UNSIGNED_8PIX__GFX11   = 0x00000102,
+    CB_PERF_SEL_FORMAT_IS_16_16_SIGNED_8PIX__GFX11     = 0x00000103,
+    CB_PERF_SEL_FORMAT_IS_16_16_FLOAT_8PIX__GFX11      = 0x00000104,
+    CB_PERF_SEL_EXPORT_ADDED_1_FRAGMENT__GFX11         = 0x00000105,
+    CB_PERF_SEL_EXPORT_ADDED_2_FRAGMENTS__GFX11        = 0x00000106,
+    CB_PERF_SEL_EXPORT_ADDED_3_FRAGMENTS__GFX11        = 0x00000107,
+    CB_PERF_SEL_EXPORT_ADDED_4_FRAGMENTS__GFX11        = 0x00000108,
+    CB_PERF_SEL_EXPORT_ADDED_5_FRAGMENTS__GFX11        = 0x00000109,
+    CB_PERF_SEL_EXPORT_ADDED_6_FRAGMENTS__GFX11        = 0x0000010a,
+    CB_PERF_SEL_EXPORT_ADDED_7_FRAGMENTS__GFX11        = 0x0000010b,
+    CB_PERF_SEL_EXPORT_BLEND_OPT_DONT_READ_DST__GFX11  = 0x0000010c,
+    CB_PERF_SEL_EXPORT_BLEND_OPT_BLEND_BYPASS__GFX11   = 0x0000010d,
+    CB_PERF_SEL_EXPORT_BLEND_OPT_DISCARD_PIXELS__GFX11 = 0x0000010e,
+    CB_PERF_SEL_EXPORT_HAS_1_FRAGMENT_BEFORE_UPDATE__GFX11 = 0x0000010f,
+    CB_PERF_SEL_EXPORT_HAS_1_FRAGMENT_AFTER_UPDATE__GFX11 = 0x00000110,
+    CB_PERF_SEL_EXPORT_HAS_2_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x00000111,
+    CB_PERF_SEL_EXPORT_HAS_2_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x00000112,
+    CB_PERF_SEL_EXPORT_HAS_3_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x00000113,
+    CB_PERF_SEL_EXPORT_HAS_3_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x00000114,
+    CB_PERF_SEL_EXPORT_HAS_4_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x00000115,
+    CB_PERF_SEL_EXPORT_HAS_4_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x00000116,
+    CB_PERF_SEL_EXPORT_HAS_5_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x00000117,
+    CB_PERF_SEL_EXPORT_HAS_5_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x00000118,
+    CB_PERF_SEL_EXPORT_HAS_6_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x00000119,
+    CB_PERF_SEL_EXPORT_HAS_6_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x0000011a,
+    CB_PERF_SEL_EXPORT_HAS_7_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x0000011b,
+    CB_PERF_SEL_EXPORT_HAS_7_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x0000011c,
+    CB_PERF_SEL_EXPORT_HAS_8_FRAGMENTS_BEFORE_UPDATE__GFX11 = 0x0000011d,
+    CB_PERF_SEL_EXPORT_HAS_8_FRAGMENTS_AFTER_UPDATE__GFX11 = 0x0000011e,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_0__GFX11         = 0x0000011f,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_1__GFX11         = 0x00000120,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_2__GFX11         = 0x00000121,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_3__GFX11         = 0x00000122,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_4__GFX11         = 0x00000123,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_5__GFX11         = 0x00000124,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_6__GFX11         = 0x00000125,
+    CB_PERF_SEL_EXPORT_READS_FRAGMENT_7__GFX11         = 0x00000126,
+    CB_PERF_SEL_EXPORT_REMOVED_1_FRAGMENT__GFX11       = 0x00000127,
+    CB_PERF_SEL_EXPORT_REMOVED_2_FRAGMENTS__GFX11      = 0x00000128,
+    CB_PERF_SEL_EXPORT_REMOVED_3_FRAGMENTS__GFX11      = 0x00000129,
+    CB_PERF_SEL_EXPORT_REMOVED_4_FRAGMENTS__GFX11      = 0x0000012a,
+    CB_PERF_SEL_EXPORT_REMOVED_5_FRAGMENTS__GFX11      = 0x0000012b,
+    CB_PERF_SEL_EXPORT_REMOVED_6_FRAGMENTS__GFX11      = 0x0000012c,
+    CB_PERF_SEL_EXPORT_REMOVED_7_FRAGMENTS__GFX11      = 0x0000012d,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_0__GFX11        = 0x0000012e,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_1__GFX11        = 0x0000012f,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_2__GFX11        = 0x00000130,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_3__GFX11        = 0x00000131,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_4__GFX11        = 0x00000132,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_5__GFX11        = 0x00000133,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_6__GFX11        = 0x00000134,
+    CB_PERF_SEL_EXPORT_WRITES_FRAGMENT_7__GFX11        = 0x00000135,
+    CB_PERF_SEL_EXPORT_KILLED_BY_COLOR_INVALID__GFX11  = 0x00000136,
+    CB_PERF_SEL_EXPORT_KILLED_BY_DISCARD_PIXEL__GFX11  = 0x00000137,
+    CB_PERF_SEL_EXPORT_KILLED_BY_NULL_SAMPLE_MASK__GFX11 = 0x00000138,
+    CB_PERF_SEL_EXPORT_KILLED_BY_NULL_TARGET_SHADER_MASK__GFX11 = 0x00000139,
+#endif
     CB_PERF_SEL_FC_DCC_CACHE_SECTORS_FLUSHED__RN       = 0x000000fd,
     CB_PERF_SEL_FC_DCC_CACHE_DIRTY_SECTORS_FLUSHED__RN = 0x000000fe,
     CB_PERF_SEL_FC_DCC_CACHE_TAGS_FLUSHED__RN          = 0x000000ff,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_REG__RN  = 0x000001b6,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_SINGLE__RN = 0x000001b7,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_AC00__RN = 0x000001b8,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_AC01__RN = 0x000001b9,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_AC10__RN = 0x000001ba,
     CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_AC11__RN = 0x000001bb,
     CB_PERF_SEL_FC_DCC_CACHE_TAGS_FLUSHED__VG10_VG12_VG20_RV1X_RV2X = 0x000000fd,
     CB_PERF_SEL_FC_DCC_CACHE_SECTORS_FLUSHED__VG10_VG12_VG20_RV1X_RV2X = 0x000000fe,
     CB_PERF_SEL_FC_DCC_CACHE_DIRTY_SECTORS_FLUSHED__VG10_VG12_VG20_RV1X_RV2X = 0x000000ff,
 } CBPerfSel;
 
 constexpr unsigned int MaxCBPerfSelVg10_Vg12_Vg20_Rv1x_Rv2x = CB_PERF_SEL_CC_BB_BLEND_PIXEL_VLD__GFX09_10;
 constexpr unsigned int MaxCBPerfSelRn                  = CB_PERF_SEL_CC_DCC_KEY_VALUE__CONST_CLEAR_AC11__RN;
 constexpr unsigned int MaxCBPerfSelGfx10Core           = CB_PERF_SEL_CC_CACHE_SECTOR_HIT__GFX10CORE;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxCBPerfSelGfx11               = CB_PERF_SEL_EXPORT_KILLED_BY_NULL_TARGET_SHADER_MASK__GFX11;
+#endif
+
+#if CHIP_HDR_NAVI31
+typedef enum CBRamList {
+    CB_DCG_CCC_CAS_TAG_ARRAY                           = 0x00000000,
+    CB_DCG_CCC_CAS_FRAG_PTR                            = 0x00000001,
+    CB_DCG_CCC_CAS_COLOR_PTR                           = 0x00000002,
+    CB_DCG_CCC_CAS_SURF_PARAM                          = 0x00000003,
+    CB_DCG_CCC_CAS_KEYID                               = 0x00000004,
+    CB_DCG_BACKEND_RDLAT_FIFO                          = 0x00000005,
+    CB_DCG_FRONTEND_RDLAT_FIFO                         = 0x00000006,
+    CB_DCG_SRC_FIFO                                    = 0x00000007,
+    CB_DCG_COLOR_STORE                                 = 0x00000008,
+    CB_DCG_COLOR_STORE_DIRTY_BYTE                      = 0x00000009,
+    CB_DCG_FMASK_CACHE_STORE                           = 0x0000000a,
+    CB_DCG_READ_SKID_FIFO                              = 0x0000000b,
+    CB_DCG_QUAD_PTR_FIFO                               = 0x0000000c,
+    CB_DCG_OUTPUT_FIFO                                 = 0x0000000d,
+    CB_DCG_DCC_CACHE                                   = 0x0000000e,
+    CB_DCG_DCC_DIRTY_BITS                              = 0x0000000f,
+    CB_DCG_FOP_MAX_FRAG                                = 0x00000010,
+    CB_DCG_QBLOCK_ALLOC                                = 0x00000011,
+    CB_DCG_DCC_COMP_RAM                                = 0x00000012,
+    CB_DCG_DCC_DECOMP_RAM                              = 0x00000013,
+} CBRamList;
+#endif
 
 typedef enum CHA_PERF_SEL {
     CHA_PERF_SEL_BUSY                                  = 0x00000000,
     CHA_PERF_SEL_STALL_CHC0                            = 0x00000001,
     CHA_PERF_SEL_STALL_CHC1                            = 0x00000002,
     CHA_PERF_SEL_STALL_CHC2                            = 0x00000003,
     CHA_PERF_SEL_STALL_CHC3                            = 0x00000004,
     CHA_PERF_SEL_STALL_CHC4__GFX101                    = 0x00000005,
     CHA_PERF_SEL_STALL_CHC5__GFX101                    = 0x00000006,
     CHA_PERF_SEL_REQUEST_CHC0__GFX101                  = 0x00000007,
@@ -1015,23 +1349,63 @@ typedef enum CHA_PERF_SEL {
     CHA_PERF_SEL_IO_BURST_COUNT_CHC4__NV24             = 0x0000001f,
     CHA_PERF_SEL_ARB_REQUESTS__NV24                    = 0x00000020,
     CHA_PERF_SEL_REQ_INFLIGHT_LEVEL__NV24              = 0x00000021,
     CHA_PERF_SEL_STALL_RET_CONFLICT_CHC0__NV24         = 0x00000022,
     CHA_PERF_SEL_STALL_RET_CONFLICT_CHC1__NV24         = 0x00000023,
     CHA_PERF_SEL_STALL_RET_CONFLICT_CHC2__NV24         = 0x00000024,
     CHA_PERF_SEL_STALL_RET_CONFLICT_CHC3__NV24         = 0x00000025,
     CHA_PERF_SEL_STALL_RET_CONFLICT_CHC4__NV24         = 0x00000026,
     CHA_PERF_SEL_CYCLE__NV24                           = 0x00000027,
 #endif
+#if CHIP_HDR_NAVI31
+    CHA_PERF_SEL_STALL_CHC4__NV3X                      = 0x00000005,
+    CHA_PERF_SEL_STALL_CHC5__NV3X                      = 0x00000006,
+    CHA_PERF_SEL_REQUEST_CHC0__NV3X                    = 0x00000007,
+    CHA_PERF_SEL_REQUEST_CHC1__NV3X                    = 0x00000008,
+    CHA_PERF_SEL_REQUEST_CHC2__NV3X                    = 0x00000009,
+    CHA_PERF_SEL_REQUEST_CHC3__NV3X                    = 0x0000000a,
+    CHA_PERF_SEL_REQUEST_CHC4__NV3X                    = 0x0000000b,
+    CHA_PERF_SEL_MEM_32B_WDS_CHC0__NV3X                = 0x0000000c,
+    CHA_PERF_SEL_MEM_32B_WDS_CHC1__NV3X                = 0x0000000d,
+    CHA_PERF_SEL_MEM_32B_WDS_CHC2__NV3X                = 0x0000000e,
+    CHA_PERF_SEL_MEM_32B_WDS_CHC3__NV3X                = 0x0000000f,
+    CHA_PERF_SEL_MEM_32B_WDS_CHC4__NV3X                = 0x00000010,
+    CHA_PERF_SEL_IO_32B_WDS_CHC0__NV3X                 = 0x00000011,
+    CHA_PERF_SEL_IO_32B_WDS_CHC1__NV3X                 = 0x00000012,
+    CHA_PERF_SEL_IO_32B_WDS_CHC2__NV3X                 = 0x00000013,
+    CHA_PERF_SEL_IO_32B_WDS_CHC3__NV3X                 = 0x00000014,
+    CHA_PERF_SEL_IO_32B_WDS_CHC4__NV3X                 = 0x00000015,
+    CHA_PERF_SEL_MEM_BURST_COUNT_CHC0__NV3X            = 0x00000016,
+    CHA_PERF_SEL_MEM_BURST_COUNT_CHC1__NV3X            = 0x00000017,
+    CHA_PERF_SEL_MEM_BURST_COUNT_CHC2__NV3X            = 0x00000018,
+    CHA_PERF_SEL_MEM_BURST_COUNT_CHC3__NV3X            = 0x00000019,
+    CHA_PERF_SEL_MEM_BURST_COUNT_CHC4__NV3X            = 0x0000001a,
+    CHA_PERF_SEL_IO_BURST_COUNT_CHC0__NV3X             = 0x0000001b,
+    CHA_PERF_SEL_IO_BURST_COUNT_CHC1__NV3X             = 0x0000001c,
+    CHA_PERF_SEL_IO_BURST_COUNT_CHC2__NV3X             = 0x0000001d,
+    CHA_PERF_SEL_IO_BURST_COUNT_CHC3__NV3X             = 0x0000001e,
+    CHA_PERF_SEL_IO_BURST_COUNT_CHC4__NV3X             = 0x0000001f,
+    CHA_PERF_SEL_ARB_REQUESTS__NV3X                    = 0x00000020,
+    CHA_PERF_SEL_REQ_INFLIGHT_LEVEL__NV3X              = 0x00000021,
+    CHA_PERF_SEL_STALL_RET_CONFLICT_CHC0__NV3X         = 0x00000022,
+    CHA_PERF_SEL_STALL_RET_CONFLICT_CHC1__NV3X         = 0x00000023,
+    CHA_PERF_SEL_STALL_RET_CONFLICT_CHC2__NV3X         = 0x00000024,
+    CHA_PERF_SEL_STALL_RET_CONFLICT_CHC3__NV3X         = 0x00000025,
+    CHA_PERF_SEL_STALL_RET_CONFLICT_CHC4__NV3X         = 0x00000026,
+    CHA_PERF_SEL_CYCLE__NV3X                           = 0x00000027,
+#endif
 } CHA_PERF_SEL;
 
 constexpr unsigned int MaxChaPerfSelGfx101             = CHA_PERF_SEL_CYCLE__GFX101;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxChaPerfSelNv3x               = CHA_PERF_SEL_CYCLE__NV3X;
+#endif
 #if CHIP_HDR_NAVI24
 constexpr unsigned int MaxChaPerfSelNv24               = CHA_PERF_SEL_CYCLE__NV24;
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxChaPerfSelNv23               = CHA_PERF_SEL_CYCLE__NV23;
 #endif
 #if CHIP_HDR_NAVI22
 constexpr unsigned int MaxChaPerfSelNv22               = CHA_PERF_SEL_CYCLE__NV22;
 #endif
 #if CHIP_HDR_NAVI21
@@ -1235,35 +1609,84 @@ typedef enum CHCG_PERF_SEL {
     CHCG_PERF_SEL_REQ_CLIENT11__NV24                   = 0x0000001f,
     CHCG_PERF_SEL_REQ_CLIENT12__NV24                   = 0x00000020,
     CHCG_PERF_SEL_REQ_CLIENT13__NV24                   = 0x00000021,
     CHCG_PERF_SEL_REQ_CLIENT14__NV24                   = 0x00000022,
     CHCG_PERF_SEL_REQ_CLIENT15__NV24                   = 0x00000023,
     CHCG_PERF_SEL_REQ_CLIENT16__NV24                   = 0x00000024,
     CHCG_PERF_SEL_REQ_CLIENT17__NV24                   = 0x00000025,
     CHCG_PERF_SEL_REQ_CLIENT18__NV24                   = 0x00000026,
     CHCG_PERF_SEL_REQ_CLIENT19__NV24                   = 0x00000027,
 #endif
+#if CHIP_HDR_NAVI31
+    CHCG_PERF_SEL_CYCLE__NV3X                          = 0x00000000,
+    CHCG_PERF_SEL_BUSY__NV3X                           = 0x00000001,
+    CHCG_PERF_SEL_STARVE__NV3X                         = 0x00000002,
+    CHCG_PERF_SEL_ARB_RET_LEVEL__NV3X                  = 0x00000003,
+    CHCG_PERF_SEL_GL2_REQ_READ_LATENCY__NV3X           = 0x00000004,
+    CHCG_PERF_SEL_GL2_REQ_WRITE_LATENCY__NV3X          = 0x00000005,
+    CHCG_PERF_SEL_REQ__NV3X                            = 0x00000006,
+    CHCG_PERF_SEL_REQ_ATOMIC_WITH_RET__NV3X            = 0x00000007,
+    CHCG_PERF_SEL_REQ_ATOMIC_WITHOUT_RET__NV3X         = 0x00000008,
+    CHCG_PERF_SEL_REQ_NOP_ACK__NV3X                    = 0x00000009,
+    CHCG_PERF_SEL_REQ_NOP_RTN0__NV3X                   = 0x0000000a,
+    CHCG_PERF_SEL_REQ_READ__NV3X                       = 0x0000000b,
+    CHCG_PERF_SEL_REQ_READ_128B__NV3X                  = 0x0000000c,
+    CHCG_PERF_SEL_REQ_READ_32B__NV3X                   = 0x0000000d,
+    CHCG_PERF_SEL_REQ_READ_64B__NV3X                   = 0x0000000e,
+    CHCG_PERF_SEL_REQ_WRITE__NV3X                      = 0x0000000f,
+    CHCG_PERF_SEL_REQ_WRITE_32B__NV3X                  = 0x00000010,
+    CHCG_PERF_SEL_REQ_WRITE_64B__NV3X                  = 0x00000011,
+    CHCG_PERF_SEL_STALL_GUS_GL1__NV3X                  = 0x00000012,
+    CHCG_PERF_SEL_STALL_BUFFER_FULL__NV3X              = 0x00000013,
+    CHCG_PERF_SEL_REQ_CLIENT0__NV3X                    = 0x00000014,
+    CHCG_PERF_SEL_REQ_CLIENT1__NV3X                    = 0x00000015,
+    CHCG_PERF_SEL_REQ_CLIENT2__NV3X                    = 0x00000016,
+    CHCG_PERF_SEL_REQ_CLIENT3__NV3X                    = 0x00000017,
+    CHCG_PERF_SEL_REQ_CLIENT4__NV3X                    = 0x00000018,
+    CHCG_PERF_SEL_REQ_CLIENT5__NV3X                    = 0x00000019,
+    CHCG_PERF_SEL_REQ_CLIENT6__NV3X                    = 0x0000001a,
+    CHCG_PERF_SEL_REQ_CLIENT7__NV3X                    = 0x0000001b,
+    CHCG_PERF_SEL_REQ_CLIENT8__NV3X                    = 0x0000001c,
+    CHCG_PERF_SEL_REQ_CLIENT9__NV3X                    = 0x0000001d,
+    CHCG_PERF_SEL_REQ_CLIENT10__NV3X                   = 0x0000001e,
+    CHCG_PERF_SEL_REQ_CLIENT11__NV3X                   = 0x0000001f,
+    CHCG_PERF_SEL_REQ_CLIENT12__NV3X                   = 0x00000020,
+    CHCG_PERF_SEL_REQ_CLIENT13__NV3X                   = 0x00000021,
+    CHCG_PERF_SEL_REQ_CLIENT14__NV3X                   = 0x00000022,
+    CHCG_PERF_SEL_REQ_CLIENT15__NV3X                   = 0x00000023,
+    CHCG_PERF_SEL_REQ_CLIENT16__NV3X                   = 0x00000024,
+    CHCG_PERF_SEL_REQ_CLIENT17__NV3X                   = 0x00000025,
+    CHCG_PERF_SEL_REQ_CLIENT18__NV3X                   = 0x00000026,
+    CHCG_PERF_SEL_REQ_CLIENT19__NV3X                   = 0x00000027,
+    CHCG_PERF_SEL_REQ_CLIENT20__NV3X                   = 0x00000028,
+    CHCG_PERF_SEL_REQ_CLIENT21__NV3X                   = 0x00000029,
+    CHCG_PERF_SEL_REQ_CLIENT22__NV3X                   = 0x0000002a,
+    CHCG_PERF_SEL_REQ_CLIENT23__NV3X                   = 0x0000002b,
+#endif
 } CHCG_PERF_SEL;
 
 constexpr unsigned int MaxChcgPerfSelGfx101            = CHCG_PERF_SEL_REQ_CLIENT14__GFX101;
 #if CHIP_HDR_NAVI24
 constexpr unsigned int MaxChcgPerfSelNv24              = CHCG_PERF_SEL_REQ_CLIENT19__NV24;
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxChcgPerfSelNv23              = CHCG_PERF_SEL_REQ_CLIENT19__NV23;
 #endif
 #if CHIP_HDR_NAVI22
 constexpr unsigned int MaxChcgPerfSelNv22              = CHCG_PERF_SEL_REQ_CLIENT19__NV22;
 #endif
 #if CHIP_HDR_NAVI21
 constexpr unsigned int MaxChcgPerfSelNv21              = CHCG_PERF_SEL_REQ_CLIENT19__NV21;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxChcgPerfSelNv3x              = CHCG_PERF_SEL_REQ_CLIENT23__NV3X;
+#endif
 
 typedef enum CHC_PERF_SEL {
     CHC_PERF_SEL_CYCLE                                 = 0x00000000,
     CHC_PERF_SEL_BUSY                                  = 0x00000001,
     CHC_PERF_SEL_STARVE                                = 0x00000002,
     CHC_PERF_SEL_ARB_RET_LEVEL                         = 0x00000003,
     CHC_PERF_SEL_GL2_REQ_READ_LATENCY                  = 0x00000004,
     CHC_PERF_SEL_GL2_REQ_WRITE_LATENCY                 = 0x00000005,
     CHC_PERF_SEL_REQ                                   = 0x00000006,
     CHC_PERF_SEL_REQ_ATOMIC_WITH_RET                   = 0x00000007,
@@ -1287,33 +1710,42 @@ typedef enum CHC_PERF_SEL {
     CHC_PERF_SEL_REQ_CLIENT5                           = 0x00000019,
     CHC_PERF_SEL_REQ_CLIENT6                           = 0x0000001a,
     CHC_PERF_SEL_REQ_CLIENT7                           = 0x0000001b,
     CHC_PERF_SEL_REQ_CLIENT8                           = 0x0000001c,
     CHC_PERF_SEL_REQ_CLIENT9                           = 0x0000001d,
     CHC_PERF_SEL_REQ_CLIENT10                          = 0x0000001e,
     CHC_PERF_SEL_REQ_CLIENT11                          = 0x0000001f,
     CHC_PERF_SEL_REQ_CLIENT12                          = 0x00000020,
     CHC_PERF_SEL_REQ_CLIENT13                          = 0x00000021,
     CHC_PERF_SEL_REQ_CLIENT14                          = 0x00000022,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     CHC_PERF_SEL_REQ_CLIENT15__GFX103PLUSEXCLUSIVE     = 0x00000023,
     CHC_PERF_SEL_REQ_CLIENT16__GFX103PLUSEXCLUSIVE     = 0x00000024,
     CHC_PERF_SEL_REQ_CLIENT17__GFX103PLUSEXCLUSIVE     = 0x00000025,
     CHC_PERF_SEL_REQ_CLIENT18__GFX103PLUSEXCLUSIVE     = 0x00000026,
     CHC_PERF_SEL_REQ_CLIENT19__GFX103PLUSEXCLUSIVE     = 0x00000027,
 #endif
+#if CHIP_HDR_NAVI31
+    CHC_PERF_SEL_REQ_CLIENT20__GFX11                   = 0x00000028,
+    CHC_PERF_SEL_REQ_CLIENT21__GFX11                   = 0x00000029,
+    CHC_PERF_SEL_REQ_CLIENT22__GFX11                   = 0x0000002a,
+    CHC_PERF_SEL_REQ_CLIENT23__GFX11                   = 0x0000002b,
+#endif
 } CHC_PERF_SEL;
 
 constexpr unsigned int MaxChcPerfSelGfx101             = CHC_PERF_SEL_REQ_CLIENT14;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxChcPerfSelGfx103Derivative   = CHC_PERF_SEL_REQ_CLIENT19__GFX103PLUSEXCLUSIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxChcPerfSelGfx11              = CHC_PERF_SEL_REQ_CLIENT23__GFX11;
+#endif
 
 typedef enum CmaskAddr {
     CMASK_ADDR_TILED                                   = 0x00000000,
     CMASK_ADDR_LINEAR                                  = 0x00000001,
     CMASK_ADDR_COMPATIBLE                              = 0x00000002,
 } CmaskAddr;
 
 typedef enum CmaskCode {
     CMASK_CLR00_F0                                     = 0x00000000,
     CMASK_CLR00_F1                                     = 0x00000001,
@@ -1386,24 +1818,24 @@ typedef enum ColorFormat {
     COLOR_RESERVED_25                                  = 0x00000019,
     COLOR_RESERVED_26                                  = 0x0000001a,
     COLOR_RESERVED_27                                  = 0x0000001b,
     COLOR_RESERVED_28                                  = 0x0000001c,
     COLOR_RESERVED_29                                  = 0x0000001d,
     COLOR_2_10_10_10_6E4                               = 0x0000001f,
     COLOR_RESERVED_24__GFX09                           = 0x00000018,
     COLOR_RESERVED_30__GFX09                           = 0x0000001e,
     COLOR_RESERVED_24__GFX101                          = 0x00000018,
     COLOR_RESERVED_30__GFX101                          = 0x0000001e,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     COLOR_2_10_10_10_7E3__GFX103COREPLUS               = 0x0000001e,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     COLOR_5_9_9_9__GFX103PLUSEXCLUSIVE                 = 0x00000018,
 #endif
 } ColorFormat;
 
 typedef enum ColorTransform {
     DCC_CT_AUTO                                        = 0x00000000,
     DCC_CT_NONE                                        = 0x00000001,
     ABGR_TO_A_BG_G_RB                                  = 0x00000002,
     BGRA_TO_BG_G_RB_A                                  = 0x00000003,
 } ColorTransform;
@@ -1509,24 +1941,42 @@ typedef enum CPC_PERFCOUNT_SEL {
     CPC_PERF_SEL_CPC_GCRIU_STALL__GFX10COREPLUS        = 0x00000025,
     CPC_PERF_SEL_GCRIU_STALL_WAIT_ON_FREE__GFX10COREPLUS = 0x00000026,
     CPC_PERF_SEL_ME1_STALL_WAIT_ON_TCIU_READ__GFX10COREPLUS = 0x00000027,
     CPC_PERF_SEL_ME2_STALL_WAIT_ON_TCIU_READ__GFX10COREPLUS = 0x00000028,
     CPC_PERF_SEL_CPC_UTCL2IU_XACK__GFX10COREPLUS       = 0x00000029,
     CPC_PERF_SEL_CPC_UTCL2IU_XNACK__GFX10COREPLUS      = 0x0000002a,
     CPC_PERF_SEL_MEC_INSTR_CACHE_HIT__GFX10COREPLUS    = 0x0000002b,
     CPC_PERF_SEL_MEC_INSTR_CACHE_MISS__GFX10COREPLUS   = 0x0000002c,
     CPC_PERF_SEL_MES_THREAD0__GFX10COREPLUS            = 0x0000002d,
     CPC_PERF_SEL_MES_THREAD1__GFX10COREPLUS            = 0x0000002e,
+#if CHIP_HDR_NAVI31
+    CPC_PERF_SEL_ME1_STALL_WAIT_ON_MEM_READ__GFX11     = 0x00000009,
+    CPC_PERF_SEL_ME1_STALL_WAIT_ON_MEM_WRITE__GFX11    = 0x0000000a,
+    CPC_PERF_SEL_ME2_STALL_WAIT_ON_MEM_READ__GFX11     = 0x00000011,
+    CPC_PERF_SEL_ME2_STALL_WAIT_ON_MEM_WRITE__GFX11    = 0x00000012,
+    CPC_PERF_SEL_TCIU_STALL_WAIT_ON_TAGS__GFX11        = 0x0000002f,
+    CPC_PERF_SEL_TCIU_WRITE_REQUEST_SENT__GFX11        = 0x00000030,
+    CPC_PERF_SEL_TCIU_READ_REQUEST_SENT__GFX11         = 0x00000031,
+    CPC_PERF_SEL_GUS_WRITE_REQUEST_SENT__GFX11         = 0x00000032,
+    CPC_PERF_SEL_GUS_READ_REQUEST_SENT__GFX11          = 0x00000033,
+    CPC_PERF_SEL_MEC_THREAD0__GFX11                    = 0x00000034,
+    CPC_PERF_SEL_MEC_THREAD1__GFX11                    = 0x00000035,
+    CPC_PERF_SEL_MEC_THREAD2__GFX11                    = 0x00000036,
+    CPC_PERF_SEL_MEC_THREAD3__GFX11                    = 0x00000037,
+#endif
 } CPC_PERFCOUNT_SEL;
 
 constexpr unsigned int MaxCpcPerfcountSelGfx09         = CPC_PERF_SEL_ME2_DC1_SPI_BUSY__CORE;
 constexpr unsigned int MaxCpcPerfcountSelGfx10Core     = CPC_PERF_SEL_MES_THREAD1__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxCpcPerfcountSelGfx11         = CPC_PERF_SEL_MEC_THREAD3__GFX11;
+#endif
 
 typedef enum CPF_LATENCY_STATS_SEL {
     CPF_LATENCY_STATS_SEL_XACK_MAX                     = 0x00000000,
     CPF_LATENCY_STATS_SEL_XACK_MIN                     = 0x00000001,
     CPF_LATENCY_STATS_SEL_XACK_LAST                    = 0x00000002,
     CPF_LATENCY_STATS_SEL_XNACK_MAX                    = 0x00000003,
     CPF_LATENCY_STATS_SEL_XNACK_MIN                    = 0x00000004,
     CPF_LATENCY_STATS_SEL_XNACK_LAST                   = 0x00000005,
     CPF_LATENCY_STATS_SEL_READ_MAX                     = 0x00000006,
     CPF_LATENCY_STATS_SEL_READ_MIN                     = 0x00000007,
@@ -1571,21 +2021,21 @@ typedef enum CPF_PERFCOUNT_SEL {
     CPF_PERF_SEL_CPF_TCIU_BUSY__GFX09                  = 0x0000001a,
     CPF_PERF_SEL_CPF_TCIU_IDLE__GFX09                  = 0x0000001b,
     CPF_PERF_SEL_CPF_TCIU_STALL__GFX09                 = 0x0000001c,
     CPF_PERF_SEL_CPF_UTCL2IU_BUSY__GFX09               = 0x0000001d,
     CPF_PERF_SEL_CPF_UTCL2IU_IDLE__GFX09               = 0x0000001e,
     CPF_PERF_SEL_CPF_UTCL2IU_STALL__GFX09              = 0x0000001f,
     CPF_PERF_SEL_MIU_STALLED_WAITING_RDREQ_FREE__GFX09_10 = 0x00000001,
     CPF_PERF_SEL_MIU_BUSY_FOR_OUTSTANDING_TAGS__GFX09_10 = 0x00000008,
     CPF_PERF_SEL_CSF_RTS_MIU_NOT_RTR__GFX09_10         = 0x00000009,
     CPF_PERF_SEL_CSF_BUSY_FOR_FECTHINC_STATE__GFX101   = 0x00000007,
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     CPF_PERF_SEL_CSF_BUSY_FOR_FETCHING_STATE__GFX103PLUS = 0x00000007,
 #endif
     CPF_PERF_SEL_GUS_WRITE_REQUEST_SENT__GFX10COREPLUS = 0x0000000f,
     CPF_PERF_SEL_GUS_READ_REQUEST_SENT__GFX10COREPLUS  = 0x00000010,
     CPF_PERF_SEL_TCIU_WRITE_REQUEST_SENT__GFX10COREPLUS = 0x00000016,
     CPF_PERF_SEL_TCIU_READ_REQUEST_SENT__GFX10COREPLUS = 0x00000017,
     CPF_PERF_SEL_CPF_STAT_BUSY__GFX10COREPLUS          = 0x00000018,
     CPF_PERF_SEL_CPF_STAT_IDLE__GFX10COREPLUS          = 0x00000019,
     CPF_PERF_SEL_CPF_STAT_STALL__GFX10COREPLUS         = 0x0000001a,
     CPF_PERF_SEL_CPF_TCIU_BUSY__GFX10COREPLUS          = 0x0000001b,
@@ -1594,26 +2044,35 @@ typedef enum CPF_PERFCOUNT_SEL {
     CPF_PERF_SEL_CPF_UTCL2IU_BUSY__GFX10COREPLUS       = 0x0000001e,
     CPF_PERF_SEL_CPF_UTCL2IU_IDLE__GFX10COREPLUS       = 0x0000001f,
     CPF_PERF_SEL_CPF_UTCL2IU_STALL__GFX10COREPLUS      = 0x00000020,
     CPF_PERF_SEL_CPF_GCRIU_BUSY__GFX10COREPLUS         = 0x00000021,
     CPF_PERF_SEL_CPF_GCRIU_IDLE__GFX10COREPLUS         = 0x00000022,
     CPF_PERF_SEL_CPF_GCRIU_STALL__GFX10COREPLUS        = 0x00000023,
     CPF_PERF_SEL_GCRIU_STALL_WAIT_ON_FREE__GFX10COREPLUS = 0x00000024,
     CPF_PERF_SEL_CSF_BUSY_FOR_FETCHING_DB__GFX10COREPLUS = 0x00000025,
     CPF_PERF_SEL_CPF_UTCL2IU_XACK__GFX10COREPLUS       = 0x00000026,
     CPF_PERF_SEL_CPF_UTCL2IU_XNACK__GFX10COREPLUS      = 0x00000027,
+#if CHIP_HDR_NAVI31
+    CPF_PERF_SEL_CP_SDMA_MNGR_DMA_REQ__GFX11           = 0x00000028,
+    CPF_PERF_SEL_CP_SDMA_MNGR_DMA_DONE__GFX11          = 0x00000029,
+    CPF_PERF_SEL_CP_SDMA_MNGR_LATENCY__GFX11           = 0x0000002a,
+    CPF_PERF_SEL_CP_SDMA_MNGR_SDMABUSY__GFX11          = 0x0000002b,
+#endif
 } CPF_PERFCOUNT_SEL;
 
 constexpr unsigned int MaxCpfPerfcountSelGfx09         = CPF_PERF_SEL_CPF_UTCL2IU_STALL__GFX09;
 constexpr unsigned int MaxCpfPerfcountSelGfx10Core     = CPF_PERF_SEL_CPF_UTCL2IU_XNACK__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxCpfPerfcountSelGfx11         = CPF_PERF_SEL_CP_SDMA_MNGR_SDMABUSY__GFX11;
+#endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef enum CPF_SCRATCH_REG_ATOMIC_OP {
     CPF_SCRATCH_REG_ATOMIC_ADD                         = 0x00000000,
     CPF_SCRATCH_REG_ATOMIC_SUB                         = 0x00000001,
     CPF_SCRATCH_REG_ATOMIC_OR                          = 0x00000002,
     CPF_SCRATCH_REG_ATOMIC_AND                         = 0x00000003,
     CPF_SCRATCH_REG_ATOMIC_NOT                         = 0x00000004,
     CPF_SCRATCH_REG_ATOMIC_MIN                         = 0x00000005,
     CPF_SCRATCH_REG_ATOMIC_MAX                         = 0x00000006,
     CPF_SCRATCH_REG_ATOMIC_CMPSWAP                     = 0x00000007,
 } CPF_SCRATCH_REG_ATOMIC_OP;
@@ -1771,20 +2230,32 @@ typedef enum CPG_PERFCOUNT_SEL {
     CPG_PERF_SEL_ME_STALLED_FOR_DATA_FROM_STQ__GFX10PLUS = 0x00000017,
     CPG_PERF_SEL_ME_STALLED_ON_NO_AVAIL_GFX_CNTX__GFX10PLUS = 0x00000018,
     CPG_PERF_SEL_ME_STALLED_WRITING_TO_RCIU__GFX10PLUS = 0x00000019,
     CPG_PERF_SEL_ME_STALLED_WRITING_CONSTANTS__GFX10PLUS = 0x0000001a,
     CPG_PERF_SEL_ME_STALLED_ON_PARTIAL_FLUSH__GFX10PLUS = 0x0000001b,
     CPG_PERF_SEL_ME_WAIT_ON_CE_COUNTER__GFX10PLUS      = 0x0000001c,
     CPG_PERF_SEL_ME_WAIT_ON_AVAIL_BUFFER__GFX10PLUS    = 0x0000001d,
     CPG_PERF_SEL_LOAD_STALLED_ON_SET_COHERENCY__GFX10PLUS = 0x0000001f,
     CPG_PERF_SEL_DYNAMIC_CLK_VALID__GFX10PLUS          = 0x00000020,
     CPG_PERF_SEL_REGISTER_CLK_VALID__GFX10PLUS         = 0x00000021,
+#if CHIP_HDR_NAVI31
+    CPG_PERF_SEL_PFP_PWS_STALLED0__GFX11               = 0x00000052,
+    CPG_PERF_SEL_ME_PWS_STALLED0__GFX11                = 0x00000053,
+    CPG_PERF_SEL_PFP_VGTDMA_INDR_STRUCT_BYPASS0__GFX11 = 0x00000054,
+    CPG_PERF_SEL_PFP_VGTDMA_INDR_STRUCT_NOT_BYPASS0__GFX11 = 0x00000055,
+    CPG_PERF_SEL_PFP_VGTDMA_DB_ROQ_DATA_STALL0__GFX11  = 0x00000056,
+    CPG_PERF_SEL_PFP_PWS_STALLED1__GFX11               = 0x00000057,
+    CPG_PERF_SEL_ME_PWS_STALLED1__GFX11                = 0x00000058,
+    CPG_PERF_SEL_PFP_VGTDMA_INDR_STRUCT_BYPASS1__GFX11 = 0x00000059,
+    CPG_PERF_SEL_PFP_VGTDMA_INDR_STRUCT_NOT_BYPASS1__GFX11 = 0x0000005a,
+    CPG_PERF_SEL_PFP_VGTDMA_DB_ROQ_DATA_STALL1__GFX11  = 0x0000005b,
+#endif
     CPG_PERF_SEL_SSU_STALLED_ON_CLEAN_SIGNALS__RV1X_RV2X = 0x0000000f,
     CPG_PERF_SEL_QU_STALLED_ON_EOP_DONE_PULSE__RV1X_RV2X = 0x00000010,
     CPG_PERF_SEL_QU_STALLED_ON_EOP_DONE_WR_CONFIRM__RV1X_RV2X = 0x00000011,
     CPG_PERF_SEL_PFP_STALLED_ON_CSF_READY__RV1X_RV2X   = 0x00000012,
     CPG_PERF_SEL_PFP_STALLED_ON_MEQ_READY__RV1X_RV2X   = 0x00000013,
     CPG_PERF_SEL_PFP_STALLED_ON_RCIU_READY__RV1X_RV2X  = 0x00000014,
     CPG_PERF_SEL_PFP_STALLED_FOR_DATA_FROM_ROQ__RV1X_RV2X = 0x00000015,
     CPG_PERF_SEL_ME_STALLED_FOR_DATA_FROM_PFP__RV1X_RV2X = 0x00000016,
     CPG_PERF_SEL_ME_STALLED_FOR_DATA_FROM_STQ__RV1X_RV2X = 0x00000017,
     CPG_PERF_SEL_ME_STALLED_ON_NO_AVAIL_GFX_CNTX__RV1X_RV2X = 0x00000018,
@@ -1868,20 +2339,23 @@ typedef enum CPG_PERFCOUNT_SEL {
     CPG_PERF_SEL_CPG_UTCL2IU_IDLE__VG10_VG12_VG20_RN   = 0x0000003a,
     CPG_PERF_SEL_CPG_UTCL2IU_STALL__VG10_VG12_VG20_RN  = 0x0000003b,
 } CPG_PERFCOUNT_SEL;
 
 constexpr unsigned int MaxCpgPerfcountSelVg10_Vg12_Vg20_Rn = CPG_PERF_SEL_CPG_UTCL2IU_STALL__VG10_VG12_VG20_RN;
 constexpr unsigned int MaxCpgPerfcountSelRv1x_Rv2x     = CPG_PERF_SEL_CPG_UTCL2IU_STALL__RV1X_RV2X;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxCpgPerfcountSelGfx103        = CPG_PERF_SEL_DMA_FETCHER_STALLED_ON_ROQ_FULL__GFX10COREPLUS;
 #endif
 constexpr unsigned int MaxCpgPerfcountSelGfx101        = CPG_PERF_SEL_DMA_FETCHER_STALLED_ON_ROQ_FULL__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxCpgPerfcountSelGfx11         = CPG_PERF_SEL_PFP_VGTDMA_DB_ROQ_DATA_STALL1__GFX11;
+#endif
 
 typedef enum CP_PERFMON_ENABLE_MODE {
     CP_PERFMON_ENABLE_MODE_ALWAYS_COUNT                = 0x00000000,
     CP_PERFMON_ENABLE_MODE_RESERVED_1                  = 0x00000001,
     CP_PERFMON_ENABLE_MODE_COUNT_CONTEXT_TRUE          = 0x00000002,
     CP_PERFMON_ENABLE_MODE_COUNT_CONTEXT_FALSE         = 0x00000003,
 } CP_PERFMON_ENABLE_MODE;
 
 typedef enum CP_PERFMON_STATE {
     CP_PERFMON_STATE_DISABLE_AND_RESET                 = 0x00000000,
@@ -1926,21 +2400,21 @@ typedef enum DepthFormat {
     DEPTH_INVALID                                      = 0x00000000,
     DEPTH_16                                           = 0x00000001,
     DEPTH_X8_24                                        = 0x00000002,
     DEPTH_8_24                                         = 0x00000003,
     DEPTH_X8_24_FLOAT                                  = 0x00000004,
     DEPTH_8_24_FLOAT                                   = 0x00000005,
     DEPTH_32_FLOAT                                     = 0x00000006,
     DEPTH_X24_8_32_FLOAT                               = 0x00000007,
 } DepthFormat;
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef enum DF_MALL_PERF_SEL {
 #if CHIP_HDR_NAVI21
     DF_MALL_PERF_SEL_ML_MTQ_OCC__NV21                  = 0x00000000,
     DF_MALL_PERF_SEL_ML_MRS_OCC__NV21                  = 0x00000001,
     DF_MALL_PERF_SEL_ML_REQ__NV21                      = 0x00000002,
     DF_MALL_PERF_SEL_ML_OPTYPES__NV21                  = 0x00000003,
     DF_MALL_PERF_SEL_ML_CACHE_LKUP_RSP0__NV21          = 0x00000004,
     DF_MALL_PERF_SEL_ML_CACHE_LKUP_RSP1__NV21          = 0x00000005,
     DF_MALL_PERF_SEL_ML_CACHE_TAG_PICK_STALL__NV21     = 0x00000006,
     DF_MALL_PERF_SEL_ML_UMC_PICK_STALL__NV21           = 0x00000007,
@@ -2008,22 +2482,45 @@ typedef enum DF_MALL_PERF_SEL {
     DF_MALL_PERF_SEL_ML_MISC1__NV24                    = 0x00000009,
     DF_MALL_PERF_SEL_MALL_SDP_AVG_LAT_TRANS_CNT__NV24  = 0x00000030,
     DF_MALL_PERF_SEL_MALL_SDP_AVG_LAT_CYCLE_CNT__NV24  = 0x00000031,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT50__NV24      = 0x00000032,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT100__NV24     = 0x00000033,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT150__NV24     = 0x00000034,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT200__NV24     = 0x00000035,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT500__NV24     = 0x00000036,
     DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV24    = 0x00000037,
 #endif
+#if CHIP_HDR_NAVI31
+    DF_MALL_PERF_SEL_ML_MTQ_OCC__NV3X                  = 0x00000000,
+    DF_MALL_PERF_SEL_ML_MRS_OCC__NV3X                  = 0x00000001,
+    DF_MALL_PERF_SEL_ML_REQ__NV3X                      = 0x00000002,
+    DF_MALL_PERF_SEL_ML_OPTYPES__NV3X                  = 0x00000003,
+    DF_MALL_PERF_SEL_ML_CACHE_LKUP_RSP0__NV3X          = 0x00000004,
+    DF_MALL_PERF_SEL_ML_CACHE_LKUP_RSP1__NV3X          = 0x00000005,
+    DF_MALL_PERF_SEL_ML_CACHE_TAG_PICK_STALL__NV3X     = 0x00000006,
+    DF_MALL_PERF_SEL_ML_UMC_PICK_STALL__NV3X           = 0x00000007,
+    DF_MALL_PERF_SEL_ML_MISC0__NV3X                    = 0x00000008,
+    DF_MALL_PERF_SEL_ML_MISC1__NV3X                    = 0x00000009,
+    DF_MALL_PERF_SEL_MALL_SDP_AVG_LAT_TRANS_CNT__NV3X  = 0x00000030,
+    DF_MALL_PERF_SEL_MALL_SDP_AVG_LAT_CYCLE_CNT__NV3X  = 0x00000031,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT50__NV3X      = 0x00000032,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT100__NV3X     = 0x00000033,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT150__NV3X     = 0x00000034,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT200__NV3X     = 0x00000035,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT500__NV3X     = 0x00000036,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV3X    = 0x00000037,
+#endif
 } DF_MALL_PERF_SEL;
 
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxDfMallPerfSelNv3x            = DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV3X;
+#endif
 #if CHIP_HDR_NAVI24
 constexpr unsigned int MaxDfMallPerfSelNv24            = DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV24;
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxDfMallPerfSelNv23            = DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV23;
 #endif
 #if CHIP_HDR_NAVI22
 constexpr unsigned int MaxDfMallPerfSelNv22            = DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV22;
 #endif
 #if CHIP_HDR_NAVI21
@@ -2069,21 +2566,21 @@ typedef enum GCRPerfSel {
     GCR_PERF_SEL_CPC_GL1_ALL_REQ__GFX101               = 0x0000003b,
     GCR_PERF_SEL_CPC_METADATA_REQ__GFX101              = 0x0000003c,
     GCR_PERF_SEL_CPC_SQC_DATA_REQ__GFX101              = 0x0000003d,
     GCR_PERF_SEL_CPC_SQC_INST_REQ__GFX101              = 0x0000003e,
     GCR_PERF_SEL_CPC_TCP_REQ__GFX101                   = 0x0000003f,
     GCR_PERF_SEL_CPC_TCP_TLB_SHOOTDOWN_REQ__GFX101     = 0x00000040,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     GCR_PERF_SEL_CPC_TCP_TLB_SHOOTDOWN_REQ__GFX103     = 0x00000030,
     GCR_PERF_SEL_CPG_TCP_TLB_SHOOTDOWN_REQ__GFX103     = 0x00000040,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     GCR_PERF_SEL_CPC_ALL_REQ__GFX103COREPLUS           = 0x00000021,
     GCR_PERF_SEL_CPC_GL2_RANGE_REQ__GFX103COREPLUS     = 0x00000022,
     GCR_PERF_SEL_CPC_GL2_RANGE_LT16K_REQ__GFX103COREPLUS = 0x00000023,
     GCR_PERF_SEL_CPC_GL2_RANGE_16K_REQ__GFX103COREPLUS = 0x00000024,
     GCR_PERF_SEL_CPC_GL2_RANGE_GT16K_REQ__GFX103COREPLUS = 0x00000025,
     GCR_PERF_SEL_CPC_GL2_ALL_REQ__GFX103COREPLUS       = 0x00000026,
     GCR_PERF_SEL_CPC_GL1_RANGE_REQ__GFX103COREPLUS     = 0x00000027,
     GCR_PERF_SEL_CPC_GL1_RANGE_LT16K_REQ__GFX103COREPLUS = 0x00000028,
     GCR_PERF_SEL_CPC_GL1_RANGE_16K_REQ__GFX103COREPLUS = 0x00000029,
     GCR_PERF_SEL_CPC_GL1_RANGE_GT16K_REQ__GFX103COREPLUS = 0x0000002a,
@@ -2146,20 +2643,26 @@ typedef enum GCRPerfSel {
     GCR_PERF_SEL_TLB_SHOOTDOWN_LIGHT_REQ__GFX10COREPLUS = 0x00000054,
     GCR_PERF_SEL_ALL_REQ__GFX10COREPLUS                = 0x00000055,
     GCR_PERF_SEL_CLK_FOR_PHY_OUTSTANDING_REQ__GFX10COREPLUS = 0x00000056,
     GCR_PERF_SEL_CLK_FOR_VIRT_OUTSTANDING_REQ__GFX10COREPLUS = 0x00000057,
     GCR_PERF_SEL_CLK_FOR_ALL_OUTSTANDING_REQ__GFX10COREPLUS = 0x00000058,
     GCR_PERF_SEL_UTCL2_REQ__GFX10COREPLUS              = 0x00000059,
     GCR_PERF_SEL_UTCL2_RET__GFX10COREPLUS              = 0x0000005a,
     GCR_PERF_SEL_UTCL2_OUT_OF_CREDIT_EVENT__GFX10COREPLUS = 0x0000005b,
     GCR_PERF_SEL_UTCL2_INFLIGHT_REQ__GFX10COREPLUS     = 0x0000005c,
     GCR_PERF_SEL_UTCL2_FILTERED_RET__GFX10COREPLUS     = 0x0000005d,
+#if CHIP_HDR_NAVI31
+    GCR_PERF_SEL_SDMA0_GL1_TLB_SHOOTDOWN_REQ__GFX11    = 0x00000010,
+    GCR_PERF_SEL_CPC_GL1_TLB_SHOOTDOWN_REQ__GFX11      = 0x00000030,
+    GCR_PERF_SEL_CPG_GL1_TLB_SHOOTDOWN_REQ__GFX11      = 0x00000040,
+    GCR_PERF_SEL_CPF_GL1_TLB_SHOOTDOWN_REQ__GFX11      = 0x00000050,
+#endif
 #if CHIP_HDR_NAVI21
     GCR_PERF_SEL_SDMA1_ALL_REQ__NV21                   = 0x00000011,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_REQ__NV21             = 0x00000012,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_LT16K_REQ__NV21       = 0x00000013,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_16K_REQ__NV21         = 0x00000014,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_GT16K_REQ__NV21       = 0x00000015,
     GCR_PERF_SEL_SDMA1_GL2_ALL_REQ__NV21               = 0x00000016,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_REQ__NV21             = 0x00000017,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_LT16K_REQ__NV21       = 0x00000018,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_16K_REQ__NV21         = 0x00000019,
@@ -2313,20 +2816,99 @@ typedef enum GCRPerfSel {
     GCR_PERF_SEL_PIO_GL1_RANGE_REQ__NV24               = 0x00000064,
     GCR_PERF_SEL_PIO_GL1_RANGE_LT16K_REQ__NV24         = 0x00000065,
     GCR_PERF_SEL_PIO_GL1_RANGE_16K_REQ__NV24           = 0x00000066,
     GCR_PERF_SEL_PIO_GL1_RANGE_GT16K_REQ__NV24         = 0x00000067,
     GCR_PERF_SEL_PIO_GL1_ALL_REQ__NV24                 = 0x00000068,
     GCR_PERF_SEL_PIO_METADATA_REQ__NV24                = 0x00000069,
     GCR_PERF_SEL_PIO_SQC_DATA_REQ__NV24                = 0x0000006a,
     GCR_PERF_SEL_PIO_SQC_INST_REQ__NV24                = 0x0000006b,
     GCR_PERF_SEL_PIO_TCP_REQ__NV24                     = 0x0000006c,
     GCR_PERF_SEL_PIO_TCP_TLB_SHOOTDOWN_REQ__NV24       = 0x0000006d,
+#endif
+#if CHIP_HDR_NAVI31
+    GCR_PERF_SEL_SDMA1_ALL_REQ__NV3X                   = 0x00000011,
+    GCR_PERF_SEL_SDMA1_GL2_RANGE_REQ__NV3X             = 0x00000012,
+    GCR_PERF_SEL_SDMA1_GL2_RANGE_LT16K_REQ__NV3X       = 0x00000013,
+    GCR_PERF_SEL_SDMA1_GL2_RANGE_16K_REQ__NV3X         = 0x00000014,
+    GCR_PERF_SEL_SDMA1_GL2_RANGE_GT16K_REQ__NV3X       = 0x00000015,
+    GCR_PERF_SEL_SDMA1_GL2_ALL_REQ__NV3X               = 0x00000016,
+    GCR_PERF_SEL_SDMA1_GL1_RANGE_REQ__NV3X             = 0x00000017,
+    GCR_PERF_SEL_SDMA1_GL1_RANGE_LT16K_REQ__NV3X       = 0x00000018,
+    GCR_PERF_SEL_SDMA1_GL1_RANGE_16K_REQ__NV3X         = 0x00000019,
+    GCR_PERF_SEL_SDMA1_GL1_RANGE_GT16K_REQ__NV3X       = 0x0000001a,
+    GCR_PERF_SEL_SDMA1_GL1_ALL_REQ__NV3X               = 0x0000001b,
+    GCR_PERF_SEL_SDMA1_METADATA_REQ__NV3X              = 0x0000001c,
+    GCR_PERF_SEL_SDMA1_SQC_DATA_REQ__NV3X              = 0x0000001d,
+    GCR_PERF_SEL_SDMA1_SQC_INST_REQ__NV3X              = 0x0000001e,
+    GCR_PERF_SEL_SDMA1_TCP_REQ__NV3X                   = 0x0000001f,
+    GCR_PERF_SEL_SDMA1_GL1_TLB_SHOOTDOWN_REQ__NV3X     = 0x00000020,
+    GCR_PERF_SEL_PMM_ABIT_NUM_FLUSH__NV3X              = 0x0000005e,
+    GCR_PERF_SEL_PMM_ABIT_FLUSH_ONGOING__NV3X          = 0x0000005f,
+    GCR_PERF_SEL_PMM_NUM_INTERRUPT__NV3X               = 0x00000060,
+    GCR_PERF_SEL_PMM_STALL_PMM_IH_CREDITS__NV3X        = 0x00000061,
+    GCR_PERF_SEL_PMM_INTERRUPT_READY_TO_SEND__NV3X     = 0x00000062,
+    GCR_PERF_SEL_PMM_ABIT_TIMER_FLUSH__NV3X            = 0x00000063,
+    GCR_PERF_SEL_PMM_ABIT_FORCE_FLUSH__NV3X            = 0x00000064,
+    GCR_PERF_SEL_PMM_ABIT_FLUSH_INTERRUPT__NV3X        = 0x00000065,
+    GCR_PERF_SEL_PMM_ALOG_INTERRUPT__NV3X              = 0x00000066,
+    GCR_PERF_SEL_PMM_MAM_FLUSH_REQ__NV3X               = 0x00000067,
+    GCR_PERF_SEL_PMM_MAM_FLUSH_RESP__NV3X              = 0x00000068,
+    GCR_PERF_SEL_PMM_RLC_CGCG_REQ__NV3X                = 0x00000069,
+    GCR_PERF_SEL_PMM_RLC_CGCG_RESP__NV3X               = 0x0000006a,
+    GCR_PERF_SEL_RLC_ALL_REQ__NV3X                     = 0x0000006b,
+    GCR_PERF_SEL_RLC_GL2_RANGE_REQ__NV3X               = 0x0000006c,
+    GCR_PERF_SEL_RLC_GL2_RANGE_LT16K_REQ__NV3X         = 0x0000006d,
+    GCR_PERF_SEL_RLC_GL2_RANGE_16K_REQ__NV3X           = 0x0000006e,
+    GCR_PERF_SEL_RLC_GL2_RANGE_GT16K_REQ__NV3X         = 0x0000006f,
+    GCR_PERF_SEL_RLC_GL2_ALL_REQ__NV3X                 = 0x00000070,
+    GCR_PERF_SEL_RLC_GL1_RANGE_REQ__NV3X               = 0x00000071,
+    GCR_PERF_SEL_RLC_GL1_RANGE_LT16K_REQ__NV3X         = 0x00000072,
+    GCR_PERF_SEL_RLC_GL1_RANGE_16K_REQ__NV3X           = 0x00000073,
+    GCR_PERF_SEL_RLC_GL1_RANGE_GT16K_REQ__NV3X         = 0x00000074,
+    GCR_PERF_SEL_RLC_GL1_ALL_REQ__NV3X                 = 0x00000075,
+    GCR_PERF_SEL_RLC_METADATA_REQ__NV3X                = 0x00000076,
+    GCR_PERF_SEL_RLC_SQC_DATA_REQ__NV3X                = 0x00000077,
+    GCR_PERF_SEL_RLC_SQC_INST_REQ__NV3X                = 0x00000078,
+    GCR_PERF_SEL_RLC_TCP_REQ__NV3X                     = 0x00000079,
+    GCR_PERF_SEL_RLC_GL1_TLB_SHOOTDOWN_REQ__NV3X       = 0x0000007a,
+    GCR_PERF_SEL_PM_ALL_REQ__NV3X                      = 0x0000007b,
+    GCR_PERF_SEL_PM_GL2_RANGE_REQ__NV3X                = 0x0000007c,
+    GCR_PERF_SEL_PM_GL2_RANGE_LT16K_REQ__NV3X          = 0x0000007d,
+    GCR_PERF_SEL_PM_GL2_RANGE_16K_REQ__NV3X            = 0x0000007e,
+    GCR_PERF_SEL_PM_GL2_RANGE_GT16K_REQ__NV3X          = 0x0000007f,
+    GCR_PERF_SEL_PM_GL2_ALL_REQ__NV3X                  = 0x00000080,
+    GCR_PERF_SEL_PM_GL1_RANGE_REQ__NV3X                = 0x00000081,
+    GCR_PERF_SEL_PM_GL1_RANGE_LT16K_REQ__NV3X          = 0x00000082,
+    GCR_PERF_SEL_PM_GL1_RANGE_16K_REQ__NV3X            = 0x00000083,
+    GCR_PERF_SEL_PM_GL1_RANGE_GT16K_REQ__NV3X          = 0x00000084,
+    GCR_PERF_SEL_PM_GL1_ALL_REQ__NV3X                  = 0x00000085,
+    GCR_PERF_SEL_PM_METADATA_REQ__NV3X                 = 0x00000086,
+    GCR_PERF_SEL_PM_SQC_DATA_REQ__NV3X                 = 0x00000087,
+    GCR_PERF_SEL_PM_SQC_INST_REQ__NV3X                 = 0x00000088,
+    GCR_PERF_SEL_PM_TCP_REQ__NV3X                      = 0x00000089,
+    GCR_PERF_SEL_PM_GL1_TLB_SHOOTDOWN_REQ__NV3X        = 0x0000008a,
+    GCR_PERF_SEL_PIO_ALL_REQ__NV3X                     = 0x0000008b,
+    GCR_PERF_SEL_PIO_GL2_RANGE_REQ__NV3X               = 0x0000008c,
+    GCR_PERF_SEL_PIO_GL2_RANGE_LT16K_REQ__NV3X         = 0x0000008d,
+    GCR_PERF_SEL_PIO_GL2_RANGE_16K_REQ__NV3X           = 0x0000008e,
+    GCR_PERF_SEL_PIO_GL2_RANGE_GT16K_REQ__NV3X         = 0x0000008f,
+    GCR_PERF_SEL_PIO_GL2_ALL_REQ__NV3X                 = 0x00000090,
+    GCR_PERF_SEL_PIO_GL1_RANGE_REQ__NV3X               = 0x00000091,
+    GCR_PERF_SEL_PIO_GL1_RANGE_LT16K_REQ__NV3X         = 0x00000092,
+    GCR_PERF_SEL_PIO_GL1_RANGE_16K_REQ__NV3X           = 0x00000093,
+    GCR_PERF_SEL_PIO_GL1_RANGE_GT16K_REQ__NV3X         = 0x00000094,
+    GCR_PERF_SEL_PIO_GL1_ALL_REQ__NV3X                 = 0x00000095,
+    GCR_PERF_SEL_PIO_METADATA_REQ__NV3X                = 0x00000096,
+    GCR_PERF_SEL_PIO_SQC_DATA_REQ__NV3X                = 0x00000097,
+    GCR_PERF_SEL_PIO_SQC_INST_REQ__NV3X                = 0x00000098,
+    GCR_PERF_SEL_PIO_TCP_REQ__NV3X                     = 0x00000099,
+    GCR_PERF_SEL_PIO_GL1_TLB_SHOOTDOWN_REQ__NV3X       = 0x0000009a,
 #endif
     GCR_PERF_SEL_SDMA1_ALL_REQ__OSS50                  = 0x00000011,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_REQ__OSS50            = 0x00000012,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_LT16K_REQ__OSS50      = 0x00000013,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_16K_REQ__OSS50        = 0x00000014,
     GCR_PERF_SEL_SDMA1_GL2_RANGE_GT16K_REQ__OSS50      = 0x00000015,
     GCR_PERF_SEL_SDMA1_GL2_ALL_REQ__OSS50              = 0x00000016,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_REQ__OSS50            = 0x00000017,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_LT16K_REQ__OSS50      = 0x00000018,
     GCR_PERF_SEL_SDMA1_GL1_RANGE_16K_REQ__OSS50        = 0x00000019,
@@ -2345,20 +2927,23 @@ constexpr unsigned int MaxGCRPerfSelNv21               = GCR_PERF_SEL_PIO_TCP_TL
 #endif
 #if CHIP_HDR_NAVI24
 constexpr unsigned int MaxGCRPerfSelNv24               = GCR_PERF_SEL_PIO_TCP_TLB_SHOOTDOWN_REQ__NV24;
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxGCRPerfSelNv23               = GCR_PERF_SEL_PIO_TCP_TLB_SHOOTDOWN_REQ__NV23;
 #endif
 #if CHIP_HDR_NAVI22
 constexpr unsigned int MaxGCRPerfSelNv22               = GCR_PERF_SEL_PIO_TCP_TLB_SHOOTDOWN_REQ__NV22;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGCRPerfSelNv3x               = GCR_PERF_SEL_PIO_GL1_TLB_SHOOTDOWN_REQ__NV3X;
+#endif
 
 typedef enum GDS_PERFCOUNT_SELECT {
     GDS_PERF_SEL_DS_ADDR_CONFL__GFX09                  = 0x00000000,
     GDS_PERF_SEL_DS_BANK_CONFL__GFX09                  = 0x00000001,
     GDS_PERF_SEL_WBUF_FLUSH__GFX09                     = 0x00000002,
     GDS_PERF_SEL_WR_COMP__GFX09                        = 0x00000003,
     GDS_PERF_SEL_WBUF_WR__GFX09                        = 0x00000004,
     GDS_PERF_SEL_RBUF_HIT__GFX09                       = 0x00000005,
     GDS_PERF_SEL_RBUF_MISS__GFX09                      = 0x00000006,
     GDS_PERF_SEL_SE0_SH0_NORET__GFX09                  = 0x00000007,
@@ -2712,47 +3297,200 @@ typedef enum GDS_PERFCOUNT_SELECT {
     GDS_PERF_SEL_SE3_SH1_GDS_WR_OP__GFX103             = 0x00000070,
     GDS_PERF_SEL_SE3_SH1_GDS_RD_OP__GFX103             = 0x00000071,
     GDS_PERF_SEL_SE3_SH1_GDS_ATOM_OP__GFX103           = 0x00000072,
     GDS_PERF_SEL_SE3_SH1_GDS_REL_OP__GFX103            = 0x00000073,
     GDS_PERF_SEL_SE3_SH1_GDS_CMPXCH_OP__GFX103         = 0x00000074,
     GDS_PERF_SEL_SE3_SH1_GDS_BYTE_OP__GFX103           = 0x00000075,
     GDS_PERF_SEL_SE3_SH1_GDS_SHORT_OP__GFX103          = 0x00000076,
     GDS_PERF_SEL_GWS_RELEASED__GFX103                  = 0x00000077,
     GDS_PERF_SEL_GWS_BYPASS__GFX103                    = 0x00000078,
 #endif
+#if CHIP_HDR_NAVI31
+    GDS_PERF_SEL_WR_COMP__GFX11                        = 0x00000000,
+    GDS_PERF_SEL_WBUF_WR__GFX11                        = 0x00000001,
+    GDS_PERF_SEL_SE0_NORET__GFX11                      = 0x00000002,
+    GDS_PERF_SEL_SE0_RET__GFX11                        = 0x00000003,
+    GDS_PERF_SEL_SE0_ORD_CNT__GFX11                    = 0x00000004,
+    GDS_PERF_SEL_SE0_2COMP_REQ__GFX11                  = 0x00000005,
+    GDS_PERF_SEL_SE0_ORD_WAVE_VALID__GFX11             = 0x00000006,
+    GDS_PERF_SEL_SE0_GDS_STALL_BY_ORD__GFX11           = 0x00000007,
+    GDS_PERF_SEL_SE0_GDS_WR_OP__GFX11                  = 0x00000008,
+    GDS_PERF_SEL_SE0_GDS_RD_OP__GFX11                  = 0x00000009,
+    GDS_PERF_SEL_SE0_GDS_ATOM_OP__GFX11                = 0x0000000a,
+    GDS_PERF_SEL_SE0_GDS_REL_OP__GFX11                 = 0x0000000b,
+    GDS_PERF_SEL_SE0_GDS_CMPXCH_OP__GFX11              = 0x0000000c,
+    GDS_PERF_SEL_SE0_GDS_BYTE_OP__GFX11                = 0x0000000d,
+    GDS_PERF_SEL_SE0_GDS_SHORT_OP__GFX11               = 0x0000000e,
+    GDS_PERF_SEL_SE1_NORET__GFX11                      = 0x0000000f,
+    GDS_PERF_SEL_SE1_RET__GFX11                        = 0x00000010,
+    GDS_PERF_SEL_SE1_ORD_CNT__GFX11                    = 0x00000011,
+    GDS_PERF_SEL_SE1_2COMP_REQ__GFX11                  = 0x00000012,
+    GDS_PERF_SEL_SE1_ORD_WAVE_VALID__GFX11             = 0x00000013,
+    GDS_PERF_SEL_SE1_GDS_STALL_BY_ORD__GFX11           = 0x00000014,
+    GDS_PERF_SEL_SE1_GDS_WR_OP__GFX11                  = 0x00000015,
+    GDS_PERF_SEL_SE1_GDS_RD_OP__GFX11                  = 0x00000016,
+    GDS_PERF_SEL_SE1_GDS_ATOM_OP__GFX11                = 0x00000017,
+    GDS_PERF_SEL_SE1_GDS_REL_OP__GFX11                 = 0x00000018,
+    GDS_PERF_SEL_SE1_GDS_CMPXCH_OP__GFX11              = 0x00000019,
+    GDS_PERF_SEL_SE1_GDS_BYTE_OP__GFX11                = 0x0000001a,
+    GDS_PERF_SEL_SE1_GDS_SHORT_OP__GFX11               = 0x0000001b,
+    GDS_PERF_SEL_SE2_NORET__GFX11                      = 0x0000001c,
+    GDS_PERF_SEL_SE2_RET__GFX11                        = 0x0000001d,
+    GDS_PERF_SEL_SE2_ORD_CNT__GFX11                    = 0x0000001e,
+    GDS_PERF_SEL_SE2_2COMP_REQ__GFX11                  = 0x0000001f,
+    GDS_PERF_SEL_SE2_ORD_WAVE_VALID__GFX11             = 0x00000020,
+    GDS_PERF_SEL_SE2_GDS_STALL_BY_ORD__GFX11           = 0x00000021,
+    GDS_PERF_SEL_SE2_GDS_WR_OP__GFX11                  = 0x00000022,
+    GDS_PERF_SEL_SE2_GDS_RD_OP__GFX11                  = 0x00000023,
+    GDS_PERF_SEL_SE2_GDS_ATOM_OP__GFX11                = 0x00000024,
+    GDS_PERF_SEL_SE2_GDS_REL_OP__GFX11                 = 0x00000025,
+    GDS_PERF_SEL_SE2_GDS_CMPXCH_OP__GFX11              = 0x00000026,
+    GDS_PERF_SEL_SE2_GDS_BYTE_OP__GFX11                = 0x00000027,
+    GDS_PERF_SEL_SE2_GDS_SHORT_OP__GFX11               = 0x00000028,
+    GDS_PERF_SEL_SE3_NORET__GFX11                      = 0x00000029,
+    GDS_PERF_SEL_SE3_RET__GFX11                        = 0x0000002a,
+    GDS_PERF_SEL_SE3_ORD_CNT__GFX11                    = 0x0000002b,
+    GDS_PERF_SEL_SE3_2COMP_REQ__GFX11                  = 0x0000002c,
+    GDS_PERF_SEL_SE3_ORD_WAVE_VALID__GFX11             = 0x0000002d,
+    GDS_PERF_SEL_SE3_GDS_STALL_BY_ORD__GFX11           = 0x0000002e,
+    GDS_PERF_SEL_SE3_GDS_WR_OP__GFX11                  = 0x0000002f,
+    GDS_PERF_SEL_SE3_GDS_RD_OP__GFX11                  = 0x00000030,
+    GDS_PERF_SEL_SE3_GDS_ATOM_OP__GFX11                = 0x00000031,
+    GDS_PERF_SEL_SE3_GDS_REL_OP__GFX11                 = 0x00000032,
+    GDS_PERF_SEL_SE3_GDS_CMPXCH_OP__GFX11              = 0x00000033,
+    GDS_PERF_SEL_SE3_GDS_BYTE_OP__GFX11                = 0x00000034,
+    GDS_PERF_SEL_SE3_GDS_SHORT_OP__GFX11               = 0x00000035,
+    GDS_PERF_SEL_SE4_NORET__GFX11                      = 0x00000036,
+    GDS_PERF_SEL_SE4_RET__GFX11                        = 0x00000037,
+    GDS_PERF_SEL_SE4_ORD_CNT__GFX11                    = 0x00000038,
+    GDS_PERF_SEL_SE4_2COMP_REQ__GFX11                  = 0x00000039,
+    GDS_PERF_SEL_SE4_ORD_WAVE_VALID__GFX11             = 0x0000003a,
+    GDS_PERF_SEL_SE4_GDS_STALL_BY_ORD__GFX11           = 0x0000003b,
+    GDS_PERF_SEL_SE4_GDS_WR_OP__GFX11                  = 0x0000003c,
+    GDS_PERF_SEL_SE4_GDS_RD_OP__GFX11                  = 0x0000003d,
+    GDS_PERF_SEL_SE4_GDS_ATOM_OP__GFX11                = 0x0000003e,
+    GDS_PERF_SEL_SE4_GDS_REL_OP__GFX11                 = 0x0000003f,
+    GDS_PERF_SEL_SE4_GDS_CMPXCH_OP__GFX11              = 0x00000040,
+    GDS_PERF_SEL_SE4_GDS_BYTE_OP__GFX11                = 0x00000041,
+    GDS_PERF_SEL_SE4_GDS_SHORT_OP__GFX11               = 0x00000042,
+    GDS_PERF_SEL_SE5_NORET__GFX11                      = 0x00000043,
+    GDS_PERF_SEL_SE5_RET__GFX11                        = 0x00000044,
+    GDS_PERF_SEL_SE5_ORD_CNT__GFX11                    = 0x00000045,
+    GDS_PERF_SEL_SE5_2COMP_REQ__GFX11                  = 0x00000046,
+    GDS_PERF_SEL_SE5_ORD_WAVE_VALID__GFX11             = 0x00000047,
+    GDS_PERF_SEL_SE5_GDS_STALL_BY_ORD__GFX11           = 0x00000048,
+    GDS_PERF_SEL_SE5_GDS_WR_OP__GFX11                  = 0x00000049,
+    GDS_PERF_SEL_SE5_GDS_RD_OP__GFX11                  = 0x0000004a,
+    GDS_PERF_SEL_SE5_GDS_ATOM_OP__GFX11                = 0x0000004b,
+    GDS_PERF_SEL_SE5_GDS_REL_OP__GFX11                 = 0x0000004c,
+    GDS_PERF_SEL_SE5_GDS_CMPXCH_OP__GFX11              = 0x0000004d,
+    GDS_PERF_SEL_SE5_GDS_BYTE_OP__GFX11                = 0x0000004e,
+    GDS_PERF_SEL_SE5_GDS_SHORT_OP__GFX11               = 0x0000004f,
+    GDS_PERF_SEL_SE6_NORET__GFX11                      = 0x00000050,
+    GDS_PERF_SEL_SE6_RET__GFX11                        = 0x00000051,
+    GDS_PERF_SEL_SE6_ORD_CNT__GFX11                    = 0x00000052,
+    GDS_PERF_SEL_SE6_2COMP_REQ__GFX11                  = 0x00000053,
+    GDS_PERF_SEL_SE6_ORD_WAVE_VALID__GFX11             = 0x00000054,
+    GDS_PERF_SEL_SE6_GDS_STALL_BY_ORD__GFX11           = 0x00000055,
+    GDS_PERF_SEL_SE6_GDS_WR_OP__GFX11                  = 0x00000056,
+    GDS_PERF_SEL_SE6_GDS_RD_OP__GFX11                  = 0x00000057,
+    GDS_PERF_SEL_SE6_GDS_ATOM_OP__GFX11                = 0x00000058,
+    GDS_PERF_SEL_SE6_GDS_REL_OP__GFX11                 = 0x00000059,
+    GDS_PERF_SEL_SE6_GDS_CMPXCH_OP__GFX11              = 0x0000005a,
+    GDS_PERF_SEL_SE6_GDS_BYTE_OP__GFX11                = 0x0000005b,
+    GDS_PERF_SEL_SE6_GDS_SHORT_OP__GFX11               = 0x0000005c,
+    GDS_PERF_SEL_SE7_NORET__GFX11                      = 0x0000005d,
+    GDS_PERF_SEL_SE7_RET__GFX11                        = 0x0000005e,
+    GDS_PERF_SEL_SE7_ORD_CNT__GFX11                    = 0x0000005f,
+    GDS_PERF_SEL_SE7_2COMP_REQ__GFX11                  = 0x00000060,
+    GDS_PERF_SEL_SE7_ORD_WAVE_VALID__GFX11             = 0x00000061,
+    GDS_PERF_SEL_SE7_GDS_STALL_BY_ORD__GFX11           = 0x00000062,
+    GDS_PERF_SEL_SE7_GDS_WR_OP__GFX11                  = 0x00000063,
+    GDS_PERF_SEL_SE7_GDS_RD_OP__GFX11                  = 0x00000064,
+    GDS_PERF_SEL_SE7_GDS_ATOM_OP__GFX11                = 0x00000065,
+    GDS_PERF_SEL_SE7_GDS_REL_OP__GFX11                 = 0x00000066,
+    GDS_PERF_SEL_SE7_GDS_CMPXCH_OP__GFX11              = 0x00000067,
+    GDS_PERF_SEL_SE7_GDS_BYTE_OP__GFX11                = 0x00000068,
+    GDS_PERF_SEL_SE7_GDS_SHORT_OP__GFX11               = 0x00000069,
+    GDS_PERF_SEL_GWS_RELEASED__GFX11                   = 0x0000006a,
+    GDS_PERF_SEL_GWS_BYPASS__GFX11                     = 0x0000006b,
+    GDS_PERF_SEL_SE0_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x0000006c,
+    GDS_PERF_SEL_SE0_GS_ORD_CNT_REL_DONE__GFX11        = 0x0000006d,
+    GDS_PERF_SEL_SE0_ADD_GS_REG_OP__GFX11              = 0x0000006e,
+    GDS_PERF_SEL_SE0_SUB_GS_REG_OP__GFX11              = 0x0000006f,
+    GDS_PERF_SEL_SE0_GS_WAVE_ID_VALID__GFX11           = 0x00000070,
+    GDS_PERF_SEL_SE1_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x00000071,
+    GDS_PERF_SEL_SE1_GS_ORD_CNT_REL_DONE__GFX11        = 0x00000072,
+    GDS_PERF_SEL_SE1_ADD_GS_REG_OP__GFX11              = 0x00000073,
+    GDS_PERF_SEL_SE1_SUB_GS_REG_OP__GFX11              = 0x00000074,
+    GDS_PERF_SEL_SE1_GS_WAVE_ID_VALID__GFX11           = 0x00000075,
+    GDS_PERF_SEL_SE2_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x00000076,
+    GDS_PERF_SEL_SE2_GS_ORD_CNT_REL_DONE__GFX11        = 0x00000077,
+    GDS_PERF_SEL_SE2_ADD_GS_REG_OP__GFX11              = 0x00000078,
+    GDS_PERF_SEL_SE2_SUB_GS_REG_OP__GFX11              = 0x00000079,
+    GDS_PERF_SEL_SE2_GS_WAVE_ID_VALID__GFX11           = 0x0000007a,
+    GDS_PERF_SEL_SE3_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x0000007b,
+    GDS_PERF_SEL_SE3_GS_ORD_CNT_REL_DONE__GFX11        = 0x0000007c,
+    GDS_PERF_SEL_SE3_ADD_GS_REG_OP__GFX11              = 0x0000007d,
+    GDS_PERF_SEL_SE3_SUB_GS_REG_OP__GFX11              = 0x0000007e,
+    GDS_PERF_SEL_SE3_GS_WAVE_ID_VALID__GFX11           = 0x0000007f,
+    GDS_PERF_SEL_SE4_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x00000080,
+    GDS_PERF_SEL_SE4_GS_ORD_CNT_REL_DONE__GFX11        = 0x00000081,
+    GDS_PERF_SEL_SE4_ADD_GS_REG_OP__GFX11              = 0x00000082,
+    GDS_PERF_SEL_SE4_SUB_GS_REG_OP__GFX11              = 0x00000083,
+    GDS_PERF_SEL_SE4_GS_WAVE_ID_VALID__GFX11           = 0x00000084,
+    GDS_PERF_SEL_SE5_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x00000085,
+    GDS_PERF_SEL_SE5_GS_ORD_CNT_REL_DONE__GFX11        = 0x00000086,
+    GDS_PERF_SEL_SE5_ADD_GS_REG_OP__GFX11              = 0x00000087,
+    GDS_PERF_SEL_SE5_SUB_GS_REG_OP__GFX11              = 0x00000088,
+    GDS_PERF_SEL_SE5_GS_WAVE_ID_VALID__GFX11           = 0x00000089,
+    GDS_PERF_SEL_SE6_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x0000008a,
+    GDS_PERF_SEL_SE6_GS_ORD_CNT_REL_DONE__GFX11        = 0x0000008b,
+    GDS_PERF_SEL_SE6_ADD_GS_REG_OP__GFX11              = 0x0000008c,
+    GDS_PERF_SEL_SE6_SUB_GS_REG_OP__GFX11              = 0x0000008d,
+    GDS_PERF_SEL_SE6_GS_WAVE_ID_VALID__GFX11           = 0x0000008e,
+    GDS_PERF_SEL_SE7_GS_ORD_CNT_NOT_REL_NOT_DONE__GFX11 = 0x0000008f,
+    GDS_PERF_SEL_SE7_GS_ORD_CNT_REL_DONE__GFX11        = 0x00000090,
+    GDS_PERF_SEL_SE7_ADD_GS_REG_OP__GFX11              = 0x00000091,
+    GDS_PERF_SEL_SE7_SUB_GS_REG_OP__GFX11              = 0x00000092,
+    GDS_PERF_SEL_SE7_GS_WAVE_ID_VALID__GFX11           = 0x00000093,
+#endif
 } GDS_PERFCOUNT_SELECT;
 
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxGdsPerfcountSelectGfx103     = GDS_PERF_SEL_GWS_BYPASS__GFX103;
 #endif
 constexpr unsigned int MaxGdsPerfcountSelectGfx09      = GDS_PERF_SEL_GWS_BYPASS__GFX09;
 constexpr unsigned int MaxGdsPerfcountSelectGfx101     = GDS_PERF_SEL_GWS_BYPASS__GFX101;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGdsPerfcountSelectGfx11      = GDS_PERF_SEL_SE7_GS_WAVE_ID_VALID__GFX11;
+#endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef enum GE1_PERFCOUNT_SELECT {
     ge1_assembler_busy                                 = 0x00000000,
     ge1_assembler_stalled                              = 0x00000001,
     ge1_dma_busy                                       = 0x00000002,
     ge1_dma_lat_bin_0                                  = 0x00000003,
     ge1_dma_lat_bin_1                                  = 0x00000004,
     ge1_dma_lat_bin_2                                  = 0x00000005,
     ge1_dma_lat_bin_3                                  = 0x00000006,
     ge1_dma_lat_bin_4                                  = 0x00000007,
     ge1_dma_lat_bin_5                                  = 0x00000008,
     ge1_dma_lat_bin_6                                  = 0x00000009,
     ge1_dma_lat_bin_7                                  = 0x0000000a,
     ge1_dma_return_cl0                                 = 0x0000000b,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     ge1_bypass_fifo_full__GFX103                       = 0x00000020,
     ge1_vert_group_limit_hit__GFX103                   = 0x00000023,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     ge1_dma_return_cl1__GFX103COREPLUS                 = 0x0000000c,
     ge1_dma_utcl1_consecutive_retry_event__GFX103COREPLUS = 0x0000000d,
     ge1_dma_utcl1_request_event__GFX103COREPLUS        = 0x0000000e,
     ge1_dma_utcl1_retry_event__GFX103COREPLUS          = 0x0000000f,
     ge1_dma_utcl1_stall_event__GFX103COREPLUS          = 0x00000010,
     ge1_dma_utcl1_stall_utcl2_event__GFX103COREPLUS    = 0x00000011,
     ge1_dma_utcl1_translation_hit_event__GFX103COREPLUS = 0x00000012,
     ge1_dma_utcl1_translation_miss_event__GFX103COREPLUS = 0x00000013,
     ge1_assembler_dma_starved__GFX103COREPLUS          = 0x00000014,
     ge1_rbiu_di_fifo_stalled_p0__GFX103COREPLUS        = 0x00000015,
@@ -2766,23 +3504,27 @@ typedef enum GE1_PERFCOUNT_SELECT {
     ge1_pipe1_to_pipe0__GFX103COREPLUS                 = 0x0000001d,
     ge1_dma_return_size_cl0__GFX103COREPLUS            = 0x0000001e,
     ge1_dma_return_size_cl1__GFX103COREPLUS            = 0x0000001f,
     ge1_sclk_input_vld__GFX103COREPLUS                 = 0x00000021,
     ge1_prim_group_limit_hit__GFX103COREPLUS           = 0x00000022,
     ge1_rbiu_di_fifo_stalled_p1__GFX103COREPLUS        = 0x00000024,
     ge1_rbiu_di_fifo_starved_p1__GFX103COREPLUS        = 0x00000025,
     ge1_rbiu_dr_fifo_stalled_p1__GFX103COREPLUS        = 0x00000026,
     ge1_rbiu_dr_fifo_starved_p1__GFX103COREPLUS        = 0x00000027,
 #endif
+#if CHIP_HDR_NAVI31
+    ge1_small_draws_one_instance__GFX11                = 0x00000020,
+    ge1_unopt_multi_instance_draws__GFX11              = 0x00000023,
+#endif
 } GE1_PERFCOUNT_SELECT;
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 constexpr unsigned int MaxGe1PerfcountSelectGfx103CorePlus = ge1_rbiu_dr_fifo_starved_p1__GFX103COREPLUS;
 #endif
 
 typedef enum GE2_DIST_PERFCOUNT_SELECT {
     ge_dist_hs_done                                    = 0x00000000,
     ge_dist_hs_done_latency_se0                        = 0x00000001,
     ge_dist_hs_done_latency_se1                        = 0x00000002,
     ge_dist_hs_done_latency_se2                        = 0x00000003,
     ge_dist_hs_done_latency_se3                        = 0x00000004,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
@@ -2838,25 +3580,126 @@ typedef enum GE2_DIST_PERFCOUNT_SELECT {
     ge_se3_te11_starved_on_hs_done__GFX103DERIVATIVE   = 0x00000036,
     ge_dist_op_fifo_full_starve__GFX103DERIVATIVE      = 0x00000037,
     ge_dist_hs_done_se0__GFX103DERIVATIVE              = 0x00000038,
     ge_dist_hs_done_se1__GFX103DERIVATIVE              = 0x00000039,
     ge_dist_hs_done_se2__GFX103DERIVATIVE              = 0x0000003a,
     ge_dist_hs_done_se3__GFX103DERIVATIVE              = 0x0000003b,
     ge_dist_hs_done_latency__GFX103DERIVATIVE          = 0x0000003c,
     ge_dist_distributer_busy__GFX103DERIVATIVE         = 0x0000003d,
     ge_tf_ret_data_stalling_hs_done__GFX103DERIVATIVE  = 0x0000003e,
 #endif
+#if CHIP_HDR_NAVI31
+    ge_dist_hs_done_latency_se4__GFX11                 = 0x00000005,
+    ge_dist_hs_done_latency_se5__GFX11                 = 0x00000006,
+    ge_dist_hs_done_latency_se6__GFX11                 = 0x00000007,
+    ge_dist_hs_done_latency_se7__GFX11                 = 0x00000008,
+    ge_dist_inside_tf_bin_0__GFX11                     = 0x00000009,
+    ge_dist_inside_tf_bin_1__GFX11                     = 0x0000000a,
+    ge_dist_inside_tf_bin_2__GFX11                     = 0x0000000b,
+    ge_dist_inside_tf_bin_3__GFX11                     = 0x0000000c,
+    ge_dist_inside_tf_bin_4__GFX11                     = 0x0000000d,
+    ge_dist_inside_tf_bin_5__GFX11                     = 0x0000000e,
+    ge_dist_inside_tf_bin_6__GFX11                     = 0x0000000f,
+    ge_dist_inside_tf_bin_7__GFX11                     = 0x00000010,
+    ge_dist_inside_tf_bin_8__GFX11                     = 0x00000011,
+    ge_dist_null_patch__GFX11                          = 0x00000012,
+    ge_dist_sclk_core_vld__GFX11                       = 0x00000013,
+    ge_dist_sclk_wd_te11_vld__GFX11                    = 0x00000014,
+    ge_dist_tfreq_lat_bin_0__GFX11                     = 0x00000015,
+    ge_dist_tfreq_lat_bin_1__GFX11                     = 0x00000016,
+    ge_dist_tfreq_lat_bin_2__GFX11                     = 0x00000017,
+    ge_dist_tfreq_lat_bin_3__GFX11                     = 0x00000018,
+    ge_dist_tfreq_lat_bin_4__GFX11                     = 0x00000019,
+    ge_dist_tfreq_lat_bin_5__GFX11                     = 0x0000001a,
+    ge_dist_tfreq_lat_bin_6__GFX11                     = 0x0000001b,
+    ge_dist_tfreq_lat_bin_7__GFX11                     = 0x0000001c,
+    ge_dist_tfreq_utcl1_consecutive_retry_event__GFX11 = 0x0000001d,
+    ge_dist_tfreq_utcl1_request_event__GFX11           = 0x0000001e,
+    ge_dist_tfreq_utcl1_retry_event__GFX11             = 0x0000001f,
+    ge_dist_tfreq_utcl1_stall_event__GFX11             = 0x00000020,
+    ge_dist_tfreq_utcl1_stall_utcl2_event__GFX11       = 0x00000021,
+    ge_dist_tfreq_utcl1_translation_hit_event__GFX11   = 0x00000022,
+    ge_dist_tfreq_utcl1_translation_miss_event__GFX11  = 0x00000023,
+    ge_dist_pc_feorder_fifo_full__GFX11                = 0x00000024,
+    ge_dist_pc_ge_manager_busy__GFX11                  = 0x00000025,
+    ge_dist_sclk_input_vld__GFX11                      = 0x00000026,
+    ge_dist_wd_te11_busy__GFX11                        = 0x00000027,
+    ge_dist_te11_starved__GFX11                        = 0x00000028,
+    ge_dist_switch_mode_stall__GFX11                   = 0x00000029,
+    ge_all_tf_eq__GFX11                                = 0x0000002a,
+    ge_all_tf2__GFX11                                  = 0x0000002b,
+    ge_all_tf3__GFX11                                  = 0x0000002c,
+    ge_all_tf4__GFX11                                  = 0x0000002d,
+    ge_all_tf5__GFX11                                  = 0x0000002e,
+    ge_all_tf6__GFX11                                  = 0x0000002f,
+    ge_se0_te11_starved_on_hs_done__GFX11              = 0x00000030,
+    ge_se1_te11_starved_on_hs_done__GFX11              = 0x00000031,
+    ge_se2_te11_starved_on_hs_done__GFX11              = 0x00000032,
+    ge_se3_te11_starved_on_hs_done__GFX11              = 0x00000033,
+    ge_se4_te11_starved_on_hs_done__GFX11              = 0x00000034,
+    ge_se5_te11_starved_on_hs_done__GFX11              = 0x00000035,
+    ge_se6_te11_starved_on_hs_done__GFX11              = 0x00000036,
+    ge_se7_te11_starved_on_hs_done__GFX11              = 0x00000037,
+    ge_dist_op_fifo_full_starve__GFX11                 = 0x00000038,
+    ge_dist_hs_done_se0__GFX11                         = 0x00000039,
+    ge_dist_hs_done_se1__GFX11                         = 0x0000003a,
+    ge_dist_hs_done_se2__GFX11                         = 0x0000003b,
+    ge_dist_hs_done_se3__GFX11                         = 0x0000003c,
+    ge_dist_hs_done_se4__GFX11                         = 0x0000003d,
+    ge_dist_hs_done_se5__GFX11                         = 0x0000003e,
+    ge_dist_hs_done_se6__GFX11                         = 0x0000003f,
+    ge_dist_hs_done_se7__GFX11                         = 0x00000040,
+    ge_dist_hs_done_latency__GFX11                     = 0x00000041,
+    ge_dist_distributer_busy__GFX11                    = 0x00000042,
+    ge_tf_ret_data_stalling_hs_done__GFX11             = 0x00000043,
+    ge_num_of_no_dist_patches__GFX11                   = 0x00000044,
+    ge_num_of_donut_dist_patches__GFX11                = 0x00000045,
+    ge_num_of_patch_dist_patches__GFX11                = 0x00000046,
+    ge_num_of_se_switches_due_to_patch_accum__GFX11    = 0x00000047,
+    ge_num_of_se_switches_due_to_donut__GFX11          = 0x00000048,
+    ge_num_of_se_switches_due_to_trap__GFX11           = 0x00000049,
+    ge_num_of_hs_dealloc_events__GFX11                 = 0x0000004a,
+    ge_agm_gcr_req__GFX11                              = 0x0000004b,
+    ge_agm_gcr_tag_stall__GFX11                        = 0x0000004c,
+    ge_agm_gcr_crd_stall__GFX11                        = 0x0000004d,
+    ge_agm_gcr_stall__GFX11                            = 0x0000004e,
+    ge_agm_gcr_latency__GFX11                          = 0x0000004f,
+    ge_distclk_vld__GFX11                              = 0x00000050,
+    ge_dist_indx_fifos_full_and_empty__GFX11           = 0x00000051,
+    ge_hs_done_all_tf0_se0__GFX11                      = 0x00000052,
+    ge_hs_done_all_tf0_se1__GFX11                      = 0x00000053,
+    ge_hs_done_all_tf0_se2__GFX11                      = 0x00000054,
+    ge_hs_done_all_tf0_se3__GFX11                      = 0x00000055,
+    ge_hs_done_all_tf0_se4__GFX11                      = 0x00000056,
+    ge_hs_done_all_tf0_se5__GFX11                      = 0x00000057,
+    ge_hs_done_all_tf0_se6__GFX11                      = 0x00000058,
+    ge_hs_done_all_tf0_se7__GFX11                      = 0x00000059,
+    ge_hs_done_all_tf1_se0__GFX11                      = 0x0000005a,
+    ge_hs_done_all_tf1_se1__GFX11                      = 0x0000005b,
+    ge_hs_done_all_tf1_se2__GFX11                      = 0x0000005c,
+    ge_hs_done_all_tf1_se3__GFX11                      = 0x0000005d,
+    ge_hs_done_all_tf1_se4__GFX11                      = 0x0000005e,
+    ge_hs_done_all_tf1_se5__GFX11                      = 0x0000005f,
+    ge_hs_done_all_tf1_se6__GFX11                      = 0x00000060,
+    ge_hs_done_all_tf1_se7__GFX11                      = 0x00000061,
+    ge_agm_gcr_req_outstanding__GFX11                  = 0x00000062,
+    ge_agm_gcr_req_amount__GFX11                       = 0x00000063,
+    ge_agm_gcr_combine__GFX11                          = 0x00000064,
+#endif
 } GE2_DIST_PERFCOUNT_SELECT;
 
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxGe2DistPerfcountSelectGfx103Derivative = ge_tf_ret_data_stalling_hs_done__GFX103DERIVATIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGe2DistPerfcountSelectGfx11  = ge_agm_gcr_combine__GFX11;
+#endif
 
 typedef enum GE2_SE_PERFCOUNT_SELECT {
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     ge_se_es_ring_high_water_mark__GFX103              = 0x00000008,
     ge_se_es_thread_groups__GFX103                     = 0x00000009,
     ge_se_esthread_stalled_es_rb_full__GFX103          = 0x0000000a,
     ge_se_esthread_stalled_spi_bp__GFX103              = 0x0000000b,
     ge_se_esvert_stalled_gs_event__GFX103              = 0x0000000c,
     ge_se_esvert_stalled_gs_tbl__GFX103                = 0x0000000d,
     ge_se_esvert_stalled_gsprim__GFX103                = 0x0000000e,
@@ -2988,25 +3831,118 @@ typedef enum GE2_SE_PERFCOUNT_SELECT {
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     ge_se_cm_reading_stalled__GFX103DERIVATIVE         = 0x00000000,
     ge_se_cm_stalled_by_gog__GFX103DERIVATIVE          = 0x00000001,
     ge_se_cm_stalled_by_gsfetch_done__GFX103DERIVATIVE = 0x00000002,
     ge_se_ds_cache_hits__GFX103DERIVATIVE              = 0x00000003,
     ge_se_ds_prims__GFX103DERIVATIVE                   = 0x00000004,
     ge_se_es_done__GFX103DERIVATIVE                    = 0x00000005,
     ge_se_es_done_latency__GFX103DERIVATIVE            = 0x00000006,
     ge_se_es_flush__GFX103DERIVATIVE                   = 0x00000007,
 #endif
+#if CHIP_HDR_NAVI31
+    ge_se_ds_prims__GFX11                              = 0x00000000,
+    ge_se_es_thread_groups__GFX11                      = 0x00000001,
+    ge_se_esvert_stalled_gsprim__GFX11                 = 0x00000002,
+    ge_se_hs_tfm_stall__GFX11                          = 0x00000003,
+    ge_se_hs_tgs_active_high_water_mark__GFX11         = 0x00000004,
+    ge_se_hs_thread_groups__GFX11                      = 0x00000005,
+    ge_se_reused_es_indices__GFX11                     = 0x00000006,
+    ge_se_sclk_ngg_vld__GFX11                          = 0x00000007,
+    ge_se_sclk_te11_vld__GFX11                         = 0x00000008,
+    ge_se_spi_esvert_eov__GFX11                        = 0x00000009,
+    ge_se_spi_esvert_stalled__GFX11                    = 0x0000000a,
+    ge_se_spi_esvert_starved_busy__GFX11               = 0x0000000b,
+    ge_se_spi_esvert_valid__GFX11                      = 0x0000000c,
+    ge_se_spi_gsprim_cont__GFX11                       = 0x0000000d,
+    ge_se_spi_gsprim_eov__GFX11                        = 0x0000000e,
+    ge_se_spi_gsprim_stalled__GFX11                    = 0x0000000f,
+    ge_se_spi_gsprim_starved_busy__GFX11               = 0x00000010,
+    ge_se_spi_gsprim_valid__GFX11                      = 0x00000011,
+    ge_se_spi_gssubgrp_is_event__GFX11                 = 0x00000012,
+    ge_se_spi_gssubgrp_send__GFX11                     = 0x00000013,
+    ge_se_spi_hsvert_eov__GFX11                        = 0x00000014,
+    ge_se_spi_hsvert_stalled__GFX11                    = 0x00000015,
+    ge_se_spi_hsvert_starved_busy__GFX11               = 0x00000016,
+    ge_se_spi_hsvert_valid__GFX11                      = 0x00000017,
+    ge_se_spi_hsgrp_is_event__GFX11                    = 0x00000018,
+    ge_se_spi_hsgrp_send__GFX11                        = 0x00000019,
+    ge_se_spi_lsvert_eov__GFX11                        = 0x0000001a,
+    ge_se_spi_lsvert_stalled__GFX11                    = 0x0000001b,
+    ge_se_spi_lsvert_starved_busy__GFX11               = 0x0000001c,
+    ge_se_spi_lsvert_valid__GFX11                      = 0x0000001d,
+    ge_se_spi_hsvert_fifo_full_stall__GFX11            = 0x0000001e,
+    ge_se_spi_tgrp_fifo_stall__GFX11                   = 0x0000001f,
+    ge_spi_hsgrp_spi_stall__GFX11                      = 0x00000020,
+    ge_se_spi_gssubgrp_event_window_active__GFX11      = 0x00000021,
+    ge_se_hs_input_stall__GFX11                        = 0x00000022,
+    ge_se_sending_vert_or_prim__GFX11                  = 0x00000023,
+    ge_se_sclk_input_vld__GFX11                        = 0x00000024,
+    ge_spi_lswave_fifo_full_stall__GFX11               = 0x00000025,
+    ge_spi_hswave_fifo_full_stall__GFX11               = 0x00000026,
+    ge_hs_tif_stall__GFX11                             = 0x00000027,
+    ge_csb_spi_bp__GFX11                               = 0x00000028,
+    ge_ngg_starving_for_wave_id__GFX11                 = 0x00000029,
+    ge_pa0_csb_eop__GFX11                              = 0x0000002a,
+    ge_ngg_starved_idle__GFX11                         = 0x0000002b,
+    ge_gsprim_send__GFX11                              = 0x0000002c,
+    ge_esvert_send__GFX11                              = 0x0000002d,
+    ge_ngg_starved_after_work__GFX11                   = 0x0000002e,
+    ge_ngg_subgrp_fifo_stall__GFX11                    = 0x0000002f,
+    ge_ngg_ord_id_req_stall__GFX11                     = 0x00000030,
+    ge_ngg_indx_bus_stall__GFX11                       = 0x00000031,
+    ge_hs_stall_tfmm_fifo_full__GFX11                  = 0x00000032,
+    ge_gs_issue_rtr_stalled__GFX11                     = 0x00000033,
+    ge_gsprim_stalled_esvert__GFX11                    = 0x00000034,
+    ge_gsthread_stalled__GFX11                         = 0x00000035,
+    ge_ngg_attr_grp_alloc__GFX11                       = 0x00000036,
+    ge_ngg_attr_discard_alloc__GFX11                   = 0x00000037,
+    ge_ngg_pc_space_not_avail__GFX11                   = 0x00000038,
+    ge_ngg_agm_req_stall__GFX11                        = 0x00000039,
+    ge_ngg_spi_esvert_partial_eov__GFX11               = 0x0000003a,
+    ge_ngg_spi_gsprim_partial_eov__GFX11               = 0x0000003b,
+    ge_spi_gsgrp_valid__GFX11                          = 0x0000003c,
+    ge_ngg_attr_grp_latency__GFX11                     = 0x0000003d,
+    ge_ngg_reuse_prim_limit_hit__GFX11                 = 0x0000003e,
+    ge_ngg_reuse_vert_limit_hit__GFX11                 = 0x0000003f,
+    ge_te11_con_stall__GFX11                           = 0x00000040,
+    ge_te11_compactor_starved__GFX11                   = 0x00000041,
+    ge_ngg_stall_tess_off_tess_on__GFX11               = 0x00000042,
+    ge_ngg_stall_tess_on_tess_off__GFX11               = 0x00000043,
+    ge_merged_lses_vert_stalled__GFX11                 = 0x00000044,
+    ge_merged_hsgs_vert_stalled__GFX11                 = 0x00000045,
+    ge_merged_hsgs_grp_stalled__GFX11                  = 0x00000046,
+    ge_merge_lses_fifo_blocked__GFX11                  = 0x00000047,
+    ge_merge_hsgs_fifo_blocked__GFX11                  = 0x00000048,
+    ge_merge_lses_vert_switch__GFX11                   = 0x00000049,
+    ge_merge_hsgs_vert_switch__GFX11                   = 0x0000004a,
+    ge_merge_hsgs_grp_switch__GFX11                    = 0x0000004b,
+    ge_merge_gsgrp_rdy_pending_verts__GFX11            = 0x0000004c,
+    ge_merge_hsgrp_rdy_pending_verts__GFX11            = 0x0000004d,
+    ge_se_ds_cache_hits__GFX11                         = 0x0000004e,
+    ge_se_api_vs_verts__GFX11                          = 0x0000004f,
+    ge_se_api_ds_verts__GFX11                          = 0x00000050,
+    ge_se_combined_busy__GFX11                         = 0x00000051,
+    ge_spi_lsvert_send__GFX11                          = 0x00000052,
+    ge_spi_hsvert_send__GFX11                          = 0x00000053,
+    ge_ngg_attr_grp_wasted__GFX11                      = 0x00000054,
+    ge_spi_gssubgrp_stalled__GFX11                     = 0x00000055,
+    ge_ngg_attr_null_dealloc__GFX11                    = 0x00000056,
+    ge_ngg_busy_base__GFX11                            = 0x00000057,
+#endif
 } GE2_SE_PERFCOUNT_SELECT;
 
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxGe2SePerfcountSelectGfx103   = ge_hs_stall_tfmm_fifo_full__GFX103;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGe2SePerfcountSelectGfx11    = ge_ngg_busy_base__GFX11;
+#endif
 #endif
 
 typedef enum GE_PERFCOUNT_SELECT {
     ge_assembler_busy__GFX101                          = 0x00000000,
     ge_assembler_stalled__GFX101                       = 0x00000001,
     ge_cm_reading_stalled__GFX101                      = 0x00000002,
     ge_cm_stalled_by_gog__GFX101                       = 0x00000003,
     ge_cm_stalled_by_gsfetch_done__GFX101              = 0x00000004,
     ge_dma_busy__GFX101                                = 0x00000005,
     ge_dma_lat_bin_0__GFX101                           = 0x00000006,
@@ -3359,21 +4295,21 @@ typedef enum GL1A_PERF_SEL {
     GL1A_PERF_SEL_REQ_ARB_LEVEL_GL1C0__GFX101          = 0x0000001a,
     GL1A_PERF_SEL_REQ_ARB_LEVEL_GL1C1__GFX101          = 0x0000001b,
     GL1A_PERF_SEL_REQ_ARB_LEVEL_GL1C2__GFX101          = 0x0000001c,
     GL1A_PERF_SEL_REQ_ARB_LEVEL_GL1C3__GFX101          = 0x0000001d,
     GL1A_PERF_SEL_REQ_INFLIGHT_LEVEL__GFX101           = 0x0000001e,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C0__GFX101     = 0x0000001f,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C1__GFX101     = 0x00000020,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C2__GFX101     = 0x00000021,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C3__GFX101     = 0x00000022,
     GL1A_PERF_SEL_CYCLE__GFX101                        = 0x00000023,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     GL1A_PERF_SEL_REQUEST_GL1C0__GFX103PLUSEXCLUSIVE   = 0x00000005,
     GL1A_PERF_SEL_REQUEST_GL1C1__GFX103PLUSEXCLUSIVE   = 0x00000006,
     GL1A_PERF_SEL_REQUEST_GL1C2__GFX103PLUSEXCLUSIVE   = 0x00000007,
     GL1A_PERF_SEL_REQUEST_GL1C3__GFX103PLUSEXCLUSIVE   = 0x00000008,
     GL1A_PERF_SEL_WDS_32B_GL1C0__GFX103PLUSEXCLUSIVE   = 0x00000009,
     GL1A_PERF_SEL_WDS_32B_GL1C1__GFX103PLUSEXCLUSIVE   = 0x0000000a,
     GL1A_PERF_SEL_WDS_32B_GL1C2__GFX103PLUSEXCLUSIVE   = 0x0000000b,
     GL1A_PERF_SEL_WDS_32B_GL1C3__GFX103PLUSEXCLUSIVE   = 0x0000000c,
     GL1A_PERF_SEL_BURST_COUNT_GL1C0__GFX103PLUSEXCLUSIVE = 0x0000000d,
     GL1A_PERF_SEL_BURST_COUNT_GL1C1__GFX103PLUSEXCLUSIVE = 0x0000000e,
@@ -3383,21 +4319,21 @@ typedef enum GL1A_PERF_SEL {
     GL1A_PERF_SEL_REQ_INFLIGHT_LEVEL__GFX103PLUSEXCLUSIVE = 0x00000012,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C0__GFX103PLUSEXCLUSIVE = 0x00000013,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C1__GFX103PLUSEXCLUSIVE = 0x00000014,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C2__GFX103PLUSEXCLUSIVE = 0x00000015,
     GL1A_PERF_SEL_STALL_RET_CONFLICT_GL1C3__GFX103PLUSEXCLUSIVE = 0x00000016,
     GL1A_PERF_SEL_CYCLE__GFX103PLUSEXCLUSIVE           = 0x00000017,
 #endif
 } GL1A_PERF_SEL;
 
 constexpr unsigned int MaxGl1aPerfSelGfx101            = GL1A_PERF_SEL_CYCLE__GFX101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 constexpr unsigned int MaxGl1aPerfSelGfx103PlusExclusive = GL1A_PERF_SEL_CYCLE__GFX103PLUSEXCLUSIVE;
 #endif
 
 typedef enum GL1C_PERF_SEL {
     GL1C_PERF_SEL_CYCLE                                = 0x00000000,
     GL1C_PERF_SEL_BUSY                                 = 0x00000001,
     GL1C_PERF_SEL_STARVE                               = 0x00000002,
     GL1C_PERF_SEL_ARB_RET_LEVEL                        = 0x00000003,
     GL1C_PERF_SEL_GL2_REQ_READ                         = 0x00000004,
     GL1C_PERF_SEL_GL2_REQ_READ_128B                    = 0x00000005,
@@ -3468,21 +4404,21 @@ typedef enum GL1C_PERF_SEL {
     GL1C_PERF_SEL_UTCL0_STALL_MULTI_MISS__GFX103DERIVATIVE = 0x0000004a,
     GL1C_PERF_SEL_UTCL0_STALL_UTCL1_REQ_OUT_OF_CREDITS__GFX103DERIVATIVE = 0x0000004b,
     GL1C_PERF_SEL_UTCL0_UTCL1_PERM_FAULT__GFX103DERIVATIVE = 0x0000004c,
     GL1C_PERF_SEL_CLIENT_UTCL0_INFLIGHT__GFX103DERIVATIVE = 0x0000004d,
     GL1C_PERF_SEL_UTCL0_UTCL1_INFLIGHT__GFX103DERIVATIVE = 0x0000004e,
     GL1C_PERF_SEL_UTCL0_INTERNAL_RETRY_REQ__GFX103DERIVATIVE = 0x0000004f,
     GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_RETRY_FAULT__GFX103DERIVATIVE = 0x00000050,
     GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_PRT_FAULT__GFX103DERIVATIVE = 0x00000051,
     GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_NO_RETRY_FAULT__GFX103DERIVATIVE = 0x00000052,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     GL1C_PERF_SEL_STALL_VM__GFX103PLUSEXCLUSIVE        = 0x00000024,
     GL1C_PERF_SEL_REQ_CLIENT0__GFX103PLUSEXCLUSIVE     = 0x00000025,
     GL1C_PERF_SEL_REQ_CLIENT1__GFX103PLUSEXCLUSIVE     = 0x00000026,
     GL1C_PERF_SEL_REQ_CLIENT2__GFX103PLUSEXCLUSIVE     = 0x00000027,
     GL1C_PERF_SEL_REQ_CLIENT3__GFX103PLUSEXCLUSIVE     = 0x00000028,
     GL1C_PERF_SEL_REQ_CLIENT4__GFX103PLUSEXCLUSIVE     = 0x00000029,
     GL1C_PERF_SEL_REQ_CLIENT5__GFX103PLUSEXCLUSIVE     = 0x0000002a,
     GL1C_PERF_SEL_REQ_CLIENT6__GFX103PLUSEXCLUSIVE     = 0x0000002b,
     GL1C_PERF_SEL_REQ_CLIENT7__GFX103PLUSEXCLUSIVE     = 0x0000002c,
     GL1C_PERF_SEL_REQ_CLIENT8__GFX103PLUSEXCLUSIVE     = 0x0000002d,
@@ -3503,26 +4439,46 @@ typedef enum GL1C_PERF_SEL {
     GL1C_PERF_SEL_REQ_CLIENT23__GFX103PLUSEXCLUSIVE    = 0x0000003c,
     GL1C_PERF_SEL_REQ_CLIENT24__GFX103PLUSEXCLUSIVE    = 0x0000003d,
     GL1C_PERF_SEL_REQ_CLIENT25__GFX103PLUSEXCLUSIVE    = 0x0000003e,
     GL1C_PERF_SEL_REQ_CLIENT26__GFX103PLUSEXCLUSIVE    = 0x0000003f,
     GL1C_PERF_SEL_REQ_CLIENT27__GFX103PLUSEXCLUSIVE    = 0x00000040,
     GL1C_PERF_SEL_UTCL0_REQUEST__GFX103PLUSEXCLUSIVE   = 0x00000041,
     GL1C_PERF_SEL_UTCL0_TRANSLATION_HIT__GFX103PLUSEXCLUSIVE = 0x00000042,
     GL1C_PERF_SEL_UTCL0_TRANSLATION_MISS__GFX103PLUSEXCLUSIVE = 0x00000043,
     GL1C_PERF_SEL_UTCL0_PERMISSION_MISS__GFX103PLUSEXCLUSIVE = 0x00000044,
 #endif
+#if CHIP_HDR_NAVI31
+    GL1C_PERF_SEL_UTCL0_MISS_UNDER_MISS__GFX11         = 0x00000045,
+    GL1C_PERF_SEL_UTCL0_LFIFO_FULL__GFX11              = 0x00000046,
+    GL1C_PERF_SEL_UTCL0_STALL_INFLIGHT_MAX__GFX11      = 0x00000047,
+    GL1C_PERF_SEL_UTCL0_STALL_LFIFO_NOT_RES__GFX11     = 0x00000048,
+    GL1C_PERF_SEL_UTCL0_STALL_LRU_INFLIGHT__GFX11      = 0x00000049,
+    GL1C_PERF_SEL_UTCL0_STALL_MISSFIFO_FULL__GFX11     = 0x0000004a,
+    GL1C_PERF_SEL_UTCL0_STALL_MULTI_MISS__GFX11        = 0x0000004b,
+    GL1C_PERF_SEL_UTCL0_STALL_UTCL1_REQ_OUT_OF_CREDITS__GFX11 = 0x0000004c,
+    GL1C_PERF_SEL_UTCL0_UTCL1_PERM_FAULT__GFX11        = 0x0000004d,
+    GL1C_PERF_SEL_CLIENT_UTCL0_INFLIGHT__GFX11         = 0x0000004e,
+    GL1C_PERF_SEL_UTCL0_UTCL1_INFLIGHT__GFX11          = 0x0000004f,
+    GL1C_PERF_SEL_UTCL0_INTERNAL_RETRY_REQ__GFX11      = 0x00000050,
+    GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_RETRY_FAULT__GFX11 = 0x00000051,
+    GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_PRT_FAULT__GFX11   = 0x00000052,
+    GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_NO_RETRY_FAULT__GFX11 = 0x00000053,
+#endif
 } GL1C_PERF_SEL;
 
 constexpr unsigned int MaxGl1cPerfSelGfx101            = GL1C_PERF_SEL_REQ_CLIENT27__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxGl1cPerfSelGfx103Derivative  = GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_NO_RETRY_FAULT__GFX103DERIVATIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGl1cPerfSelGfx11             = GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_NO_RETRY_FAULT__GFX11;
+#endif
 
 typedef enum GL1_CACHE_POLICIES {
     GL1_CACHE_POLICY_MISS_LRU                          = 0x00000000,
     GL1_CACHE_POLICY_MISS_EVICT                        = 0x00000001,
     GL1_CACHE_POLICY_HIT_LRU                           = 0x00000002,
     GL1_CACHE_POLICY_HIT_EVICT                         = 0x00000003,
 } GL1_CACHE_POLICIES;
 
 typedef enum GL1_CACHE_STORE_POLICIES {
     GL1_CACHE_STORE_POLICY_BYPASS                      = 0x00000000,
@@ -3613,23 +4569,44 @@ typedef enum GL2A_PERF_SEL {
     GL2A_PERF_SEL_REQ_BURST_CLIENT6                    = 0x00000051,
     GL2A_PERF_SEL_REQ_BURST_CLIENT7                    = 0x00000052,
     GL2A_PERF_SEL_REQ_BURST_CLIENT8                    = 0x00000053,
     GL2A_PERF_SEL_REQ_BURST_CLIENT9                    = 0x00000054,
     GL2A_PERF_SEL_REQ_BURST_CLIENT10                   = 0x00000055,
     GL2A_PERF_SEL_REQ_BURST_CLIENT11                   = 0x00000056,
     GL2A_PERF_SEL_REQ_BURST_CLIENT12                   = 0x00000057,
     GL2A_PERF_SEL_REQ_BURST_CLIENT13                   = 0x00000058,
     GL2A_PERF_SEL_REQ_BURST_CLIENT14                   = 0x00000059,
     GL2A_PERF_SEL_REQ_BURST_CLIENT15                   = 0x0000005a,
+#if CHIP_HDR_NAVI31
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT0__GFX104PLUS = 0x0000005b,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT1__GFX104PLUS = 0x0000005c,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT2__GFX104PLUS = 0x0000005d,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT3__GFX104PLUS = 0x0000005e,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT4__GFX104PLUS = 0x0000005f,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT5__GFX104PLUS = 0x00000060,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT6__GFX104PLUS = 0x00000061,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT7__GFX104PLUS = 0x00000062,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT8__GFX104PLUS = 0x00000063,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT9__GFX104PLUS = 0x00000064,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT10__GFX104PLUS = 0x00000065,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT11__GFX104PLUS = 0x00000067,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT12__GFX104PLUS = 0x00000068,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT13__GFX104PLUS = 0x00000069,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT14__GFX104PLUS = 0x0000006a,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT15__GFX104PLUS = 0x0000006b,
+#endif
 } GL2A_PERF_SEL;
 
 constexpr unsigned int MaxGl2aPerfSelGfx10Core         = GL2A_PERF_SEL_REQ_BURST_CLIENT15;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGl2aPerfSelGfx104Plus        = GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT15__GFX104PLUS;
+#endif
 
 typedef enum GL2C_PERF_SEL {
     GL2C_PERF_SEL_NONE                                 = 0x00000000,
     GL2C_PERF_SEL_CYCLE                                = 0x00000001,
     GL2C_PERF_SEL_BUSY                                 = 0x00000002,
     GL2C_PERF_SEL_REQ                                  = 0x00000003,
     GL2C_PERF_SEL_VOL_REQ                              = 0x00000004,
     GL2C_PERF_SEL_HIGH_PRIORITY_REQ                    = 0x00000005,
     GL2C_PERF_SEL_READ                                 = 0x00000006,
     GL2C_PERF_SEL_WRITE                                = 0x00000007,
@@ -3853,21 +4830,21 @@ typedef enum GL2C_PERF_SEL {
     GL2C_PERF_SEL_CM_COMP_STENCIL_REQ__GFX101          = 0x000000e1,
     GL2C_PERF_SEL_CM_COMP_DEPTH16_REQ__GFX101          = 0x000000e2,
     GL2C_PERF_SEL_CM_COMP_DEPTH32_REQ__GFX101          = 0x000000e3,
     GL2C_PERF_SEL_CM_COLOR_32B_WR_REQ__GFX101          = 0x000000e4,
     GL2C_PERF_SEL_CM_COLOR_64B_WR_REQ__GFX101          = 0x000000e5,
     GL2C_PERF_SEL_CM_FULL_WRITE_REQ__GFX101            = 0x000000e6,
     GL2C_PERF_SEL_CM_RVF_FULL__GFX101                  = 0x000000e7,
     GL2C_PERF_SEL_CM_SDR_FULL__GFX101                  = 0x000000e8,
     GL2C_PERF_SEL_CM_MERGE_BUF_FULL__GFX101            = 0x000000e9,
     GL2C_PERF_SEL_CM_DCC_STALL__GFX101                 = 0x000000ea,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     GL2C_PERF_SEL_EA_WRREQ_SNOOP__GFX103COREPLUS       = 0x00000054,
     GL2C_PERF_SEL_EA_WRREQ_64B__GFX103COREPLUS         = 0x00000055,
     GL2C_PERF_SEL_EA_WRREQ_PROBE_COMMAND__GFX103COREPLUS = 0x00000056,
     GL2C_PERF_SEL_EA_WR_UNCACHED_32B__GFX103COREPLUS   = 0x00000057,
     GL2C_PERF_SEL_EA_WRREQ_IO_CREDIT_STALL__GFX103COREPLUS = 0x00000059,
     GL2C_PERF_SEL_EA_WRREQ_GMI_CREDIT_STALL__GFX103COREPLUS = 0x0000005a,
     GL2C_PERF_SEL_EA_WRREQ_DRAM_CREDIT_STALL__GFX103COREPLUS = 0x0000005b,
     GL2C_PERF_SEL_TOO_MANY_EA_WRREQS_STALL__GFX103COREPLUS = 0x0000005c,
     GL2C_PERF_SEL_EA_ATOMIC__GFX103COREPLUS            = 0x0000005e,
     GL2C_PERF_SEL_EA_ATOMIC_LEVEL__GFX103COREPLUS      = 0x0000005f,
@@ -3887,21 +4864,21 @@ typedef enum GL2C_PERF_SEL {
     GL2C_PERF_SEL_EA_WRREQ_DRAM__GFX103COREPLUS        = 0x0000006f,
     GL2C_PERF_SEL_EA_RDREQ_DRAM_32B__GFX103COREPLUS    = 0x00000070,
     GL2C_PERF_SEL_EA_WRREQ_DRAM_32B__GFX103COREPLUS    = 0x00000071,
     GL2C_PERF_SEL_EA_OUTSTANDING__GFX103COREPLUS       = 0x00000078,
     GL2C_PERF_SEL_EA_RDRET_NACK__GFX103COREPLUS        = 0x0000008e,
     GL2C_PERF_SEL_EA_WRRET_NACK__GFX103COREPLUS        = 0x0000008f,
 #endif
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     GL2C_PERF_SEL_CM_DCC_OUT_CONST__GFX103DERIVATIVE   = 0x000000fd,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     GL2C_PERF_SEL_CLIENT8_REQ__GFX103PLUSEXCLUSIVE     = 0x00000018,
     GL2C_PERF_SEL_CLIENT9_REQ__GFX103PLUSEXCLUSIVE     = 0x00000019,
     GL2C_PERF_SEL_CLIENT10_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001a,
     GL2C_PERF_SEL_CLIENT11_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001b,
     GL2C_PERF_SEL_CLIENT12_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001c,
     GL2C_PERF_SEL_CLIENT13_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001d,
     GL2C_PERF_SEL_CLIENT14_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001e,
     GL2C_PERF_SEL_CLIENT15_REQ__GFX103PLUSEXCLUSIVE    = 0x0000001f,
     GL2C_PERF_SEL_C_RW_S_REQ__GFX103PLUSEXCLUSIVE      = 0x00000020,
     GL2C_PERF_SEL_C_RW_US_REQ__GFX103PLUSEXCLUSIVE     = 0x00000021,
@@ -4089,26 +5066,37 @@ typedef enum GL2C_PERF_SEL {
     GL2C_PERF_SEL_CM_MERGE_BUF_FULL__GFX103PLUSEXCLUSIVE = 0x000000f4,
     GL2C_PERF_SEL_CM_DCC_STALL__GFX103PLUSEXCLUSIVE    = 0x000000f5,
     GL2C_PERF_SEL_CM_DCC_IN_XFC__GFX103PLUSEXCLUSIVE   = 0x000000f6,
     GL2C_PERF_SEL_CM_DCC_OUT_XFC__GFX103PLUSEXCLUSIVE  = 0x000000f7,
     GL2C_PERF_SEL_CM_DCC_OUT_1x1__GFX103PLUSEXCLUSIVE  = 0x000000f8,
     GL2C_PERF_SEL_CM_DCC_OUT_1x2__GFX103PLUSEXCLUSIVE  = 0x000000f9,
     GL2C_PERF_SEL_CM_DCC_OUT_2x1__GFX103PLUSEXCLUSIVE  = 0x000000fa,
     GL2C_PERF_SEL_CM_DCC_OUT_2x2__GFX103PLUSEXCLUSIVE  = 0x000000fb,
     GL2C_PERF_SEL_CM_DCC_OUT_UNCOMP__GFX103PLUSEXCLUSIVE = 0x000000fc,
 #endif
+#if CHIP_HDR_NAVI31
+    GL2C_PERF_SEL_CM_DCC_OUT_CONST2SINGLE__GFX11       = 0x000000fd,
+    GL2C_PERF_SEL_CM_DCC_OUT_CONST2CLEAR__GFX11        = 0x000000fe,
+    GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT16__GFX11     = 0x000000ff,
+    GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT17__GFX11     = 0x00000100,
+    GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT18__GFX11     = 0x00000101,
+    GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT19__GFX11     = 0x00000102,
+#endif
 } GL2C_PERF_SEL;
 
 constexpr unsigned int MaxGl2cPerfSelGfx101            = GL2C_PERF_SEL_CM_DCC_STALL__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxGl2cPerfSelGfx103            = GL2C_PERF_SEL_CM_DCC_OUT_CONST__GFX103DERIVATIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGl2cPerfSelGfx11             = GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT19__GFX11;
+#endif
 
 typedef enum GL2_CACHE_POLICIES {
     GL2_CACHE_POLICY_LRU                               = 0x00000000,
     GL2_CACHE_POLICY_STREAM                            = 0x00000001,
     GL2_CACHE_POLICY_NOA                               = 0x00000002,
     GL2_CACHE_POLICY_BYPASS                            = 0x00000003,
 } GL2_CACHE_POLICIES;
 
 typedef enum GRBM_PERF_SEL {
     GRBM_PERF_SEL_COUNT                                = 0x00000000,
@@ -4157,24 +5145,32 @@ typedef enum GRBM_PERF_SEL {
     GRBM_PERF_SEL_GUS_BUSY__GFX10COREPLUS              = 0x0000002d,
     GRBM_PERF_SEL_TCP_BUSY__GFX10PLUS                  = 0x0000001c,
     GRBM_PERF_SEL_GE_BUSY__GFX10PLUS                   = 0x00000020,
     GRBM_PERF_SEL_GE_NO_DMA_BUSY__GFX10PLUS            = 0x00000021,
     GRBM_PERF_SEL_UTCL1_BUSY__GFX10PLUS                = 0x00000027,
     GRBM_PERF_SEL_GL2CC_BUSY__GFX10PLUS                = 0x00000028,
     GRBM_PERF_SEL_SDMA_BUSY__GFX10PLUS                 = 0x00000029,
     GRBM_PERF_SEL_CH_BUSY__GFX10PLUS                   = 0x0000002a,
     GRBM_PERF_SEL_PH_BUSY__GFX10PLUS                   = 0x0000002b,
     GRBM_PERF_SEL_GL1CC_BUSY__GFX10PLUS                = 0x0000002e,
+#if CHIP_HDR_NAVI31
+    GRBM_PERF_SEL_ANY_ACTIVE_F_BUSY__GFX11             = 0x0000002f,
+    GRBM_PERF_SEL_GL1H_BUSY__GFX11                     = 0x00000030,
+    GRBM_PERF_SEL_PC_BUSY__GFX11                       = 0x00000031,
+#endif
 } GRBM_PERF_SEL;
 
 constexpr unsigned int MaxGrbmPerfSelGfx09             = GRBM_PERF_SEL_CPAXI_BUSY;
 constexpr unsigned int MaxGrbmPerfSelGfx10             = GRBM_PERF_SEL_GL1CC_BUSY__GFX10PLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGrbmPerfSelGfx11             = GRBM_PERF_SEL_PC_BUSY__GFX11;
+#endif
 
 typedef enum GRBM_SE0_PERF_SEL {
     GRBM_SE0_PERF_SEL_COUNT                            = 0x00000000,
     GRBM_SE0_PERF_SEL_USER_DEFINED                     = 0x00000001,
     GRBM_SE0_PERF_SEL_CB_BUSY                          = 0x00000002,
     GRBM_SE0_PERF_SEL_DB_BUSY                          = 0x00000003,
     GRBM_SE0_PERF_SEL_SC_BUSY                          = 0x00000004,
     GRBM_SE0_PERF_SEL_SPI_BUSY                         = 0x00000006,
     GRBM_SE0_PERF_SEL_SX_BUSY                          = 0x00000007,
     GRBM_SE0_PERF_SEL_TA_BUSY                          = 0x00000008,
@@ -4183,24 +5179,31 @@ typedef enum GRBM_SE0_PERF_SEL {
     GRBM_SE0_PERF_SEL_PA_BUSY                          = 0x0000000c,
     GRBM_SE0_PERF_SEL_BCI_BUSY                         = 0x0000000e,
     GRBM_SE0_PERF_SEL_RMI_BUSY                         = 0x0000000f,
     GRBM_SE0_PERF_SEL_VGT_BUSY__GFX09                  = 0x0000000d,
     GRBM_SE0_PERF_SEL_RESERVED_1__GFX09_10             = 0x00000005,
     GRBM_SE0_PERF_SEL_RESERVED_0__GFX09_10             = 0x0000000b,
     GRBM_SE0_PERF_SEL_RESERVED_2__GFX10                = 0x0000000d,
     GRBM_SE0_PERF_SEL_UTCL1_BUSY__GFX10PLUS            = 0x00000010,
     GRBM_SE0_PERF_SEL_TCP_BUSY__GFX10PLUS              = 0x00000011,
     GRBM_SE0_PERF_SEL_GL1CC_BUSY__GFX10PLUS            = 0x00000012,
+#if CHIP_HDR_NAVI31
+    GRBM_SE0_PERF_SEL_GL1H_BUSY__GFX11                 = 0x00000013,
+    GRBM_SE0_PERF_SEL_PC_BUSY__GFX11                   = 0x00000014,
+#endif
 } GRBM_SE0_PERF_SEL;
 
 constexpr unsigned int MaxGrbmSe0PerfSelGfx09          = GRBM_SE0_PERF_SEL_RMI_BUSY;
 constexpr unsigned int MaxGrbmSe0PerfSelGfx10          = GRBM_SE0_PERF_SEL_GL1CC_BUSY__GFX10PLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGrbmSe0PerfSelGfx11          = GRBM_SE0_PERF_SEL_PC_BUSY__GFX11;
+#endif
 
 typedef enum GRBM_SE1_PERF_SEL {
     GRBM_SE1_PERF_SEL_COUNT                            = 0x00000000,
     GRBM_SE1_PERF_SEL_USER_DEFINED                     = 0x00000001,
     GRBM_SE1_PERF_SEL_CB_BUSY                          = 0x00000002,
     GRBM_SE1_PERF_SEL_DB_BUSY                          = 0x00000003,
     GRBM_SE1_PERF_SEL_SC_BUSY                          = 0x00000004,
     GRBM_SE1_PERF_SEL_SPI_BUSY                         = 0x00000006,
     GRBM_SE1_PERF_SEL_SX_BUSY                          = 0x00000007,
     GRBM_SE1_PERF_SEL_TA_BUSY                          = 0x00000008,
@@ -4211,24 +5214,31 @@ typedef enum GRBM_SE1_PERF_SEL {
     GRBM_SE1_PERF_SEL_RMI_BUSY                         = 0x0000000f,
     GRBM_SE1_PERF_SEL_RESERVED_1__GFX09                = 0x00000005,
     GRBM_SE1_PERF_SEL_RESERVED_0__GFX09                = 0x0000000b,
     GRBM_SE1_PERF_SEL_VGT_BUSY__GFX09                  = 0x0000000d,
     GRBM_SE1_PERF_SEL_RESERVED_1__GFX10CORE            = 0x00000005,
     GRBM_SE1_PERF_SEL_RESERVED_0__GFX10CORE            = 0x0000000b,
     GRBM_SE1_PERF_SEL_RESERVED_2__GFX10CORE            = 0x0000000d,
     GRBM_SE1_PERF_SEL_UTCL1_BUSY__GFX10COREPLUS        = 0x00000010,
     GRBM_SE1_PERF_SEL_TCP_BUSY__GFX10COREPLUS          = 0x00000011,
     GRBM_SE1_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS        = 0x00000012,
+#if CHIP_HDR_NAVI31
+    GRBM_SE1_PERF_SEL_GL1H_BUSY__GFX11                 = 0x00000013,
+    GRBM_SE1_PERF_SEL_PC_BUSY__GFX11                   = 0x00000014,
+#endif
 } GRBM_SE1_PERF_SEL;
 
 constexpr unsigned int MaxGrbmSe1PerfSelGfx09          = GRBM_SE1_PERF_SEL_RMI_BUSY;
 constexpr unsigned int MaxGrbmSe1PerfSelGfx10Core      = GRBM_SE1_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGrbmSe1PerfSelGfx11          = GRBM_SE1_PERF_SEL_PC_BUSY__GFX11;
+#endif
 
 typedef enum GRBM_SE2_PERF_SEL {
     GRBM_SE2_PERF_SEL_COUNT                            = 0x00000000,
     GRBM_SE2_PERF_SEL_USER_DEFINED                     = 0x00000001,
     GRBM_SE2_PERF_SEL_CB_BUSY                          = 0x00000002,
     GRBM_SE2_PERF_SEL_DB_BUSY                          = 0x00000003,
     GRBM_SE2_PERF_SEL_SC_BUSY                          = 0x00000004,
     GRBM_SE2_PERF_SEL_SPI_BUSY                         = 0x00000006,
     GRBM_SE2_PERF_SEL_SX_BUSY                          = 0x00000007,
     GRBM_SE2_PERF_SEL_TA_BUSY                          = 0x00000008,
@@ -4239,24 +5249,31 @@ typedef enum GRBM_SE2_PERF_SEL {
     GRBM_SE2_PERF_SEL_RMI_BUSY                         = 0x0000000f,
     GRBM_SE2_PERF_SEL_RESERVED_1__GFX09                = 0x00000005,
     GRBM_SE2_PERF_SEL_RESERVED_0__GFX09                = 0x0000000b,
     GRBM_SE2_PERF_SEL_VGT_BUSY__GFX09                  = 0x0000000d,
     GRBM_SE2_PERF_SEL_RESERVED_1__GFX10CORE            = 0x00000005,
     GRBM_SE2_PERF_SEL_RESERVED_0__GFX10CORE            = 0x0000000b,
     GRBM_SE2_PERF_SEL_RESERVED_2__GFX10CORE            = 0x0000000d,
     GRBM_SE2_PERF_SEL_UTCL1_BUSY__GFX10COREPLUS        = 0x00000010,
     GRBM_SE2_PERF_SEL_TCP_BUSY__GFX10COREPLUS          = 0x00000011,
     GRBM_SE2_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS        = 0x00000012,
+#if CHIP_HDR_NAVI31
+    GRBM_SE2_PERF_SEL_GL1H_BUSY__GFX11                 = 0x00000013,
+    GRBM_SE2_PERF_SEL_PC_BUSY__GFX11                   = 0x00000014,
+#endif
 } GRBM_SE2_PERF_SEL;
 
 constexpr unsigned int MaxGrbmSe2PerfSelGfx09          = GRBM_SE2_PERF_SEL_RMI_BUSY;
 constexpr unsigned int MaxGrbmSe2PerfSelGfx10Core      = GRBM_SE2_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGrbmSe2PerfSelGfx11          = GRBM_SE2_PERF_SEL_PC_BUSY__GFX11;
+#endif
 
 typedef enum GRBM_SE3_PERF_SEL {
     GRBM_SE3_PERF_SEL_COUNT                            = 0x00000000,
     GRBM_SE3_PERF_SEL_USER_DEFINED                     = 0x00000001,
     GRBM_SE3_PERF_SEL_CB_BUSY                          = 0x00000002,
     GRBM_SE3_PERF_SEL_DB_BUSY                          = 0x00000003,
     GRBM_SE3_PERF_SEL_SC_BUSY                          = 0x00000004,
     GRBM_SE3_PERF_SEL_SPI_BUSY                         = 0x00000006,
     GRBM_SE3_PERF_SEL_SX_BUSY                          = 0x00000007,
     GRBM_SE3_PERF_SEL_TA_BUSY                          = 0x00000008,
@@ -4267,24 +5284,125 @@ typedef enum GRBM_SE3_PERF_SEL {
     GRBM_SE3_PERF_SEL_RMI_BUSY                         = 0x0000000f,
     GRBM_SE3_PERF_SEL_RESERVED_1__GFX09                = 0x00000005,
     GRBM_SE3_PERF_SEL_RESERVED_0__GFX09                = 0x0000000b,
     GRBM_SE3_PERF_SEL_VGT_BUSY__GFX09                  = 0x0000000d,
     GRBM_SE3_PERF_SEL_RESERVED_1__GFX10CORE            = 0x00000005,
     GRBM_SE3_PERF_SEL_RESERVED_0__GFX10CORE            = 0x0000000b,
     GRBM_SE3_PERF_SEL_RESERVED_2__GFX10CORE            = 0x0000000d,
     GRBM_SE3_PERF_SEL_UTCL1_BUSY__GFX10COREPLUS        = 0x00000010,
     GRBM_SE3_PERF_SEL_TCP_BUSY__GFX10COREPLUS          = 0x00000011,
     GRBM_SE3_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS        = 0x00000012,
+#if CHIP_HDR_NAVI31
+    GRBM_SE3_PERF_SEL_GL1H_BUSY__GFX11                 = 0x00000013,
+    GRBM_SE3_PERF_SEL_PC_BUSY__GFX11                   = 0x00000014,
+#endif
 } GRBM_SE3_PERF_SEL;
 
 constexpr unsigned int MaxGrbmSe3PerfSelGfx09          = GRBM_SE3_PERF_SEL_RMI_BUSY;
 constexpr unsigned int MaxGrbmSe3PerfSelGfx10Core      = GRBM_SE3_PERF_SEL_GL1CC_BUSY__GFX10COREPLUS;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxGrbmSe3PerfSelGfx11          = GRBM_SE3_PERF_SEL_PC_BUSY__GFX11;
+#endif
+
+#if CHIP_HDR_NAVI31
+typedef enum GRBM_SE4_PERF_SEL {
+    GRBM_SE4_PERF_SEL_COUNT                            = 0x00000000,
+    GRBM_SE4_PERF_SEL_USER_DEFINED                     = 0x00000001,
+    GRBM_SE4_PERF_SEL_CB_BUSY                          = 0x00000002,
+    GRBM_SE4_PERF_SEL_DB_BUSY                          = 0x00000003,
+    GRBM_SE4_PERF_SEL_SC_BUSY                          = 0x00000004,
+    GRBM_SE4_PERF_SEL_SPI_BUSY                         = 0x00000006,
+    GRBM_SE4_PERF_SEL_SX_BUSY                          = 0x00000007,
+    GRBM_SE4_PERF_SEL_TA_BUSY                          = 0x00000008,
+    GRBM_SE4_PERF_SEL_CB_CLEAN                         = 0x00000009,
+    GRBM_SE4_PERF_SEL_DB_CLEAN                         = 0x0000000a,
+    GRBM_SE4_PERF_SEL_PA_BUSY                          = 0x0000000c,
+    GRBM_SE4_PERF_SEL_BCI_BUSY                         = 0x0000000e,
+    GRBM_SE4_PERF_SEL_RMI_BUSY                         = 0x0000000f,
+    GRBM_SE4_PERF_SEL_UTCL1_BUSY                       = 0x00000010,
+    GRBM_SE4_PERF_SEL_TCP_BUSY                         = 0x00000011,
+    GRBM_SE4_PERF_SEL_GL1CC_BUSY                       = 0x00000012,
+    GRBM_SE4_PERF_SEL_GL1H_BUSY                        = 0x00000013,
+    GRBM_SE4_PERF_SEL_PC_BUSY                          = 0x00000014,
+} GRBM_SE4_PERF_SEL;
+
+constexpr unsigned int MaxGrbmSe4PerfSel               = GRBM_SE4_PERF_SEL_PC_BUSY;
+
+typedef enum GRBM_SE5_PERF_SEL {
+    GRBM_SE5_PERF_SEL_COUNT                            = 0x00000000,
+    GRBM_SE5_PERF_SEL_USER_DEFINED                     = 0x00000001,
+    GRBM_SE5_PERF_SEL_CB_BUSY                          = 0x00000002,
+    GRBM_SE5_PERF_SEL_DB_BUSY                          = 0x00000003,
+    GRBM_SE5_PERF_SEL_SC_BUSY                          = 0x00000004,
+    GRBM_SE5_PERF_SEL_SPI_BUSY                         = 0x00000006,
+    GRBM_SE5_PERF_SEL_SX_BUSY                          = 0x00000007,
+    GRBM_SE5_PERF_SEL_TA_BUSY                          = 0x00000008,
+    GRBM_SE5_PERF_SEL_CB_CLEAN                         = 0x00000009,
+    GRBM_SE5_PERF_SEL_DB_CLEAN                         = 0x0000000a,
+    GRBM_SE5_PERF_SEL_PA_BUSY                          = 0x0000000c,
+    GRBM_SE5_PERF_SEL_BCI_BUSY                         = 0x0000000e,
+    GRBM_SE5_PERF_SEL_RMI_BUSY                         = 0x0000000f,
+    GRBM_SE5_PERF_SEL_UTCL1_BUSY                       = 0x00000010,
+    GRBM_SE5_PERF_SEL_TCP_BUSY                         = 0x00000011,
+    GRBM_SE5_PERF_SEL_GL1CC_BUSY                       = 0x00000012,
+    GRBM_SE5_PERF_SEL_GL1H_BUSY                        = 0x00000013,
+    GRBM_SE5_PERF_SEL_PC_BUSY                          = 0x00000014,
+} GRBM_SE5_PERF_SEL;
+
+constexpr unsigned int MaxGrbmSe5PerfSel               = GRBM_SE5_PERF_SEL_PC_BUSY;
+
+typedef enum GRBM_SE6_PERF_SEL {
+    GRBM_SE6_PERF_SEL_COUNT                            = 0x00000000,
+    GRBM_SE6_PERF_SEL_USER_DEFINED                     = 0x00000001,
+    GRBM_SE6_PERF_SEL_CB_BUSY                          = 0x00000002,
+    GRBM_SE6_PERF_SEL_DB_BUSY                          = 0x00000003,
+    GRBM_SE6_PERF_SEL_SC_BUSY                          = 0x00000004,
+    GRBM_SE6_PERF_SEL_SPI_BUSY                         = 0x00000006,
+    GRBM_SE6_PERF_SEL_SX_BUSY                          = 0x00000007,
+    GRBM_SE6_PERF_SEL_TA_BUSY                          = 0x00000008,
+    GRBM_SE6_PERF_SEL_CB_CLEAN                         = 0x00000009,
+    GRBM_SE6_PERF_SEL_DB_CLEAN                         = 0x0000000a,
+    GRBM_SE6_PERF_SEL_PA_BUSY                          = 0x0000000c,
+    GRBM_SE6_PERF_SEL_BCI_BUSY                         = 0x0000000e,
+    GRBM_SE6_PERF_SEL_RMI_BUSY                         = 0x0000000f,
+    GRBM_SE6_PERF_SEL_UTCL1_BUSY                       = 0x00000010,
+    GRBM_SE6_PERF_SEL_TCP_BUSY                         = 0x00000011,
+    GRBM_SE6_PERF_SEL_GL1CC_BUSY                       = 0x00000012,
+    GRBM_SE6_PERF_SEL_GL1H_BUSY                        = 0x00000013,
+    GRBM_SE6_PERF_SEL_PC_BUSY                          = 0x00000014,
+} GRBM_SE6_PERF_SEL;
+
+constexpr unsigned int MaxGrbmSe6PerfSel               = GRBM_SE6_PERF_SEL_PC_BUSY;
+
+typedef enum GRBM_SE7_PERF_SEL {
+    GRBM_SE7_PERF_SEL_COUNT                            = 0x00000000,
+    GRBM_SE7_PERF_SEL_USER_DEFINED                     = 0x00000001,
+    GRBM_SE7_PERF_SEL_CB_BUSY                          = 0x00000002,
+    GRBM_SE7_PERF_SEL_DB_BUSY                          = 0x00000003,
+    GRBM_SE7_PERF_SEL_SC_BUSY                          = 0x00000004,
+    GRBM_SE7_PERF_SEL_SPI_BUSY                         = 0x00000006,
+    GRBM_SE7_PERF_SEL_SX_BUSY                          = 0x00000007,
+    GRBM_SE7_PERF_SEL_TA_BUSY                          = 0x00000008,
+    GRBM_SE7_PERF_SEL_CB_CLEAN                         = 0x00000009,
+    GRBM_SE7_PERF_SEL_DB_CLEAN                         = 0x0000000a,
+    GRBM_SE7_PERF_SEL_PA_BUSY                          = 0x0000000c,
+    GRBM_SE7_PERF_SEL_BCI_BUSY                         = 0x0000000e,
+    GRBM_SE7_PERF_SEL_RMI_BUSY                         = 0x0000000f,
+    GRBM_SE7_PERF_SEL_UTCL1_BUSY                       = 0x00000010,
+    GRBM_SE7_PERF_SEL_TCP_BUSY                         = 0x00000011,
+    GRBM_SE7_PERF_SEL_GL1CC_BUSY                       = 0x00000012,
+    GRBM_SE7_PERF_SEL_GL1H_BUSY                        = 0x00000013,
+    GRBM_SE7_PERF_SEL_PC_BUSY                          = 0x00000014,
+} GRBM_SE7_PERF_SEL;
+
+constexpr unsigned int MaxGrbmSe7PerfSel               = GRBM_SE7_PERF_SEL_PC_BUSY;
+#endif
 
 typedef enum IA_PERFCOUNT_SELECT {
     ia_perf_grp_input_event_window_active              = 0x00000000,
     ia_perf_dma_data_fifo_full                         = 0x00000001,
     ia_perf_UNUSED2                                    = 0x00000002,
     ia_perf_UNUSED3                                    = 0x00000003,
     ia_perf_UNUSED4                                    = 0x00000004,
     ia_perf_UNUSED5                                    = 0x00000005,
     ia_perf_UNUSED6                                    = 0x00000006,
     ia_perf_MC_LAT_BIN_0                               = 0x00000007,
@@ -4392,22 +5510,30 @@ typedef enum IMG_DATA_FORMAT {
     IMG_DATA_FORMAT_RESERVED_29__GFX101                = 0x0000001d,
     IMG_DATA_FORMAT_RESERVED_30__GFX101                = 0x0000001e,
     IMG_DATA_FORMAT_RESERVED_61__GFX101                = 0x0000003d,
     IMG_DATA_FORMAT_RESERVED_86__GFX101                = 0x00000056,
     IMG_DATA_FORMAT_RESERVED_87__GFX101                = 0x00000057,
     IMG_DATA_FORMAT_RESERVED_88__GFX101                = 0x00000058,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     IMG_DATA_FORMAT_YCBCR__GFX103                      = 0x0000001d,
     IMG_DATA_FORMAT_LOD_5P3_USCALED__GFX103            = 0x0000003d,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     IMG_DATA_FORMAT_7E3__GFX103COREPLUS                = 0x0000001e,
+#endif
+#if CHIP_HDR_NAVI31
+    IMG_DATA_FORMAT_RESERVED_44__GFX104PLUS            = 0x0000002c,
+    IMG_DATA_FORMAT_RESERVED_45__GFX104PLUS            = 0x0000002d,
+    IMG_DATA_FORMAT_RESERVED_46__GFX104PLUS            = 0x0000002e,
+    IMG_DATA_FORMAT_YCBCR__GFX104PLUS                  = 0x0000002f,
+    IMG_DATA_FORMAT_MM_8__GFX104PLUS                   = 0x00000031,
+    IMG_DATA_FORMAT_MM_8_8__GFX104PLUS                 = 0x00000032,
 #endif
     IMG_DATA_FORMAT_GB_GR__GFX10CORE                   = 0x00000020,
     IMG_DATA_FORMAT_BG_RG__GFX10CORE                   = 0x00000021,
     IMG_DATA_FORMAT_5_9_9_9__GFX10CORE                 = 0x00000022,
     IMG_DATA_FORMAT_BC1__GFX10CORE                     = 0x00000023,
     IMG_DATA_FORMAT_BC2__GFX10CORE                     = 0x00000024,
     IMG_DATA_FORMAT_BC3__GFX10CORE                     = 0x00000025,
     IMG_DATA_FORMAT_BC4__GFX10CORE                     = 0x00000026,
     IMG_DATA_FORMAT_BC5__GFX10CORE                     = 0x00000027,
     IMG_DATA_FORMAT_BC6__GFX10CORE                     = 0x00000028,
@@ -4488,20 +5614,51 @@ typedef enum IMG_DATA_FORMAT {
     IMG_DATA_FORMAT_RESERVED_122__GFX10CORE            = 0x0000007a,
     IMG_DATA_FORMAT_RESERVED_123__GFX10CORE            = 0x0000007b,
     IMG_DATA_FORMAT_RESERVED_124__GFX10CORE            = 0x0000007c,
     IMG_DATA_FORMAT_RESERVED_125__GFX10CORE            = 0x0000007d,
     IMG_DATA_FORMAT_RESERVED_126__GFX10CORE            = 0x0000007e,
     IMG_DATA_FORMAT_RESERVED_127__GFX10CORE            = 0x0000007f,
     IMG_DATA_FORMAT_RESERVED_23__GFX10COREPLUS         = 0x00000017,
     IMG_DATA_FORMAT_RESERVED_42__GFX10COREPLUS         = 0x0000002a,
     IMG_DATA_FORMAT_RESERVED_62__GFX10COREPLUS         = 0x0000003e,
     IMG_DATA_FORMAT_RESERVED_43__GFX10PLUS             = 0x0000002b,
+#if CHIP_HDR_NAVI31
+    IMG_DATA_FORMAT_5_9_9_9__GFX11                     = 0x00000018,
+    IMG_DATA_FORMAT_GB_GR__GFX11                       = 0x00000019,
+    IMG_DATA_FORMAT_BG_RG__GFX11                       = 0x0000001a,
+    IMG_DATA_FORMAT_4_4__GFX11                         = 0x0000001b,
+    IMG_DATA_FORMAT_1__GFX11                           = 0x0000001c,
+    IMG_DATA_FORMAT_1_REVERSED__GFX11                  = 0x0000001d,
+    IMG_DATA_FORMAT_BC1__GFX11                         = 0x00000020,
+    IMG_DATA_FORMAT_BC2__GFX11                         = 0x00000021,
+    IMG_DATA_FORMAT_BC3__GFX11                         = 0x00000022,
+    IMG_DATA_FORMAT_BC4__GFX11                         = 0x00000023,
+    IMG_DATA_FORMAT_BC5__GFX11                         = 0x00000024,
+    IMG_DATA_FORMAT_BC6__GFX11                         = 0x00000025,
+    IMG_DATA_FORMAT_BC7__GFX11                         = 0x00000026,
+    IMG_DATA_FORMAT_RESERVED_39__GFX11                 = 0x00000027,
+    IMG_DATA_FORMAT_RESERVED_40__GFX11                 = 0x00000028,
+    IMG_DATA_FORMAT_RESERVED_41__GFX11                 = 0x00000029,
+    IMG_DATA_FORMAT_LOD_5P3_USCALED__GFX11             = 0x00000030,
+    IMG_DATA_FORMAT_MM_8_8_8_8__GFX11                  = 0x00000033,
+    IMG_DATA_FORMAT_MM_VYUY8__GFX11                    = 0x00000034,
+    IMG_DATA_FORMAT_MM_10_11_11__GFX11                 = 0x00000035,
+    IMG_DATA_FORMAT_MM_2_10_10_10__GFX11               = 0x00000036,
+    IMG_DATA_FORMAT_MM_10_IN_16__GFX11                 = 0x00000037,
+    IMG_DATA_FORMAT_MM_10_IN_16_16__GFX11              = 0x00000038,
+    IMG_DATA_FORMAT_MM_10_IN_16_16_16_16__GFX11        = 0x00000039,
+    IMG_DATA_FORMAT_MM_12_IN_16__GFX11                 = 0x0000003a,
+    IMG_DATA_FORMAT_MM_12_IN_16_16__GFX11              = 0x0000003b,
+    IMG_DATA_FORMAT_MM_12_IN_16_16_16_16__GFX11        = 0x0000003c,
+    IMG_DATA_FORMAT_MM_16_16_16_16__GFX11              = 0x0000003d,
+    IMG_DATA_FORMAT_RESERVED_63__GFX11                 = 0x0000003f,
+#endif
 #if CHIP_HDR_NAVI21
     IMG_DATA_FORMAT_RESERVED_24__NV21                  = 0x00000018,
     IMG_DATA_FORMAT_RESERVED_25__NV21                  = 0x00000019,
     IMG_DATA_FORMAT_RESERVED_26__NV21                  = 0x0000001a,
     IMG_DATA_FORMAT_RESERVED_27__NV21                  = 0x0000001b,
     IMG_DATA_FORMAT_RESERVED_28__NV21                  = 0x0000001c,
     IMG_DATA_FORMAT_MM_12_IN_16__NV21                  = 0x00000056,
     IMG_DATA_FORMAT_MM_12_IN_16_16__NV21               = 0x00000057,
     IMG_DATA_FORMAT_MM_12_IN_16_16_16_16__NV21         = 0x00000058,
 #endif
@@ -4594,20 +5751,164 @@ typedef enum IMG_FMT {
     IMG_FMT_RESERVED_288__GFX101                       = 0x00000120,
     IMG_FMT_RESERVED_289__GFX101                       = 0x00000121,
     IMG_FMT_RESERVED_290__GFX101                       = 0x00000122,
     IMG_FMT_RESERVED_291__GFX101                       = 0x00000123,
     IMG_FMT_RESERVED_292__GFX101                       = 0x00000124,
     IMG_FMT_RESERVED_293__GFX101                       = 0x00000125,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     IMG_FMT_7E3_FLOAT__GFX103                          = 0x0000011d,
     IMG_FMT_YCBCR_UNORM__GFX103                        = 0x0000011e,
     IMG_FMT_YCBCR_SRGB__GFX103                         = 0x0000011f,
+#endif
+#if CHIP_HDR_NAVI31
+    IMG_FMT_10_11_11_FLOAT__GFX104PLUS                 = 0x0000001e,
+    IMG_FMT_11_11_10_FLOAT__GFX104PLUS                 = 0x0000001f,
+    IMG_FMT_10_10_10_2_UNORM__GFX104PLUS               = 0x00000020,
+    IMG_FMT_10_10_10_2_SNORM__GFX104PLUS               = 0x00000021,
+    IMG_FMT_10_10_10_2_UINT__GFX104PLUS                = 0x00000022,
+    IMG_FMT_10_10_10_2_SINT__GFX104PLUS                = 0x00000023,
+    IMG_FMT_2_10_10_10_UNORM__GFX104PLUS               = 0x00000024,
+    IMG_FMT_2_10_10_10_SNORM__GFX104PLUS               = 0x00000025,
+    IMG_FMT_2_10_10_10_USCALED__GFX104PLUS             = 0x00000026,
+    IMG_FMT_2_10_10_10_SSCALED__GFX104PLUS             = 0x00000027,
+    IMG_FMT_2_10_10_10_UINT__GFX104PLUS                = 0x00000028,
+    IMG_FMT_2_10_10_10_SINT__GFX104PLUS                = 0x00000029,
+    IMG_FMT_8_8_8_8_UNORM__GFX104PLUS                  = 0x0000002a,
+    IMG_FMT_8_8_8_8_SNORM__GFX104PLUS                  = 0x0000002b,
+    IMG_FMT_8_8_8_8_USCALED__GFX104PLUS                = 0x0000002c,
+    IMG_FMT_8_8_8_8_SSCALED__GFX104PLUS                = 0x0000002d,
+    IMG_FMT_8_8_8_8_UINT__GFX104PLUS                   = 0x0000002e,
+    IMG_FMT_8_8_8_8_SINT__GFX104PLUS                   = 0x0000002f,
+    IMG_FMT_32_32_UINT__GFX104PLUS                     = 0x00000030,
+    IMG_FMT_32_32_SINT__GFX104PLUS                     = 0x00000031,
+    IMG_FMT_32_32_FLOAT__GFX104PLUS                    = 0x00000032,
+    IMG_FMT_16_16_16_16_UNORM__GFX104PLUS              = 0x00000033,
+    IMG_FMT_16_16_16_16_SNORM__GFX104PLUS              = 0x00000034,
+    IMG_FMT_16_16_16_16_USCALED__GFX104PLUS            = 0x00000035,
+    IMG_FMT_16_16_16_16_SSCALED__GFX104PLUS            = 0x00000036,
+    IMG_FMT_16_16_16_16_UINT__GFX104PLUS               = 0x00000037,
+    IMG_FMT_16_16_16_16_SINT__GFX104PLUS               = 0x00000038,
+    IMG_FMT_16_16_16_16_FLOAT__GFX104PLUS              = 0x00000039,
+    IMG_FMT_32_32_32_UINT__GFX104PLUS                  = 0x0000003a,
+    IMG_FMT_32_32_32_SINT__GFX104PLUS                  = 0x0000003b,
+    IMG_FMT_32_32_32_FLOAT__GFX104PLUS                 = 0x0000003c,
+    IMG_FMT_32_32_32_32_UINT__GFX104PLUS               = 0x0000003d,
+    IMG_FMT_32_32_32_32_SINT__GFX104PLUS               = 0x0000003e,
+    IMG_FMT_32_32_32_32_FLOAT__GFX104PLUS              = 0x0000003f,
+    IMG_FMT_8_SRGB__GFX104PLUS                         = 0x00000040,
+    IMG_FMT_8_8_SRGB__GFX104PLUS                       = 0x00000041,
+    IMG_FMT_8_8_8_8_SRGB__GFX104PLUS                   = 0x00000042,
+    IMG_FMT_5_9_9_9_FLOAT__GFX104PLUS                  = 0x00000043,
+    IMG_FMT_5_6_5_UNORM__GFX104PLUS                    = 0x00000044,
+    IMG_FMT_1_5_5_5_UNORM__GFX104PLUS                  = 0x00000045,
+    IMG_FMT_5_5_5_1_UNORM__GFX104PLUS                  = 0x00000046,
+    IMG_FMT_4_4_4_4_UNORM__GFX104PLUS                  = 0x00000047,
+    IMG_FMT_4_4_UNORM__GFX104PLUS                      = 0x00000048,
+    IMG_FMT_1_UNORM__GFX104PLUS                        = 0x00000049,
+    IMG_FMT_1_REVERSED_UNORM__GFX104PLUS               = 0x0000004a,
+    IMG_FMT_32_FLOAT_CLAMP__GFX104PLUS                 = 0x0000004b,
+    IMG_FMT_8_24_UNORM__GFX104PLUS                     = 0x0000004c,
+    IMG_FMT_8_24_UINT__GFX104PLUS                      = 0x0000004d,
+    IMG_FMT_24_8_UNORM__GFX104PLUS                     = 0x0000004e,
+    IMG_FMT_24_8_UINT__GFX104PLUS                      = 0x0000004f,
+    IMG_FMT_X24_8_32_UINT__GFX104PLUS                  = 0x00000050,
+    IMG_FMT_X24_8_32_FLOAT__GFX104PLUS                 = 0x00000051,
+    IMG_FMT_GB_GR_UNORM__GFX104PLUS                    = 0x00000052,
+    IMG_FMT_GB_GR_SNORM__GFX104PLUS                    = 0x00000053,
+    IMG_FMT_GB_GR_UINT__GFX104PLUS                     = 0x00000054,
+    IMG_FMT_GB_GR_SRGB__GFX104PLUS                     = 0x00000055,
+    IMG_FMT_BG_RG_UNORM__GFX104PLUS                    = 0x00000056,
+    IMG_FMT_BG_RG_SNORM__GFX104PLUS                    = 0x00000057,
+    IMG_FMT_BG_RG_UINT__GFX104PLUS                     = 0x00000058,
+    IMG_FMT_BG_RG_SRGB__GFX104PLUS                     = 0x00000059,
+    IMG_FMT_BC1_UNORM__GFX104PLUS                      = 0x0000006d,
+    IMG_FMT_BC1_SRGB__GFX104PLUS                       = 0x0000006e,
+    IMG_FMT_BC2_UNORM__GFX104PLUS                      = 0x0000006f,
+    IMG_FMT_BC2_SRGB__GFX104PLUS                       = 0x00000070,
+    IMG_FMT_BC3_UNORM__GFX104PLUS                      = 0x00000071,
+    IMG_FMT_BC3_SRGB__GFX104PLUS                       = 0x00000072,
+    IMG_FMT_RESERVED_147__GFX104PLUS                   = 0x00000093,
+    IMG_FMT_RESERVED_148__GFX104PLUS                   = 0x00000094,
+    IMG_FMT_RESERVED_149__GFX104PLUS                   = 0x00000095,
+    IMG_FMT_RESERVED_150__GFX104PLUS                   = 0x00000096,
+    IMG_FMT_RESERVED_151__GFX104PLUS                   = 0x00000097,
+    IMG_FMT_RESERVED_152__GFX104PLUS                   = 0x00000098,
+    IMG_FMT_RESERVED_153__GFX104PLUS                   = 0x00000099,
+    IMG_FMT_RESERVED_154__GFX104PLUS                   = 0x0000009a,
+    IMG_FMT_RESERVED_156__GFX104PLUS                   = 0x0000009c,
+    IMG_FMT_RESERVED_157__GFX104PLUS                   = 0x0000009d,
+    IMG_FMT_RESERVED_158__GFX104PLUS                   = 0x0000009e,
+    IMG_FMT_RESERVED_159__GFX104PLUS                   = 0x0000009f,
+    IMG_FMT_RESERVED_160__GFX104PLUS                   = 0x000000a0,
+    IMG_FMT_RESERVED_175__GFX104PLUS                   = 0x000000af,
+    IMG_FMT_RESERVED_176__GFX104PLUS                   = 0x000000b0,
+    IMG_FMT_RESERVED_177__GFX104PLUS                   = 0x000000b1,
+    IMG_FMT_RESERVED_178__GFX104PLUS                   = 0x000000b2,
+    IMG_FMT_RESERVED_179__GFX104PLUS                   = 0x000000b3,
+    IMG_FMT_RESERVED_180__GFX104PLUS                   = 0x000000b4,
+    IMG_FMT_RESERVED_181__GFX104PLUS                   = 0x000000b5,
+    IMG_FMT_RESERVED_182__GFX104PLUS                   = 0x000000b6,
+    IMG_FMT_RESERVED_183__GFX104PLUS                   = 0x000000b7,
+    IMG_FMT_RESERVED_184__GFX104PLUS                   = 0x000000b8,
+    IMG_FMT_RESERVED_185__GFX104PLUS                   = 0x000000b9,
+    IMG_FMT_RESERVED_186__GFX104PLUS                   = 0x000000ba,
+    IMG_FMT_RESERVED_187__GFX104PLUS                   = 0x000000bb,
+    IMG_FMT_RESERVED_188__GFX104PLUS                   = 0x000000bc,
+    IMG_FMT_RESERVED_189__GFX104PLUS                   = 0x000000bd,
+    IMG_FMT_RESERVED_190__GFX104PLUS                   = 0x000000be,
+    IMG_FMT_RESERVED_191__GFX104PLUS                   = 0x000000bf,
+    IMG_FMT_RESERVED_192__GFX104PLUS                   = 0x000000c0,
+    IMG_FMT_RESERVED_193__GFX104PLUS                   = 0x000000c1,
+    IMG_FMT_RESERVED_194__GFX104PLUS                   = 0x000000c2,
+    IMG_FMT_RESERVED_195__GFX104PLUS                   = 0x000000c3,
+    IMG_FMT_RESERVED_196__GFX104PLUS                   = 0x000000c4,
+    IMG_FMT_RESERVED_197__GFX104PLUS                   = 0x000000c5,
+    IMG_FMT_RESERVED_198__GFX104PLUS                   = 0x000000c6,
+    IMG_FMT_RESERVED_199__GFX104PLUS                   = 0x000000c7,
+    IMG_FMT_RESERVED_200__GFX104PLUS                   = 0x000000c8,
+    IMG_FMT_RESERVED_201__GFX104PLUS                   = 0x000000c9,
+    IMG_FMT_RESERVED_202__GFX104PLUS                   = 0x000000ca,
+    IMG_FMT_RESERVED_203__GFX104PLUS                   = 0x000000cb,
+    IMG_FMT_RESERVED_204__GFX104PLUS                   = 0x000000cc,
+    IMG_FMT_YCBCR_UNORM__GFX104PLUS                    = 0x000000cd,
+    IMG_FMT_YCBCR_SRGB__GFX104PLUS                     = 0x000000ce,
+    IMG_FMT_MM_8_UNORM__GFX104PLUS                     = 0x000000cf,
+    IMG_FMT_MM_8_UINT__GFX104PLUS                      = 0x000000d0,
+    IMG_FMT_MM_8_8_UNORM__GFX104PLUS                   = 0x000000d1,
+    IMG_FMT_MM_8_8_UINT__GFX104PLUS                    = 0x000000d2,
+    IMG_FMT_RESERVED_229__GFX104PLUS                   = 0x000000e5,
+    IMG_FMT_RESERVED_230__GFX104PLUS                   = 0x000000e6,
+    IMG_FMT_RESERVED_231__GFX104PLUS                   = 0x000000e7,
+    IMG_FMT_RESERVED_232__GFX104PLUS                   = 0x000000e8,
+    IMG_FMT_RESERVED_233__GFX104PLUS                   = 0x000000e9,
+    IMG_FMT_RESERVED_234__GFX104PLUS                   = 0x000000ea,
+    IMG_FMT_RESERVED_235__GFX104PLUS                   = 0x000000eb,
+    IMG_FMT_RESERVED_236__GFX104PLUS                   = 0x000000ec,
+    IMG_FMT_RESERVED_237__GFX104PLUS                   = 0x000000ed,
+    IMG_FMT_RESERVED_238__GFX104PLUS                   = 0x000000ee,
+    IMG_FMT_RESERVED_239__GFX104PLUS                   = 0x000000ef,
+    IMG_FMT_RESERVED_240__GFX104PLUS                   = 0x000000f0,
+    IMG_FMT_RESERVED_241__GFX104PLUS                   = 0x000000f1,
+    IMG_FMT_RESERVED_242__GFX104PLUS                   = 0x000000f2,
+    IMG_FMT_RESERVED_243__GFX104PLUS                   = 0x000000f3,
+    IMG_FMT_RESERVED_244__GFX104PLUS                   = 0x000000f4,
+    IMG_FMT_RESERVED_245__GFX104PLUS                   = 0x000000f5,
+    IMG_FMT_RESERVED_246__GFX104PLUS                   = 0x000000f6,
+    IMG_FMT_RESERVED_247__GFX104PLUS                   = 0x000000f7,
+    IMG_FMT_RESERVED_248__GFX104PLUS                   = 0x000000f8,
+    IMG_FMT_RESERVED_249__GFX104PLUS                   = 0x000000f9,
+    IMG_FMT_RESERVED_250__GFX104PLUS                   = 0x000000fa,
+    IMG_FMT_RESERVED_251__GFX104PLUS                   = 0x000000fb,
+    IMG_FMT_RESERVED_252__GFX104PLUS                   = 0x000000fc,
+    IMG_FMT_RESERVED_253__GFX104PLUS                   = 0x000000fd,
+    IMG_FMT_RESERVED_254__GFX104PLUS                   = 0x000000fe,
+    IMG_FMT_RESERVED_255__GFX104PLUS                   = 0x000000ff,
 #endif
     IMG_FMT_10_11_11_UNORM__GFX10CORE                  = 0x0000001e,
     IMG_FMT_10_11_11_SNORM__GFX10CORE                  = 0x0000001f,
     IMG_FMT_10_11_11_USCALED__GFX10CORE                = 0x00000020,
     IMG_FMT_10_11_11_SSCALED__GFX10CORE                = 0x00000021,
     IMG_FMT_10_11_11_UINT__GFX10CORE                   = 0x00000022,
     IMG_FMT_10_11_11_SINT__GFX10CORE                   = 0x00000023,
     IMG_FMT_10_11_11_FLOAT__GFX10CORE                  = 0x00000024,
     IMG_FMT_11_11_10_UNORM__GFX10CORE                  = 0x00000025,
     IMG_FMT_11_11_10_SNORM__GFX10CORE                  = 0x00000026,
@@ -5048,20 +6349,87 @@ typedef enum IMG_FMT {
     IMG_FMT_RESERVED_509__GFX10CORE                    = 0x000001fd,
     IMG_FMT_RESERVED_510__GFX10CORE                    = 0x000001fe,
     IMG_FMT_RESERVED_511__GFX10CORE                    = 0x000001ff,
     IMG_FMT_RESERVED_96__GFX10COREPLUS                 = 0x00000060,
     IMG_FMT_RESERVED_97__GFX10COREPLUS                 = 0x00000061,
     IMG_FMT_RESERVED_123__GFX10COREPLUS                = 0x0000007b,
     IMG_FMT_RESERVED_124__GFX10COREPLUS                = 0x0000007c,
     IMG_FMT_RESERVED_125__GFX10COREPLUS                = 0x0000007d,
     IMG_FMT_RESERVED_126__GFX10COREPLUS                = 0x0000007e,
     IMG_FMT_RESERVED_127__GFX10COREPLUS                = 0x0000007f,
+#if CHIP_HDR_NAVI31
+    IMG_FMT_MM_10_IN_16_UNORM__GFX11                   = 0x0000005a,
+    IMG_FMT_MM_10_IN_16_UINT__GFX11                    = 0x0000005b,
+    IMG_FMT_MM_10_IN_16_16_UNORM__GFX11                = 0x0000005c,
+    IMG_FMT_MM_10_IN_16_16_UINT__GFX11                 = 0x0000005d,
+    IMG_FMT_MM_10_IN_16_16_16_16_UNORM__GFX11          = 0x0000005e,
+    IMG_FMT_MM_10_IN_16_16_16_16_UINT__GFX11           = 0x0000005f,
+    IMG_FMT_BC4_UNORM__GFX11                           = 0x00000073,
+    IMG_FMT_BC4_SNORM__GFX11                           = 0x00000074,
+    IMG_FMT_BC5_UNORM__GFX11                           = 0x00000075,
+    IMG_FMT_BC5_SNORM__GFX11                           = 0x00000076,
+    IMG_FMT_BC6_UFLOAT__GFX11                          = 0x00000077,
+    IMG_FMT_BC6_SFLOAT__GFX11                          = 0x00000078,
+    IMG_FMT_BC7_UNORM__GFX11                           = 0x00000079,
+    IMG_FMT_BC7_SRGB__GFX11                            = 0x0000007a,
+    IMG_FMT_RESERVED_128__GFX11                        = 0x00000080,
+    IMG_FMT_RESERVED_129__GFX11                        = 0x00000081,
+    IMG_FMT_RESERVED_130__GFX11                        = 0x00000082,
+    IMG_FMT_RESERVED_131__GFX11                        = 0x00000083,
+    IMG_FMT_RESERVED_132__GFX11                        = 0x00000084,
+    IMG_FMT_RESERVED_133__GFX11                        = 0x00000085,
+    IMG_FMT_RESERVED_134__GFX11                        = 0x00000086,
+    IMG_FMT_RESERVED_135__GFX11                        = 0x00000087,
+    IMG_FMT_RESERVED_136__GFX11                        = 0x00000088,
+    IMG_FMT_RESERVED_137__GFX11                        = 0x00000089,
+    IMG_FMT_RESERVED_138__GFX11                        = 0x0000008a,
+    IMG_FMT_RESERVED_139__GFX11                        = 0x0000008b,
+    IMG_FMT_RESERVED_140__GFX11                        = 0x0000008c,
+    IMG_FMT_RESERVED_141__GFX11                        = 0x0000008d,
+    IMG_FMT_RESERVED_142__GFX11                        = 0x0000008e,
+    IMG_FMT_RESERVED_143__GFX11                        = 0x0000008f,
+    IMG_FMT_RESERVED_144__GFX11                        = 0x00000090,
+    IMG_FMT_RESERVED_145__GFX11                        = 0x00000091,
+    IMG_FMT_RESERVED_146__GFX11                        = 0x00000092,
+    IMG_FMT_RESERVED_161__GFX11                        = 0x000000a1,
+    IMG_FMT_RESERVED_162__GFX11                        = 0x000000a2,
+    IMG_FMT_RESERVED_163__GFX11                        = 0x000000a3,
+    IMG_FMT_RESERVED_164__GFX11                        = 0x000000a4,
+    IMG_FMT_RESERVED_165__GFX11                        = 0x000000a5,
+    IMG_FMT_RESERVED_166__GFX11                        = 0x000000a6,
+    IMG_FMT_RESERVED_167__GFX11                        = 0x000000a7,
+    IMG_FMT_RESERVED_168__GFX11                        = 0x000000a8,
+    IMG_FMT_RESERVED_169__GFX11                        = 0x000000a9,
+    IMG_FMT_RESERVED_170__GFX11                        = 0x000000aa,
+    IMG_FMT_RESERVED_171__GFX11                        = 0x000000ab,
+    IMG_FMT_RESERVED_172__GFX11                        = 0x000000ac,
+    IMG_FMT_RESERVED_173__GFX11                        = 0x000000ad,
+    IMG_FMT_RESERVED_174__GFX11                        = 0x000000ae,
+    IMG_FMT_MM_8_8_8_8_UNORM__GFX11                    = 0x000000d3,
+    IMG_FMT_MM_8_8_8_8_UINT__GFX11                     = 0x000000d4,
+    IMG_FMT_MM_VYUY8_UNORM__GFX11                      = 0x000000d5,
+    IMG_FMT_MM_VYUY8_UINT__GFX11                       = 0x000000d6,
+    IMG_FMT_MM_10_11_11_UNORM__GFX11                   = 0x000000d7,
+    IMG_FMT_MM_10_11_11_UINT__GFX11                    = 0x000000d8,
+    IMG_FMT_MM_2_10_10_10_UNORM__GFX11                 = 0x000000d9,
+    IMG_FMT_MM_2_10_10_10_UINT__GFX11                  = 0x000000da,
+    IMG_FMT_MM_16_16_16_16_UNORM__GFX11                = 0x000000db,
+    IMG_FMT_MM_16_16_16_16_UINT__GFX11                 = 0x000000dc,
+    IMG_FMT_MM_12_IN_16_UNORM__GFX11                   = 0x000000dd,
+    IMG_FMT_MM_12_IN_16_UINT__GFX11                    = 0x000000de,
+    IMG_FMT_MM_12_IN_16_16_UNORM__GFX11                = 0x000000df,
+    IMG_FMT_MM_12_IN_16_16_UINT__GFX11                 = 0x000000e0,
+    IMG_FMT_MM_12_IN_16_16_16_16_UNORM__GFX11          = 0x000000e1,
+    IMG_FMT_MM_12_IN_16_16_16_16_UINT__GFX11           = 0x000000e2,
+    IMG_FMT_6E4_FLOAT__GFX11                           = 0x000000e3,
+    IMG_FMT_7E3_FLOAT__GFX11                           = 0x000000e4,
+#endif
 #if CHIP_HDR_NAVI21
     IMG_FMT_MM_12_IN_16_UNORM__NV21                    = 0x00000120,
     IMG_FMT_MM_12_IN_16_UINT__NV21                     = 0x00000121,
     IMG_FMT_MM_12_IN_16_16_UNORM__NV21                 = 0x00000122,
     IMG_FMT_MM_12_IN_16_16_UINT__NV21                  = 0x00000123,
     IMG_FMT_MM_12_IN_16_16_16_16_UNORM__NV21           = 0x00000124,
     IMG_FMT_MM_12_IN_16_16_16_16_UINT__NV21            = 0x00000125,
 #endif
 #if CHIP_HDR_NAVI22
     IMG_FMT_MM_12_IN_16_UNORM__NV22                    = 0x00000120,
@@ -5099,20 +6467,23 @@ typedef enum IMG_NUM_FORMAT {
     IMG_NUM_FORMAT_FLOAT                               = 0x00000007,
     IMG_NUM_FORMAT_RESERVED_6__GFX09                   = 0x00000006,
     IMG_NUM_FORMAT_SRGB__GFX09                         = 0x00000009,
     IMG_NUM_FORMAT_UNORM_UINT__GFX09                   = 0x0000000a,
     IMG_NUM_FORMAT_RESERVED_11__GFX09                  = 0x0000000b,
     IMG_NUM_FORMAT_RESERVED_12__GFX09                  = 0x0000000c,
     IMG_NUM_FORMAT_RESERVED_13__GFX09                  = 0x0000000d,
     IMG_NUM_FORMAT_RESERVED_8__GFX09_10                = 0x00000008,
     IMG_NUM_FORMAT_RESERVED_14__GFX09_10               = 0x0000000e,
     IMG_NUM_FORMAT_RESERVED_15__GFX09_10               = 0x0000000f,
+#if CHIP_HDR_NAVI31
+    IMG_NUM_FORMAT_SRGB__GFX104PLUS                    = 0x00000006,
+#endif
     IMG_NUM_FORMAT_SNORM_NZ__GFX10CORE                 = 0x00000006,
     IMG_NUM_FORMAT_SRGB__GFX10CORE                     = 0x00000009,
     IMG_NUM_FORMAT_UBNORM__GFX10CORE                   = 0x0000000a,
     IMG_NUM_FORMAT_UBNORM_NZ__GFX10CORE                = 0x0000000b,
     IMG_NUM_FORMAT_UBINT__GFX10CORE                    = 0x0000000c,
     IMG_NUM_FORMAT_UBSCALED__GFX10CORE                 = 0x0000000d,
 } IMG_NUM_FORMAT;
 
 typedef enum IMG_NUM_FORMAT_ASTC_2D {
     IMG_NUM_FORMAT_ASTC_2D_RESERVED_14                 = 0x0000000e,
@@ -5227,20 +6598,29 @@ typedef enum MTYPE {
     MTYPE_CC__GFX09                                    = 0x00000002,
     MTYPE_RESERVED_1__GFX10COREPLUS                    = 0x00000001,
     MTYPE_C_RO_S__GFX10COREPLUS                        = 0x00000002,
     MTYPE_C_RW_S__GFX10COREPLUS                        = 0x00000004,
     MTYPE_RESERVED_5__GFX10COREPLUS                    = 0x00000005,
     MTYPE_C_RO_US__GFX10COREPLUS                       = 0x00000006,
     MTYPE_RESERVED_7__GFX10COREPLUS                    = 0x00000007,
     MTYPE_C_RW_US__GFX10PLUS                           = 0x00000000,
 } MTYPE;
 
+#if CHIP_HDR_NAVI31
+typedef enum OreoMode {
+    OMODE_BLEND                                        = 0x00000000,
+    OMODE_O_THEN_B                                     = 0x00000001,
+    OMODE_P_THEN_O_THEN_B                              = 0x00000002,
+    OMODE_RESERVED_3                                   = 0x00000003,
+} OreoMode;
+#endif
+
 typedef enum PerfCounter_Vals {
     DB_PERF_SEL_SC_DB_tile_sends                       = 0x00000000,
     DB_PERF_SEL_SC_DB_tile_busy                        = 0x00000001,
     DB_PERF_SEL_SC_DB_tile_stalls                      = 0x00000002,
     DB_PERF_SEL_SC_DB_tile_events                      = 0x00000003,
     DB_PERF_SEL_SC_DB_tile_tiles                       = 0x00000004,
     DB_PERF_SEL_SC_DB_tile_covered                     = 0x00000005,
     DB_PERF_SEL_hiz_tc_read_starved                    = 0x00000006,
     DB_PERF_SEL_hiz_tc_write_stall                     = 0x00000007,
     DB_PERF_SEL_DB_SC_tile_sends                       = 0x0000000a,
@@ -5622,20 +7002,83 @@ typedef enum PerfCounter_Vals {
     RMI_rd_tile_32byte_ret__GFX103                     = 0x0000017d,
     RMI_rd_z_32byte_ret__GFX103                        = 0x0000017e,
     RMI_rd_s_32byte_ret__GFX103                        = 0x0000017f,
     RMI_wr_tile_32byte_ack__GFX103                     = 0x00000180,
     RMI_wr_z_32byte_ack__GFX103                        = 0x00000181,
     RMI_wr_s_32byte_ack__GFX103                        = 0x00000182,
     RMI_wr_psdzpc_32byte_ack__GFX103                   = 0x00000183,
     DB_PERF_SEL_DB_CB_lquad_quads_vrs_rate_2x2__GFX103 = 0x00000184,
     DB_PERF_SEL_prez_ps_invoked_pixel_cnt__GFX103      = 0x00000185,
     DB_PERF_SEL_postz_ps_invoked_pixel_cnt__GFX103     = 0x00000186,
+#endif
+#if CHIP_HDR_NAVI31
+    DB_PERF_SEL_esr_ps_vic_busy__GFX104PLUS            = 0x000000c2,
+    DB_PERF_SEL_esr_ps_vic_stall__GFX104PLUS           = 0x000000c3,
+    DB_PERF_SEL_CB_DB_rdreq_sends__GFX104PLUS          = 0x00000109,
+    DB_PERF_SEL_CB_DB_rdreq_prt_sends__GFX104PLUS      = 0x0000010a,
+    DB_PERF_SEL_CB_DB_wrreq_sends__GFX104PLUS          = 0x0000010b,
+    DB_PERF_SEL_CB_DB_wrreq_prt_sends__GFX104PLUS      = 0x0000010c,
+    DB_PERF_SEL_DB_CB_rdret_ack__GFX104PLUS            = 0x0000010d,
+    DB_PERF_SEL_DB_CB_rdret_nack__GFX104PLUS           = 0x0000010e,
+    DB_PERF_SEL_DB_CB_wrret_ack__GFX104PLUS            = 0x0000010f,
+    DB_PERF_SEL_DB_CB_wrret_nack__GFX104PLUS           = 0x00000110,
+    DB_PERF_SEL_unmapped_z_tile_culled__GFX104PLUS     = 0x00000115,
+    DB_PERF_SEL_DB_CB_context_dones__GFX104PLUS        = 0x0000011f,
+    DB_PERF_SEL_DB_CB_eop_dones__GFX104PLUS            = 0x00000120,
+    DB_PERF_SEL_SX_DB_quad_all_pixels_killed__GFX104PLUS = 0x00000121,
+    DB_PERF_SEL_SX_DB_quad_all_pixels_enabled__GFX104PLUS = 0x00000122,
+    DB_PERF_SEL_SX_DB_quad_need_blending_and_dst_read__GFX104PLUS = 0x00000123,
+    DB_PERF_SEL_SC_DB_tile_backface__GFX104PLUS        = 0x00000124,
+    DB_PERF_SEL_SC_DB_quad_quads__GFX104PLUS           = 0x00000125,
+    DB_PERF_SEL_DB_SC_quad_quads_with_1_pixel__GFX104PLUS = 0x00000126,
+    DB_PERF_SEL_DB_SC_quad_quads_with_2_pixels__GFX104PLUS = 0x00000127,
+    DB_PERF_SEL_DB_SC_quad_quads_with_3_pixels__GFX104PLUS = 0x00000128,
+    DB_PERF_SEL_DB_SC_quad_quads_with_4_pixels__GFX104PLUS = 0x00000129,
+    DB_PERF_SEL_DB_SC_quad_double_quad__GFX104PLUS     = 0x0000012a,
+    DB_PERF_SEL_SX_DB_quad_export_quads__GFX104PLUS    = 0x0000012b,
+    DB_PERF_SEL_SX_DB_quad_double_format__GFX104PLUS   = 0x0000012c,
+    DB_PERF_SEL_SX_DB_quad_fast_format__GFX104PLUS     = 0x0000012d,
+    DB_PERF_SEL_SX_DB_quad_slow_format__GFX104PLUS     = 0x0000012e,
+    DB_PERF_SEL_quad_rd_sends_unc__GFX104PLUS          = 0x0000012f,
+    DB_PERF_SEL_quad_rd_mi_stall_unc__GFX104PLUS       = 0x00000130,
+    DB_PERF_SEL_SC_DB_tile_tiles_pipe0__GFX104PLUS     = 0x00000131,
+    DB_PERF_SEL_SC_DB_tile_tiles_pipe1__GFX104PLUS     = 0x00000132,
+    DB_PERF_SEL_SC_DB_quad_quads_pipe0__GFX104PLUS     = 0x00000133,
+    DB_PERF_SEL_SC_DB_quad_quads_pipe1__GFX104PLUS     = 0x00000134,
+    DB_PERF_SEL_PERF_fg_lob_fwdr_timeout_hits__GFX104PLUS = 0x00000135,
+    DB_PERF_SEL_RMI_rd_tile_32byte_req__GFX104PLUS     = 0x0000013b,
+    DB_PERF_SEL_RMI_rd_z_32byte_req__GFX104PLUS        = 0x0000013c,
+    DB_PERF_SEL_RMI_rd_s_32byte_req__GFX104PLUS        = 0x0000013d,
+    DB_PERF_SEL_RMI_wr_tile_32byte_req__GFX104PLUS     = 0x0000013e,
+    DB_PERF_SEL_RMI_wr_z_32byte_req__GFX104PLUS        = 0x0000013f,
+    DB_PERF_SEL_RMI_wr_s_32byte_req__GFX104PLUS        = 0x00000140,
+    DB_PERF_SEL_RMI_wr_psdzpc_32byte_req__GFX104PLUS   = 0x00000141,
+    DB_PERF_SEL_RMI_rd_tile_32byte_ret__GFX104PLUS     = 0x00000142,
+    DB_PERF_SEL_RMI_rd_z_32byte_ret__GFX104PLUS        = 0x00000143,
+    DB_PERF_SEL_RMI_rd_s_32byte_ret__GFX104PLUS        = 0x00000144,
+    DB_PERF_SEL_RMI_wr_tile_32byte_ack__GFX104PLUS     = 0x00000145,
+    DB_PERF_SEL_RMI_wr_z_32byte_ack__GFX104PLUS        = 0x00000146,
+    DB_PERF_SEL_RMI_wr_s_32byte_ack__GFX104PLUS        = 0x00000147,
+    DB_PERF_SEL_RMI_wr_psdzpc_32byte_ack__GFX104PLUS   = 0x00000148,
+    DB_PERF_SEL_esr_vic_sqq_busy__GFX104PLUS           = 0x00000149,
+    DB_PERF_SEL_esr_vic_sqq_stall__GFX104PLUS          = 0x0000014a,
+    DB_PERF_SEL_esr_psi_vic_tile_rate__GFX104PLUS      = 0x0000014b,
+    DB_PERF_SEL_esr_vic_footprint_match_2x2__GFX104PLUS = 0x0000014c,
+    DB_PERF_SEL_esr_vic_footprint_match_2x1__GFX104PLUS = 0x0000014d,
+    DB_PERF_SEL_esr_vic_footprint_match_1x2__GFX104PLUS = 0x0000014e,
+    DB_PERF_SEL_DB_SC_quad_num_null_2x2_coarse_pixels__GFX104PLUS = 0x0000014f,
+    DB_PERF_SEL_DB_SC_quad_num_null_2x1_coarse_pixels__GFX104PLUS = 0x00000150,
+    DB_PERF_SEL_DB_SC_quad_num_null_1x2_coarse_pixels__GFX104PLUS = 0x00000151,
+    DB_PERF_SEL_hi_z_s_checker_force_coarse_vrs_1x1__GFX104PLUS = 0x00000152,
+    DB_PERF_SEL_hi_z_s_checker_force_ssaa_vrs_1x1__GFX104PLUS = 0x00000153,
+    DB_PERF_SEL_esr_ps_woc_1squadIn_2squadOut__GFX104PLUS = 0x00000154,
+    DB_PERF_SEL_esr_ps_woc_2squadIn_1squadOut__GFX104PLUS = 0x00000155,
 #endif
     Spare_261__GFX10CORE                               = 0x00000105,
     DB_PERF_SEL_DB_CB_lquad_export_quads__GFX10CORE    = 0x00000106,
     DB_PERF_SEL_DB_CB_lquad_double_format__GFX10CORE   = 0x00000107,
     DB_PERF_SEL_DB_CB_lquad_fast_format__GFX10CORE     = 0x00000108,
     DB_PERF_SEL_DB_CB_lquad_slow_format__GFX10CORE     = 0x00000109,
     DB_PERF_SEL_CB_DB_rdreq_sends__GFX10CORE           = 0x0000010a,
     DB_PERF_SEL_CB_DB_rdreq_prt_sends__GFX10CORE       = 0x0000010b,
     DB_PERF_SEL_CB_DB_wrreq_sends__GFX10CORE           = 0x0000010c,
     DB_PERF_SEL_CB_DB_wrreq_prt_sends__GFX10CORE       = 0x0000010d,
@@ -5720,46 +7163,130 @@ typedef enum PerfCounter_Vals {
     DB_PERF_SEL_SC_DB_tile_tiles_pipe1__GFX10CORE      = 0x0000016e,
     DB_PERF_SEL_SC_DB_quad_quads_pipe0__GFX10CORE      = 0x0000016f,
     DB_PERF_SEL_SC_DB_quad_quads_pipe1__GFX10CORE      = 0x00000170,
     DB_PERF_SEL_hiz_tile_culled__GFX10PLUS             = 0x00000008,
     DB_PERF_SEL_his_tile_culled__GFX10PLUS             = 0x00000009,
     DB_PERF_SEL_prezl_tile_mem_stall__GFX10PLUS        = 0x000000d2,
     DB_PERF_SEL_depth_bounds_tile_culled__GFX10PLUS    = 0x000000f3,
     DB_PERF_SEL_DB_SC_s_tile_rate__GFX10PLUS           = 0x00000102,
     DB_PERF_SEL_DB_SC_c_tile_rate__GFX10PLUS           = 0x00000103,
     DB_PERF_SEL_DB_SC_z_tile_rate__GFX10PLUS           = 0x00000104,
+#if CHIP_HDR_NAVI31
+    DB_PERF_SEL_DB_CB_export_events__GFX11             = 0x00000022,
+    DB_PERF_SEL_DB_CB_export_sends__GFX11              = 0x0000002c,
+    DB_PERF_SEL_DB_CB_export_busy__GFX11               = 0x0000002d,
+    DB_PERF_SEL_DB_CB_export_stalls__GFX11             = 0x0000002e,
+    DB_PERF_SEL_DB_CB_export_quads__GFX11              = 0x0000002f,
+    DB_PERF_SEL_DB_CB_export_export_quads__GFX11       = 0x00000105,
+    DB_PERF_SEL_DB_CB_export_double_format__GFX11      = 0x00000106,
+    DB_PERF_SEL_DB_CB_export_fast_format__GFX11        = 0x00000107,
+    DB_PERF_SEL_DB_CB_export_slow_format__GFX11        = 0x00000108,
+    DB_PERF_SEL_MI_tile_req_wrack_counter_stall__GFX11 = 0x00000111,
+    DB_PERF_SEL_MI_quad_req_wrack_counter_stall__GFX11 = 0x00000112,
+    DB_PERF_SEL_MI_zpc_req_wrack_counter_stall__GFX11  = 0x00000113,
+    DB_PERF_SEL_MI_psd_req_wrack_counter_stall__GFX11  = 0x00000114,
+    DB_PERF_SEL_DB_CB_export_is_event_FLUSH_AND_INV_DB_DATA_TS__GFX11 = 0x00000116,
+    DB_PERF_SEL_DB_CB_export_is_event_FLUSH_AND_INV_CB_PIXEL_DATA__GFX11 = 0x00000117,
+    DB_PERF_SEL_DB_CB_export_is_event_BOTTOM_OF_PIPE_TS__GFX11 = 0x00000118,
+    DB_PERF_SEL_DB_CB_export_waiting_for_perfcounter_stop_event__GFX11 = 0x00000119,
+    DB_PERF_SEL_DB_CB_export_fmt_32bpp_8pix__GFX11     = 0x0000011a,
+    DB_PERF_SEL_DB_CB_export_fmt_16_16_unsigned_8pix__GFX11 = 0x0000011b,
+    DB_PERF_SEL_DB_CB_export_fmt_16_16_signed_8pix__GFX11 = 0x0000011c,
+    DB_PERF_SEL_DB_CB_export_fmt_16_16_float_8pix__GFX11 = 0x0000011d,
+    DB_PERF_SEL_DB_CB_export_num_pixels_need_blending__GFX11 = 0x0000011e,
+    DB_PERF_SEL_noz_waiting_for_postz_done__GFX11      = 0x00000136,
+    DB_PERF_SEL_DB_CB_export_quads_vrs_rate_1x1__GFX11 = 0x00000137,
+    DB_PERF_SEL_DB_CB_export_quads_vrs_rate_2x1__GFX11 = 0x00000138,
+    DB_PERF_SEL_DB_CB_export_quads_vrs_rate_1x2__GFX11 = 0x00000139,
+    DB_PERF_SEL_DB_CB_export_quads_vrs_rate_2x2__GFX11 = 0x0000013a,
+    DB_PERF_SEL_prez_ps_invoked_pixel_cnt__GFX11       = 0x00000156,
+    DB_PERF_SEL_postz_ps_invoked_pixel_cnt__GFX11      = 0x00000157,
+    DB_PERF_SEL_DB_SC_quad_noz_tiles__GFX11            = 0x0000015b,
+    DB_PERF_SEL_DB_SC_quad_lit_noz_quad__GFX11         = 0x0000015c,
+    DB_PERF_SEL_DB_SC_quad_conflicts__GFX11            = 0x0000015d,
+    DB_PERF_SEL_SC_DB_quad_vrs_1x1__GFX11              = 0x0000015e,
+    DB_PERF_SEL_SC_DB_quad_vrs_1x2__GFX11              = 0x0000015f,
+    DB_PERF_SEL_SC_DB_quad_vrs_2x1__GFX11              = 0x00000160,
+    DB_PERF_SEL_SC_DB_quad_vrs_2x2__GFX11              = 0x00000161,
+    DB_PERF_SEL_SC_DB_quad_vrs_2x_ssaa__GFX11          = 0x00000162,
+    DB_PERF_SEL_SC_DB_quad_vrs_4x_ssaa__GFX11          = 0x00000163,
+    DB_PERF_SEL_SC_DB_quad_vrs_8x_ssaa__GFX11          = 0x00000164,
+    DB_PERF_SEL_SC_DB_wave_sends__GFX11                = 0x00000165,
+    DB_PERF_SEL_SC_DB_wave_busy__GFX11                 = 0x00000166,
+    DB_PERF_SEL_SC_DB_wave_quads__GFX11                = 0x00000167,
+    DB_PERF_SEL_SC_DB_wave_id_wrapped__GFX11           = 0x00000168,
+    DB_PERF_SEL_DB_SC_wave_sends__GFX11                = 0x00000169,
+    DB_PERF_SEL_DB_SC_wave_busy__GFX11                 = 0x0000016a,
+    DB_PERF_SEL_DB_SC_wave_stalls__GFX11               = 0x0000016b,
+    DB_PERF_SEL_DB_SC_wave_conflict__GFX11             = 0x0000016c,
+    DB_PERF_SEL_DB_SC_wave_hard_conflict__GFX11        = 0x0000016d,
+    DB_PERF_SEL_DB_SC_wave_id_wrapped__GFX11           = 0x0000016e,
+    DB_PERF_SEL_SX_DB_quad_waves__GFX11                = 0x0000016f,
+    DB_PERF_SEL_OREO_TT_load__GFX11                    = 0x00000173,
+    DB_PERF_SEL_OREO_TT_read__GFX11                    = 0x00000174,
+    DB_PERF_SEL_OREO_TT_stalls__GFX11                  = 0x00000175,
+    DB_PERF_SEL_OREO_ST_load__GFX11                    = 0x00000176,
+    DB_PERF_SEL_OREO_ST_read__GFX11                    = 0x00000177,
+    DB_PERF_SEL_OREO_ST_stalls__GFX11                  = 0x00000178,
+    DB_PERF_SEL_OREO_WT_load__GFX11                    = 0x00000179,
+    DB_PERF_SEL_OREO_WT_read__GFX11                    = 0x0000017a,
+    DB_PERF_SEL_OREO_SB_misses__GFX11                  = 0x0000017b,
+    DB_PERF_SEL_OREO_SB_hits__GFX11                    = 0x0000017c,
+    DB_PERF_SEL_OREO_SB_evicts__GFX11                  = 0x0000017d,
+    DB_PERF_SEL_OREO_SB_stalls__GFX11                  = 0x0000017e,
+    DB_PERF_SEL_OREO_Events_load__GFX11                = 0x0000017f,
+    DB_PERF_SEL_OREO_Events_transition__GFX11          = 0x00000180,
+    DB_PERF_SEL_OREO_Events_non_transition__GFX11      = 0x00000181,
+    DB_PERF_SEL_OREO_Events_delayed__GFX11             = 0x00000182,
+    DB_PERF_SEL_OREO_Events_stalls__GFX11              = 0x00000183,
+#endif
+#if CHIP_HDR_NAVI31
+    DB_PERF_SEL_ts_events_pws_enable__HASPWS           = 0x00000158,
+    DB_PERF_SEL_ps_events_pws_enable__HASPWS           = 0x00000159,
+    DB_PERF_SEL_cs_events_pws_enable__HASPWS           = 0x0000015a,
+    DB_PERF_SEL_pws_stall__HASPWS                      = 0x00000170,
+    DB_PERF_SEL_pws_liveness_stall_dtt_tag__HASPWS     = 0x00000171,
+    DB_PERF_SEL_pws_liveness_stall_tcp_cache_mgr__HASPWS = 0x00000172,
+#endif
 } PerfCounter_Vals;
 
 constexpr unsigned int MaxPerfcounterValsGfx09         = DB_PERF_SEL_DB_SC_quad_quads_with_4_pixels__GFX09;
 constexpr unsigned int MaxPerfcounterValsGfx101        = DB_PERF_SEL_FG_LOB_FWDR_TIMEOUT_hits__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxPerfcounterValsGfx103        = DB_PERF_SEL_postz_ps_invoked_pixel_cnt__GFX103;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxPerfcounterValsGfx11         = DB_PERF_SEL_OREO_Events_stalls__GFX11;
+#endif
 
 typedef enum PERFMON_CNTOFF_AND_OR {
     PERFMON_CNTOFF_OR__GFX101                          = 0x00000000,
     PERFMON_CNTOFF_AND__GFX101                         = 0x00000001,
 #if CHIP_HDR_NAVI21
     PERFMON_CNTOFF_OR__NV21                            = 0x00000000,
     PERFMON_CNTOFF_AND__NV21                           = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI22
     PERFMON_CNTOFF_OR__NV22                            = 0x00000000,
     PERFMON_CNTOFF_AND__NV22                           = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI23
     PERFMON_CNTOFF_OR__NV23                            = 0x00000000,
     PERFMON_CNTOFF_AND__NV23                           = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI24
     PERFMON_CNTOFF_OR__NV24                            = 0x00000000,
     PERFMON_CNTOFF_AND__NV24                           = 0x00000001,
+#endif
+#if CHIP_HDR_NAVI31
+    PERFMON_CNTOFF_OR__NV31                            = 0x00000000,
+    PERFMON_CNTOFF_AND__NV31                           = 0x00000001,
 #endif
     PERFMON_CNTOFF_OR__VG12_RN                         = 0x00000000,
     PERFMON_CNTOFF_AND__VG12_RN                        = 0x00000001,
 } PERFMON_CNTOFF_AND_OR;
 
 typedef enum PERFMON_CNTOFF_INT_EN {
     PERFMON_CNTOFF_INT_DISABLE__GFX101                 = 0x00000000,
     PERFMON_CNTOFF_INT_ENABLE__GFX101                  = 0x00000001,
 #if CHIP_HDR_NAVI21
     PERFMON_CNTOFF_INT_DISABLE__NV21                   = 0x00000000,
@@ -5769,20 +7296,24 @@ typedef enum PERFMON_CNTOFF_INT_EN {
     PERFMON_CNTOFF_INT_DISABLE__NV22                   = 0x00000000,
     PERFMON_CNTOFF_INT_ENABLE__NV22                    = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI23
     PERFMON_CNTOFF_INT_DISABLE__NV23                   = 0x00000000,
     PERFMON_CNTOFF_INT_ENABLE__NV23                    = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI24
     PERFMON_CNTOFF_INT_DISABLE__NV24                   = 0x00000000,
     PERFMON_CNTOFF_INT_ENABLE__NV24                    = 0x00000001,
+#endif
+#if CHIP_HDR_NAVI31
+    PERFMON_CNTOFF_INT_DISABLE__NV31                   = 0x00000000,
+    PERFMON_CNTOFF_INT_ENABLE__NV31                    = 0x00000001,
 #endif
     PERFMON_CNTOFF_INT_DISABLE__VG12_RN                = 0x00000000,
     PERFMON_CNTOFF_INT_ENABLE__VG12_RN                 = 0x00000001,
 } PERFMON_CNTOFF_INT_EN;
 
 typedef enum PERFMON_CNTOFF_INT_TYPE {
     PERFMON_CNTOFF_INT_TYPE_LEVEL__GFX101              = 0x00000000,
     PERFMON_CNTOFF_INT_TYPE_PULSE__GFX101              = 0x00000001,
 #if CHIP_HDR_NAVI21
     PERFMON_CNTOFF_INT_TYPE_LEVEL__NV21                = 0x00000000,
@@ -5792,20 +7323,24 @@ typedef enum PERFMON_CNTOFF_INT_TYPE {
     PERFMON_CNTOFF_INT_TYPE_LEVEL__NV22                = 0x00000000,
     PERFMON_CNTOFF_INT_TYPE_PULSE__NV22                = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI23
     PERFMON_CNTOFF_INT_TYPE_LEVEL__NV23                = 0x00000000,
     PERFMON_CNTOFF_INT_TYPE_PULSE__NV23                = 0x00000001,
 #endif
 #if CHIP_HDR_NAVI24
     PERFMON_CNTOFF_INT_TYPE_LEVEL__NV24                = 0x00000000,
     PERFMON_CNTOFF_INT_TYPE_PULSE__NV24                = 0x00000001,
+#endif
+#if CHIP_HDR_NAVI31
+    PERFMON_CNTOFF_INT_TYPE_LEVEL__NV31                = 0x00000000,
+    PERFMON_CNTOFF_INT_TYPE_PULSE__NV31                = 0x00000001,
 #endif
     PERFMON_CNTOFF_INT_TYPE_LEVEL__VG12_RN             = 0x00000000,
     PERFMON_CNTOFF_INT_TYPE_PULSE__VG12_RN             = 0x00000001,
 } PERFMON_CNTOFF_INT_TYPE;
 
 typedef enum PERFMON_COUNTER_MODE {
     PERFMON_COUNTER_MODE_ACCUM                         = 0x00000000,
     PERFMON_COUNTER_MODE_ACTIVE_CYCLES                 = 0x00000001,
     PERFMON_COUNTER_MODE_MAX                           = 0x00000002,
     PERFMON_COUNTER_MODE_DIRTY                         = 0x00000003,
@@ -5853,20 +7388,26 @@ typedef enum PERFMON_STATE {
     PERFMON_STATE_RESET__NV23                          = 0x00000000,
     PERFMON_STATE_START__NV23                          = 0x00000001,
     PERFMON_STATE_FREEZE__NV23                         = 0x00000002,
     PERFMON_STATE_HW__NV23                             = 0x00000003,
 #endif
 #if CHIP_HDR_NAVI24
     PERFMON_STATE_RESET__NV24                          = 0x00000000,
     PERFMON_STATE_START__NV24                          = 0x00000001,
     PERFMON_STATE_FREEZE__NV24                         = 0x00000002,
     PERFMON_STATE_HW__NV24                             = 0x00000003,
+#endif
+#if CHIP_HDR_NAVI31
+    PERFMON_STATE_RESET__NV31                          = 0x00000000,
+    PERFMON_STATE_START__NV31                          = 0x00000001,
+    PERFMON_STATE_FREEZE__NV31                         = 0x00000002,
+    PERFMON_STATE_HW__NV31                             = 0x00000003,
 #endif
     PERFMON_STATE_RESET__VG12_RN                       = 0x00000000,
     PERFMON_STATE_START__VG12_RN                       = 0x00000001,
     PERFMON_STATE_FREEZE__VG12_RN                      = 0x00000002,
     PERFMON_STATE_HW__VG12_RN                          = 0x00000003,
 } PERFMON_STATE;
 
 typedef enum PH_PERFCNT_SEL {
     PH_PERF_SEL_SC0_SRPS_WINDOW_VALID                  = 0x00000000,
     PH_PERF_SEL_SC0_ARB_XFC_ALL_EVENT_OR_PRIM_CYCLES   = 0x00000001,
@@ -6821,21 +8362,21 @@ typedef enum PH_PERFCNT_SEL {
     PH_PERF_SEL_SC5_GFX_PIPE0_TO_1_TRANSITION__GFX101  = 0x0000026e,
     PH_PERF_SEL_SC5_GFX_PIPE1_TO_0_TRANSITION__GFX101  = 0x0000026f,
     PH_PERF_SEL_SC6_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX101 = 0x000002e4,
     PH_PERF_SEL_SC6_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX101 = 0x000002e5,
     PH_PERF_SEL_SC6_GFX_PIPE0_TO_1_TRANSITION__GFX101  = 0x000002e6,
     PH_PERF_SEL_SC6_GFX_PIPE1_TO_0_TRANSITION__GFX101  = 0x000002e7,
     PH_PERF_SEL_SC7_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX101 = 0x0000035c,
     PH_PERF_SEL_SC7_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX101 = 0x0000035d,
     PH_PERF_SEL_SC7_GFX_PIPE0_TO_1_TRANSITION__GFX101  = 0x0000035e,
     PH_PERF_SEL_SC7_GFX_PIPE1_TO_0_TRANSITION__GFX101  = 0x0000035f,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     PH_PERF_SEL_1_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c0,
     PH_PERF_SEL_2_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c1,
     PH_PERF_SEL_3_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c2,
     PH_PERF_SEL_4_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c3,
     PH_PERF_SEL_5_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c4,
     PH_PERF_SEL_6_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c5,
     PH_PERF_SEL_7_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c6,
     PH_PERF_SEL_8_SC_ARB_STALLED_FROM_BELOW__GFX103PLUSEXCLUSIVE = 0x000003c7,
     PH_PERF_SEL_1_SC_ARB_STARVED_FROM_ABOVE__GFX103PLUSEXCLUSIVE = 0x000003c8,
     PH_PERF_SEL_2_SC_ARB_STARVED_FROM_ABOVE__GFX103PLUSEXCLUSIVE = 0x000003c9,
@@ -6855,20 +8396,214 @@ typedef enum PH_PERFCNT_SEL {
     PH_PERF_SEL_8_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_NOT_EMPTY__GFX103PLUSEXCLUSIVE = 0x000003d7,
     PH_PERF_SEL_1_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003d8,
     PH_PERF_SEL_2_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003d9,
     PH_PERF_SEL_3_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003da,
     PH_PERF_SEL_4_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003db,
     PH_PERF_SEL_5_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003dc,
     PH_PERF_SEL_6_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003dd,
     PH_PERF_SEL_7_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003de,
     PH_PERF_SEL_8_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000003df,
 #endif
+#if CHIP_HDR_NAVI31
+    PH_PERF_SEL_SC0_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x00000014,
+    PH_PERF_SEL_SC0_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x00000015,
+    PH_PERF_SEL_SC0_GFX_PIPE_PRIM_PROVOKED_TRANSITION__GFX11 = 0x00000016,
+    PH_PERF_SEL_SC0_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x00000017,
+    PH_PERF_SEL_SC0_PA0_FPOP_WE__GFX11                 = 0x0000001f,
+    PH_PERF_SEL_SC0_PA0_DEALLOC_WE__GFX11              = 0x00000023,
+    PH_PERF_SEL_SC0_PA1_FPOP_WE__GFX11                 = 0x0000002b,
+    PH_PERF_SEL_SC0_PA1_DEALLOC_WE__GFX11              = 0x0000002f,
+    PH_PERF_SEL_SC0_PA2_FPOP_WE__GFX11                 = 0x00000037,
+    PH_PERF_SEL_SC0_PA2_DEALLOC_WE__GFX11              = 0x0000003b,
+    PH_PERF_SEL_SC0_PA3_FPOP_WE__GFX11                 = 0x00000043,
+    PH_PERF_SEL_SC0_PA3_DEALLOC_WE__GFX11              = 0x00000047,
+    PH_PERF_SEL_SC0_PA4_FPOP_WE__GFX11                 = 0x0000004f,
+    PH_PERF_SEL_SC0_PA4_DEALLOC_WE__GFX11              = 0x00000053,
+    PH_PERF_SEL_SC0_PA5_FPOP_WE__GFX11                 = 0x0000005b,
+    PH_PERF_SEL_SC0_PA5_DEALLOC_WE__GFX11              = 0x0000005f,
+    PH_PERF_SEL_SC0_PA6_FPOP_WE__GFX11                 = 0x00000067,
+    PH_PERF_SEL_SC0_PA6_DEALLOC_WE__GFX11              = 0x0000006b,
+    PH_PERF_SEL_SC0_PA7_FPOP_WE__GFX11                 = 0x00000073,
+    PH_PERF_SEL_SC0_PA7_DEALLOC_WE__GFX11              = 0x00000077,
+    PH_PERF_SEL_SC1_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x0000008c,
+    PH_PERF_SEL_SC1_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x0000008d,
+    PH_PERF_SEL_SC1_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x0000008e,
+    PH_PERF_SEL_SC1_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x0000008f,
+    PH_PERF_SEL_SC1_PA0_FPOP_WE__GFX11                 = 0x00000097,
+    PH_PERF_SEL_SC1_PA0_DEALLOC_WE__GFX11              = 0x0000009b,
+    PH_PERF_SEL_SC1_PA1_FPOP_WE__GFX11                 = 0x000000a3,
+    PH_PERF_SEL_SC1_PA1_DEALLOC_WE__GFX11              = 0x000000a7,
+    PH_PERF_SEL_SC1_PA2_FPOP_WE__GFX11                 = 0x000000af,
+    PH_PERF_SEL_SC1_PA2_DEALLOC_WE__GFX11              = 0x000000b3,
+    PH_PERF_SEL_SC1_PA3_FPOP_WE__GFX11                 = 0x000000bb,
+    PH_PERF_SEL_SC1_PA3_DEALLOC_WE__GFX11              = 0x000000bf,
+    PH_PERF_SEL_SC1_PA4_FPOP_WE__GFX11                 = 0x000000c7,
+    PH_PERF_SEL_SC1_PA4_DEALLOC_WE__GFX11              = 0x000000cb,
+    PH_PERF_SEL_SC1_PA5_FPOP_WE__GFX11                 = 0x000000d3,
+    PH_PERF_SEL_SC1_PA5_DEALLOC_WE__GFX11              = 0x000000d7,
+    PH_PERF_SEL_SC1_PA6_FPOP_WE__GFX11                 = 0x000000df,
+    PH_PERF_SEL_SC1_PA6_DEALLOC_WE__GFX11              = 0x000000e3,
+    PH_PERF_SEL_SC1_PA7_FPOP_WE__GFX11                 = 0x000000eb,
+    PH_PERF_SEL_SC1_PA7_DEALLOC_WE__GFX11              = 0x000000ef,
+    PH_PERF_SEL_SC2_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x00000104,
+    PH_PERF_SEL_SC2_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x00000105,
+    PH_PERF_SEL_SC2_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x00000106,
+    PH_PERF_SEL_SC2_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x00000107,
+    PH_PERF_SEL_SC2_PA0_FPOP_WE__GFX11                 = 0x0000010f,
+    PH_PERF_SEL_SC2_PA0_DEALLOC_WE__GFX11              = 0x00000113,
+    PH_PERF_SEL_SC2_PA1_FPOP_WE__GFX11                 = 0x0000011b,
+    PH_PERF_SEL_SC2_PA1_DEALLOC_WE__GFX11              = 0x0000011f,
+    PH_PERF_SEL_SC2_PA2_FPOP_WE__GFX11                 = 0x00000127,
+    PH_PERF_SEL_SC2_PA2_DEALLOC_WE__GFX11              = 0x0000012b,
+    PH_PERF_SEL_SC2_PA3_FPOP_WE__GFX11                 = 0x00000133,
+    PH_PERF_SEL_SC2_PA3_DEALLOC_WE__GFX11              = 0x00000137,
+    PH_PERF_SEL_SC2_PA4_FPOP_WE__GFX11                 = 0x0000013f,
+    PH_PERF_SEL_SC2_PA4_DEALLOC_WE__GFX11              = 0x00000143,
+    PH_PERF_SEL_SC2_PA5_FPOP_WE__GFX11                 = 0x0000014b,
+    PH_PERF_SEL_SC2_PA5_DEALLOC_WE__GFX11              = 0x0000014f,
+    PH_PERF_SEL_SC2_PA6_FPOP_WE__GFX11                 = 0x00000157,
+    PH_PERF_SEL_SC2_PA6_DEALLOC_WE__GFX11              = 0x0000015b,
+    PH_PERF_SEL_SC2_PA7_FPOP_WE__GFX11                 = 0x00000163,
+    PH_PERF_SEL_SC2_PA7_DEALLOC_WE__GFX11              = 0x00000167,
+    PH_PERF_SEL_SC3_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x0000017c,
+    PH_PERF_SEL_SC3_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x0000017d,
+    PH_PERF_SEL_SC3_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x0000017e,
+    PH_PERF_SEL_SC3_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x0000017f,
+    PH_PERF_SEL_SC3_PA0_FPOP_WE__GFX11                 = 0x00000187,
+    PH_PERF_SEL_SC3_PA0_DEALLOC_WE__GFX11              = 0x0000018b,
+    PH_PERF_SEL_SC3_PA1_FPOP_WE__GFX11                 = 0x00000193,
+    PH_PERF_SEL_SC3_PA1_DEALLOC_WE__GFX11              = 0x00000197,
+    PH_PERF_SEL_SC3_PA2_FPOP_WE__GFX11                 = 0x0000019f,
+    PH_PERF_SEL_SC3_PA2_DEALLOC_WE__GFX11              = 0x000001a3,
+    PH_PERF_SEL_SC3_PA3_FPOP_WE__GFX11                 = 0x000001ab,
+    PH_PERF_SEL_SC3_PA3_DEALLOC_WE__GFX11              = 0x000001af,
+    PH_PERF_SEL_SC3_PA4_FPOP_WE__GFX11                 = 0x000001b7,
+    PH_PERF_SEL_SC3_PA4_DEALLOC_WE__GFX11              = 0x000001bb,
+    PH_PERF_SEL_SC3_PA5_FPOP_WE__GFX11                 = 0x000001c3,
+    PH_PERF_SEL_SC3_PA5_DEALLOC_WE__GFX11              = 0x000001c7,
+    PH_PERF_SEL_SC3_PA6_FPOP_WE__GFX11                 = 0x000001cf,
+    PH_PERF_SEL_SC3_PA6_DEALLOC_WE__GFX11              = 0x000001d3,
+    PH_PERF_SEL_SC3_PA7_FPOP_WE__GFX11                 = 0x000001db,
+    PH_PERF_SEL_SC3_PA7_DEALLOC_WE__GFX11              = 0x000001df,
+    PH_PERF_SEL_SC4_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x000001f4,
+    PH_PERF_SEL_SC4_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x000001f5,
+    PH_PERF_SEL_SC4_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x000001f6,
+    PH_PERF_SEL_SC4_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x000001f7,
+    PH_PERF_SEL_SC4_PA0_FPOP_WE__GFX11                 = 0x000001ff,
+    PH_PERF_SEL_SC4_PA0_DEALLOC_WE__GFX11              = 0x00000203,
+    PH_PERF_SEL_SC4_PA1_FPOP_WE__GFX11                 = 0x0000020b,
+    PH_PERF_SEL_SC4_PA1_DEALLOC_WE__GFX11              = 0x0000020f,
+    PH_PERF_SEL_SC4_PA2_FPOP_WE__GFX11                 = 0x00000217,
+    PH_PERF_SEL_SC4_PA2_DEALLOC_WE__GFX11              = 0x0000021b,
+    PH_PERF_SEL_SC4_PA3_FPOP_WE__GFX11                 = 0x00000223,
+    PH_PERF_SEL_SC4_PA3_DEALLOC_WE__GFX11              = 0x00000227,
+    PH_PERF_SEL_SC4_PA4_FPOP_WE__GFX11                 = 0x0000022f,
+    PH_PERF_SEL_SC4_PA4_DEALLOC_WE__GFX11              = 0x00000233,
+    PH_PERF_SEL_SC4_PA5_FPOP_WE__GFX11                 = 0x0000023b,
+    PH_PERF_SEL_SC4_PA5_DEALLOC_WE__GFX11              = 0x0000023f,
+    PH_PERF_SEL_SC4_PA6_FPOP_WE__GFX11                 = 0x00000247,
+    PH_PERF_SEL_SC4_PA6_DEALLOC_WE__GFX11              = 0x0000024b,
+    PH_PERF_SEL_SC4_PA7_FPOP_WE__GFX11                 = 0x00000253,
+    PH_PERF_SEL_SC4_PA7_DEALLOC_WE__GFX11              = 0x00000257,
+    PH_PERF_SEL_SC5_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x0000026c,
+    PH_PERF_SEL_SC5_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x0000026d,
+    PH_PERF_SEL_SC5_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x0000026e,
+    PH_PERF_SEL_SC5_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x0000026f,
+    PH_PERF_SEL_SC5_PA0_FPOP_WE__GFX11                 = 0x00000277,
+    PH_PERF_SEL_SC5_PA0_DEALLOC_WE__GFX11              = 0x0000027b,
+    PH_PERF_SEL_SC5_PA1_FPOP_WE__GFX11                 = 0x00000283,
+    PH_PERF_SEL_SC5_PA1_DEALLOC_WE__GFX11              = 0x00000287,
+    PH_PERF_SEL_SC5_PA2_FPOP_WE__GFX11                 = 0x0000028f,
+    PH_PERF_SEL_SC5_PA2_DEALLOC_WE__GFX11              = 0x00000293,
+    PH_PERF_SEL_SC5_PA3_FPOP_WE__GFX11                 = 0x0000029b,
+    PH_PERF_SEL_SC5_PA3_DEALLOC_WE__GFX11              = 0x0000029f,
+    PH_PERF_SEL_SC5_PA4_FPOP_WE__GFX11                 = 0x000002a7,
+    PH_PERF_SEL_SC5_PA4_DEALLOC_WE__GFX11              = 0x000002ab,
+    PH_PERF_SEL_SC5_PA5_FPOP_WE__GFX11                 = 0x000002b3,
+    PH_PERF_SEL_SC5_PA5_DEALLOC_WE__GFX11              = 0x000002b7,
+    PH_PERF_SEL_SC5_PA6_FPOP_WE__GFX11                 = 0x000002bf,
+    PH_PERF_SEL_SC5_PA6_DEALLOC_WE__GFX11              = 0x000002c3,
+    PH_PERF_SEL_SC5_PA7_FPOP_WE__GFX11                 = 0x000002cb,
+    PH_PERF_SEL_SC5_PA7_DEALLOC_WE__GFX11              = 0x000002cf,
+    PH_PERF_SEL_SC6_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x000002e4,
+    PH_PERF_SEL_SC6_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x000002e5,
+    PH_PERF_SEL_SC6_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x000002e6,
+    PH_PERF_SEL_SC6_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x000002e7,
+    PH_PERF_SEL_SC6_PA0_FPOP_WE__GFX11                 = 0x000002ef,
+    PH_PERF_SEL_SC6_PA0_DEALLOC_WE__GFX11              = 0x000002f3,
+    PH_PERF_SEL_SC6_PA1_FPOP_WE__GFX11                 = 0x000002fb,
+    PH_PERF_SEL_SC6_PA1_DEALLOC_WE__GFX11              = 0x000002ff,
+    PH_PERF_SEL_SC6_PA2_FPOP_WE__GFX11                 = 0x00000307,
+    PH_PERF_SEL_SC6_PA2_DEALLOC_WE__GFX11              = 0x0000030b,
+    PH_PERF_SEL_SC6_PA3_FPOP_WE__GFX11                 = 0x00000313,
+    PH_PERF_SEL_SC6_PA3_DEALLOC_WE__GFX11              = 0x00000317,
+    PH_PERF_SEL_SC6_PA4_FPOP_WE__GFX11                 = 0x0000031f,
+    PH_PERF_SEL_SC6_PA4_DEALLOC_WE__GFX11              = 0x00000323,
+    PH_PERF_SEL_SC6_PA5_FPOP_WE__GFX11                 = 0x0000032b,
+    PH_PERF_SEL_SC6_PA5_DEALLOC_WE__GFX11              = 0x0000032f,
+    PH_PERF_SEL_SC6_PA6_FPOP_WE__GFX11                 = 0x00000337,
+    PH_PERF_SEL_SC6_PA6_DEALLOC_WE__GFX11              = 0x0000033b,
+    PH_PERF_SEL_SC6_PA7_FPOP_WE__GFX11                 = 0x00000343,
+    PH_PERF_SEL_SC6_PA7_DEALLOC_WE__GFX11              = 0x00000347,
+    PH_PERF_SEL_SC7_GFX_PIPE0_TO_1_TRANSITION__GFX11   = 0x0000035c,
+    PH_PERF_SEL_SC7_GFX_PIPE1_TO_0_TRANSITION__GFX11   = 0x0000035d,
+    PH_PERF_SEL_SC7_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__GFX11 = 0x0000035e,
+    PH_PERF_SEL_SC7_GFX_PIPE_EVENT_PROVOKED_TRANSITION__GFX11 = 0x0000035f,
+    PH_PERF_SEL_SC7_PA0_FPOP_WE__GFX11                 = 0x00000367,
+    PH_PERF_SEL_SC7_PA0_DEALLOC_WE__GFX11              = 0x0000036b,
+    PH_PERF_SEL_SC7_PA1_FPOP_WE__GFX11                 = 0x00000373,
+    PH_PERF_SEL_SC7_PA1_DEALLOC_WE__GFX11              = 0x00000377,
+    PH_PERF_SEL_SC7_PA2_FPOP_WE__GFX11                 = 0x0000037f,
+    PH_PERF_SEL_SC7_PA2_DEALLOC_WE__GFX11              = 0x00000383,
+    PH_PERF_SEL_SC7_PA3_FPOP_WE__GFX11                 = 0x0000038b,
+    PH_PERF_SEL_SC7_PA3_DEALLOC_WE__GFX11              = 0x0000038f,
+    PH_PERF_SEL_SC7_PA4_FPOP_WE__GFX11                 = 0x00000397,
+    PH_PERF_SEL_SC7_PA4_DEALLOC_WE__GFX11              = 0x0000039b,
+    PH_PERF_SEL_SC7_PA5_FPOP_WE__GFX11                 = 0x000003a3,
+    PH_PERF_SEL_SC7_PA5_DEALLOC_WE__GFX11              = 0x000003a7,
+    PH_PERF_SEL_SC7_PA6_FPOP_WE__GFX11                 = 0x000003af,
+    PH_PERF_SEL_SC7_PA6_DEALLOC_WE__GFX11              = 0x000003b3,
+    PH_PERF_SEL_SC7_PA7_FPOP_WE__GFX11                 = 0x000003bb,
+    PH_PERF_SEL_SC7_PA7_DEALLOC_WE__GFX11              = 0x000003bf,
+    PH_PERF_SC0_FIFO_STATUS_0__GFX11                   = 0x000003e0,
+    PH_PERF_SC0_FIFO_STATUS_1__GFX11                   = 0x000003e1,
+    PH_PERF_SC0_FIFO_STATUS_2__GFX11                   = 0x000003e2,
+    PH_PERF_SC0_FIFO_STATUS_3__GFX11                   = 0x000003e3,
+    PH_PERF_SC1_FIFO_STATUS_0__GFX11                   = 0x000003e4,
+    PH_PERF_SC1_FIFO_STATUS_1__GFX11                   = 0x000003e5,
+    PH_PERF_SC1_FIFO_STATUS_2__GFX11                   = 0x000003e6,
+    PH_PERF_SC1_FIFO_STATUS_3__GFX11                   = 0x000003e7,
+    PH_PERF_SC2_FIFO_STATUS_0__GFX11                   = 0x000003e8,
+    PH_PERF_SC2_FIFO_STATUS_1__GFX11                   = 0x000003e9,
+    PH_PERF_SC2_FIFO_STATUS_2__GFX11                   = 0x000003ea,
+    PH_PERF_SC2_FIFO_STATUS_3__GFX11                   = 0x000003eb,
+    PH_PERF_SC3_FIFO_STATUS_0__GFX11                   = 0x000003ec,
+    PH_PERF_SC3_FIFO_STATUS_1__GFX11                   = 0x000003ed,
+    PH_PERF_SC3_FIFO_STATUS_2__GFX11                   = 0x000003ee,
+    PH_PERF_SC3_FIFO_STATUS_3__GFX11                   = 0x000003ef,
+    PH_PERF_SC4_FIFO_STATUS_0__GFX11                   = 0x000003f0,
+    PH_PERF_SC4_FIFO_STATUS_1__GFX11                   = 0x000003f1,
+    PH_PERF_SC4_FIFO_STATUS_2__GFX11                   = 0x000003f2,
+    PH_PERF_SC4_FIFO_STATUS_3__GFX11                   = 0x000003f3,
+    PH_PERF_SC5_FIFO_STATUS_0__GFX11                   = 0x000003f4,
+    PH_PERF_SC5_FIFO_STATUS_1__GFX11                   = 0x000003f5,
+    PH_PERF_SC5_FIFO_STATUS_2__GFX11                   = 0x000003f6,
+    PH_PERF_SC5_FIFO_STATUS_3__GFX11                   = 0x000003f7,
+    PH_PERF_SC6_FIFO_STATUS_0__GFX11                   = 0x000003f8,
+    PH_PERF_SC6_FIFO_STATUS_1__GFX11                   = 0x000003f9,
+    PH_PERF_SC6_FIFO_STATUS_2__GFX11                   = 0x000003fa,
+    PH_PERF_SC6_FIFO_STATUS_3__GFX11                   = 0x000003fb,
+    PH_PERF_SC7_FIFO_STATUS_0__GFX11                   = 0x000003fc,
+    PH_PERF_SC7_FIFO_STATUS_1__GFX11                   = 0x000003fd,
+    PH_PERF_SC7_FIFO_STATUS_2__GFX11                   = 0x000003fe,
+    PH_PERF_SC7_FIFO_STATUS_3__GFX11                   = 0x000003ff,
+#endif
 #if CHIP_HDR_NAVI21
     PH_PERF_SEL_SC0_GFX_PIPE_EVENT_PROVOKED_TRANSITION__NV21 = 0x00000014,
     PH_PERF_SEL_SC0_GFX_PIPE_PRIM_PROVOKED_TRANSITION__NV21 = 0x00000015,
     PH_PERF_SEL_SC0_GFX_PIPE0_TO_1_TRANSITION__NV21    = 0x00000016,
     PH_PERF_SEL_SC0_GFX_PIPE1_TO_0_TRANSITION__NV21    = 0x00000017,
     PH_PERF_SEL_SC1_GFX_PIPE_EVENT_PROVOKED_TRANSITION__NV21 = 0x0000008c,
     PH_PERF_SEL_SC1_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__NV21 = 0x0000008d,
     PH_PERF_SEL_SC1_GFX_PIPE0_TO_1_TRANSITION__NV21    = 0x0000008e,
     PH_PERF_SEL_SC1_GFX_PIPE1_TO_0_TRANSITION__NV21    = 0x0000008f,
     PH_PERF_SEL_SC2_GFX_PIPE_EVENT_PROVOKED_TRANSITION__NV21 = 0x00000104,
@@ -6997,20 +8732,23 @@ typedef enum PH_PERFCNT_SEL {
     PH_PERF_SEL_SC7_GFX_PIPE1_TO_0_TRANSITION__NV24    = 0x0000035d,
     PH_PERF_SEL_SC7_GFX_PIPE_EOP_PRIM_PROVOKED_TRANSITION__NV24 = 0x0000035e,
     PH_PERF_SEL_SC7_GFX_PIPE_EVENT_PROVOKED_TRANSITION__NV24 = 0x0000035f,
 #endif
 } PH_PERFCNT_SEL;
 
 constexpr unsigned int MaxPhPerfcntSelGfx101           = PH_PERF_SEL_SC7_PA7_DEALLOC_4_0_RD__GFX10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxPhPerfcntSelGfx103Derivative = PH_PERF_SEL_8_SC_ARB_STARVED_FROM_ABOVE_WITH_UNSELECTED_FIFO_FULL__GFX103PLUSEXCLUSIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxPhPerfcntSelGfx11            = PH_PERF_SC7_FIFO_STATUS_3__GFX11;
+#endif
 
 typedef enum PipeConfig {
     ADDR_SURF_P2                                       = 0x00000000,
     ADDR_SURF_P2_RESERVED0                             = 0x00000001,
     ADDR_SURF_P2_RESERVED1                             = 0x00000002,
     ADDR_SURF_P2_RESERVED2                             = 0x00000003,
     ADDR_SURF_P4_8x16                                  = 0x00000004,
     ADDR_SURF_P4_16x16                                 = 0x00000005,
     ADDR_SURF_P4_16x32                                 = 0x00000006,
     ADDR_SURF_P4_32x32                                 = 0x00000007,
@@ -7600,24 +9338,160 @@ typedef enum RMIPerfSel {
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID3__GFX10CORE    = 0x000000f8,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID4__GFX10CORE    = 0x000000f9,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID5__GFX10CORE    = 0x000000fa,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID6__GFX10CORE    = 0x000000fb,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID7__GFX10CORE    = 0x000000fc,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_NACK0__GFX10CORE   = 0x000000fd,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_NACK1__GFX10CORE   = 0x000000fe,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_NACK2__GFX10CORE   = 0x000000ff,
     RMI_PERF_SEL_RMI_RB_EARLY_WRACK_NACK3__GFX10CORE   = 0x00000100,
     RMI_PERF_SEL_UTCL0_UTCL1_PERM_FAULT__GFX10CORE     = 0x00000101,
+#if CHIP_HDR_NAVI31
+    RMI_PERF_SEL_RB_RMI_WRREQ_ALL_CID__GFX11           = 0x00000008,
+    RMI_PERF_SEL_RB_RMI_WRREQ_TO_WRRET_BUSY__GFX11     = 0x00000009,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID0__GFX11              = 0x0000000a,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID1__GFX11              = 0x0000000b,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID2__GFX11              = 0x0000000c,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID3__GFX11              = 0x0000000d,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID4__GFX11              = 0x0000000e,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID5__GFX11              = 0x0000000f,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID6__GFX11              = 0x00000010,
+    RMI_PERF_SEL_RB_RMI_WRREQ_CID7__GFX11              = 0x00000011,
+    RMI_PERF_SEL_RB_RMI_32BWRREQ_INFLIGHT_ALL_ORONE_CID__GFX11 = 0x00000012,
+    RMI_PERF_SEL_RB_RMI_WRREQ_BURST_LENGTH_ALL_ORONE_CID__GFX11 = 0x00000013,
+    RMI_PERF_SEL_RB_RMI_WRREQ_BURST_ALL_ORONE_CID__GFX11 = 0x00000014,
+    RMI_PERF_SEL_RB_RMI_WRREQ_RESIDENCY__GFX11         = 0x00000015,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_ALL_CID__GFX11     = 0x00000016,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID0__GFX11        = 0x00000017,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID1__GFX11        = 0x00000018,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID2__GFX11        = 0x00000019,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID3__GFX11        = 0x0000001a,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID4__GFX11        = 0x0000001b,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID5__GFX11        = 0x0000001c,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID6__GFX11        = 0x0000001d,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_CID7__GFX11        = 0x0000001e,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_NACK0__GFX11       = 0x0000001f,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_NACK1__GFX11       = 0x00000020,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_NACK2__GFX11       = 0x00000021,
+    RMI_PERF_SEL_RMI_RB_WRRET_VALID_NACK3__GFX11       = 0x00000022,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_ALL_CID__GFX11        = 0x00000023,
+    RMI_PERF_SEL_RB_RMI_RDREQ_ALL_CID__GFX11           = 0x00000024,
+    RMI_PERF_SEL_RB_RMI_RDREQ_TO_RDRET_BUSY__GFX11     = 0x00000025,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID0__GFX11           = 0x00000026,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID1__GFX11           = 0x00000027,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID2__GFX11           = 0x00000028,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID3__GFX11           = 0x00000029,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID4__GFX11           = 0x0000002a,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID5__GFX11           = 0x0000002b,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID6__GFX11           = 0x0000002c,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_CID7__GFX11           = 0x0000002d,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID0__GFX11              = 0x0000002e,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID1__GFX11              = 0x0000002f,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID2__GFX11              = 0x00000030,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID3__GFX11              = 0x00000031,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID4__GFX11              = 0x00000032,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID5__GFX11              = 0x00000033,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID6__GFX11              = 0x00000034,
+    RMI_PERF_SEL_RB_RMI_RDREQ_CID7__GFX11              = 0x00000035,
+    RMI_PERF_SEL_RB_RMI_32BRDREQ_INFLIGHT_ALL_ORONE_CID__GFX11 = 0x00000036,
+    RMI_PERF_SEL_RB_RMI_RDREQ_BURST_LENGTH_ALL_ORONE_CID__GFX11 = 0x00000037,
+    RMI_PERF_SEL_RB_RMI_RDREQ_BURST_ALL_ORONE_CID__GFX11 = 0x00000038,
+    RMI_PERF_SEL_RB_RMI_RDREQ_RESIDENCY__GFX11         = 0x00000039,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_ALL_CID__GFX11  = 0x0000003a,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID0__GFX11     = 0x0000003b,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID1__GFX11     = 0x0000003c,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID2__GFX11     = 0x0000003d,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID3__GFX11     = 0x0000003e,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID4__GFX11     = 0x0000003f,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID5__GFX11     = 0x00000040,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID6__GFX11     = 0x00000041,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_CID7__GFX11     = 0x00000042,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_NACK0__GFX11    = 0x00000043,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_NACK1__GFX11    = 0x00000044,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_NACK2__GFX11    = 0x00000045,
+    RMI_PERF_SEL_RMI_RB_32BRDRET_VALID_NACK3__GFX11    = 0x00000046,
+    RMI_PERF_SEL_RB_RMI_WR_FIFO_MAX__GFX11             = 0x00000047,
+    RMI_PERF_SEL_RB_RMI_WR_FIFO_EMPTY__GFX11           = 0x00000048,
+    RMI_PERF_SEL_RB_RMI_WR_IDLE__GFX11                 = 0x00000049,
+    RMI_PERF_SEL_RB_RMI_WR_STARVE__GFX11               = 0x0000004a,
+    RMI_PERF_SEL_RB_RMI_WR_STALL__GFX11                = 0x0000004b,
+    RMI_PERF_SEL_RB_RMI_WR_BUSY__GFX11                 = 0x0000004c,
+    RMI_PERF_SEL_RB_RMI_WR_INTF_BUSY__GFX11            = 0x0000004d,
+    RMI_PERF_SEL_RB_RMI_RD_FIFO_MAX__GFX11             = 0x0000004e,
+    RMI_PERF_SEL_RB_RMI_RD_FIFO_EMPTY__GFX11           = 0x0000004f,
+    RMI_PERF_SEL_RB_RMI_RD_IDLE__GFX11                 = 0x00000050,
+    RMI_PERF_SEL_RB_RMI_RD_STARVE__GFX11               = 0x00000051,
+    RMI_PERF_SEL_RB_RMI_RD_STALL__GFX11                = 0x00000052,
+    RMI_PERF_SEL_RB_RMI_RD_BUSY__GFX11                 = 0x00000053,
+    RMI_PERF_SEL_RB_RMI_RD_INTF_BUSY__GFX11            = 0x00000054,
+    RMI_PERF_SEL_RMI_TC_64BWRREQ_ALL_ORONE_CID__GFX11  = 0x00000055,
+    RMI_PERF_SEL_RMI_TC_64BRDREQ_ALL_ORONE_CID__GFX11  = 0x00000056,
+    RMI_PERF_SEL_RMI_TC_WRREQ_ALL_CID__GFX11           = 0x00000057,
+    RMI_PERF_SEL_RMI_TC_REQ_BUSY__GFX11                = 0x00000058,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID0__GFX11              = 0x00000059,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID1__GFX11              = 0x0000005a,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID2__GFX11              = 0x0000005b,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID3__GFX11              = 0x0000005c,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID4__GFX11              = 0x0000005d,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID5__GFX11              = 0x0000005e,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID6__GFX11              = 0x0000005f,
+    RMI_PERF_SEL_RMI_TC_WRREQ_CID7__GFX11              = 0x00000060,
+    RMI_PERF_SEL_RMI_TC_WRREQ_INFLIGHT_ALL_CID__GFX11  = 0x00000061,
+    RMI_PERF_SEL_TC_RMI_WRRET_VALID_ALL_CID__GFX11     = 0x00000062,
+    RMI_PERF_SEL_RMI_TC_RDREQ_ALL_CID__GFX11           = 0x00000063,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID0__GFX11              = 0x00000064,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID1__GFX11              = 0x00000065,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID2__GFX11              = 0x00000066,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID3__GFX11              = 0x00000067,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID4__GFX11              = 0x00000068,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID5__GFX11              = 0x00000069,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID6__GFX11              = 0x0000006a,
+    RMI_PERF_SEL_RMI_TC_RDREQ_CID7__GFX11              = 0x0000006b,
+    RMI_PERF_SEL_RMI_TC_STALL_RDREQ__GFX11             = 0x0000006c,
+    RMI_PERF_SEL_RMI_TC_STALL_WRREQ__GFX11             = 0x0000006d,
+    RMI_PERF_SEL_RMI_TC_STALL_ALLREQ__GFX11            = 0x0000006e,
+    RMI_PERF_SEL_RMI_TC_CREDIT_FULL_NO_PENDING_SEND__GFX11 = 0x0000006f,
+    RMI_PERF_SEL_RMI_TC_CREDIT_ZERO_PENDING_SEND__GFX11 = 0x00000070,
+    RMI_PERF_SEL_RMI_TC_RDREQ_INFLIGHT_ALL_CID__GFX11  = 0x00000071,
+    RMI_PERF_SEL_TC_RMI_RDRET_VALID_ALL_CID__GFX11     = 0x00000072,
+    RMI_PERF_SEL_TCIW_INFLIGHT_COUNT__GFX11            = 0x00000073,
+    RMI_PERF_SEL_TCIW_REQ__GFX11                       = 0x00000074,
+    RMI_PERF_SEL_TCIW_BUSY__GFX11                      = 0x00000075,
+    RMI_PERF_SEL_DEMUX_TCIW_FORMATTER_RTS_RTR__GFX11   = 0x00000076,
+    RMI_PERF_SEL_DEMUX_TCIW_FORMATTER_RTSB_RTR__GFX11  = 0x00000077,
+    RMI_PERF_SEL_DEMUX_TCIW_FORMATTER_RTS_RTRB__GFX11  = 0x00000078,
+    RMI_PERF_SEL_DEMUX_TCIW_FORMATTER_RTSB_RTRB__GFX11 = 0x00000079,
+    RMI_PERF_SEL_REORDER_FIFO_REQ__GFX11               = 0x0000007a,
+    RMI_PERF_SEL_REORDER_FIFO_BUSY__GFX11              = 0x0000007b,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_ALL_CID__GFX11     = 0x0000007c,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID0__GFX11        = 0x0000007d,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID1__GFX11        = 0x0000007e,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID2__GFX11        = 0x0000007f,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID3__GFX11        = 0x00000080,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID4__GFX11        = 0x00000081,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID5__GFX11        = 0x00000082,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID6__GFX11        = 0x00000083,
+    RMI_PERF_SEL_RMI_RB_EARLY_WRACK_CID7__GFX11        = 0x00000084,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_READ_RTS_RTR__GFX11 = 0x00000085,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_WRITE_RTS_RTR__GFX11 = 0x00000086,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_IN0_RTS_RTR__GFX11  = 0x00000087,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_IN1_RTS_RTR__GFX11  = 0x00000088,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_CB_RTS_RTR__GFX11   = 0x00000089,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_DB_RTS_RTR__GFX11   = 0x0000008a,
+#endif
 } RMIPerfSel;
 
 constexpr unsigned int MaxRMIPerfSelGfx09              = RMI_PERF_SEL_RMI_RB_EARLY_WRACK_NACK3__GFX09;
 constexpr unsigned int MaxRMIPerfSelGfx10Core          = RMI_PERF_SEL_UTCL0_UTCL1_PERM_FAULT__GFX10CORE;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxRMIPerfSelGfx11              = RMI_PERF_SEL_CONSUMER_PROBEGEN_DB_RTS_RTR__GFX11;
+#endif
 
 typedef enum RoundMode {
     ROUND_BY_HALF                                      = 0x00000000,
     ROUND_TRUNCATE                                     = 0x00000001,
 } RoundMode;
 
 typedef enum SC_PERFCNT_SEL {
     SC_SRPS_WINDOW_VALID                               = 0x00000000,
     SC_PSSW_WINDOW_VALID                               = 0x00000001,
     SC_TPQZ_WINDOW_VALID                               = 0x00000002,
@@ -8140,40 +10014,40 @@ typedef enum SC_PERFCNT_SEL {
     SC_SC_SPI_DEALLOC_3_1__GFX101                      = 0x00000150,
     SC_SC_SPI_DEALLOC_3_2__GFX101                      = 0x00000151,
     SC_SC_SPI_FPOV_0__GFX101                           = 0x00000152,
     SC_SC_SPI_FPOV_1__GFX101                           = 0x00000153,
     SC_SC_SPI_FPOV_2__GFX101                           = 0x00000154,
     SC_SC_SPI_FPOV_3__GFX101                           = 0x00000155,
     SC_SC_SPI_EVENT__GFX101                            = 0x00000156,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     SC_PBB_BATCH_BREAK_DUE_TO_PIPELINE_MODE_CHANGE__GFX103DERIVATIVE = 0x00000238,
 #endif
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SC_SPI_EVENT__GFX103PLUS                           = 0x00000156,
     SC_PK_PM_VRS_RATE_X_00_Y_00_QUAD__GFX103PLUS       = 0x00000228,
     SC_PK_PM_VRS_RATE_X_00_Y_01_QUAD__GFX103PLUS       = 0x00000229,
     SC_PK_PM_VRS_RATE_X_00_Y_10_QUAD__GFX103PLUS       = 0x0000022a,
     SC_PK_PM_VRS_RATE_X_00_Y_11_QUAD__GFX103PLUS       = 0x0000022b,
     SC_PK_PM_VRS_RATE_X_01_Y_00_QUAD__GFX103PLUS       = 0x0000022c,
     SC_PK_PM_VRS_RATE_X_01_Y_01_QUAD__GFX103PLUS       = 0x0000022d,
     SC_PK_PM_VRS_RATE_X_01_Y_10_QUAD__GFX103PLUS       = 0x0000022e,
     SC_PK_PM_VRS_RATE_X_01_Y_11_QUAD__GFX103PLUS       = 0x0000022f,
     SC_PK_PM_VRS_RATE_X_10_Y_00_QUAD__GFX103PLUS       = 0x00000230,
     SC_PK_PM_VRS_RATE_X_10_Y_01_QUAD__GFX103PLUS       = 0x00000231,
     SC_PK_PM_VRS_RATE_X_10_Y_10_QUAD__GFX103PLUS       = 0x00000232,
     SC_PK_PM_VRS_RATE_X_10_Y_11_QUAD__GFX103PLUS       = 0x00000233,
     SC_PK_PM_VRS_RATE_X_11_Y_00_QUAD__GFX103PLUS       = 0x00000234,
     SC_PK_PM_VRS_RATE_X_11_Y_01_QUAD__GFX103PLUS       = 0x00000235,
     SC_PK_PM_VRS_RATE_X_11_Y_10_QUAD__GFX103PLUS       = 0x00000236,
     SC_PK_PM_VRS_RATE_X_11_Y_11_QUAD__GFX103PLUS       = 0x00000237,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SC_PBB_RESERVED__GFX103PLUSEXCLUSIVE               = 0x00000239,
     SC_BM_BE0_STALLED__GFX103PLUSEXCLUSIVE             = 0x0000023a,
     SC_BM_BE1_STALLED__GFX103PLUSEXCLUSIVE             = 0x0000023b,
     SC_BM_BE2_STALLED__GFX103PLUSEXCLUSIVE             = 0x0000023c,
     SC_BM_BE3_STALLED__GFX103PLUSEXCLUSIVE             = 0x0000023d,
     SC_BM_MULTI_ACCUM_1_BE_STALLED__GFX103PLUSEXCLUSIVE = 0x0000023e,
     SC_BM_MULTI_ACCUM_2_BE_STALLED__GFX103PLUSEXCLUSIVE = 0x0000023f,
     SC_BM_MULTI_ACCUM_3_BE_STALLED__GFX103PLUSEXCLUSIVE = 0x00000240,
     SC_BM_MULTI_ACCUM_4_BE_STALLED__GFX103PLUSEXCLUSIVE = 0x00000241,
 #endif
@@ -8254,30 +10128,493 @@ typedef enum SC_PERFCNT_SEL {
     SC_SPI_DEALLOC_2_0__GFX10VRS                       = 0x0000014c,
     SC_SPI_DEALLOC_2_1__GFX10VRS                       = 0x0000014d,
     SC_SPI_DEALLOC_2_2__GFX10VRS                       = 0x0000014e,
     SC_SPI_DEALLOC_3_0__GFX10VRS                       = 0x0000014f,
     SC_SPI_DEALLOC_3_1__GFX10VRS                       = 0x00000150,
     SC_SPI_DEALLOC_3_2__GFX10VRS                       = 0x00000151,
     SC_SPI_FPOV_0__GFX10VRS                            = 0x00000152,
     SC_SPI_FPOV_1__GFX10VRS                            = 0x00000153,
     SC_SPI_FPOV_2__GFX10VRS                            = 0x00000154,
     SC_SPI_FPOV_3__GFX10VRS                            = 0x00000155,
+#endif
+#if CHIP_HDR_NAVI31
+    SC_PERF_SEL_RESERVED_76__GFX11                     = 0x0000004c,
+    SC_PERF_SEL_RESERVED_77__GFX11                     = 0x0000004d,
+    SC_PERF_SEL_RESERVED_78__GFX11                     = 0x0000004e,
+    SC_PERF_SEL_RESERVED_80__GFX11                     = 0x00000050,
+    SC_PERF_SEL_RESERVED_81__GFX11                     = 0x00000051,
+    SC_PERF_SEL_RESERVED_82__GFX11                     = 0x00000052,
+    SC_PERF_SEL_RESERVED_84__GFX11                     = 0x00000054,
+    SC_PERF_SEL_RESERVED_85__GFX11                     = 0x00000055,
+    SC_PERF_SEL_RESERVED_86__GFX11                     = 0x00000056,
+    SC_PERF_SEL_RESERVED_88__GFX11                     = 0x00000058,
+    SC_PERF_SEL_RESERVED_89__GFX11                     = 0x00000059,
+    SC_PERF_SEL_RESERVED_90__GFX11                     = 0x0000005a,
+    SC_PERF_SEL_RESERVED_108__GFX11                    = 0x0000006c,
+    SC_PERF_SEL_RESERVED_109__GFX11                    = 0x0000006d,
+    SC_PERF_SEL_RESERVED_110__GFX11                    = 0x0000006e,
+    SC_PERF_SEL_RESERVED_111__GFX11                    = 0x0000006f,
+    SC_PERF_SEL_RESERVED_112__GFX11                    = 0x00000070,
+    SC_PERF_SEL_RESERVED_113__GFX11                    = 0x00000071,
+    SC_PERF_SEL_RESERVED_114__GFX11                    = 0x00000072,
+    SC_PERF_SEL_RESERVED_115__GFX11                    = 0x00000073,
+    SC_PERF_SEL_RESERVED_116__GFX11                    = 0x00000074,
+    SC_PERF_SEL_RESERVED_117__GFX11                    = 0x00000075,
+    SC_PERF_SEL_RESERVED_118__GFX11                    = 0x00000076,
+    SC_PERF_SEL_RESERVED_119__GFX11                    = 0x00000077,
+    SC_PERF_SEL_RESERVED_120__GFX11                    = 0x00000078,
+    SC_PERF_SEL_RESERVED_121__GFX11                    = 0x00000079,
+    SC_PERF_SEL_RESERVED_122__GFX11                    = 0x0000007a,
+    SC_PERF_SEL_RESERVED_123__GFX11                    = 0x0000007b,
+    SC_PERF_SEL_RESERVED_124__GFX11                    = 0x0000007c,
+    SC_PERF_SEL_RESERVED_125__GFX11                    = 0x0000007d,
+    SC_PERF_SEL_RESERVED_126__GFX11                    = 0x0000007e,
+    SC_PERF_SEL_RESERVED_127__GFX11                    = 0x0000007f,
+    SC_PERF_SEL_RESERVED_128__GFX11                    = 0x00000080,
+    SC_PERF_SEL_RESERVED_129__GFX11                    = 0x00000081,
+    SC_PERF_SEL_RESERVED_130__GFX11                    = 0x00000082,
+    SC_PERF_SEL_RESERVED_131__GFX11                    = 0x00000083,
+    SC_PERF_SEL_RESERVED_132__GFX11                    = 0x00000084,
+    SC_PERF_SEL_RESERVED_133__GFX11                    = 0x00000085,
+    SC_PERF_SEL_RESERVED_134__GFX11                    = 0x00000086,
+    SC_PERF_SEL_RESERVED_135__GFX11                    = 0x00000087,
+    SC_PERF_SEL_RESERVED_136__GFX11                    = 0x00000088,
+    SC_PERF_SEL_RESERVED_137__GFX11                    = 0x00000089,
+    SC_PERF_SEL_RESERVED_138__GFX11                    = 0x0000008a,
+    SC_PERF_SEL_RESERVED_139__GFX11                    = 0x0000008b,
+    SC_PERF_SEL_RESERVED_140__GFX11                    = 0x0000008c,
+    SC_PERF_SEL_RESERVED_141__GFX11                    = 0x0000008d,
+    SC_PERF_SEL_RESERVED_142__GFX11                    = 0x0000008e,
+    SC_PERF_SEL_RESERVED_143__GFX11                    = 0x0000008f,
+    SC_PERF_SEL_RESERVED_144__GFX11                    = 0x00000090,
+    SC_PERF_SEL_RESERVED_145__GFX11                    = 0x00000091,
+    SC_PERF_SEL_RESERVED_146__GFX11                    = 0x00000092,
+    SC_PERF_SEL_RESERVED_147__GFX11                    = 0x00000093,
+    SC_PERF_SEL_RESERVED_148__GFX11                    = 0x00000094,
+    SC_PERF_SEL_RESERVED_149__GFX11                    = 0x00000095,
+    SC_PERF_SEL_RESERVED_150__GFX11                    = 0x00000096,
+    SC_PERF_SEL_RESERVED_151__GFX11                    = 0x00000097,
+    SC_PERF_SEL_RESERVED_152__GFX11                    = 0x00000098,
+    SC_PERF_SEL_RESERVED_153__GFX11                    = 0x00000099,
+    SC_PERF_SEL_RESERVED_154__GFX11                    = 0x0000009a,
+    SC_PERF_SEL_RESERVED_155__GFX11                    = 0x0000009b,
+    SC_PERF_SEL_RESERVED_156__GFX11                    = 0x0000009c,
+    SC_PERF_SEL_RESERVED_157__GFX11                    = 0x0000009d,
+    SC_PERF_SEL_RESERVED_158__GFX11                    = 0x0000009e,
+    SC_PERF_SEL_RESERVED_160__GFX11                    = 0x000000a0,
+    SC_PERF_SEL_RESERVED_161__GFX11                    = 0x000000a1,
+    SC_PERF_SEL_RESERVED_162__GFX11                    = 0x000000a2,
+    SC_PERF_SEL_RESERVED_164__GFX11                    = 0x000000a4,
+    SC_PERF_SEL_RESERVED_165__GFX11                    = 0x000000a5,
+    SC_PERF_SEL_RESERVED_166__GFX11                    = 0x000000a6,
+    SC_PERF_SEL_RESERVED_184__GFX11                    = 0x000000b8,
+    SC_PERF_SEL_RESERVED_185__GFX11                    = 0x000000b9,
+    SC_PERF_SEL_RESERVED_186__GFX11                    = 0x000000ba,
+    SC_PERF_SEL_RESERVED_187__GFX11                    = 0x000000bb,
+    SC_PERF_SEL_RESERVED_188__GFX11                    = 0x000000bc,
+    SC_PERF_SEL_RESERVED_189__GFX11                    = 0x000000bd,
+    SC_PERF_SEL_RESERVED_190__GFX11                    = 0x000000be,
+    SC_PERF_SEL_RESERVED_191__GFX11                    = 0x000000bf,
+    SC_PERF_SEL_RESERVED_192__GFX11                    = 0x000000c0,
+    SC_PERF_SEL_RESERVED_193__GFX11                    = 0x000000c1,
+    SC_PERF_SEL_RESERVED_194__GFX11                    = 0x000000c2,
+    SC_PERF_SEL_RESERVED_195__GFX11                    = 0x000000c3,
+    SC_PERF_SEL_RESERVED_196__GFX11                    = 0x000000c4,
+    SC_PERF_SEL_RESERVED_197__GFX11                    = 0x000000c5,
+    SC_PERF_SEL_RESERVED_198__GFX11                    = 0x000000c6,
+    SC_PERF_SEL_RESERVED_199__GFX11                    = 0x000000c7,
+    SC_PERF_SEL_RESERVED_200__GFX11                    = 0x000000c8,
+    SC_PERF_SEL_RESERVED_201__GFX11                    = 0x000000c9,
+    SC_PERF_SEL_RESERVED_202__GFX11                    = 0x000000ca,
+    SC_PERF_SEL_RESERVED_203__GFX11                    = 0x000000cb,
+    SC_PERF_SEL_RESERVED_204__GFX11                    = 0x000000cc,
+    SC_PERF_SEL_RESERVED_205__GFX11                    = 0x000000cd,
+    SC_PERF_SEL_RESERVED_206__GFX11                    = 0x000000ce,
+    SC_PERF_SEL_RESERVED_207__GFX11                    = 0x000000cf,
+    SC_PERF_SEL_RESERVED_208__GFX11                    = 0x000000d0,
+    SC_PERF_SEL_RESERVED_209__GFX11                    = 0x000000d1,
+    SC_PERF_SEL_RESERVED_210__GFX11                    = 0x000000d2,
+    SC_PERF_SEL_RESERVED_211__GFX11                    = 0x000000d3,
+    SC_PERF_SEL_RESERVED_212__GFX11                    = 0x000000d4,
+    SC_PERF_SEL_RESERVED_213__GFX11                    = 0x000000d5,
+    SC_PERF_SEL_RESERVED_214__GFX11                    = 0x000000d6,
+    SC_PERF_SEL_RESERVED_215__GFX11                    = 0x000000d7,
+    SC_PERF_SEL_RESERVED_216__GFX11                    = 0x000000d8,
+    SC_PERF_SEL_RESERVED_217__GFX11                    = 0x000000d9,
+    SC_PERF_SEL_RESERVED_218__GFX11                    = 0x000000da,
+    SC_PERF_SEL_RESERVED_219__GFX11                    = 0x000000db,
+    SC_PERF_SEL_RESERVED_220__GFX11                    = 0x000000dc,
+    SC_PERF_SEL_RESERVED_221__GFX11                    = 0x000000dd,
+    SC_PERF_SEL_RESERVED_222__GFX11                    = 0x000000de,
+    SC_PERF_SEL_RESERVED_223__GFX11                    = 0x000000df,
+    SC_PERF_SEL_RESERVED_224__GFX11                    = 0x000000e0,
+    SC_PERF_SEL_RESERVED_225__GFX11                    = 0x000000e1,
+    SC_PERF_SEL_RESERVED_226__GFX11                    = 0x000000e2,
+    SC_PERF_SEL_RESERVED_227__GFX11                    = 0x000000e3,
+    SC_PERF_SEL_RESERVED_228__GFX11                    = 0x000000e4,
+    SC_PERF_SEL_RESERVED_229__GFX11                    = 0x000000e5,
+    SC_PERF_SEL_RESERVED_230__GFX11                    = 0x000000e6,
+    SC_PERF_SEL_RESERVED_231__GFX11                    = 0x000000e7,
+    SC_PERF_SEL_RESERVED_232__GFX11                    = 0x000000e8,
+    SC_PERF_SEL_RESERVED_233__GFX11                    = 0x000000e9,
+    SC_PERF_SEL_RESERVED_234__GFX11                    = 0x000000ea,
+    SC_PERF_SEL_RESERVED_236__GFX11                    = 0x000000ec,
+    SC_PERF_SEL_RESERVED_237__GFX11                    = 0x000000ed,
+    SC_PERF_SEL_RESERVED_238__GFX11                    = 0x000000ee,
+    SC_PERF_SEL_RESERVED_240__GFX11                    = 0x000000f0,
+    SC_PERF_SEL_RESERVED_241__GFX11                    = 0x000000f1,
+    SC_PERF_SEL_RESERVED_242__GFX11                    = 0x000000f2,
+    SC_PERF_SEL_RESERVED_247__GFX11                    = 0x000000f7,
+    SC_PERF_SEL_RESERVED_248__GFX11                    = 0x000000f8,
+    SC_PERF_SEL_RESERVED_249__GFX11                    = 0x000000f9,
+    SC_PERF_SEL_RESERVED_250__GFX11                    = 0x000000fa,
+    SC_PERF_SEL_RESERVED_251__GFX11                    = 0x000000fb,
+    SC_PERF_SEL_RESERVED_252__GFX11                    = 0x000000fc,
+    SC_PERF_SEL_RESERVED_253__GFX11                    = 0x000000fd,
+    SC_PERF_SEL_RESERVED_254__GFX11                    = 0x000000fe,
+    SC_PERF_SEL_RESERVED_255__GFX11                    = 0x000000ff,
+    SC_PERF_SEL_RESERVED_256__GFX11                    = 0x00000100,
+    SC_PERF_SEL_RESERVED_257__GFX11                    = 0x00000101,
+    SC_PERF_SEL_RESERVED_258__GFX11                    = 0x00000102,
+    SC_PERF_SEL_RESERVED_279__GFX11                    = 0x00000117,
+    SC_PERF_SEL_RESERVED_280__GFX11                    = 0x00000118,
+    SC_PERF_SEL_RESERVED_288__GFX11                    = 0x00000120,
+    SC_PERF_SEL_RESERVED_289__GFX11                    = 0x00000121,
+    SC_PERF_SEL_RESERVED_290__GFX11                    = 0x00000122,
+    SC_PERF_SEL_RESERVED_291__GFX11                    = 0x00000123,
+    SC_PA_SC_DEALLOC_2_0_WE__GFX11                     = 0x00000124,
+    SC_PERF_SEL_RESERVED_293__GFX11                    = 0x00000125,
+    SC_PERF_SEL_RESERVED_294__GFX11                    = 0x00000126,
+    SC_PERF_SEL_RESERVED_295__GFX11                    = 0x00000127,
+    SC_PERF_SEL_RESERVED_296__GFX11                    = 0x00000128,
+    SC_PERF_SEL_RESERVED_297__GFX11                    = 0x00000129,
+    SC_PERF_SEL_RESERVED_298__GFX11                    = 0x0000012a,
+    SC_PERF_SEL_RESERVED_299__GFX11                    = 0x0000012b,
+    SC_PERF_SEL_RESERVED_301__GFX11                    = 0x0000012d,
+    SC_PERF_SEL_RESERVED_303__GFX11                    = 0x0000012f,
+    SC_PERF_SEL_RESERVED_304__GFX11                    = 0x00000130,
+    SC_PERF_SEL_RESERVED_305__GFX11                    = 0x00000131,
+    SC_PERF_SEL_RESERVED_306__GFX11                    = 0x00000132,
+    SC_PERF_SEL_RESERVED_307__GFX11                    = 0x00000133,
+    SC_PERF_SEL_RESERVED_308__GFX11                    = 0x00000134,
+    SC_PERF_SEL_RESERVED_309__GFX11                    = 0x00000135,
+    SC_PERF_SEL_RESERVED_310__GFX11                    = 0x00000136,
+    SC_PERF_SEL_RESERVED_311__GFX11                    = 0x00000137,
+    SC_PERF_SEL_RESERVED_312__GFX11                    = 0x00000138,
+    SC_PERF_SEL_RESERVED_313__GFX11                    = 0x00000139,
+    SC_PERF_SEL_RESERVED_314__GFX11                    = 0x0000013a,
+    SC_PERF_SEL_RESERVED_315__GFX11                    = 0x0000013b,
+    SC_PERF_SEL_RESERVED_316__GFX11                    = 0x0000013c,
+    SC_PERF_SEL_RESERVED_317__GFX11                    = 0x0000013d,
+    SC_PA_SC_FPOV_WE__GFX11                            = 0x0000013e,
+    SC_PERF_SEL_RESERVED_319__GFX11                    = 0x0000013f,
+    SC_PERF_SEL_RESERVED_320__GFX11                    = 0x00000140,
+    SC_PERF_SEL_RESERVED_321__GFX11                    = 0x00000141,
+    SC_PERF_SEL_RESERVED_322__GFX11                    = 0x00000142,
+    SC_PERF_SEL_RESERVED_323__GFX11                    = 0x00000143,
+    SC_PERF_SEL_RESERVED_324__GFX11                    = 0x00000144,
+    SC_PERF_SEL_RESERVED_325__GFX11                    = 0x00000145,
+    SC_SPI_DEALLOC_4_0__GFX11                          = 0x00000146,
+    SC_SPI_DEALLOC_7_5__GFX11                          = 0x00000147,
+    SC_PERF_SEL_RESERVED_328__GFX11                    = 0x00000148,
+    SC_PERF_SEL_RESERVED_329__GFX11                    = 0x00000149,
+    SC_PERF_SEL_RESERVED_330__GFX11                    = 0x0000014a,
+    SC_PERF_SEL_RESERVED_331__GFX11                    = 0x0000014b,
+    SC_PERF_SEL_RESERVED_332__GFX11                    = 0x0000014c,
+    SC_PERF_SEL_RESERVED_333__GFX11                    = 0x0000014d,
+    SC_PERF_SEL_RESERVED_334__GFX11                    = 0x0000014e,
+    SC_PERF_SEL_RESERVED_335__GFX11                    = 0x0000014f,
+    SC_PERF_SEL_RESERVED_336__GFX11                    = 0x00000150,
+    SC_PERF_SEL_RESERVED_337__GFX11                    = 0x00000151,
+    SC_SPI_FPOV_4_0__GFX11                             = 0x00000152,
+    SC_SPI_FPOV_7_5__GFX11                             = 0x00000153,
+    SC_PERF_SEL_RESERVED_340__GFX11                    = 0x00000154,
+    SC_PERF_SEL_RESERVED_341__GFX11                    = 0x00000155,
+    SC_PERF_SEL_RESERVED_347__GFX11                    = 0x0000015b,
+    SC_PERF_SEL_RESERVED_348__GFX11                    = 0x0000015c,
+    SC_PERF_SEL_RESERVED_351__GFX11                    = 0x0000015f,
+    SC_PA0_SC_DEALLOC_2_0_RD__GFX11                    = 0x00000161,
+    SC_PERF_SEL_RESERVED_354__GFX11                    = 0x00000162,
+    SC_PERF_SEL_RESERVED_355__GFX11                    = 0x00000163,
+    SC_PERF_SEL_RESERVED_356__GFX11                    = 0x00000164,
+    SC_PERF_SEL_RESERVED_357__GFX11                    = 0x00000165,
+    SC_PERF_SEL_RESERVED_358__GFX11                    = 0x00000166,
+    SC_PERF_SEL_RESERVED_359__GFX11                    = 0x00000167,
+    SC_PERF_SEL_RESERVED_360__GFX11                    = 0x00000168,
+    SC_PERF_SEL_RESERVED_361__GFX11                    = 0x00000169,
+    SC_PERF_SEL_RESERVED_362__GFX11                    = 0x0000016a,
+    SC_PERF_SEL_RESERVED_363__GFX11                    = 0x0000016b,
+    SC_PERF_SEL_RESERVED_364__GFX11                    = 0x0000016c,
+    SC_PERF_SEL_RESERVED_365__GFX11                    = 0x0000016d,
+    SC_PERF_SEL_RESERVED_366__GFX11                    = 0x0000016e,
+    SC_PERF_SEL_RESERVED_367__GFX11                    = 0x0000016f,
+    SC_PERF_SEL_RESERVED_368__GFX11                    = 0x00000170,
+    SC_PERF_SEL_RESERVED_369__GFX11                    = 0x00000171,
+    SC_PERF_SEL_RESERVED_370__GFX11                    = 0x00000172,
+    SC_PERF_SEL_RESERVED_371__GFX11                    = 0x00000173,
+    SC_PERF_SEL_RESERVED_372__GFX11                    = 0x00000174,
+    SC_PERF_SEL_RESERVED_375__GFX11                    = 0x00000177,
+    SC_PERF_SEL_RESERVED_376__GFX11                    = 0x00000178,
+    SC_PERF_SEL_RESERVED_377__GFX11                    = 0x00000179,
+    SC_PERF_SEL_RESERVED_378__GFX11                    = 0x0000017a,
+    SC_PERF_SEL_RESERVED_379__GFX11                    = 0x0000017b,
+    SC_PERF_SEL_RESERVED_380__GFX11                    = 0x0000017c,
+    SC_PERF_SEL_RESERVED_381__GFX11                    = 0x0000017d,
+    SC_PERF_SEL_RESERVED_382__GFX11                    = 0x0000017e,
+    SC_PERF_SEL_RESERVED_383__GFX11                    = 0x0000017f,
+    SC_PERF_SEL_RESERVED_384__GFX11                    = 0x00000180,
+    SC_PERF_SEL_RESERVED_385__GFX11                    = 0x00000181,
+    SC_PERF_SEL_RESERVED_423__GFX11                    = 0x000001a7,
+    SC_PERF_SEL_RESERVED_424__GFX11                    = 0x000001a8,
+    SC_PERF_SEL_RESERVED_425__GFX11                    = 0x000001a9,
+    SC_PERF_SEL_RESERVED_426__GFX11                    = 0x000001aa,
+    SC_PERF_SEL_RESERVED_427__GFX11                    = 0x000001ab,
+    SC_PERF_SEL_RESERVED_428__GFX11                    = 0x000001ac,
+    SC_PERF_SEL_RESERVED_429__GFX11                    = 0x000001ad,
+    SC_PERF_SEL_RESERVED_430__GFX11                    = 0x000001ae,
+    SC_PERF_SEL_RESERVED_431__GFX11                    = 0x000001af,
+    SC_PERF_SEL_RESERVED_432__GFX11                    = 0x000001b0,
+    SC_PERF_SEL_RESERVED_433__GFX11                    = 0x000001b1,
+    SC_PERF_SEL_RESERVED_434__GFX11                    = 0x000001b2,
+    SC_PERF_SEL_RESERVED_435__GFX11                    = 0x000001b3,
+    SC_PERF_SEL_RESERVED_436__GFX11                    = 0x000001b4,
+    SC_PERF_SEL_RESERVED_478__GFX11                    = 0x000001de,
+    SC_PERF_SEL_RESERVED_479__GFX11                    = 0x000001df,
+    SC_PERF_SEL_RESERVED_483__GFX11                    = 0x000001e3,
+    SC_PERF_SEL_RESERVED_484__GFX11                    = 0x000001e4,
+    SC_PERF_SEL_RESERVED_485__GFX11                    = 0x000001e5,
+    SC_PERF_SEL_RESERVED_486__GFX11                    = 0x000001e6,
+    SC_PERF_SEL_RESERVED_487__GFX11                    = 0x000001e7,
+    SC_PERF_SEL_RESERVED_488__GFX11                    = 0x000001e8,
+    SC_PERF_SEL_RESERVED_489__GFX11                    = 0x000001e9,
+    SC_PERF_SEL_RESERVED_490__GFX11                    = 0x000001ea,
+    SC_PERF_SEL_RESERVED_509__GFX11                    = 0x000001fd,
+    SC_PERF_SEL_RESERVED_510__GFX11                    = 0x000001fe,
+    SC_PERF_SEL_RESERVED_511__GFX11                    = 0x000001ff,
+    SC_PERF_SEL_RESERVED_512__GFX11                    = 0x00000200,
+    SC_PERF_SEL_RESERVED_513__GFX11                    = 0x00000201,
+    SC_PERF_SEL_RESERVED_514__GFX11                    = 0x00000202,
+    SC_PERF_SEL_RESERVED_523__GFX11                    = 0x0000020b,
+    SC_PERF_SEL_RESERVED_524__GFX11                    = 0x0000020c,
+    SC_PERF_SEL_RESERVED_525__GFX11                    = 0x0000020d,
+    SC_PERF_SEL_RESERVED_532__GFX11                    = 0x00000214,
+    SC_PERF_SEL_RESERVED_533__GFX11                    = 0x00000215,
+    SC_PERF_SEL_RESERVED_534__GFX11                    = 0x00000216,
+    SC_PERF_SEL_RESERVED_539__GFX11                    = 0x0000021b,
+    SC_PK_PM_OREO_CONFLICT_QUAD_FORCE_EOV_WAVE_BRK_1H__GFX11 = 0x00000223,
+    SC_PERF_SEL_RESERVED_568__GFX11                    = 0x00000238,
+    SC_PBB_READ_PH0__GFX11                             = 0x00000242,
+    SC_PBB_READ_DEALLOC_4_0__GFX11                     = 0x00000243,
+    SC_PBB_READ_DEALLOC_7_5__GFX11                     = 0x00000244,
+    SC_PBB_READ_FPOG_4_0__GFX11                        = 0x00000245,
+    SC_PBB_READ_FPOG_7_5__GFX11                        = 0x00000246,
+    SC_VRC_SECTOR_HIT__GFX11                           = 0x00000247,
+    SC_VRC_TAG_MISS__GFX11                             = 0x00000248,
+    SC_VRC_SECTOR_MISS__GFX11                          = 0x00000249,
+    SC_VRC_LRU_EVICT_STALL__GFX11                      = 0x0000024a,
+    SC_VRC_LRU_EVICT_SCHEDULED_EVICT_STALL__GFX11      = 0x0000024b,
+    SC_VRC_LRU_EVICT_PENDING_EVICT_STALL__GFX11        = 0x0000024c,
+    SC_VRC_REEVICTION_STALL__GFX11                     = 0x0000024d,
+    SC_VRC_EVICT_NONZERO_INFLIGHT_STALL__GFX11         = 0x0000024e,
+    SC_VRC_REPLACE_SCHEDULED_EVICT_STALL__GFX11        = 0x0000024f,
+    SC_VRC_REPLACE_PENDING_EVICT_STALL__GFX11          = 0x00000250,
+    SC_VRC_REPLACE_FLUSH_IN_PROGRESS_STALL__GFX11      = 0x00000251,
+    SC_VRC_INFLIGHT_COUNTER_MAXIMUM_STALL__GFX11       = 0x00000252,
+    SC_VRC_READ_OUTPUT_STALL__GFX11                    = 0x00000253,
+    SC_VRC_WRITE_OUTPUT_STALL__GFX11                   = 0x00000254,
+    SC_VRC_ACK_OUTPUT_STALL__GFX11                     = 0x00000255,
+    SC_VRC_FLUSH_EVICT_STALL__GFX11                    = 0x00000256,
+    SC_VRC_FLUSH_REFLUSH_STALL__GFX11                  = 0x00000257,
+    SC_VRC_FLUSH_FIP_HIT_STALL__GFX11                  = 0x00000258,
+    SC_VRC_FLUSH_WRREQ_DRAIN_STALL__GFX11              = 0x00000259,
+    SC_VRC_FLUSH_DONE_STALL__GFX11                     = 0x0000025a,
+    SC_VRC_FLUSH_STALL__GFX11                          = 0x0000025b,
+    SC_VRC_STALL__GFX11                                = 0x0000025c,
+    SC_VRC_SECTORS_FLUSHED__GFX11                      = 0x0000025d,
+    SC_VRC_DIRTY_SECTORS_FLUSHED__GFX11                = 0x0000025e,
+    SC_VRC_TAGS_FLUSHED__GFX11                         = 0x0000025f,
+    SC_VRC_VRF_REQ__GFX11                              = 0x00000260,
+    SC_VRC_VRF_EVENT__GFX11                            = 0x00000261,
+    SC_VRC_VRF_STALLED__GFX11                          = 0x00000262,
+    SC_VRC_PROBE_ACK_TILES__GFX11                      = 0x00000263,
+    SC_VRC_GL1H_RD_REQ__GFX11                          = 0x00000264,
+    SC_VRC_GL1H_WR_REQ__GFX11                          = 0x00000265,
+    SC_VRC_GL1H_SRC_XFR__GFX11                         = 0x00000266,
+    SC_VRC_GL1H_RD_RET_0__GFX11                        = 0x00000267,
+    SC_VRC_GL1H_RD_RET_1__GFX11                        = 0x00000268,
+    SC_VRC_GL1H_WR_ACK_0__GFX11                        = 0x00000269,
+    SC_VRC_GL1H_WR_ACK_1__GFX11                        = 0x0000026a,
+    SC_VRC_GL1H_RD_XNACK_0__GFX11                      = 0x0000026b,
+    SC_VRC_GL1H_RD_XNACK_1__GFX11                      = 0x0000026c,
+    SC_VRC_GL1H_WR_XNACK_0__GFX11                      = 0x0000026d,
+    SC_VRC_GL1H_WR_XNACK_1__GFX11                      = 0x0000026e,
+    SC_VRC_GL1H_REQ_STALLED__GFX11                     = 0x0000026f,
+    SC_VRC_GL1H_SRC_STALLED__GFX11                     = 0x00000270,
+    SC_VRC_RATEMEM_WE_CNT__GFX11                       = 0x00000271,
+    SC_VRC_RATEMEM_RE_CNT__GFX11                       = 0x00000272,
+    SC_VRC_HINTMEM_WE_CNT__GFX11                       = 0x00000273,
+    SC_VRC_HINTMEM_RE_CNT__GFX11                       = 0x00000274,
+    SC_VRC_BUSY__GFX11                                 = 0x00000275,
+    SC_GL1H_BUSY__GFX11                                = 0x00000276,
+    SC_BE_VRS_RD_REQ__GFX11                            = 0x00000277,
+    SC_BE_VRS_RD_REQ_STALLED__GFX11                    = 0x00000278,
+    SC_BE_VRS_RD_REQ_HIT__GFX11                        = 0x00000279,
+    SC_BE_VRS_RD_RET__GFX11                            = 0x0000027a,
+    SC_BE_VRS_RD_RET_STALLED__GFX11                    = 0x0000027b,
+    SC_BE_VRS_FB_RET__GFX11                            = 0x0000027c,
+    SC_BE_VRS_FB_RET_STALLED__GFX11                    = 0x0000027d,
+    SC_BE_VRS_FB_RET_HIT__GFX11                        = 0x0000027e,
+    SC_VRS_BE_BUSY__GFX11                              = 0x0000027f,
+    SC_PWS_CS_EVENTS_PWS_ENABLE__GFX11                 = 0x00000280,
+    SC_PWS_PS_EVENTS_PWS_ENABLE__GFX11                 = 0x00000281,
+    SC_PWS_TS_EVENTS_PWS_ENABLE__GFX11                 = 0x00000282,
+    SC_PWS_STALLED__GFX11                              = 0x00000283,
+    SC_PWS_P0_CS_SYNC_COMPLETE__GFX11                  = 0x00000284,
+    SC_PWS_P0_PS_SYNC_COMPLETE__GFX11                  = 0x00000285,
+    SC_PWS_P0_TS_SYNC_COMPLETE__GFX11                  = 0x00000286,
+    SC_PWS_P1_CS_SYNC_COMPLETE__GFX11                  = 0x00000287,
+    SC_PWS_P1_PS_SYNC_COMPLETE__GFX11                  = 0x00000288,
+    SC_PWS_P1_TS_SYNC_COMPLETE__GFX11                  = 0x00000289,
+    SC_PKR_PC_NO_CREDITS__GFX11                        = 0x0000028a,
+    SC_PKR_PC_STALLED__GFX11                           = 0x0000028b,
+    SC_PKR_PC_SEND__GFX11                              = 0x0000028c,
+    SC_PKR_PC_SEND_PRIM_VALID_1__GFX11                 = 0x0000028d,
+    SC_PKR_PC_SEND_PRIM_VALID_0__GFX11                 = 0x0000028e,
+    SC_PKR_PC_SEND_TRUE_PRIM__GFX11                    = 0x0000028f,
+    SC_PKR_PC_SEND_EOV__GFX11                          = 0x00000290,
+    SC_PKR_PC_SEND_EVENT__GFX11                        = 0x00000291,
+    SC_PKR_DB_WAVE_STALL__GFX11                        = 0x00000292,
+    SC_PKR_PSINVOC_SEDC_FIFO_FULL__GFX11               = 0x00000293,
+    SC_PKR_OREO_STALLED_BY_NO_VALID_WAIVE_ID__GFX11    = 0x00000294,
+    SC_PKR_SPI_QUAD_COUNT__GFX11                       = 0x00000295,
+    SC_PKR_DB_OREO_WAVE_QUAD_COUNT__GFX11              = 0x00000296,
+    SC_PKR_BCI_QUAD_NEW_PRIM__GFX11                    = 0x00000297,
+    SC_SPI_WAVE_STALLED_BY_SPI__GFX11                  = 0x00000298,
 #endif
     SC_BACKEND_PRIM_FIFO_FULL__VG12_VG20_RN            = 0x000001eb,
 } SC_PERFCNT_SEL;
 
 constexpr unsigned int MaxScPerfcntSelVg10_Rv1x_Rv2x   = SC_DB1_TILE_INTERFACE_CREDIT_AT_MAX_WITH_NO_PENDING_SEND__GFX09_10;
 constexpr unsigned int MaxScPerfcntSelVg12_Vg20_Rn     = SC_BACKEND_PRIM_FIFO_FULL__VG12_VG20_RN;
 constexpr unsigned int MaxScPerfcntSelGfx101           = SC_PK_PM_MAX_REZ_CNT_FORCE_EOV_WAVE_BRK_1H__GFX10PLUS;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxScPerfcntSelGfx103           = SC_BM_MULTI_ACCUM_4_BE_STALLED__GFX103PLUSEXCLUSIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxScPerfcntSelNv31             = SC_SPI_WAVE_STALLED_BY_SPI__GFX11;
+#endif
+
+#if CHIP_HDR_NAVI31
+typedef enum SDMA_PERFMON_SEL {
+    SDMA_PERFMON_SEL_CYCLE                             = 0x00000000,
+    SDMA_PERFMON_SEL_IDLE                              = 0x00000001,
+    SDMA_PERFMON_SEL_REG_IDLE                          = 0x00000002,
+    SDMA_PERFMON_SEL_RB_EMPTY                          = 0x00000003,
+    SDMA_PERFMON_SEL_RB_FULL                           = 0x00000004,
+    SDMA_PERFMON_SEL_RB_WPTR_WRAP                      = 0x00000005,
+    SDMA_PERFMON_SEL_RB_RPTR_WRAP                      = 0x00000006,
+    SDMA_PERFMON_SEL_RB_WPTR_POLL_READ                 = 0x00000007,
+    SDMA_PERFMON_SEL_RB_RPTR_WB                        = 0x00000008,
+    SDMA_PERFMON_SEL_RB_CMD_IDLE                       = 0x00000009,
+    SDMA_PERFMON_SEL_RB_CMD_FULL                       = 0x0000000a,
+    SDMA_PERFMON_SEL_IB_CMD_IDLE                       = 0x0000000b,
+    SDMA_PERFMON_SEL_IB_CMD_FULL                       = 0x0000000c,
+    SDMA_PERFMON_SEL_EX_IDLE                           = 0x0000000d,
+    SDMA_PERFMON_SEL_SRBM_REG_SEND                     = 0x0000000e,
+    SDMA_PERFMON_SEL_EX_IDLE_POLL_TIMER_EXPIRE         = 0x0000000f,
+    SDMA_PERFMON_SEL_WR_BA_RTR                         = 0x00000010,
+    SDMA_PERFMON_SEL_MC_WR_IDLE                        = 0x00000011,
+    SDMA_PERFMON_SEL_MC_WR_COUNT                       = 0x00000012,
+    SDMA_PERFMON_SEL_RD_BA_RTR                         = 0x00000013,
+    SDMA_PERFMON_SEL_MC_RD_IDLE                        = 0x00000014,
+    SDMA_PERFMON_SEL_MC_RD_COUNT                       = 0x00000015,
+    SDMA_PERFMON_SEL_MC_RD_RET_STALL                   = 0x00000016,
+    SDMA_PERFMON_SEL_MC_RD_NO_POLL_IDLE                = 0x00000017,
+    SDMA_PERFMON_SEL_DRM_IDLE                          = 0x00000018,
+    SDMA_PERFMON_SEL_DRM_REQ_STALL                     = 0x00000019,
+    SDMA_PERFMON_SEL_SEM_IDLE                          = 0x0000001a,
+    SDMA_PERFMON_SEL_SEM_REQ_STALL                     = 0x0000001b,
+    SDMA_PERFMON_SEL_SEM_REQ_COUNT                     = 0x0000001c,
+    SDMA_PERFMON_SEL_SEM_RESP_INCOMPLETE               = 0x0000001d,
+    SDMA_PERFMON_SEL_SEM_RESP_FAIL                     = 0x0000001e,
+    SDMA_PERFMON_SEL_SEM_RESP_PASS                     = 0x0000001f,
+    SDMA_PERFMON_SEL_INT_IDLE                          = 0x00000020,
+    SDMA_PERFMON_SEL_INT_REQ_STALL                     = 0x00000021,
+    SDMA_PERFMON_SEL_INT_REQ_COUNT                     = 0x00000022,
+    SDMA_PERFMON_SEL_INT_RESP_ACCEPTED                 = 0x00000023,
+    SDMA_PERFMON_SEL_INT_RESP_RETRY                    = 0x00000024,
+    SDMA_PERFMON_SEL_NUM_PACKET                        = 0x00000025,
+    SDMA_PERFMON_SEL_DRM1_REQ_STALL                    = 0x00000026,
+    SDMA_PERFMON_SEL_CE_WREQ_IDLE                      = 0x00000027,
+    SDMA_PERFMON_SEL_CE_WR_IDLE                        = 0x00000028,
+    SDMA_PERFMON_SEL_CE_SPLIT_IDLE                     = 0x00000029,
+    SDMA_PERFMON_SEL_CE_RREQ_IDLE                      = 0x0000002a,
+    SDMA_PERFMON_SEL_CE_OUT_IDLE                       = 0x0000002b,
+    SDMA_PERFMON_SEL_CE_IN_IDLE                        = 0x0000002c,
+    SDMA_PERFMON_SEL_CE_DST_IDLE                       = 0x0000002d,
+    SDMA_PERFMON_SEL_CE_DRM_IDLE                       = 0x0000002e,
+    SDMA_PERFMON_SEL_CE_DRM1_IDLE                      = 0x0000002f,
+    SDMA_PERFMON_SEL_CE_AFIFO_FULL                     = 0x00000030,
+    SDMA_PERFMON_SEL_DUMMY_0                           = 0x00000031,
+    SDMA_PERFMON_SEL_DUMMY_1                           = 0x00000032,
+    SDMA_PERFMON_SEL_CE_INFO_FULL                      = 0x00000033,
+    SDMA_PERFMON_SEL_CE_INFO1_FULL                     = 0x00000034,
+    SDMA_PERFMON_SEL_CE_RD_STALL                       = 0x00000035,
+    SDMA_PERFMON_SEL_CE_WR_STALL                       = 0x00000036,
+    SDMA_PERFMON_SEL_QUEUE0_SELECT                     = 0x00000037,
+    SDMA_PERFMON_SEL_QUEUE1_SELECT                     = 0x00000038,
+    SDMA_PERFMON_SEL_QUEUE2_SELECT                     = 0x00000039,
+    SDMA_PERFMON_SEL_QUEUE3_SELECT                     = 0x0000003a,
+    SDMA_PERFMON_SEL_CTX_CHANGE                        = 0x0000003b,
+    SDMA_PERFMON_SEL_CTX_CHANGE_EXPIRED                = 0x0000003c,
+    SDMA_PERFMON_SEL_CTX_CHANGE_EXCEPTION              = 0x0000003d,
+    SDMA_PERFMON_SEL_DOORBELL                          = 0x0000003e,
+    SDMA_PERFMON_SEL_F32_L1_WR_VLD                     = 0x0000003f,
+    SDMA_PERFMON_SEL_CE_L1_WR_VLD                      = 0x00000040,
+    SDMA_PERFMON_SEL_CPF_SDMA_INVREQ                   = 0x00000041,
+    SDMA_PERFMON_SEL_SDMA_CPF_INVACK                   = 0x00000042,
+    SDMA_PERFMON_SEL_UTCL2_SDMA_INVREQ                 = 0x00000043,
+    SDMA_PERFMON_SEL_SDMA_UTCL2_INVACK                 = 0x00000044,
+    SDMA_PERFMON_SEL_UTCL2_SDMA_INVREQ_ALL             = 0x00000045,
+    SDMA_PERFMON_SEL_SDMA_UTCL2_INVACK_ALL             = 0x00000046,
+    SDMA_PERFMON_SEL_UTCL2_RET_XNACK                   = 0x00000047,
+    SDMA_PERFMON_SEL_UTCL2_RET_ACK                     = 0x00000048,
+    SDMA_PERFMON_SEL_UTCL2_FREE                        = 0x00000049,
+    SDMA_PERFMON_SEL_SDMA_UTCL2_SEND                   = 0x0000004a,
+    SDMA_PERFMON_SEL_DMA_L1_WR_SEND                    = 0x0000004b,
+    SDMA_PERFMON_SEL_DMA_L1_RD_SEND                    = 0x0000004c,
+    SDMA_PERFMON_SEL_DMA_MC_WR_SEND                    = 0x0000004d,
+    SDMA_PERFMON_SEL_DMA_MC_RD_SEND                    = 0x0000004e,
+    SDMA_PERFMON_SEL_GPUVM_INV_HIGH                    = 0x0000004f,
+    SDMA_PERFMON_SEL_GPUVM_INV_LOW                     = 0x00000050,
+    SDMA_PERFMON_SEL_L1_WRL2_IDLE                      = 0x00000051,
+    SDMA_PERFMON_SEL_L1_RDL2_IDLE                      = 0x00000052,
+    SDMA_PERFMON_SEL_L1_WRMC_IDLE                      = 0x00000053,
+    SDMA_PERFMON_SEL_L1_RDMC_IDLE                      = 0x00000054,
+    SDMA_PERFMON_SEL_L1_WR_INV_IDLE                    = 0x00000055,
+    SDMA_PERFMON_SEL_L1_RD_INV_IDLE                    = 0x00000056,
+    SDMA_PERFMON_SEL_META_L2_REQ_SEND                  = 0x00000057,
+    SDMA_PERFMON_SEL_L2_META_RET_VLD                   = 0x00000058,
+    SDMA_PERFMON_SEL_SDMA_UTCL2_RD_SEND                = 0x00000059,
+    SDMA_PERFMON_SEL_UTCL2_SDMA_RD_RTN                 = 0x0000005a,
+    SDMA_PERFMON_SEL_SDMA_UTCL2_WR_SEND                = 0x0000005b,
+    SDMA_PERFMON_SEL_UTCL2_SDMA_WR_RTN                 = 0x0000005c,
+    SDMA_PERFMON_SEL_META_REQ_SEND                     = 0x0000005d,
+    SDMA_PERFMON_SEL_META_RTN_VLD                      = 0x0000005e,
+    SDMA_PERFMON_SEL_TLBI_SEND                         = 0x0000005f,
+    SDMA_PERFMON_SEL_TLBI_RTN                          = 0x00000060,
+    SDMA_PERFMON_SEL_GCR_SEND                          = 0x00000061,
+    SDMA_PERFMON_SEL_GCR_RTN                           = 0x00000062,
+    SDMA_PERFMON_SEL_UTCL1_TAG_DELAY_COUNTER           = 0x00000063,
+    SDMA_PERFMON_SEL_MMHUB_TAG_DELAY_COUNTER           = 0x00000064,
+} SDMA_PERFMON_SEL;
+#endif
 
 typedef enum SDMA_PERF_SEL {
     SDMA_PERF_SEL_CYCLE                                = 0x00000000,
     SDMA_PERF_SEL_IDLE                                 = 0x00000001,
     SDMA_PERF_SEL_REG_IDLE                             = 0x00000002,
     SDMA_PERF_SEL_RB_EMPTY                             = 0x00000003,
     SDMA_PERF_SEL_RB_FULL                              = 0x00000004,
     SDMA_PERF_SEL_RB_WPTR_WRAP                         = 0x00000005,
     SDMA_PERF_SEL_RB_RPTR_WRAP                         = 0x00000006,
     SDMA_PERF_SEL_RB_WPTR_POLL_READ                    = 0x00000007,
@@ -8392,21 +10729,21 @@ typedef enum SDMA_PERF_SEL {
     SDMA_PERF_SEL_CE_BUSY_START__GFX103                = 0x00000077,
     SDMA_PERF_SEL_CE_BUSY_END__GFX103                  = 0x00000078,
     SDMA_PERF_SEL_F32_PERFCNT_TRIGGER__GFX103          = 0x00000079,
     SDMA_PERF_SEL_F32_PERFCNT_TRIGGER_START__GFX103    = 0x0000007a,
     SDMA_PERF_SEL_F32_PERFCNT_TRIGGER_END__GFX103      = 0x0000007b,
     SDMA_PERF_SEL_CE_CH_WRREQ_SEND__GFX103             = 0x0000007c,
     SDMA_PERF_SEL_CH_CE_WRRET_VALID__GFX103            = 0x0000007d,
     SDMA_PERF_SEL_CE_CH_RDREQ_SEND__GFX103             = 0x0000007e,
     SDMA_PERF_SEL_CH_CE_RDRET_VALID__GFX103            = 0x0000007f,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SDMA_PERF_SEL_GPUVM_INV_HIGH__GFX103COREPLUS       = 0x0000004f,
     SDMA_PERF_SEL_GPUVM_INV_LOW__GFX103COREPLUS        = 0x00000050,
 #endif
     SDMA_PERF_SEL_CE_DRM_FULL__GFX10CORE               = 0x0000002f,
     SDMA_PERF_SEL_CE_DRM1_FULL__GFX10CORE              = 0x00000030,
     SDMA_PERF_SEL_GFX_SELECT__GFX10CORE                = 0x00000035,
     SDMA_PERF_SEL_RLC0_SELECT__GFX10CORE               = 0x00000036,
     SDMA_PERF_SEL_RLC1_SELECT__GFX10CORE               = 0x00000037,
     SDMA_PERF_SEL_PAGE_SELECT__GFX10CORE               = 0x00000038,
     SDMA_PERF_SEL_UTCL1_TAG_DELAY_COUNTER__GFX10CORE   = 0x00000063,
@@ -8436,29 +10773,72 @@ typedef enum SDMA_PERF_SEL {
     SDMA_PERF_SEL_SDMA_UTCL2_RD_SEND__GFX10COREPLUS    = 0x00000059,
     SDMA_PERF_SEL_UTCL2_SDMA_RD_RTN__GFX10COREPLUS     = 0x0000005a,
     SDMA_PERF_SEL_SDMA_UTCL2_WR_SEND__GFX10COREPLUS    = 0x0000005b,
     SDMA_PERF_SEL_UTCL2_SDMA_WR_RTN__GFX10COREPLUS     = 0x0000005c,
     SDMA_PERF_SEL_META_REQ_SEND__GFX10COREPLUS         = 0x0000005d,
     SDMA_PERF_SEL_META_RTN_VLD__GFX10COREPLUS          = 0x0000005e,
     SDMA_PERF_SEL_TLBI_SEND__GFX10COREPLUS             = 0x0000005f,
     SDMA_PERF_SEL_TLBI_RTN__GFX10COREPLUS              = 0x00000060,
     SDMA_PERF_SEL_GCR_SEND__GFX10COREPLUS              = 0x00000061,
     SDMA_PERF_SEL_GCR_RTN__GFX10COREPLUS               = 0x00000062,
+#if CHIP_HDR_NAVI31
+    SDMA_PERF_SEL_DUMMY_0__GFX11                       = 0x0000002f,
+    SDMA_PERF_SEL_DUMMY_1__GFX11                       = 0x00000030,
+    SDMA_PERF_SEL_QUEUE0_SELECT__GFX11                 = 0x00000035,
+    SDMA_PERF_SEL_QUEUE1_SELECT__GFX11                 = 0x00000036,
+    SDMA_PERF_SEL_QUEUE2_SELECT__GFX11                 = 0x00000037,
+    SDMA_PERF_SEL_QUEUE3_SELECT__GFX11                 = 0x00000038,
+    SDMA_PERF_SEL_CGCG_FENCE__GFX11                    = 0x00000063,
+    SDMA_PERF_SEL_CE_CH_WR_REQ__GFX11                  = 0x00000064,
+    SDMA_PERF_SEL_CE_CH_WR_RET__GFX11                  = 0x00000065,
+    SDMA_PERF_SEL_F32_CH_WR_REQ__GFX11                 = 0x00000066,
+    SDMA_PERF_SEL_F32_CH_WR_RET__GFX11                 = 0x00000067,
+    SDMA_PERF_SEL_CE_OR_F32_CH_RD_REQ__GFX11           = 0x00000068,
+    SDMA_PERF_SEL_CE_OR_F32_CH_RD_RET__GFX11           = 0x00000069,
+    SDMA_PERF_SEL_RB_CH_RD_REQ__GFX11                  = 0x0000006a,
+    SDMA_PERF_SEL_RB_CH_RD_RET__GFX11                  = 0x0000006b,
+    SDMA_PERF_SEL_IB_CH_RD_REQ__GFX11                  = 0x0000006c,
+    SDMA_PERF_SEL_IB_CH_RD_RET__GFX11                  = 0x0000006d,
+    SDMA_PERF_SEL_WPTR_CH_RD_REQ__GFX11                = 0x0000006e,
+    SDMA_PERF_SEL_WPTR_CH_RD_RET__GFX11                = 0x0000006f,
+    SDMA_PERF_SEL_UTCL1_UTCL2_REQ__GFX11               = 0x00000070,
+    SDMA_PERF_SEL_UTCL1_UTCL2_RET__GFX11               = 0x00000071,
+    SDMA_PERF_SEL_CMD_OP_MATCH__GFX11                  = 0x00000072,
+    SDMA_PERF_SEL_CMD_OP_START__GFX11                  = 0x00000073,
+    SDMA_PERF_SEL_CMD_OP_END__GFX11                    = 0x00000074,
+    SDMA_PERF_SEL_CE_BUSY__GFX11                       = 0x00000075,
+    SDMA_PERF_SEL_CE_BUSY_START__GFX11                 = 0x00000076,
+    SDMA_PERF_SEL_CE_BUSY_END__GFX11                   = 0x00000077,
+    SDMA_PERF_SEL_F32_PERFCNT_TRIGGER__GFX11           = 0x00000078,
+    SDMA_PERF_SEL_F32_PERFCNT_TRIGGER_START__GFX11     = 0x00000079,
+    SDMA_PERF_SEL_F32_PERFCNT_TRIGGER_END__GFX11       = 0x0000007a,
+    SDMA_PERF_SEL_CE_CH_WRREQ_SEND__GFX11              = 0x0000007b,
+    SDMA_PERF_SEL_CH_CE_WRRET_VALID__GFX11             = 0x0000007c,
+    SDMA_PERF_SEL_CE_CH_RDREQ_SEND__GFX11              = 0x0000007d,
+    SDMA_PERF_SEL_CH_CE_RDRET_VALID__GFX11             = 0x0000007e,
+    SDMA_PERF_SEL_QUEUE4_SELECT__GFX11                 = 0x0000007f,
+    SDMA_PERF_SEL_QUEUE5_SELECT__GFX11                 = 0x00000080,
+    SDMA_PERF_SEL_QUEUE6_SELECT__GFX11                 = 0x00000081,
+    SDMA_PERF_SEL_QUEUE7_SELECT__GFX11                 = 0x00000082,
+#endif
     SDMA_PERF_SEL_GPUVM_INVREQ_HIGH__OSS50             = 0x0000004f,
     SDMA_PERF_SEL_GPUVM_INVREQ_LOW__OSS50              = 0x00000050,
 } SDMA_PERF_SEL;
 
 constexpr unsigned int MaxSdmaPerfSelGfx09             = SDMA_PERF_SEL_MMHUB_TAG_DELAY_COUNTER__GFX09;
 constexpr unsigned int MaxSdmaPerfSelOss50             = SDMA_PERF_SEL_MMHUB_TAG_DELAY_COUNTER__GFX10CORE;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxSdmaPerfSelGfx103            = SDMA_PERF_SEL_CH_CE_RDRET_VALID__GFX103;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxSdmaPerfSelGfx11             = SDMA_PERF_SEL_QUEUE7_SELECT__GFX11;
+#endif
 
 typedef enum SH_MEM_ADDRESS_MODE {
     SH_MEM_ADDRESS_MODE_64                             = 0x00000000,
     SH_MEM_ADDRESS_MODE_32                             = 0x00000001,
 } SH_MEM_ADDRESS_MODE;
 
 typedef enum SH_MEM_ALIGNMENT_MODE {
     SH_MEM_ALIGNMENT_MODE_DWORD                        = 0x00000000,
     SH_MEM_ALIGNMENT_MODE_DWORD_STRICT                 = 0x00000001,
     SH_MEM_ALIGNMENT_MODE_STRICT                       = 0x00000002,
@@ -8476,20 +10856,23 @@ typedef enum SPI_FOG_MODE {
     SPI_FOG_EXP                                        = 0x00000001,
     SPI_FOG_EXP2                                       = 0x00000002,
     SPI_FOG_LINEAR                                     = 0x00000003,
 } SPI_FOG_MODE;
 
 typedef enum SPI_LB_WAVES_SELECT {
     HS_GS                                              = 0x00000000,
     CS_NA                                              = 0x00000002,
     SPI_LB_WAVES_RSVD                                  = 0x00000003,
     VS_PS__GFX10                                       = 0x00000001,
+#if CHIP_HDR_NAVI31
+    PS__GFX11                                          = 0x00000001,
+#endif
 } SPI_LB_WAVES_SELECT;
 
 typedef enum SPI_PERFCNT_SEL {
     SPI_PERF_VS_PC_STALL__GFX09                        = 0x00000005,
     SPI_PERF_VS_POS0_STALL__GFX09                      = 0x00000006,
     SPI_PERF_VS_POS1_STALL__GFX09                      = 0x00000007,
     SPI_PERF_VS_CRAWLER_STALL__GFX09                   = 0x00000008,
     SPI_PERF_VS_EVENT_WAVE__GFX09                      = 0x00000009,
     SPI_PERF_VS_WAVE__GFX09                            = 0x0000000a,
     SPI_PERF_VS_PERS_UPD_FULL0__GFX09                  = 0x0000000b,
@@ -8747,20 +11130,43 @@ typedef enum SPI_PERFCNT_SEL {
     SPI_PERF_LS_LAST_WAVE__GFX101                      = 0x00000143,
     SPI_PERF_LS_OFFCHIP_LDS_STALL__GFX101              = 0x00000144,
     SPI_PERF_LS_EVENT_WAVE__GFX101                     = 0x00000145,
     SPI_PERF_LS_WAVE__GFX101                           = 0x00000146,
     SPI_PERF_LS_PERS_UPD_FULL0__GFX101                 = 0x00000147,
     SPI_PERF_LS_PERS_UPD_FULL1__GFX101                 = 0x00000148,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     SPI_PERF_EXP_THROT_UPSTEP__GFX103                  = 0x00000149,
     SPI_PERF_EXP_THROT_DOWNSTEP__GFX103                = 0x0000014a,
     SPI_PERF_EXP_THROT_CAUSALITY_DETECTED__GFX103      = 0x0000014b,
+#endif
+#if CHIP_HDR_NAVI31
+    SPI_PERF_PS0_WINDOW_VALID__GFX104PLUS              = 0x00000035,
+    SPI_PERF_PS1_WINDOW_VALID__GFX104PLUS              = 0x00000036,
+    SPI_PERF_PS2_WINDOW_VALID__GFX104PLUS              = 0x00000037,
+    SPI_PERF_PS3_WINDOW_VALID__GFX104PLUS              = 0x00000038,
+    SPI_PERF_PS0_BUSY__GFX104PLUS                      = 0x00000039,
+    SPI_PERF_PS1_BUSY__GFX104PLUS                      = 0x0000003a,
+    SPI_PERF_PS2_BUSY__GFX104PLUS                      = 0x0000003b,
+    SPI_PERF_PS3_BUSY__GFX104PLUS                      = 0x0000003c,
+    SPI_PERF_PS0_ACTIVE__GFX104PLUS                    = 0x0000003d,
+    SPI_PERF_PS1_ACTIVE__GFX104PLUS                    = 0x0000003e,
+    SPI_PERF_PS2_ACTIVE__GFX104PLUS                    = 0x0000003f,
+    SPI_PERF_PS3_ACTIVE__GFX104PLUS                    = 0x00000040,
+    SPI_PERF_PS0_DEALLOC__GFX104PLUS                   = 0x00000041,
+    SPI_PERF_PS1_DEALLOC__GFX104PLUS                   = 0x00000042,
+    SPI_PERF_PS2_DEALLOC__GFX104PLUS                   = 0x00000043,
+    SPI_PERF_PS3_DEALLOC__GFX104PLUS                   = 0x00000044,
+    SPI_PERF_RA_PIPE_REQ_BIN2__GFX104PLUS              = 0x0000008d,
+    SPI_PERF_RA_TASK_REQ_BIN3__GFX104PLUS              = 0x0000008e,
+    SPI_PERF_RA_WR_CTL_FULL__GFX104PLUS                = 0x0000008f,
+    SPI_PERF_RA_REQ_NO_ALLOC__GFX104PLUS               = 0x00000090,
+    SPI_PERF_RA_REQ_NO_ALLOC_PS__GFX104PLUS            = 0x00000091,
 #endif
     SPI_PERF_GS_LAST_SUBGRP__GFX10CORE                 = 0x00000019,
     SPI_PERF_GS_HS_DEALLOC__GFX10CORE                  = 0x0000001a,
     SPI_PERF_GS_NGG_SE_LATE_ALLOC_LIMIT__GFX10CORE     = 0x0000001b,
     SPI_PERF_GS_GRP_FIFO_FULL__GFX10CORE               = 0x0000001c,
     SPI_PERF_GS_POS0_STALL__GFX10CORE                  = 0x0000001d,
     SPI_PERF_GS_POS1_STALL__GFX10CORE                  = 0x0000001e,
     SPI_PERF_GS_INDX0_STALL__GFX10CORE                 = 0x0000001f,
     SPI_PERF_GS_INDX1_STALL__GFX10CORE                 = 0x00000020,
     SPI_PERF_HS_WINDOW_VALID__GFX10CORE                = 0x00000021,
@@ -8999,20 +11405,262 @@ typedef enum SPI_PERFCNT_SEL {
     SPI_PERF_SWC_GS_WR__GFX10CORE                      = 0x00000126,
     SPI_PERF_SWC_HS_WR__GFX10CORE                      = 0x00000128,
     SPI_PERF_SWC_CSGN_WR__GFX10CORE                    = 0x00000129,
     SPI_PERF_SWC_CSN_WR__GFX10CORE                     = 0x0000012a,
     SPI_PERF_VWC_PS_WR__GFX10CORE                      = 0x0000012b,
     SPI_PERF_VWC_VS_WR__GFX10CORE                      = 0x0000012c,
     SPI_PERF_VWC_GS_WR__GFX10CORE                      = 0x0000012e,
     SPI_PERF_VWC_HS_WR__GFX10CORE                      = 0x00000130,
     SPI_PERF_VWC_CSGN_WR__GFX10CORE                    = 0x00000131,
     SPI_PERF_VWC_CSN_WR__GFX10CORE                     = 0x00000132,
+#if CHIP_HDR_NAVI31
+    SPI_PERF_GS_WINDOW_VALID__GFX11                    = 0x00000001,
+    SPI_PERF_GS_BUSY__GFX11                            = 0x00000002,
+    SPI_PERF_GS_CRAWLER_STALL__GFX11                   = 0x00000003,
+    SPI_PERF_GS_EVENT_WAVE__GFX11                      = 0x00000004,
+    SPI_PERF_GS_WAVE__GFX11                            = 0x00000005,
+    SPI_PERF_GS_PERS_UPD_FULL0__GFX11                  = 0x00000006,
+    SPI_PERF_GS_PERS_UPD_FULL1__GFX11                  = 0x00000007,
+    SPI_PERF_GS_FIRST_SUBGRP__GFX11                    = 0x00000008,
+    SPI_PERF_GS_HS_DEALLOC__GFX11                      = 0x00000009,
+    SPI_PERF_GS_NGG_SE_LATE_ALLOC_LIMIT__GFX11         = 0x0000000a,
+    SPI_PERF_GS_POS0_STALL__GFX11                      = 0x0000000b,
+    SPI_PERF_GS_POS1_STALL__GFX11                      = 0x0000000c,
+    SPI_PERF_GS_INDX0_STALL__GFX11                     = 0x0000000d,
+    SPI_PERF_GS_INDX1_STALL__GFX11                     = 0x0000000e,
+    SPI_PERF_GS_PWS_STALL__GFX11                       = 0x0000000f,
+    SPI_PERF_GS_GRP_LIFETIME__GFX11                    = 0x00000010,
+    SPI_PERF_GS_WAVE_IN_FLIGHT__GFX11                  = 0x00000011,
+    SPI_PERF_HS_WINDOW_VALID__GFX11                    = 0x00000015,
+    SPI_PERF_HS_BUSY__GFX11                            = 0x00000016,
+    SPI_PERF_HS_CRAWLER_STALL__GFX11                   = 0x00000017,
+    SPI_PERF_HS_FIRST_WAVE__GFX11                      = 0x00000018,
+    SPI_PERF_HS_OFFCHIP_LDS_STALL__GFX11               = 0x00000019,
+    SPI_PERF_HS_EVENT_WAVE__GFX11                      = 0x0000001a,
+    SPI_PERF_HS_WAVE__GFX11                            = 0x0000001b,
+    SPI_PERF_HS_PERS_UPD_FULL0__GFX11                  = 0x0000001c,
+    SPI_PERF_HS_PERS_UPD_FULL1__GFX11                  = 0x0000001d,
+    SPI_PERF_HS_PWS_STALL__GFX11                       = 0x0000001e,
+    SPI_PERF_HS_WAVE_IN_FLIGHT__GFX11                  = 0x0000001f,
+    SPI_PERF_CSGN_WINDOW_VALID__GFX11                  = 0x00000025,
+    SPI_PERF_CSGN_BUSY__GFX11                          = 0x00000026,
+    SPI_PERF_CSGN_NUM_THREADGROUPS__GFX11              = 0x00000027,
+    SPI_PERF_CSGN_CRAWLER_STALL__GFX11                 = 0x00000028,
+    SPI_PERF_CSGN_EVENT_WAVE__GFX11                    = 0x00000029,
+    SPI_PERF_CSGN_WAVE__GFX11                          = 0x0000002a,
+    SPI_PERF_CSGN_PWS_STALL__GFX11                     = 0x0000002b,
+    SPI_PERF_CSGN_WAVE_IN_FLIGHT__GFX11                = 0x0000002c,
+    SPI_PERF_CSN_WINDOW_VALID__GFX11                   = 0x0000002d,
+    SPI_PERF_CSN_BUSY__GFX11                           = 0x0000002e,
+    SPI_PERF_CSN_NUM_THREADGROUPS__GFX11               = 0x0000002f,
+    SPI_PERF_CSN_CRAWLER_STALL__GFX11                  = 0x00000030,
+    SPI_PERF_CSN_EVENT_WAVE__GFX11                     = 0x00000031,
+    SPI_PERF_CSN_WAVE__GFX11                           = 0x00000032,
+    SPI_PERF_CSN_WAVE_IN_FLIGHT__GFX11                 = 0x00000033,
+    SPI_PERF_PS0_EVENT_WAVE__GFX11                     = 0x00000045,
+    SPI_PERF_PS1_EVENT_WAVE__GFX11                     = 0x00000046,
+    SPI_PERF_PS2_EVENT_WAVE__GFX11                     = 0x00000047,
+    SPI_PERF_PS3_EVENT_WAVE__GFX11                     = 0x00000048,
+    SPI_PERF_PS0_WAVE__GFX11                           = 0x00000049,
+    SPI_PERF_PS1_WAVE__GFX11                           = 0x0000004a,
+    SPI_PERF_PS2_WAVE__GFX11                           = 0x0000004b,
+    SPI_PERF_PS3_WAVE__GFX11                           = 0x0000004c,
+    SPI_PERF_PS0_OPT_WAVE__GFX11                       = 0x0000004d,
+    SPI_PERF_PS1_OPT_WAVE__GFX11                       = 0x0000004e,
+    SPI_PERF_PS2_OPT_WAVE__GFX11                       = 0x0000004f,
+    SPI_PERF_PS3_OPT_WAVE__GFX11                       = 0x00000050,
+    SPI_PERF_PS0_PRIM_BIN0__GFX11                      = 0x00000051,
+    SPI_PERF_PS1_PRIM_BIN0__GFX11                      = 0x00000052,
+    SPI_PERF_PS2_PRIM_BIN0__GFX11                      = 0x00000053,
+    SPI_PERF_PS3_PRIM_BIN0__GFX11                      = 0x00000054,
+    SPI_PERF_PS0_PRIM_BIN1__GFX11                      = 0x00000055,
+    SPI_PERF_PS1_PRIM_BIN1__GFX11                      = 0x00000056,
+    SPI_PERF_PS2_PRIM_BIN1__GFX11                      = 0x00000057,
+    SPI_PERF_PS3_PRIM_BIN1__GFX11                      = 0x00000058,
+    SPI_PERF_PS0_CRAWLER_STALL__GFX11                  = 0x00000059,
+    SPI_PERF_PS1_CRAWLER_STALL__GFX11                  = 0x0000005a,
+    SPI_PERF_PS2_CRAWLER_STALL__GFX11                  = 0x0000005b,
+    SPI_PERF_PS3_CRAWLER_STALL__GFX11                  = 0x0000005c,
+    SPI_PERF_PS_PERS_UPD_FULL0__GFX11                  = 0x0000005d,
+    SPI_PERF_PS_PERS_UPD_FULL1__GFX11                  = 0x0000005e,
+    SPI_PERF_PS0_2_WAVE_GROUPS__GFX11                  = 0x0000005f,
+    SPI_PERF_PS1_2_WAVE_GROUPS__GFX11                  = 0x00000060,
+    SPI_PERF_PS2_2_WAVE_GROUPS__GFX11                  = 0x00000061,
+    SPI_PERF_PS3_2_WAVE_GROUPS__GFX11                  = 0x00000062,
+    SPI_PERF_PS0_WAVE_GROUP_CLOCK_DELAY__GFX11         = 0x00000063,
+    SPI_PERF_PS1_WAVE_GROUP_CLOCK_DELAY__GFX11         = 0x00000064,
+    SPI_PERF_PS2_WAVE_GROUP_CLOCK_DELAY__GFX11         = 0x00000065,
+    SPI_PERF_PS3_WAVE_GROUP_CLOCK_DELAY__GFX11         = 0x00000066,
+    SPI_PERF_PS0_WAVE_GROUP_TIMEOUTS__GFX11            = 0x00000067,
+    SPI_PERF_PS1_WAVE_GROUP_TIMEOUTS__GFX11            = 0x00000068,
+    SPI_PERF_PS2_WAVE_GROUP_TIMEOUTS__GFX11            = 0x00000069,
+    SPI_PERF_PS3_WAVE_GROUP_TIMEOUTS__GFX11            = 0x0000006a,
+    SPI_PERF_PS_PWS_STALL__GFX11                       = 0x0000006b,
+    SPI_PERF_PS0_LDS_DONE_FULL__GFX11                  = 0x0000006c,
+    SPI_PERF_PS1_LDS_DONE_FULL__GFX11                  = 0x0000006d,
+    SPI_PERF_PS2_LDS_DONE_FULL__GFX11                  = 0x0000006e,
+    SPI_PERF_PS3_LDS_DONE_FULL__GFX11                  = 0x0000006f,
+    SPI_PERF_PS0_DEALLOC_FULL__GFX11                   = 0x00000070,
+    SPI_PERF_PS1_DEALLOC_FULL__GFX11                   = 0x00000071,
+    SPI_PERF_PS2_DEALLOC_FULL__GFX11                   = 0x00000072,
+    SPI_PERF_PS3_DEALLOC_FULL__GFX11                   = 0x00000073,
+    SPI_PERF_PS0_WAVE_IN_FLIGHT__GFX11                 = 0x00000074,
+    SPI_PERF_PS1_WAVE_IN_FLIGHT__GFX11                 = 0x00000075,
+    SPI_PERF_PS2_WAVE_IN_FLIGHT__GFX11                 = 0x00000076,
+    SPI_PERF_PS3_WAVE_IN_FLIGHT__GFX11                 = 0x00000077,
+    SPI_PERF_RA_GS_LDS_OCCUPANCY__GFX11                = 0x00000085,
+    SPI_PERF_RA_GS_VGPR_OCCUPANCY__GFX11               = 0x00000086,
+    SPI_PERF_RA_PS_LDS_OCCUPANCY__GFX11                = 0x00000087,
+    SPI_PERF_RA_PS_VGPR_OCCUPANCY__GFX11               = 0x00000088,
+    SPI_PERF_RA_SPI_THROTTLE__GFX11                    = 0x00000089,
+    SPI_PERF_RA_PH_THROTTLE__GFX11                     = 0x0000008a,
+    SPI_PERF_RA_PC_PROBE_STALL_PS__GFX11               = 0x0000008b,
+    SPI_PERF_RA_PC_PSWAVE_STALL_PS__GFX11              = 0x0000008c,
+    SPI_PERF_RA_REQ_NO_ALLOC_GS__GFX11                 = 0x00000092,
+    SPI_PERF_RA_REQ_NO_ALLOC_HS__GFX11                 = 0x00000093,
+    SPI_PERF_RA_REQ_NO_ALLOC_CSG__GFX11                = 0x00000094,
+    SPI_PERF_RA_REQ_NO_ALLOC_CSN__GFX11                = 0x00000095,
+    SPI_PERF_RA_RES_STALL_PS__GFX11                    = 0x00000096,
+    SPI_PERF_RA_RES_STALL_GS__GFX11                    = 0x00000097,
+    SPI_PERF_RA_RES_STALL_HS__GFX11                    = 0x00000098,
+    SPI_PERF_RA_RES_STALL_CSG__GFX11                   = 0x00000099,
+    SPI_PERF_RA_RES_STALL_CSN__GFX11                   = 0x0000009a,
+    SPI_PERF_RA_TMP_STALL_PS__GFX11                    = 0x0000009b,
+    SPI_PERF_RA_TMP_STALL_GS__GFX11                    = 0x0000009c,
+    SPI_PERF_RA_TMP_STALL_HS__GFX11                    = 0x0000009d,
+    SPI_PERF_RA_TMP_STALL_CSG__GFX11                   = 0x0000009e,
+    SPI_PERF_RA_TMP_STALL_CSN__GFX11                   = 0x0000009f,
+    SPI_PERF_RA_WAVE_SIMD_FULL_PS__GFX11               = 0x000000a0,
+    SPI_PERF_RA_WAVE_SIMD_FULL_GS__GFX11               = 0x000000a1,
+    SPI_PERF_RA_WAVE_SIMD_FULL_HS__GFX11               = 0x000000a2,
+    SPI_PERF_RA_WAVE_SIMD_FULL_CSG__GFX11              = 0x000000a3,
+    SPI_PERF_RA_WAVE_SIMD_FULL_CSN__GFX11              = 0x000000a4,
+    SPI_PERF_RA_VGPR_SIMD_FULL_PS__GFX11               = 0x000000a5,
+    SPI_PERF_RA_VGPR_SIMD_FULL_GS__GFX11               = 0x000000a6,
+    SPI_PERF_RA_VGPR_SIMD_FULL_HS__GFX11               = 0x000000a7,
+    SPI_PERF_RA_VGPR_SIMD_FULL_CSG__GFX11              = 0x000000a8,
+    SPI_PERF_RA_VGPR_SIMD_FULL_CSN__GFX11              = 0x000000a9,
+    SPI_PERF_RA_LDS_CU_FULL_PS__GFX11                  = 0x000000aa,
+    SPI_PERF_RA_LDS_CU_FULL_HS__GFX11                  = 0x000000ab,
+    SPI_PERF_RA_LDS_CU_FULL_GS__GFX11                  = 0x000000ac,
+    SPI_PERF_RA_LDS_CU_FULL_CSG__GFX11                 = 0x000000ad,
+    SPI_PERF_RA_LDS_CU_FULL_CSN__GFX11                 = 0x000000ae,
+    SPI_PERF_RA_BAR_CU_FULL_PS__GFX11                  = 0x000000af,
+    SPI_PERF_RA_BAR_CU_FULL_GS__GFX11                  = 0x000000b0,
+    SPI_PERF_RA_BAR_CU_FULL_HS__GFX11                  = 0x000000b1,
+    SPI_PERF_RA_BAR_CU_FULL_CSG__GFX11                 = 0x000000b2,
+    SPI_PERF_RA_BAR_CU_FULL_CSN__GFX11                 = 0x000000b3,
+    SPI_PERF_RA_BULKY_CU_FULL_CSG__GFX11               = 0x000000b4,
+    SPI_PERF_RA_BULKY_CU_FULL_CSN__GFX11               = 0x000000b5,
+    SPI_PERF_RA_TGLIM_CU_FULL_CSG__GFX11               = 0x000000b6,
+    SPI_PERF_RA_TGLIM_CU_FULL_CSN__GFX11               = 0x000000b7,
+    SPI_PERF_RA_WVLIM_STALL_PS__GFX11                  = 0x000000b8,
+    SPI_PERF_RA_WVLIM_STALL_GS__GFX11                  = 0x000000b9,
+    SPI_PERF_RA_WVLIM_STALL_HS__GFX11                  = 0x000000ba,
+    SPI_PERF_RA_WVLIM_STALL_CSG__GFX11                 = 0x000000bb,
+    SPI_PERF_RA_WVLIM_STALL_CSN__GFX11                 = 0x000000bc,
+    SPI_PERF_RA_GS_LOCK__GFX11                         = 0x000000bd,
+    SPI_PERF_RA_HS_LOCK__GFX11                         = 0x000000be,
+    SPI_PERF_RA_CSG_LOCK__GFX11                        = 0x000000bf,
+    SPI_PERF_RA_CSN_LOCK__GFX11                        = 0x000000c0,
+    SPI_PERF_RA_RSV_UPD__GFX11                         = 0x000000c1,
+    SPI_PERF_RA_PRE_ALLOC_STALL__GFX11                 = 0x000000c2,
+    SPI_PERF_RA_GFX_UNDER_TUNNEL__GFX11                = 0x000000c3,
+    SPI_PERF_RA_CSC_UNDER_TUNNEL__GFX11                = 0x000000c4,
+    SPI_PERF_RA_WVALLOC_STALL__GFX11                   = 0x000000c5,
+    SPI_PERF_RA_ACCUM0_SIMD_FULL_PS__GFX11             = 0x000000c6,
+    SPI_PERF_RA_ACCUM1_SIMD_FULL_PS__GFX11             = 0x000000c7,
+    SPI_PERF_RA_ACCUM2_SIMD_FULL_PS__GFX11             = 0x000000c8,
+    SPI_PERF_RA_ACCUM3_SIMD_FULL_PS__GFX11             = 0x000000c9,
+    SPI_PERF_RA_ACCUM0_SIMD_FULL_GS__GFX11             = 0x000000ca,
+    SPI_PERF_RA_ACCUM1_SIMD_FULL_GS__GFX11             = 0x000000cb,
+    SPI_PERF_RA_ACCUM2_SIMD_FULL_GS__GFX11             = 0x000000cc,
+    SPI_PERF_RA_ACCUM3_SIMD_FULL_GS__GFX11             = 0x000000cd,
+    SPI_PERF_RA_ACCUM0_SIMD_FULL_HS__GFX11             = 0x000000ce,
+    SPI_PERF_RA_ACCUM1_SIMD_FULL_HS__GFX11             = 0x000000cf,
+    SPI_PERF_RA_ACCUM2_SIMD_FULL_HS__GFX11             = 0x000000d0,
+    SPI_PERF_RA_ACCUM3_SIMD_FULL_HS__GFX11             = 0x000000d1,
+    SPI_PERF_RA_ACCUM0_SIMD_FULL_CSG__GFX11            = 0x000000d2,
+    SPI_PERF_RA_ACCUM1_SIMD_FULL_CSG__GFX11            = 0x000000d3,
+    SPI_PERF_RA_ACCUM2_SIMD_FULL_CSG__GFX11            = 0x000000d4,
+    SPI_PERF_RA_ACCUM3_SIMD_FULL_CSG__GFX11            = 0x000000d5,
+    SPI_PERF_RA_ACCUM0_SIMD_FULL_CSN__GFX11            = 0x000000d6,
+    SPI_PERF_RA_ACCUM1_SIMD_FULL_CSN__GFX11            = 0x000000d7,
+    SPI_PERF_RA_ACCUM2_SIMD_FULL_CSN__GFX11            = 0x000000d8,
+    SPI_PERF_RA_ACCUM3_SIMD_FULL_CSN__GFX11            = 0x000000d9,
+    SPI_PERF_EXP_ARB_COL_CNT__GFX11                    = 0x000000da,
+    SPI_PERF_EXP_ARB_POS_CNT__GFX11                    = 0x000000db,
+    SPI_PERF_EXP_ARB_GDS_CNT__GFX11                    = 0x000000dc,
+    SPI_PERF_EXP_ARB_IDX_CNT__GFX11                    = 0x000000dd,
+    SPI_PERF_EXP_WITH_CONFLICT__GFX11                  = 0x000000de,
+    SPI_PERF_EXP_WITH_CONFLICT_CLEAR__GFX11            = 0x000000df,
+    SPI_PERF_GS_EXP_DONE__GFX11                        = 0x000000e0,
+    SPI_PERF_PS_EXP_DONE__GFX11                        = 0x000000e1,
+    SPI_PERF_PS_EXP_ARB_CONFLICT__GFX11                = 0x000000e2,
+    SPI_PERF_GS_SCBD_IDX_CLEANUP__GFX11                = 0x000000e3,
+    SPI_PERF_GS_SCBD_POS_CLEANUP__GFX11                = 0x000000e4,
+    SPI_PERF_PS_EXP_ALLOC__GFX11                       = 0x000000e5,
+    SPI_PERF_PS0_WAVEID_STARVED__GFX11                 = 0x000000e6,
+    SPI_PERF_PS1_WAVEID_STARVED__GFX11                 = 0x000000e7,
+    SPI_PERF_PS2_WAVEID_STARVED__GFX11                 = 0x000000e8,
+    SPI_PERF_PS3_WAVEID_STARVED__GFX11                 = 0x000000e9,
+    SPI_PERF_PS0_EXP_ALLOC_WITH_CONFLICT__GFX11        = 0x000000ea,
+    SPI_PERF_PS1_EXP_ALLOC_WITH_CONFLICT__GFX11        = 0x000000eb,
+    SPI_PERF_PS2_EXP_ALLOC_WITH_CONFLICT__GFX11        = 0x000000ec,
+    SPI_PERF_PS3_EXP_ALLOC_WITH_CONFLICT__GFX11        = 0x000000ed,
+    SPI_PERF_NUM_PS_COL_SA0SQ0_EXPORTS__GFX11          = 0x000000ee,
+    SPI_PERF_NUM_PS_COL_SA0SQ1_EXPORTS__GFX11          = 0x000000ef,
+    SPI_PERF_NUM_PS_COL_SA1SQ0_EXPORTS__GFX11          = 0x000000f0,
+    SPI_PERF_NUM_PS_COL_SA1SQ1_EXPORTS__GFX11          = 0x000000f1,
+    SPI_PERF_NUM_POS_SA0SQ0_EXPORTS__GFX11             = 0x000000f2,
+    SPI_PERF_NUM_POS_SA0SQ1_EXPORTS__GFX11             = 0x000000f3,
+    SPI_PERF_NUM_POS_SA1SQ0_EXPORTS__GFX11             = 0x000000f4,
+    SPI_PERF_NUM_POS_SA1SQ1_EXPORTS__GFX11             = 0x000000f5,
+    SPI_PERF_NUM_GDS_SA0SQ0_EXPORTS__GFX11             = 0x000000f6,
+    SPI_PERF_NUM_GDS_SA0SQ1_EXPORTS__GFX11             = 0x000000f7,
+    SPI_PERF_NUM_GDS_SA1SQ0_EXPORTS__GFX11             = 0x000000f8,
+    SPI_PERF_NUM_GDS_SA1SQ1_EXPORTS__GFX11             = 0x000000f9,
+    SPI_PERF_NUM_EXPGRANT_EXPORTS__GFX11               = 0x000000fa,
+    SPI_PERF_GS_ALLOC_IDX__GFX11                       = 0x000000fb,
+    SPI_PERF_GS_ALLOC_POS__GFX11                       = 0x000000fc,
+    SPI_PERF_PIX_ALLOC_PEND_CNT__GFX11                 = 0x000000fd,
+    SPI_PERF_EXPORT_SCB0_STALL__GFX11                  = 0x000000fe,
+    SPI_PERF_EXPORT_SCB1_STALL__GFX11                  = 0x000000ff,
+    SPI_PERF_EXPORT_SCB2_STALL__GFX11                  = 0x00000100,
+    SPI_PERF_EXPORT_SCB3_STALL__GFX11                  = 0x00000101,
+    SPI_PERF_EXPORT_DB0_STALL__GFX11                   = 0x00000102,
+    SPI_PERF_EXPORT_DB1_STALL__GFX11                   = 0x00000103,
+    SPI_PERF_EXPORT_DB2_STALL__GFX11                   = 0x00000104,
+    SPI_PERF_EXPORT_DB3_STALL__GFX11                   = 0x00000105,
+    SPI_PERF_EXPORT_DB4_STALL__GFX11                   = 0x00000106,
+    SPI_PERF_EXPORT_DB5_STALL__GFX11                   = 0x00000107,
+    SPI_PERF_EXPORT_DB6_STALL__GFX11                   = 0x00000108,
+    SPI_PERF_EXPORT_DB7_STALL__GFX11                   = 0x00000109,
+    SPI_PERF_GS_NGG_SE_SEND_GS_ALLOC__GFX11            = 0x0000010a,
+    SPI_PERF_GS_NGG_STALL_MSG_VAL__GFX11               = 0x0000010b,
+    SPI_PERF_SWC_PS_WR__GFX11                          = 0x0000010c,
+    SPI_PERF_SWC_GS_WR__GFX11                          = 0x0000010d,
+    SPI_PERF_SWC_HS_WR__GFX11                          = 0x0000010e,
+    SPI_PERF_SWC_CSGN_WR__GFX11                        = 0x0000010f,
+    SPI_PERF_SWC_CSN_WR__GFX11                         = 0x00000110,
+    SPI_PERF_VWC_PS_WR__GFX11                          = 0x00000111,
+    SPI_PERF_VWC_ES_WR__GFX11                          = 0x00000112,
+    SPI_PERF_VWC_GS_WR__GFX11                          = 0x00000113,
+    SPI_PERF_VWC_LS_WR__GFX11                          = 0x00000114,
+    SPI_PERF_VWC_HS_WR__GFX11                          = 0x00000115,
+    SPI_PERF_VWC_CSGN_WR__GFX11                        = 0x00000116,
+    SPI_PERF_VWC_CSN_WR__GFX11                         = 0x00000117,
+    SPI_PERF_EXP_THROT_UPSTEP__GFX11                   = 0x00000118,
+    SPI_PERF_EXP_THROT_DOWNSTEP__GFX11                 = 0x00000119,
+    SPI_PERF_EXP_THROT_CAUSALITY_DETECTED__GFX11       = 0x0000011a,
+    SPI_PERF_BUSY__GFX11                               = 0x0000011b,
+#endif
     SPI_PERF_VS_WINDOW_VALID__HASHWVS                  = 0x00000000,
     SPI_PERF_VS_BUSY__HASHWVS                          = 0x00000001,
     SPI_PERF_VS_FIRST_WAVE__HASHWVS                    = 0x00000002,
     SPI_PERF_VS_LAST_WAVE__HASHWVS                     = 0x00000003,
     SPI_PERF_VS_LSHS_DEALLOC__HASHWVS                  = 0x00000004,
 #if CHIP_HDR_NAVI21
     SPI_PERF_RA_REQ_NO_ALLOC_ES__NV21                  = 0x00000092,
     SPI_PERF_RA_REQ_NO_ALLOC_LS__NV21                  = 0x00000094,
     SPI_PERF_RA_RES_STALL_ES__NV21                     = 0x0000009a,
     SPI_PERF_RA_RES_STALL_LS__NV21                     = 0x0000009c,
@@ -9129,29 +11777,40 @@ typedef enum SPI_PERFCNT_SEL {
     SPI_PERF_SWC_PS_WR__NV24                           = 0x00000124,
     SPI_PERF_SWC_VS_WR__NV24                           = 0x00000125,
 #endif
 } SPI_PERFCNT_SEL;
 
 constexpr unsigned int MaxSpiPerfcntSelGfx09           = SPI_PERF_VWC_CSC_WR__GFX09;
 constexpr unsigned int MaxSpiPerfcntSelGfx101          = SPI_PERF_LS_PERS_UPD_FULL1__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxSpiPerfcntSelGfx103          = SPI_PERF_EXP_THROT_CAUSALITY_DETECTED__GFX103;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxSpiPerfcntSelGfx11           = SPI_PERF_BUSY__GFX11;
+#endif
 
 typedef enum SPI_PNT_SPRITE_OVERRIDE {
     SPI_PNT_SPRITE_SEL_0                               = 0x00000000,
     SPI_PNT_SPRITE_SEL_1                               = 0x00000001,
     SPI_PNT_SPRITE_SEL_S                               = 0x00000002,
     SPI_PNT_SPRITE_SEL_T                               = 0x00000003,
     SPI_PNT_SPRITE_SEL_NONE                            = 0x00000004,
 } SPI_PNT_SPRITE_OVERRIDE;
 
+#if CHIP_HDR_NAVI31
+typedef enum SPI_PS_LDS_GROUP_SIZE {
+    SPI_PS_LDS_GROUP_1                                 = 0x00000000,
+    SPI_PS_LDS_GROUP_2                                 = 0x00000001,
+    SPI_PS_LDS_GROUP_4                                 = 0x00000002,
+} SPI_PS_LDS_GROUP_SIZE;
+#endif
+
 typedef enum SPI_SAMPLE_CNTL {
     CENTROIDS_ONLY                                     = 0x00000000,
     CENTERS_ONLY                                       = 0x00000001,
     CENTROIDS_AND_CENTERS                              = 0x00000002,
     UNDEF                                              = 0x00000003,
 } SPI_SAMPLE_CNTL;
 
 typedef enum SPI_SHADER_EX_FORMAT {
     SPI_SHADER_ZERO                                    = 0x00000000,
     SPI_SHADER_32_R                                    = 0x00000001,
@@ -9175,27 +11834,71 @@ typedef enum SPI_SHADER_FORMAT {
 
 typedef enum SPM_PERFMON_STATE {
     STRM_PERFMON_STATE_DISABLE_AND_RESET               = 0x00000000,
     STRM_PERFMON_STATE_START_COUNTING                  = 0x00000001,
     STRM_PERFMON_STATE_STOP_COUNTING                   = 0x00000002,
     STRM_PERFMON_STATE_RESERVED_3                      = 0x00000003,
     STRM_PERFMON_STATE_DISABLE_AND_RESET_PHANTOM       = 0x00000004,
     STRM_PERFMON_STATE_COUNT_AND_DUMP_PHANTOM          = 0x00000005,
 } SPM_PERFMON_STATE;
 
+#if CHIP_HDR_NAVI31
+typedef enum SQG_PERF_SEL {
+    SQG_PERF_SEL_NONE                                  = 0x00000000,
+    SQG_PERF_SEL_MSG_BUS_BUSY                          = 0x00000001,
+    SQG_PERF_SEL_EXP_REQ0_BUS_BUSY                     = 0x00000002,
+    SQG_PERF_SEL_EXP_REQ1_BUS_BUSY                     = 0x00000003,
+    SQG_PERF_SEL_EXP_BUS0_BUSY                         = 0x00000004,
+    SQG_PERF_SEL_EXP_BUS1_BUSY                         = 0x00000005,
+    SQG_PERF_SEL_TTRACE_REQS                           = 0x00000006,
+    SQG_PERF_SEL_TTRACE_INFLIGHT_REQS                  = 0x00000007,
+    SQG_PERF_SEL_TTRACE_STALL                          = 0x00000008,
+    SQG_PERF_SEL_TTRACE_LOST_PACKETS                   = 0x00000009,
+    SQG_PERF_SEL_WAVES_INITIAL_PREFETCH                = 0x0000000a,
+    SQG_PERF_SEL_EVENTS                                = 0x0000000b,
+    SQG_PERF_SEL_WAVES_RESTORED                        = 0x0000000c,
+    SQG_PERF_SEL_WAVES_SAVED                           = 0x0000000d,
+    SQG_PERF_SEL_ACCUM_PREV                            = 0x0000000e,
+    SQG_PERF_SEL_CYCLES                                = 0x0000000f,
+    SQG_PERF_SEL_BUSY_CYCLES                           = 0x00000010,
+    SQG_PERF_SEL_WAVE_CYCLES                           = 0x00000011,
+    SQG_PERF_SEL_MSG                                   = 0x00000012,
+    SQG_PERF_SEL_MSG_INTERRUPT                         = 0x00000013,
+    SQG_PERF_SEL_WAVES                                 = 0x00000014,
+    SQG_PERF_SEL_WAVES_32                              = 0x00000015,
+    SQG_PERF_SEL_WAVES_64                              = 0x00000016,
+    SQG_PERF_SEL_LEVEL_WAVES                           = 0x00000017,
+    SQG_PERF_SEL_ITEMS                                 = 0x00000018,
+    SQG_PERF_SEL_WAVE32_ITEMS                          = 0x00000019,
+    SQG_PERF_SEL_WAVE64_ITEMS                          = 0x0000001a,
+    SQG_PERF_SEL_PS_QUADS                              = 0x0000001b,
+    SQG_PERF_SEL_WAVES_EQ_64                           = 0x0000001c,
+    SQG_PERF_SEL_WAVES_EQ_32                           = 0x0000001d,
+    SQG_PERF_SEL_WAVES_LT_64                           = 0x0000001e,
+    SQG_PERF_SEL_WAVES_LT_48                           = 0x0000001f,
+    SQG_PERF_SEL_WAVES_LT_32                           = 0x00000020,
+    SQG_PERF_SEL_WAVES_LT_16                           = 0x00000021,
+    SQG_PERF_SEL_WAVES_STARTED                         = 0x00000022,
+    SQG_PERF_SEL_WAVES_ENDED                           = 0x00000023,
+    SQG_PERF_SEL_DUMMY_LAST                            = 0x00000024,
+} SQG_PERF_SEL;
+
+constexpr unsigned int MaxSqgPerfSel                   = SQG_PERF_SEL_DUMMY_LAST;
+#endif
+
 typedef enum SQ_IMG_FILTER_TYPE {
     SQ_IMG_FILTER_MODE_BLEND                           = 0x00000000,
     SQ_IMG_FILTER_MODE_MIN                             = 0x00000001,
     SQ_IMG_FILTER_MODE_MAX                             = 0x00000002,
 } SQ_IMG_FILTER_TYPE;
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef enum SQ_LLC_CTL {
     SQ_LLC_0                                           = 0x00000000,
     SQ_LLC_1                                           = 0x00000001,
     SQ_LLC_RSVD_2                                      = 0x00000002,
     SQ_LLC_BYPASS                                      = 0x00000003,
 } SQ_LLC_CTL;
 #endif
 
 typedef enum SQ_OOB_SELECT {
     SQ_OOB_INDEX_AND_OFFSET                            = 0x00000000,
@@ -9991,41 +12694,348 @@ typedef enum SQ_PERF_SEL {
     SQC_PERF_SEL_Reserved_0x198__GFX103DERIVATIVE      = 0x00000199,
     SQC_PERF_SEL_Reserved_0x199__GFX103DERIVATIVE      = 0x0000019a,
     SQC_PERF_SEL_ICACHE_GCR__GFX103DERIVATIVE          = 0x0000019b,
     SQC_PERF_SEL_ICACHE_GCR_HITS__GFX103DERIVATIVE     = 0x0000019c,
     SQC_PERF_SEL_DCACHE_GCR__GFX103DERIVATIVE          = 0x0000019d,
     SQC_PERF_SEL_DCACHE_GCR_HITS__GFX103DERIVATIVE     = 0x0000019e,
     SQC_PERF_SEL_ICACHE_GCR_INVALIDATE__GFX103DERIVATIVE = 0x0000019f,
     SQC_PERF_SEL_DCACHE_GCR_INVALIDATE__GFX103DERIVATIVE = 0x000001a0,
     SQC_PERF_SEL_Reserved_0x1a0__GFX103DERIVATIVE      = 0x000001a1,
     SQC_PERF_SEL_DCACHE_SPI_RETURN_STALL__GFX103DERIVATIVE = 0x000001a2,
+#endif
+#if CHIP_HDR_NAVI31
+    SQ_PERF_SEL_WAVES_INITIAL_PREFETCH__GFX104PLUS     = 0x00000017,
+    SQ_PERF_SEL_NONE2__GFX104PLUS                      = 0x000001ff,
 #endif
     SQ_PERF_SEL_Reserved_1__GFX10CORE                  = 0x00000017,
     SQ_PERF_SEL_INSTS_WAVE32_EXP_GDS__GFX10CORE        = 0x0000004c,
     SQ_PERF_SEL_INSTS_VALU_LDS_DIRECT_RD__GFX10CORE    = 0x0000005f,
     SQ_PERF_SEL_INSTS_VALU_VINTRP_OP__GFX10CORE        = 0x00000060,
     SP_PERF_SEL_DUMMY_LAST__GFX10CORE                  = 0x000001ff,
     SQ_PERF_SEL_WAVES_32__GFX10PLUS                    = 0x00000005,
     SQ_PERF_SEL_WAVES_64__GFX10PLUS                    = 0x00000006,
     SQ_PERF_SEL_LEVEL_WAVES__GFX10PLUS                 = 0x00000007,
     SQ_PERF_SEL_ITEMS__GFX10PLUS                       = 0x00000008,
     SQ_PERF_SEL_WAVE32_ITEMS__GFX10PLUS                = 0x00000009,
     SQ_PERF_SEL_WAVE64_ITEMS__GFX10PLUS                = 0x0000000a,
     SQ_PERF_SEL_EVENTS__GFX10PLUS                      = 0x0000000c,
     SQ_PERF_SEL_MSG_INTERRUPT__GFX10PLUS               = 0x00000016,
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     SQC_PERF_SEL_DUMMY_LAST__GFX10VRS                  = 0x000001a3,
 #endif
+#if CHIP_HDR_NAVI31
+    SQ_PERF_SEL_PS_QUADS__GFX11                        = 0x0000000b,
+    SQ_PERF_SEL_WAVES_EQ_32__GFX11                     = 0x0000000d,
+    SQ_PERF_SEL_WAVES_EQ_64__GFX11                     = 0x0000000e,
+    SQ_PERF_SEL_WAVES_LT_64__GFX11                     = 0x0000000f,
+    SQ_PERF_SEL_WAVES_LT_48__GFX11                     = 0x00000010,
+    SQ_PERF_SEL_WAVES_LT_32__GFX11                     = 0x00000011,
+    SQ_PERF_SEL_WAVES_LT_16__GFX11                     = 0x00000012,
+    SQ_PERF_SEL_WAVES_RESTORED__GFX11                  = 0x00000013,
+    SQ_PERF_SEL_WAVES_SAVED__GFX11                     = 0x00000014,
+    SQ_PERF_SEL_MSG__GFX11                             = 0x00000015,
+    SQ_PERF_SEL_WAVE_CYCLES__GFX11                     = 0x00000018,
+    SQ_PERF_SEL_WAVE_READY__GFX11                      = 0x00000019,
+    SQ_PERF_SEL_WAIT_INST_ANY__GFX11                   = 0x0000001a,
+    SQ_PERF_SEL_WAIT_INST_VALU__GFX11                  = 0x0000001b,
+    SQ_PERF_SEL_WAIT_INST_SCA__GFX11                   = 0x0000001c,
+    SQ_PERF_SEL_WAIT_INST_LDS__GFX11                   = 0x0000001d,
+    SQ_PERF_SEL_WAIT_INST_TEX__GFX11                   = 0x0000001e,
+    SQ_PERF_SEL_WAIT_INST_FLAT__GFX11                  = 0x0000001f,
+    SQ_PERF_SEL_WAIT_INST_VMEM__GFX11                  = 0x00000020,
+    SQ_PERF_SEL_WAIT_INST_EXP_GDS__GFX11               = 0x00000021,
+    SQ_PERF_SEL_WAIT_INST_BR_MSG__GFX11                = 0x00000022,
+    SQ_PERF_SEL_WAIT_ANY__GFX11                        = 0x00000023,
+    SQ_PERF_SEL_WAIT_CNT_ANY__GFX11                    = 0x00000024,
+    SQ_PERF_SEL_WAIT_CNT_VMVS__GFX11                   = 0x00000025,
+    SQ_PERF_SEL_WAIT_CNT_LGKM__GFX11                   = 0x00000026,
+    SQ_PERF_SEL_WAIT_CNT_EXP__GFX11                    = 0x00000027,
+    SQ_PERF_SEL_WAIT_TTRACE__GFX11                     = 0x00000028,
+    SQ_PERF_SEL_WAIT_IFETCH__GFX11                     = 0x00000029,
+    SQ_PERF_SEL_WAIT_BARRIER__GFX11                    = 0x0000002a,
+    SQ_PERF_SEL_WAIT_EXP_ALLOC__GFX11                  = 0x0000002b,
+    SQ_PERF_SEL_WAIT_SLEEP__GFX11                      = 0x0000002c,
+    SQ_PERF_SEL_WAIT_DELAY_ALU__GFX11                  = 0x0000002d,
+    SQ_PERF_SEL_WAIT_DEPCTR__GFX11                     = 0x0000002e,
+    SQ_PERF_SEL_WAIT_OTHER__GFX11                      = 0x0000002f,
+    SQ_PERF_SEL_INSTS_ALL__GFX11                       = 0x00000030,
+    SQ_PERF_SEL_INSTS_BRANCH__GFX11                    = 0x00000031,
+    SQ_PERF_SEL_INSTS_CBRANCH_NOT_TAKEN__GFX11         = 0x00000032,
+    SQ_PERF_SEL_INSTS_CBRANCH_TAKEN__GFX11             = 0x00000033,
+    SQ_PERF_SEL_INSTS_CBRANCH_TAKEN_HIT_IS__GFX11      = 0x00000034,
+    SQ_PERF_SEL_INSTS_EXP_GDS__GFX11                   = 0x00000035,
+    SQ_PERF_SEL_INSTS_GDS__GFX11                       = 0x00000036,
+    SQ_PERF_SEL_INSTS_EXP__GFX11                       = 0x00000037,
+    SQ_PERF_SEL_INSTS_FLAT__GFX11                      = 0x00000038,
+    SQ_PERF_SEL_INSTS_LDS__GFX11                       = 0x00000039,
+    SQ_PERF_SEL_INSTS_SALU__GFX11                      = 0x0000003a,
+    SQ_PERF_SEL_INSTS_SMEM__GFX11                      = 0x0000003b,
+    SQ_PERF_SEL_INSTS_SMEM_NORM__GFX11                 = 0x0000003c,
+    SQ_PERF_SEL_INSTS_SENDMSG__GFX11                   = 0x0000003d,
+    SQ_PERF_SEL_INSTS_VALU__GFX11                      = 0x0000003e,
+    SQ_PERF_SEL_INSTS_VALU_TRANS32__GFX11              = 0x0000003f,
+    SQ_PERF_SEL_INSTS_VALU_NO_COEXEC__GFX11            = 0x00000040,
+    SQ_PERF_SEL_INSTS_TEX__GFX11                       = 0x00000041,
+    SQ_PERF_SEL_INSTS_TEX_LOAD__GFX11                  = 0x00000042,
+    SQ_PERF_SEL_INSTS_TEX_STORE__GFX11                 = 0x00000043,
+    SQ_PERF_SEL_INSTS_DELAY_ALU__GFX11                 = 0x00000044,
+    SQ_PERF_SEL_INSTS_INTERNAL__GFX11                  = 0x00000045,
+    SQ_PERF_SEL_INSTS_WAVE32__GFX11                    = 0x00000046,
+    SQ_PERF_SEL_INSTS_WAVE32_FLAT__GFX11               = 0x00000047,
+    SQ_PERF_SEL_INSTS_WAVE32_LDS__GFX11                = 0x00000048,
+    SQ_PERF_SEL_INSTS_WAVE32_VALU__GFX11               = 0x00000049,
+    SQ_PERF_SEL_WAVE32_INSTS_EXP_GDS__GFX11            = 0x0000004a,
+    SQ_PERF_SEL_INSTS_WAVE32_VALU_TRANS32__GFX11       = 0x0000004b,
+    SQ_PERF_SEL_INSTS_WAVE32_VALU_NO_COEXEC__GFX11     = 0x0000004c,
+    SQ_PERF_SEL_INSTS_WAVE32_TEX__GFX11                = 0x0000004d,
+    SQ_PERF_SEL_INSTS_WAVE32_TEX_LOAD__GFX11           = 0x0000004e,
+    SQ_PERF_SEL_INSTS_WAVE32_TEX_STORE__GFX11          = 0x0000004f,
+    SQ_PERF_SEL_ITEM_CYCLES_VALU__GFX11                = 0x00000050,
+    SQ_PERF_SEL_VALU_READWRITELANE_CYCLES__GFX11       = 0x00000051,
+    SQ_PERF_SEL_WAVE32_INSTS__GFX11                    = 0x00000052,
+    SQ_PERF_SEL_WAVE64_INSTS__GFX11                    = 0x00000053,
+    SQ_PERF_SEL_INSTS_VALU_EXEC_SKIPPED__GFX11         = 0x00000054,
+    SQ_PERF_SEL_WAVE64_HALF_SKIP__GFX11                = 0x00000055,
+    SQ_PERF_SEL_INST_LEVEL_EXP__GFX11                  = 0x00000056,
+    SQ_PERF_SEL_INST_LEVEL_GDS__GFX11                  = 0x00000057,
+    SQ_PERF_SEL_INST_LEVEL_LDS__GFX11                  = 0x00000058,
+    SQ_PERF_SEL_INST_LEVEL_SMEM__GFX11                 = 0x00000059,
+    SQ_PERF_SEL_INST_LEVEL_TEX_LOAD__GFX11             = 0x0000005a,
+    SQ_PERF_SEL_INST_LEVEL_TEX_STORE__GFX11            = 0x0000005b,
+    SQ_PERF_SEL_IFETCH_REQS__GFX11                     = 0x0000005c,
+    SQ_PERF_SEL_IFETCH_LEVEL__GFX11                    = 0x0000005d,
+    SQ_PERF_SEL_LDS_DIRECT_CMD_FIFO_FULL_STALL__GFX11  = 0x0000005e,
+    SQ_PERF_SEL_VALU_SGATHER_STALL__GFX11              = 0x0000005f,
+    SQ_PERF_SEL_VALU_FWD_BUFFER_FULL_STALL__GFX11      = 0x00000060,
+    SQ_PERF_SEL_VALU_SGPR_RD_FIFO_FULL_STALL__GFX11    = 0x00000061,
+    SQ_PERF_SEL_VALU_SGATHER_FULL_STALL__GFX11         = 0x00000062,
+    SQ_PERF_SEL_SALU_SGATHER_STALL__GFX11              = 0x00000063,
+    SQ_PERF_SEL_SALU_SGPR_RD_FIFO_FULL_STALL__GFX11    = 0x00000064,
+    SQ_PERF_SEL_SALU_GATHER_FULL_STALL__GFX11          = 0x00000065,
+    SQ_PERF_SEL_SMEM_DCACHE_FIFO_FULL_STALL__GFX11     = 0x00000066,
+    SQ_PERF_SEL_INST_CYCLES_VALU__GFX11                = 0x00000067,
+    SQ_PERF_SEL_INST_CYCLES_VALU_TRANS32__GFX11        = 0x00000068,
+    SQ_PERF_SEL_INST_CYCLES_VALU_NO_COEXEC__GFX11      = 0x00000069,
+    SQ_PERF_SEL_INST_CYCLES_VMEM__GFX11                = 0x0000006a,
+    SQ_PERF_SEL_INST_CYCLES_VMEM_LOAD__GFX11           = 0x0000006b,
+    SQ_PERF_SEL_INST_CYCLES_VMEM_STORE__GFX11          = 0x0000006c,
+    SQ_PERF_SEL_INST_CYCLES_LDS__GFX11                 = 0x0000006d,
+    SQ_PERF_SEL_INST_CYCLES_TEX__GFX11                 = 0x0000006e,
+    SQ_PERF_SEL_INST_CYCLES_FLAT__GFX11                = 0x0000006f,
+    SQ_PERF_SEL_INST_CYCLES_EXP_GDS__GFX11             = 0x00000070,
+    SQ_PERF_SEL_INST_CYCLES_EXP__GFX11                 = 0x00000071,
+    SQ_PERF_SEL_INST_CYCLES_GDS__GFX11                 = 0x00000072,
+    SQ_PERF_SEL_VALU_STARVE__GFX11                     = 0x00000073,
+    SQ_PERF_SEL_VMEM_ARB_FIFO_FULL__GFX11              = 0x00000074,
+    SQ_PERF_SEL_MSG_FIFO_FULL_STALL__GFX11             = 0x00000075,
+    SQ_PERF_SEL_EXP_REQ_FIFO_FULL__GFX11               = 0x00000076,
+    SQ_PERF_SEL_VMEM_BUS_ACTIVE__GFX11                 = 0x00000077,
+    SQ_PERF_SEL_VMEM_BUS_STALL__GFX11                  = 0x00000078,
+    SQ_PERF_SEL_VMEM_BUS_STALL_TA_ADDR_FIFO_FULL__GFX11 = 0x00000079,
+    SQ_PERF_SEL_VMEM_BUS_STALL_TA_CMD_FIFO_FULL__GFX11 = 0x0000007a,
+    SQ_PERF_SEL_VMEM_BUS_STALL_LDS_ADDR_FIFO_FULL__GFX11 = 0x0000007b,
+    SQ_PERF_SEL_VMEM_BUS_STALL_LDS_CMD_FIFO_FULL__GFX11 = 0x0000007c,
+    SQ_PERF_SEL_VMEM_STARVE_TA_ADDR_EMPTY__GFX11       = 0x0000007d,
+    SQ_PERF_SEL_VMEM_STARVE_LDS_ADDR_EMPTY__GFX11      = 0x0000007e,
+    SQ_PERF_SEL_SALU_PIPE_STALL__GFX11                 = 0x0000007f,
+    SQ_PERF_SEL_SMEM_DCACHE_RETURN_CYCLES__GFX11       = 0x00000080,
+    SQ_PERF_SEL_MSG_BUS_BUSY__GFX11                    = 0x00000081,
+    SQ_PERF_SEL_EXP_REQ_BUS_STALL__GFX11               = 0x00000082,
+    SQ_PERF_SEL_EXP_REQ0_BUS_BUSY__GFX11               = 0x00000083,
+    SQ_PERF_SEL_EXP_REQ1_BUS_BUSY__GFX11               = 0x00000084,
+    SQ_PERF_SEL_EXP_BUS0_BUSY__GFX11                   = 0x00000085,
+    SQ_PERF_SEL_EXP_BUS1_BUSY__GFX11                   = 0x00000086,
+    SQ_PERF_SEL_INST_CACHE_REQ_STALL__GFX11            = 0x00000087,
+    SQ_PERF_SEL_USER0__GFX11                           = 0x00000088,
+    SQ_PERF_SEL_USER1__GFX11                           = 0x00000089,
+    SQ_PERF_SEL_USER2__GFX11                           = 0x0000008a,
+    SQ_PERF_SEL_USER3__GFX11                           = 0x0000008b,
+    SQ_PERF_SEL_USER4__GFX11                           = 0x0000008c,
+    SQ_PERF_SEL_USER5__GFX11                           = 0x0000008d,
+    SQ_PERF_SEL_USER6__GFX11                           = 0x0000008e,
+    SQ_PERF_SEL_USER7__GFX11                           = 0x0000008f,
+    SQ_PERF_SEL_USER8__GFX11                           = 0x00000090,
+    SQ_PERF_SEL_USER9__GFX11                           = 0x00000091,
+    SQ_PERF_SEL_USER10__GFX11                          = 0x00000092,
+    SQ_PERF_SEL_USER11__GFX11                          = 0x00000093,
+    SQ_PERF_SEL_USER12__GFX11                          = 0x00000094,
+    SQ_PERF_SEL_USER13__GFX11                          = 0x00000095,
+    SQ_PERF_SEL_USER14__GFX11                          = 0x00000096,
+    SQ_PERF_SEL_USER15__GFX11                          = 0x00000097,
+    SQ_PERF_SEL_USER_LEVEL0__GFX11                     = 0x00000098,
+    SQ_PERF_SEL_USER_LEVEL1__GFX11                     = 0x00000099,
+    SQ_PERF_SEL_USER_LEVEL2__GFX11                     = 0x0000009a,
+    SQ_PERF_SEL_USER_LEVEL3__GFX11                     = 0x0000009b,
+    SQ_PERF_SEL_USER_LEVEL4__GFX11                     = 0x0000009c,
+    SQ_PERF_SEL_USER_LEVEL5__GFX11                     = 0x0000009d,
+    SQ_PERF_SEL_USER_LEVEL6__GFX11                     = 0x0000009e,
+    SQ_PERF_SEL_USER_LEVEL7__GFX11                     = 0x0000009f,
+    SQ_PERF_SEL_USER_LEVEL8__GFX11                     = 0x000000a0,
+    SQ_PERF_SEL_USER_LEVEL9__GFX11                     = 0x000000a1,
+    SQ_PERF_SEL_USER_LEVEL10__GFX11                    = 0x000000a2,
+    SQ_PERF_SEL_USER_LEVEL11__GFX11                    = 0x000000a3,
+    SQ_PERF_SEL_USER_LEVEL12__GFX11                    = 0x000000a4,
+    SQ_PERF_SEL_USER_LEVEL13__GFX11                    = 0x000000a5,
+    SQ_PERF_SEL_USER_LEVEL14__GFX11                    = 0x000000a6,
+    SQ_PERF_SEL_USER_LEVEL15__GFX11                    = 0x000000a7,
+    SQ_PERF_SEL_VALU_RETURN_SDST__GFX11                = 0x000000a8,
+    SQ_PERF_SEL_VMEM_VGPR_READ_STALLED_BY_EXPORT__GFX11 = 0x000000a9,
+    SQ_PERF_SEL_INSTS_VALU_TRANS__GFX11                = 0x000000aa,
+    SQ_PERF_SEL_INSTS_LDS_DIRECT_LOAD__GFX11           = 0x000000ab,
+    SQ_PERF_SEL_INSTS_LDS_PARAM_LOAD__GFX11            = 0x000000ac,
+    SQ_PERF_SEL_INSTS_WAVE32_LDS_PARAM_LOAD__GFX11     = 0x000000ad,
+    SQ_PERF_SEL_INSTS_VALU_ONE_CYCLE_WAVE64__GFX11     = 0x000000ae,
+    SQ_PERF_SEL_INSTS_VALU_VINTERP__GFX11              = 0x000000af,
+    SQ_PERF_SEL_INSTS_VALU_WAVE32_VINTERP__GFX11       = 0x000000b0,
+    SQ_PERF_SEL_OVERFLOW_PREV__GFX11                   = 0x000000b1,
+    SQ_PERF_SEL_INSTS_DUAL_VALU_WAVE32__GFX11          = 0x000000b2,
+    SQ_PERF_SEL_INSTS_VALU_1_PASS__GFX11               = 0x000000b3,
+    SQ_PERF_SEL_INSTS_VALU_2_PASS__GFX11               = 0x000000b4,
+    SQ_PERF_SEL_INSTS_VALU_4_PASS__GFX11               = 0x000000b5,
+    SQ_PERF_SEL_INSTS_VALU_DP__GFX11                   = 0x000000b6,
+    SQ_PERF_SEL_SP_CONST_CYCLES__GFX11                 = 0x000000b7,
+    SQ_PERF_SEL_SP_CONST_STALL_CYCLES__GFX11           = 0x000000b8,
+    SQ_PERF_SEL_ITEMS_VALU__GFX11                      = 0x000000b9,
+    SQ_PERF_SEL_ITEMS_MAX_VALU__GFX11                  = 0x000000ba,
+    SQ_PERF_SEL_ITEM_CYCLES_VMEM__GFX11                = 0x000000bb,
+    SQ_PERF_SEL_INSTS_DELAY_ALU_COISSUE__GFX11         = 0x000000bc,
+    SQ_PERF_SEL_INSTS_FLAT_LOAD__GFX11                 = 0x000000bd,
+    SQ_PERF_SEL_INSTS_FLAT_STORE__GFX11                = 0x000000be,
+    SQ_PERF_SEL_INSTS_VALU_ONE_CYCLE_WAVE64_16BIT__GFX11 = 0x000000bf,
+    SQ_PERF_SEL_INSTS_VALU_ONE_CYCLE_WAVE64_32BIT__GFX11 = 0x000000c0,
+    SQ_PERF_SEL_INSTS_NON_VALU_EXEC_SKIPPED__GFX11     = 0x000000c1,
+    SQ_PERF_SEL_INSTS_BARRIER__GFX11                   = 0x000000c2,
+    SQ_PERF_SEL_INSTS_WAKEUP__GFX11                    = 0x000000c3,
+    SQ_PERF_SEL_DUMMY_END__GFX11                       = 0x000000c4,
+    SQC_PERF_SEL_LDS_BANK_CONFLICT__GFX11              = 0x00000100,
+    SQC_PERF_SEL_LDS_ADDR_CONFLICT__GFX11              = 0x00000101,
+    SQC_PERF_SEL_LDS_UNALIGNED_STALL__GFX11            = 0x00000102,
+    SQC_PERF_SEL_LDS_MEM_VIOLATIONS__GFX11             = 0x00000103,
+    SQC_PERF_SEL_LDS_ATOMIC_RETURN__GFX11              = 0x00000104,
+    SQC_PERF_SEL_LDS_IDX_ACTIVE__GFX11                 = 0x00000105,
+    SQC_PERF_SEL_LDS_ADDR_STALL__GFX11                 = 0x00000106,
+    SQC_PERF_SEL_LDS_ADDR_ACTIVE__GFX11                = 0x00000107,
+    SQC_PERF_SEL_LDS_PC_LDS_WRITE_STALL_TD__GFX11      = 0x00000108,
+    SQC_PERF_SEL_LDS_SPI_VGPR_WRITE_STALL_TD__GFX11    = 0x00000109,
+    SQC_PERF_SEL_LDS_LDS_VGPR_WRITE_STALL__GFX11       = 0x0000010a,
+    SQC_PERF_SEL_LDS_FP_ADD_CYCLES__GFX11              = 0x0000010b,
+    SQC_PERF_SEL_ICACHE_BUSY_CYCLES__GFX11             = 0x0000010c,
+    SQC_PERF_SEL_ICACHE_REQ__GFX11                     = 0x0000010d,
+    SQC_PERF_SEL_ICACHE_HITS__GFX11                    = 0x0000010e,
+    SQC_PERF_SEL_ICACHE_MISSES__GFX11                  = 0x0000010f,
+    SQC_PERF_SEL_ICACHE_MISSES_DUPLICATE__GFX11        = 0x00000110,
+    SQC_PERF_SEL_ICACHE_INVAL_INST__GFX11              = 0x00000111,
+    SQC_PERF_SEL_ICACHE_INVAL_ASYNC__GFX11             = 0x00000112,
+    SQC_PERF_SEL_ICACHE_INFLIGHT_LEVEL__GFX11          = 0x00000113,
+    SQC_PERF_SEL_DCACHE_INFLIGHT_LEVEL__GFX11          = 0x00000114,
+    SQC_PERF_SEL_TC_INFLIGHT_LEVEL__GFX11              = 0x00000115,
+    SQC_PERF_SEL_ICACHE_TC_INFLIGHT_LEVEL__GFX11       = 0x00000116,
+    SQC_PERF_SEL_DCACHE_TC_INFLIGHT_LEVEL__GFX11       = 0x00000117,
+    SQC_PERF_SEL_ICACHE_INPUT_VALID_READYB__GFX11      = 0x00000118,
+    SQC_PERF_SEL_DCACHE_INPUT_VALID_READYB__GFX11      = 0x00000119,
+    SQC_PERF_SEL_TC_REQ__GFX11                         = 0x0000011a,
+    SQC_PERF_SEL_TC_INST_REQ__GFX11                    = 0x0000011b,
+    SQC_PERF_SEL_TC_DATA_READ_REQ__GFX11               = 0x0000011c,
+    SQC_PERF_SEL_TC_STALL__GFX11                       = 0x0000011d,
+    SQC_PERF_SEL_TC_STARVE__GFX11                      = 0x0000011e,
+    SQC_PERF_SEL_ICACHE_INPUT_STALL_ARB_NO_GRANT__GFX11 = 0x0000011f,
+    SQC_PERF_SEL_ICACHE_INPUT_STALL_BANK_READYB__GFX11 = 0x00000120,
+    SQC_PERF_SEL_ICACHE_CACHE_STALLED__GFX11           = 0x00000121,
+    SQC_PERF_SEL_ICACHE_CACHE_STALL_INFLIGHT_MAX__GFX11 = 0x00000122,
+    SQC_PERF_SEL_ICACHE_STALL_OUTXBAR_ARB_NO_GRANT__GFX11 = 0x00000123,
+    SQC_PERF_SEL_DCACHE_BUSY_CYCLES__GFX11             = 0x00000124,
+    SQC_PERF_SEL_DCACHE_REQ__GFX11                     = 0x00000125,
+    SQC_PERF_SEL_DCACHE_HITS__GFX11                    = 0x00000126,
+    SQC_PERF_SEL_DCACHE_MISSES__GFX11                  = 0x00000127,
+    SQC_PERF_SEL_DCACHE_MISSES_DUPLICATE__GFX11        = 0x00000128,
+    SQC_PERF_SEL_DCACHE_INVAL_INST__GFX11              = 0x00000129,
+    SQC_PERF_SEL_DCACHE_INVAL_ASYNC__GFX11             = 0x0000012a,
+    SQC_PERF_SEL_DCACHE_HIT_LRU_READ__GFX11            = 0x0000012b,
+    SQC_PERF_SEL_DCACHE_INPUT_STALL_ARB_NO_GRANT__GFX11 = 0x0000012c,
+    SQC_PERF_SEL_DCACHE_INPUT_STALL_BANK_READYB__GFX11 = 0x0000012d,
+    SQC_PERF_SEL_DCACHE_CACHE_STALLED__GFX11           = 0x0000012e,
+    SQC_PERF_SEL_DCACHE_CACHE_STALL_INFLIGHT_MAX__GFX11 = 0x0000012f,
+    SQC_PERF_SEL_DCACHE_CACHE_STALL_OUTPUT__GFX11      = 0x00000130,
+    SQC_PERF_SEL_DCACHE_STALL_OUTXBAR_ARB_NO_GRANT__GFX11 = 0x00000131,
+    SQC_PERF_SEL_DCACHE_REQ_READ_1__GFX11              = 0x00000132,
+    SQC_PERF_SEL_DCACHE_REQ_READ_2__GFX11              = 0x00000133,
+    SQC_PERF_SEL_DCACHE_REQ_READ_4__GFX11              = 0x00000134,
+    SQC_PERF_SEL_DCACHE_REQ_READ_8__GFX11              = 0x00000135,
+    SQC_PERF_SEL_DCACHE_REQ_READ_16__GFX11             = 0x00000136,
+    SQC_PERF_SEL_DCACHE_REQ_ATC_PROBE__GFX11           = 0x00000137,
+    SQC_PERF_SEL_SQ_DCACHE_REQS__GFX11                 = 0x00000138,
+    SQC_PERF_SEL_DCACHE_FLAT_REQ__GFX11                = 0x00000139,
+    SQC_PERF_SEL_TD_VGPR_BUSY__GFX11                   = 0x0000013a,
+    SQC_PERF_SEL_LDS_VGPR_BUSY__GFX11                  = 0x0000013b,
+    SQC_PERF_SEL_LDS_TD_VGPR_CONF_STALL__GFX11         = 0x0000013c,
+    SQC_PERF_SEL_ICACHE_GCR__GFX11                     = 0x0000013d,
+    SQC_PERF_SEL_ICACHE_GCR_HITS__GFX11                = 0x0000013e,
+    SQC_PERF_SEL_DCACHE_GCR__GFX11                     = 0x0000013f,
+    SQC_PERF_SEL_DCACHE_GCR_HITS__GFX11                = 0x00000140,
+    SQC_PERF_SEL_ICACHE_GCR_INVALIDATE__GFX11          = 0x00000141,
+    SQC_PERF_SEL_DCACHE_GCR_INVALIDATE__GFX11          = 0x00000142,
+    SQC_PERF_SEL_DCACHE_SPI_RETURN_STALL__GFX11        = 0x00000143,
+    SQC_PERF_SEL_DUMMY_LAST__GFX11                     = 0x00000144,
+    SP_PERF_SEL_DST_BUF_ALLOC_STALL__GFX11             = 0x000001c0,
+    SP_PERF_SEL_DST_BUF_WB_CONF_W_TD_LDS__GFX11        = 0x000001c1,
+    SP_PERF_SEL_DST_BUF_WB_CONF_W_SPI__GFX11           = 0x000001c2,
+    SP_PERF_SEL_DST_BUF_EVEN_DIRTY__GFX11              = 0x000001c3,
+    SP_PERF_SEL_DST_BUF_ODD_DIRTY__GFX11               = 0x000001c4,
+    SP_PERF_SEL_SRC_CACHE_HIT_B0__GFX11                = 0x000001c5,
+    SP_PERF_SEL_SRC_CACHE_HIT_B1__GFX11                = 0x000001c6,
+    SP_PERF_SEL_SRC_CACHE_HIT_B2__GFX11                = 0x000001c7,
+    SP_PERF_SEL_SRC_CACHE_HIT_B3__GFX11                = 0x000001c8,
+    SP_PERF_SEL_SRC_CACHE_PROBE_B0__GFX11              = 0x000001c9,
+    SP_PERF_SEL_SRC_CACHE_PROBE_B1__GFX11              = 0x000001ca,
+    SP_PERF_SEL_SRC_CACHE_PROBE_B2__GFX11              = 0x000001cb,
+    SP_PERF_SEL_SRC_CACHE_PROBE_B3__GFX11              = 0x000001cc,
+    SP_PERF_SEL_SRC_CACHE_VGPR_RD_B0__GFX11            = 0x000001cd,
+    SP_PERF_SEL_SRC_CACHE_VGPR_RD_B1__GFX11            = 0x000001ce,
+    SP_PERF_SEL_SRC_CACHE_VGPR_RD_B2__GFX11            = 0x000001cf,
+    SP_PERF_SEL_SRC_CACHE_VGPR_RD_B3__GFX11            = 0x000001d0,
+    SP_PERF_SEL_SRC_CACHE_RECYCLE_HIT_B0__GFX11        = 0x000001d1,
+    SP_PERF_SEL_SRC_CACHE_RECYCLE_HIT_B1__GFX11        = 0x000001d2,
+    SP_PERF_SEL_SRC_CACHE_RECYCLE_HIT_B2__GFX11        = 0x000001d3,
+    SP_PERF_SEL_SRC_CACHE_RECYCLE_HIT_B3__GFX11        = 0x000001d4,
+    SP_PERF_SEL_SRC_CACHE_PROBE_SUCCESS_B0__GFX11      = 0x000001d5,
+    SP_PERF_SEL_SRC_CACHE_PROBE_SUCCESS_B1__GFX11      = 0x000001d6,
+    SP_PERF_SEL_SRC_CACHE_PROBE_SUCCESS_B2__GFX11      = 0x000001d7,
+    SP_PERF_SEL_SRC_CACHE_PROBE_SUCCESS_B3__GFX11      = 0x000001d8,
+    SP_PERF_SEL_VALU_PENDING_QUEUE_STALL__GFX11        = 0x000001d9,
+    SP_PERF_SEL_VALU_OPERAND__GFX11                    = 0x000001da,
+    SP_PERF_SEL_VALU_VGPR_OPERAND__GFX11               = 0x000001db,
+    SP_PERF_SEL_VALU_OPERAND_FROM_DST_BUF__GFX11       = 0x000001dc,
+    SP_PERF_SEL_VALU_EXEC_MASK_CHANGE__GFX11           = 0x000001dd,
+    SP_PERF_SEL_VALU_COEXEC_WITH_TRANS__GFX11          = 0x000001de,
+    SP_PERF_SEL_VALU_SGPR_FWD_BUF_FULL__GFX11          = 0x000001df,
+    SP_PERF_SEL_VALU_STALL__GFX11                      = 0x000001e0,
+    SP_PERF_SEL_VALU_STALL_VGPR_NOT_READY__GFX11       = 0x000001e1,
+    SP_PERF_SEL_VALU_STALL_SGPR_NOT_READY__GFX11       = 0x000001e2,
+    SP_PERF_SEL_VALU_STALL_VDST_FWD__GFX11             = 0x000001e3,
+    SP_PERF_SEL_VALU_STALL_SDST_FWD__GFX11             = 0x000001e4,
+    SP_PERF_SEL_VALU_STALL_DST_STALL__GFX11            = 0x000001e5,
+    SP_PERF_SEL_VALU_FAST_OP_STALL_VGPR_NOT_READY__GFX11 = 0x000001e6,
+    SP_PERF_SEL_VGPR_VMEM_RD__GFX11                    = 0x000001e7,
+    SP_PERF_SEL_VGPR_EXP_RD__GFX11                     = 0x000001e8,
+    SP_PERF_SEL_VGPR_SPI_WR__GFX11                     = 0x000001e9,
+    SP_PERF_SEL_VGPR_TDLDS_DATA_WR__GFX11              = 0x000001ea,
+    SP_PERF_SEL_VGPR_WR__GFX11                         = 0x000001eb,
+    SP_PERF_SEL_VGPR_RD__GFX11                         = 0x000001ec,
+    SP_PERF_SEL_DUMMY_LAST__GFX11                      = 0x000001ed,
+#endif
 } SQ_PERF_SEL;
 
 constexpr unsigned int MaxSqPerfSelGfx09               = SQC_PERF_SEL_DUMMY_LAST__GFX09;
 constexpr unsigned int MaxSqPerfSelGfx10Core           = SP_PERF_SEL_DUMMY_LAST__GFX10CORE;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxSqPerfSelGfx104Plus          = SQ_PERF_SEL_NONE2__GFX104PLUS;
+#endif
 
 typedef enum SQ_RSRC_BUF_TYPE {
     SQ_RSRC_BUF                                        = 0x00000000,
     SQ_RSRC_BUF_RSVD_1                                 = 0x00000001,
     SQ_RSRC_BUF_RSVD_2                                 = 0x00000002,
     SQ_RSRC_BUF_RSVD_3                                 = 0x00000003,
 } SQ_RSRC_BUF_TYPE;
 
 typedef enum SQ_RSRC_FLAT_TYPE {
     SQ_RSRC_FLAT_RSVD_0                                = 0x00000000,
@@ -10255,73 +13265,85 @@ typedef enum SQ_TT_RT_FREQ {
 typedef enum SQ_TT_TOKEN_MASK_INST_EXCLUDE {
     SQ_TT_INST_EXCLUDE_VMEM_OTHER_SIMD_BIT             = 0x00000001,
     SQ_TT_INST_EXCLUDE_EXPGNT234_BIT                   = 0x00000002,
 } SQ_TT_TOKEN_MASK_INST_EXCLUDE;
 
 typedef enum SQ_TT_TOKEN_MASK_INST_EXCLUDE_SHIFT {
     SQ_TT_INST_EXCLUDE_VMEM_OTHER_SIMD_SHIFT           = 0x00000000,
     SQ_TT_INST_EXCLUDE_EXPGNT234_SHIFT                 = 0x00000001,
 } SQ_TT_TOKEN_MASK_INST_EXCLUDE_SHIFT;
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef enum SQ_TT_TOKEN_MASK_REG_EXCLUDE {
     SQ_TT_REG_EXCLUDE_USER_DATA_BIT                    = 0x00000001,
     SQ_TT_REG_EXCLUDE_CP_ME_MC_RADDR_BIT               = 0x00000002,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SQ_TT_REG_EXCLUDE_GRBM_COMPUTE_EXCLUDE_BIT__GFX103PLUSEXCLUSIVE = 0x00000004,
 #endif
 } SQ_TT_TOKEN_MASK_REG_EXCLUDE;
 
 typedef enum SQ_TT_TOKEN_MASK_REG_EXCLUDE_SHIFT {
     SQ_TT_REG_EXCLUDE_USER_DATA_SHIFT                  = 0x00000000,
     SQ_TT_REG_EXCLUDE_CP_ME_MC_RADDR_SHIFT             = 0x00000001,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SQ_TT_REG_EXCLUDE_GRBM_COMPUTE_EXCLUDE_SHIFT__GFX103PLUSEXCLUSIVE = 0x00000002,
 #endif
 } SQ_TT_TOKEN_MASK_REG_EXCLUDE_SHIFT;
 #endif
 
 typedef enum SQ_TT_TOKEN_MASK_REG_INCLUDE {
     SQ_TT_TOKEN_MASK_SQDEC_BIT                         = 0x00000001,
     SQ_TT_TOKEN_MASK_SHDEC_BIT                         = 0x00000002,
     SQ_TT_TOKEN_MASK_GFXUDEC_BIT                       = 0x00000004,
     SQ_TT_TOKEN_MASK_COMP_BIT                          = 0x00000008,
     SQ_TT_TOKEN_MASK_CONTEXT_BIT                       = 0x00000010,
     SQ_TT_TOKEN_MASK_CONFIG_BIT                        = 0x00000020,
     SQ_TT_TOKEN_MASK_READS_BIT__GFX10                  = 0x00000080,
+#if CHIP_HDR_NAVI31
+    SQ_TT_TOKEN_MASK_ALL_BIT__GFX104PLUS               = 0x00000040,
+#endif
     SQ_TT_TOKEN_MASK_OTHER_BIT__GFX10CORE              = 0x00000040,
+#if CHIP_HDR_NAVI31
+    SQ_TT_TOKEN_MASK_RSVD_BIT__GFX11                   = 0x00000080,
+#endif
 } SQ_TT_TOKEN_MASK_REG_INCLUDE;
 
 typedef enum SQ_TT_TOKEN_MASK_REG_INCLUDE_SHIFT {
     SQ_TT_TOKEN_MASK_SQDEC_SHIFT                       = 0x00000000,
     SQ_TT_TOKEN_MASK_SHDEC_SHIFT                       = 0x00000001,
     SQ_TT_TOKEN_MASK_GFXUDEC_SHIFT                     = 0x00000002,
     SQ_TT_TOKEN_MASK_COMP_SHIFT                        = 0x00000003,
     SQ_TT_TOKEN_MASK_CONTEXT_SHIFT                     = 0x00000004,
     SQ_TT_TOKEN_MASK_CONFIG_SHIFT                      = 0x00000005,
     SQ_TT_TOKEN_MASK_READS_SHIFT__GFX10                = 0x00000007,
+#if CHIP_HDR_NAVI31
+    SQ_TT_TOKEN_MASK_ALL_SHIFT__GFX104PLUS             = 0x00000006,
+#endif
     SQ_TT_TOKEN_MASK_OTHER_SHIFT__GFX10CORE            = 0x00000006,
+#if CHIP_HDR_NAVI31
+    SQ_TT_TOKEN_MASK_RSVD_SHIFT__GFX11                 = 0x00000007,
+#endif
 } SQ_TT_TOKEN_MASK_REG_INCLUDE_SHIFT;
 
 typedef enum SQ_TT_TOKEN_MASK_TOKEN_EXCLUDE_SHIFT {
     SQ_TT_TOKEN_EXCLUDE_VMEMEXEC_SHIFT                 = 0x00000000,
     SQ_TT_TOKEN_EXCLUDE_ALUEXEC_SHIFT                  = 0x00000001,
     SQ_TT_TOKEN_EXCLUDE_VALUINST_SHIFT                 = 0x00000002,
     SQ_TT_TOKEN_EXCLUDE_WAVERDY_SHIFT                  = 0x00000003,
     SQ_TT_TOKEN_EXCLUDE_IMMEDIATE_SHIFT                = 0x00000005,
     SQ_TT_TOKEN_EXCLUDE_REG_SHIFT                      = 0x00000006,
     SQ_TT_TOKEN_EXCLUDE_EVENT_SHIFT                    = 0x00000007,
     SQ_TT_TOKEN_EXCLUDE_INST_SHIFT                     = 0x00000008,
     SQ_TT_TOKEN_EXCLUDE_UTILCTR_SHIFT                  = 0x00000009,
     SQ_TT_TOKEN_EXCLUDE_WAVEALLOC_SHIFT                = 0x0000000a,
     SQ_TT_TOKEN_EXCLUDE_IMMED1_SHIFT__GFX101           = 0x00000004,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SQ_TT_TOKEN_EXCLUDE_WAVESTARTEND_SHIFT__GFX103PLUSEXCLUSIVE = 0x00000004,
 #endif
     SQ_TT_TOKEN_EXCLUDE_PERF_SHIFT__GFX10COREPLUS      = 0x0000000b,
 } SQ_TT_TOKEN_MASK_TOKEN_EXCLUDE_SHIFT;
 
 typedef enum SQ_TT_UTIL_TIMER {
     SQ_TT_UTIL_TIMER_100_CLK                           = 0x00000000,
     SQ_TT_UTIL_TIMER_250_CLK                           = 0x00000001,
 } SQ_TT_UTIL_TIMER;
 
@@ -10330,32 +13352,46 @@ typedef enum SQ_TT_WAVESTART_MODE {
     SQ_TT_WAVESTART_MODE_ALLOC                         = 0x00000001,
     SQ_TT_WAVESTART_MODE_PBB_ID                        = 0x00000002,
 } SQ_TT_WAVESTART_MODE;
 
 typedef enum SQ_TT_WTYPE_INCLUDE {
     SQ_TT_WTYPE_INCLUDE_PS_BIT                         = 0x00000001,
     SQ_TT_WTYPE_INCLUDE_GS_BIT                         = 0x00000004,
     SQ_TT_WTYPE_INCLUDE_HS_BIT                         = 0x00000010,
     SQ_TT_WTYPE_INCLUDE_CS_BIT                         = 0x00000040,
     SQ_TT_WTYPE_INCLUDE_VS_BIT__GFX10                  = 0x00000002,
+#if CHIP_HDR_NAVI31
+    SQ_TT_WTYPE_INCLUDE_RSVD1_BIT__GFX104PLUS          = 0x00000008,
+    SQ_TT_WTYPE_INCLUDE_RSVD2_BIT__GFX104PLUS          = 0x00000020,
+#endif
     SQ_TT_WTYPE_INCLUDE_ES_BIT__GFX10CORE              = 0x00000008,
     SQ_TT_WTYPE_INCLUDE_LS_BIT__GFX10CORE              = 0x00000020,
+#if CHIP_HDR_NAVI31
+    SQ_TT_WTYPE_INCLUDE_RSVD0_BIT__GFX11               = 0x00000002,
+#endif
 } SQ_TT_WTYPE_INCLUDE;
 
 typedef enum SQ_TT_WTYPE_INCLUDE_SHIFT {
     SQ_TT_WTYPE_INCLUDE_PS_SHIFT                       = 0x00000000,
     SQ_TT_WTYPE_INCLUDE_GS_SHIFT                       = 0x00000002,
     SQ_TT_WTYPE_INCLUDE_HS_SHIFT                       = 0x00000004,
     SQ_TT_WTYPE_INCLUDE_CS_SHIFT                       = 0x00000006,
     SQ_TT_WTYPE_INCLUDE_VS_SHIFT__GFX10                = 0x00000001,
+#if CHIP_HDR_NAVI31
+    SQ_TT_WTYPE_INCLUDE_RSVD1_SHIFT__GFX104PLUS        = 0x00000003,
+    SQ_TT_WTYPE_INCLUDE_RSVD2_SHIFT__GFX104PLUS        = 0x00000005,
+#endif
     SQ_TT_WTYPE_INCLUDE_ES_SHIFT__GFX10CORE            = 0x00000003,
     SQ_TT_WTYPE_INCLUDE_LS_SHIFT__GFX10CORE            = 0x00000005,
+#if CHIP_HDR_NAVI31
+    SQ_TT_WTYPE_INCLUDE_RSVD0_SHIFT__GFX11             = 0x00000001,
+#endif
 } SQ_TT_WTYPE_INCLUDE_SHIFT;
 
 typedef enum StencilFormat {
     STENCIL_INVALID                                    = 0x00000000,
     STENCIL_8                                          = 0x00000001,
 } StencilFormat;
 
 typedef enum StencilOp {
     STENCIL_KEEP                                       = 0x00000000,
     STENCIL_ZERO                                       = 0x00000001,
@@ -10935,21 +13971,21 @@ typedef enum SU_PERFCNT_SEL {
     PERF_ENGG_CSB_SPI_DELAY_BIN13__GFX101              = 0x000000e2,
     PERF_ENGG_CSB_SPI_DELAY_BIN14__GFX101              = 0x000000e3,
     PERF_ENGG_CSB_SPI_DELAY_BIN15__GFX101              = 0x000000e4,
     PERF_ENGG_POS_REQ_STALLED_BY_FULL_CLIPV_FIFO__GFX101 = 0x00000109,
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     PERF_ENGG_INDEX_REQ_0_NEW_VERTS_THIS_PRIM__GFX103DERIVATIVE = 0x000000e1,
     PERF_ENGG_INDEX_REQ_1_NEW_VERTS_THIS_PRIM__GFX103DERIVATIVE = 0x000000e2,
     PERF_ENGG_INDEX_REQ_2_NEW_VERTS_THIS_PRIM__GFX103DERIVATIVE = 0x000000e3,
     PERF_ENGG_INDEX_REQ_3_NEW_VERTS_THIS_PRIM__GFX103DERIVATIVE = 0x000000e4,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     PERF_ENGG_CSB_PAYLOAD_INPUT_FIFO_FULL__GFX103PLUSEXCLUSIVE = 0x000000bc,
     PERF_ENGG_INDEX_REQ_NULL_REQUEST__GFX103PLUSEXCLUSIVE = 0x000000e0,
     PERF_ENGG_INDEX_RET_SXRX_NULL_DROPPER_STALLED_BY_FULL_PRIM_FIFO__GFX103PLUSEXCLUSIVE = 0x00000109,
     PERF_ENGG_BUSY__GFX103PLUSEXCLUSIVE                = 0x0000010a,
     PERF_CLIPSM_CULL_PRIMS_CNT__GFX103PLUSEXCLUSIVE    = 0x0000010b,
     PERF_PH_SEND_1_SC__GFX103PLUSEXCLUSIVE             = 0x0000010c,
     PERF_PH_SEND_2_SC__GFX103PLUSEXCLUSIVE             = 0x0000010d,
     PERF_PH_SEND_3_SC__GFX103PLUSEXCLUSIVE             = 0x0000010e,
     PERF_PH_SEND_4_SC__GFX103PLUSEXCLUSIVE             = 0x0000010f,
     PERF_OUTPUT_PRIM_1_SC__GFX103PLUSEXCLUSIVE         = 0x00000110,
@@ -10996,28 +14032,83 @@ typedef enum SU_PERFCNT_SEL {
     PERF_ENGG_INDEX_RET_SXRX_READING_QDWORD_2_VALID_PRIMS_PL__GFX10PLUS = 0x000000fa,
     PERF_ENGG_INDEX_RET_SXRX_READING_QDWORD_3_VALID_PRIMS_PL__GFX10PLUS = 0x000000fb,
     PERF_ENGG_INDEX_RET_SXRX_READING_QDWORD_4_VALID_PRIMS_PL__GFX10PLUS = 0x000000fc,
     PERF_ENGG_INDEX_PRIM_IF_STALLED_BY_FULL_FETCH_TO_PRIMIC_P_FIFO__GFX10PLUS = 0x00000102,
     PERF_ENGG_INDEX_PRIM_IF_STALLED_BY_FULL_FETCH_TO_PRIMIC_S_FIFO__GFX10PLUS = 0x00000103,
     PERF_ENGG_INDEX_PRIM_IF_STARVED_BY_NO_CSB__GFX10PLUS = 0x00000104,
     PERF_ENGG_INDEX_PRIM_IF_STARVED_BY_NO_PRIM__GFX10PLUS = 0x00000105,
     PERF_ENGG_INDEX_PRIM_IF_FETCH_TO_PRIMIC_P_FIFO_WRITE__GFX10PLUS = 0x00000106,
     PERF_ENGG_INDEX_PRIM_IF_FETCH_TO_PRIMIC_P_FIFO_NO_WRITE__GFX10PLUS = 0x00000107,
     PERF_ENGG_POS_REQ_STARVED__GFX10PLUS               = 0x00000108,
+#if CHIP_HDR_NAVI31
+    PERF_CLPR_INPUT_PRIM__GFX11                        = 0x00000008,
+    PERF_CLPR_INPUT_NULL_PRIM__GFX11                   = 0x00000009,
+    PERF_CLPR_INPUT_EVENT__GFX11                       = 0x0000000a,
+    PERF_CLPR_INPUT_FIRST_OF_SUBGROUP__GFX11           = 0x0000000b,
+    PERF_CLPR_INPUT_END_OF_PACKET__GFX11               = 0x0000000c,
+    PERF_CLPR_INPUT_EXTENDED_EVENT__GFX11              = 0x0000000d,
+    PERF_CLPR_CLIP_PLANE_CNT_9_PLUS__GFX11             = 0x0000001e,
+    PERF_PAPC_CLSM_OUT_PRIM_CNT_9_PLUS__GFX11          = 0x0000002f,
+    PERF_PAPC_SU_ALL_OUTPUT_PRIM__GFX11                = 0x0000007d,
+    PERF_PAPC_SU_ALL_OUTPUT_NULL_PRIM__GFX11           = 0x00000080,
+    PERF_PAPC_SU_ALL_STALLED_SC__GFX11                 = 0x00000085,
+    PERF_ENGG_INDEX_RET_0_NEW_VERTS_THIS_PRIM__GFX11   = 0x000000e1,
+    PERF_ENGG_INDEX_RET_1_NEW_VERTS_THIS_PRIM__GFX11   = 0x000000e2,
+    PERF_ENGG_INDEX_RET_2_NEW_VERTS_THIS_PRIM__GFX11   = 0x000000e3,
+    PERF_ENGG_INDEX_RET_3_NEW_VERTS_THIS_PRIM__GFX11   = 0x000000e4,
+    PERF_PASX_POS_VECTOR__GFX11                        = 0x00000114,
+    PERF_PASX_MISC_VECTOR__GFX11                       = 0x00000115,
+    PERF_PASX_CCDIST0_VECTOR__GFX11                    = 0x00000116,
+    PERF_PASX_CCDIST1_VECTOR__GFX11                    = 0x00000117,
+    PERF_PASX_STEREO_POS_VECTOR__GFX11                 = 0x00000118,
+    PERF_CLPR_INPUT_SEND__GFX11                        = 0x00000119,
+    PERF_SU_INPUT_SEND__GFX11                          = 0x0000011a,
+    PERF_SU_OUTPUT_SEND__GFX11                         = 0x0000011b,
+    PERF_PAPC_SU_SE4_PRIM_FILTER_CULL__GFX11           = 0x0000011c,
+    PERF_PAPC_SU_SE5_PRIM_FILTER_CULL__GFX11           = 0x0000011d,
+    PERF_PAPC_SU_SE4_OUTPUT_PRIM__GFX11                = 0x0000011e,
+    PERF_PAPC_SU_SE5_OUTPUT_PRIM__GFX11                = 0x0000011f,
+    PERF_PAPC_SU_SE4_OUTPUT_NULL_PRIM__GFX11           = 0x00000120,
+    PERF_PAPC_SU_SE5_OUTPUT_NULL_PRIM__GFX11           = 0x00000121,
+    PERF_PAPC_SU_SE4_STALLED_SC__GFX11                 = 0x00000122,
+    PERF_PAPC_SU_SE5_STALLED_SC__GFX11                 = 0x00000123,
+    PERF_ENGG_INDEX_RET0_NEW_VERTS__GFX11              = 0x00000124,
+    PERF_ENGG_INDEX_RET1_NEW_VERTS__GFX11              = 0x00000125,
+    PERF_ENGG_INDEX_RET2_NEW_VERTS__GFX11              = 0x00000126,
+    PERF_ENGG_INDEX_RET3_NEW_VERTS__GFX11              = 0x00000127,
+    PERF_ENGG_INDEX_RET4_NEW_VERTS__GFX11              = 0x00000128,
+    PERF_ENGG_INDEX_RET5_NEW_VERTS__GFX11              = 0x00000129,
+    PERF_ENGG_INDEX_RET6_NEW_VERTS__GFX11              = 0x0000012a,
+    PERF_ENGG_INDEX_RET7_NEW_VERTS__GFX11              = 0x0000012b,
+    PERF_ENGG_INDEX_RET8_NEW_VERTS__GFX11              = 0x0000012c,
+    PERF_ENGG_INDEX_RET9_NEW_VERTS__GFX11              = 0x0000012d,
+    PERF_ENGG_INDEX_RET10_NEW_VERTS__GFX11             = 0x0000012e,
+    PERF_ENGG_INDEX_RET11_NEW_VERTS__GFX11             = 0x0000012f,
+    PERF_ENGG_INDEX_RET12_NEW_VERTS__GFX11             = 0x00000130,
+    PERF_PH_SEND_5_SC__GFX11                           = 0x00000131,
+    PERF_PH_SEND_6_SC__GFX11                           = 0x00000132,
+    PERF_OUTPUT_PRIM_5_SC__GFX11                       = 0x00000133,
+    PERF_OUTPUT_PRIM_6_SC__GFX11                       = 0x00000134,
+    PERF_CLPR_BACK_PRIM__GFX11                         = 0x00000135,
+    PERF_PA_BUSY__GFX11                                = 0x00000136,
+#endif
 } SU_PERFCNT_SEL;
 
 constexpr unsigned int MaxSuPerfcntSelGfx09_0          = PERF_CLIENT_UTCL1_INFLIGHT__GFX09_0;
 constexpr unsigned int MaxSuPerfcntSelGfx09_1x         = PERF_PA_PRIMIC_TO_CLPRIM_FIFO_FULL__GFX09_1X;
 constexpr unsigned int MaxSuPerfcntSelGfx101           = PERF_ENGG_POS_REQ_STALLED_BY_FULL_CLIPV_FIFO__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxSuPerfcntSelGfx103Derivative = PERF_OUTPUT_PRIM_4_SC__GFX103PLUSEXCLUSIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxSuPerfcntSelGfx11            = PERF_PA_BUSY__GFX11;
+#endif
 
 typedef enum SWIZZLE_MODE_ENUM {
     SW_LINEAR                                          = 0x00000000,
     SW_256B_S                                          = 0x00000001,
     SW_256B_D                                          = 0x00000002,
     SW_256B_R                                          = 0x00000003,
     SW_4KB_Z                                           = 0x00000004,
     SW_4KB_S                                           = 0x00000005,
     SW_4KB_D                                           = 0x00000006,
     SW_4KB_R                                           = 0x00000007,
@@ -11044,20 +14135,30 @@ typedef enum SWIZZLE_MODE_ENUM {
     SW_VAR_S_X__GFX09                                  = 0x0000001d,
     SW_VAR_D_X__GFX09                                  = 0x0000001e,
     SW_VAR_Z_X__GFX09_10                               = 0x0000001c,
     SW_VAR_R_X__GFX09_10                               = 0x0000001f,
     SW_VAR_Z__GFX10CORE                                = 0x0000000c,
     SW_VAR_S__GFX10CORE                                = 0x0000000d,
     SW_VAR_D__GFX10CORE                                = 0x0000000e,
     SW_VAR_R__GFX10CORE                                = 0x0000000f,
     SW_VAR_S_X__GFX10CORE                              = 0x0000001d,
     SW_VAR_D_X__GFX10CORE                              = 0x0000001e,
+#if CHIP_HDR_NAVI31
+    SW_256KB_Z__GFX11                                  = 0x0000000c,
+    SW_256KB_S__GFX11                                  = 0x0000000d,
+    SW_256KB_D__GFX11                                  = 0x0000000e,
+    SW_256KB_R__GFX11                                  = 0x0000000f,
+    SW_256KB_Z_X__GFX11                                = 0x0000001c,
+    SW_256KB_S_X__GFX11                                = 0x0000001d,
+    SW_256KB_D_X__GFX11                                = 0x0000001e,
+    SW_256KB_R_X__GFX11                                = 0x0000001f,
+#endif
 } SWIZZLE_MODE_ENUM;
 
 typedef enum SWIZZLE_TYPE_ENUM {
     SW_Z                                               = 0x00000000,
     SW_S                                               = 0x00000001,
     SW_D                                               = 0x00000002,
     SW_R                                               = 0x00000003,
     SW_L                                               = 0x00000004,
 } SWIZZLE_TYPE_ENUM;
 
@@ -11077,25 +14178,25 @@ typedef enum SX_DOWNCONVERT_FORMAT {
     SX_RT_EXPORT_32_R                                  = 0x00000001,
     SX_RT_EXPORT_32_A                                  = 0x00000002,
     SX_RT_EXPORT_10_11_11                              = 0x00000003,
     SX_RT_EXPORT_2_10_10_10                            = 0x00000004,
     SX_RT_EXPORT_8_8_8_8                               = 0x00000005,
     SX_RT_EXPORT_5_6_5                                 = 0x00000006,
     SX_RT_EXPORT_1_5_5_5                               = 0x00000007,
     SX_RT_EXPORT_4_4_4_4                               = 0x00000008,
     SX_RT_EXPORT_16_16_GR                              = 0x00000009,
     SX_RT_EXPORT_16_16_AR                              = 0x0000000a,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SX_RT_EXPORT_2_10_10_10_7E3__GFX103COREPLUS        = 0x0000000c,
     SX_RT_EXPORT_2_10_10_10_6E4__GFX103COREPLUS        = 0x0000000d,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     SX_RT_EXPORT_9_9_9_E5__GFX103PLUSEXCLUSIVE         = 0x0000000b,
 #endif
 } SX_DOWNCONVERT_FORMAT;
 
 typedef enum SX_OPT_COMB_FCN {
     OPT_COMB_NONE                                      = 0x00000000,
     OPT_COMB_ADD                                       = 0x00000001,
     OPT_COMB_SUBTRACT                                  = 0x00000002,
     OPT_COMB_MIN                                       = 0x00000003,
     OPT_COMB_MAX                                       = 0x00000004,
@@ -11323,24 +14424,77 @@ typedef enum SX_PERFCOUNTER_VALS {
     SX_PERF_SEL_IDX_REQ_LATENCY__GFX10                 = 0x000000d7,
     SX_PERF_SEL_IDX_SCBD_STALL__GFX10                  = 0x000000d8,
     SX_PERF_SEL_GATE_EN7__GFX10                        = 0x000000d9,
     SX_PERF_SEL_GATE_EN8__GFX10                        = 0x000000da,
     SX_PERF_SEL_SH_IDX_STARVE__GFX10                   = 0x000000db,
     SX_PERF_SEL_IDX_BUSY__GFX10                        = 0x000000dc,
     SX_PERF_SEL_RB0_STALL_DUE_TO_ORDERING__GFX10       = 0x000000dd,
     SX_PERF_SEL_RB1_STALL_DUE_TO_ORDERING__GFX10       = 0x000000de,
     SX_PERF_SEL_RB2_STALL_DUE_TO_ORDERING__GFX10       = 0x000000df,
     SX_PERF_SEL_RB3_STALL_DUE_TO_ORDERING__GFX10       = 0x000000e0,
+#if CHIP_HDR_NAVI31
+    SX_PERF_SEL_DB0_MRT_BLEND_BYPASS__GFX11            = 0x00000022,
+    SX_PERF_SEL_DB0_MRT_DONT_RD_DEST__GFX11            = 0x00000023,
+    SX_PERF_SEL_DB0_MRT_DISCARD_SRC__GFX11             = 0x00000024,
+    SX_PERF_SEL_DB0_MRT_SINGLE_QUADS__GFX11            = 0x00000025,
+    SX_PERF_SEL_DB0_MRT_DOUBLE_QUADS__GFX11            = 0x00000026,
+    SX_PERF_SEL_DB1_MRT_BLEND_BYPASS__GFX11            = 0x00000027,
+    SX_PERF_SEL_DB1_MRT_DONT_RD_DEST__GFX11            = 0x00000028,
+    SX_PERF_SEL_DB1_MRT_DISCARD_SRC__GFX11             = 0x00000029,
+    SX_PERF_SEL_DB1_MRT_SINGLE_QUADS__GFX11            = 0x0000002a,
+    SX_PERF_SEL_DB1_MRT_DOUBLE_QUADS__GFX11            = 0x0000002b,
+    SX_PERF_SEL_DB2_MRT_BLEND_BYPASS__GFX11            = 0x0000002c,
+    SX_PERF_SEL_DB2_MRT_DONT_RD_DEST__GFX11            = 0x0000002d,
+    SX_PERF_SEL_DB2_MRT_DISCARD_SRC__GFX11             = 0x0000002e,
+    SX_PERF_SEL_DB2_MRT_SINGLE_QUADS__GFX11            = 0x0000002f,
+    SX_PERF_SEL_DB2_MRT_DOUBLE_QUADS__GFX11            = 0x00000030,
+    SX_PERF_SEL_DB3_MRT_BLEND_BYPASS__GFX11            = 0x00000031,
+    SX_PERF_SEL_DB3_MRT_DONT_RD_DEST__GFX11            = 0x00000032,
+    SX_PERF_SEL_DB3_MRT_DISCARD_SRC__GFX11             = 0x00000033,
+    SX_PERF_SEL_DB3_MRT_SINGLE_QUADS__GFX11            = 0x00000034,
+    SX_PERF_SEL_DB3_MRT_DOUBLE_QUADS__GFX11            = 0x00000035,
+    SX_PERF_SEL_PA_REQ_LATENCY__GFX11                  = 0x00000036,
+    SX_PERF_SEL_POS_SCBD_STALL__GFX11                  = 0x00000037,
+    SX_PERF_SEL_CLOCK_DROP_STALL__GFX11                = 0x00000038,
+    SX_PERF_SEL_GATE_EN5__GFX11                        = 0x00000039,
+    SX_PERF_SEL_GATE_EN6__GFX11                        = 0x0000003a,
+    SX_PERF_SEL_DB0_SIZE__GFX11                        = 0x0000003b,
+    SX_PERF_SEL_DB1_SIZE__GFX11                        = 0x0000003c,
+    SX_PERF_SEL_DB2_SIZE__GFX11                        = 0x0000003d,
+    SX_PERF_SEL_DB3_SIZE__GFX11                        = 0x0000003e,
+    SX_PERF_SEL_IDX_STALL_CYCLES__GFX11                = 0x0000003f,
+    SX_PERF_SEL_IDX_IDLE_CYCLES__GFX11                 = 0x00000040,
+    SX_PERF_SEL_IDX_REQ__GFX11                         = 0x00000041,
+    SX_PERF_SEL_IDX_RET__GFX11                         = 0x00000042,
+    SX_PERF_SEL_IDX_REQ_LATENCY__GFX11                 = 0x00000043,
+    SX_PERF_SEL_IDX_SCBD_STALL__GFX11                  = 0x00000044,
+    SX_PERF_SEL_GATE_EN7__GFX11                        = 0x00000045,
+    SX_PERF_SEL_GATE_EN8__GFX11                        = 0x00000046,
+    SX_PERF_SEL_SH_IDX_STARVE__GFX11                   = 0x00000047,
+    SX_PERF_SEL_IDX_BUSY__GFX11                        = 0x00000048,
+    SX_PERF_SEL_PA_POS_BANK_CONF__GFX11                = 0x00000049,
+    SX_PERF_SEL_DB0_END_OF_WAVE__GFX11                 = 0x0000004a,
+    SX_PERF_SEL_DB0_4X2_DISCARD__GFX11                 = 0x0000004b,
+    SX_PERF_SEL_DB1_END_OF_WAVE__GFX11                 = 0x0000004c,
+    SX_PERF_SEL_DB1_4X2_DISCARD__GFX11                 = 0x0000004d,
+    SX_PERF_SEL_DB2_END_OF_WAVE__GFX11                 = 0x0000004e,
+    SX_PERF_SEL_DB2_4X2_DISCARD__GFX11                 = 0x0000004f,
+    SX_PERF_SEL_DB3_END_OF_WAVE__GFX11                 = 0x00000050,
+    SX_PERF_SEL_DB3_4X2_DISCARD__GFX11                 = 0x00000051,
+#endif
 } SX_PERFCOUNTER_VALS;
 
 constexpr unsigned int MaxSxPerfcounterValsGfx09       = SX_PERF_SEL_DB3_SIZE__GFX09_10;
 constexpr unsigned int MaxSxPerfcounterValsGfx10Core   = SX_PERF_SEL_RB3_STALL_DUE_TO_ORDERING__GFX10;
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxSxPerfcounterValsGfx11       = SX_PERF_SEL_DB3_4X2_DISCARD__GFX11;
+#endif
 
 typedef enum TA_PERFCOUNT_SEL {
     TA_PERF_SEL_NULL                                   = 0x00000000,
     TA_PERF_SEL_gradient_busy                          = 0x00000007,
     TA_PERF_SEL_gradient_fifo_busy                     = 0x00000008,
     TA_PERF_SEL_lod_busy                               = 0x00000009,
     TA_PERF_SEL_lod_fifo_busy                          = 0x0000000a,
     TA_PERF_SEL_addresser_busy                         = 0x0000000b,
     TA_PERF_SEL_addresser_fifo_busy                    = 0x0000000c,
     TA_PERF_SEL_aligner_busy                           = 0x0000000d,
@@ -11595,47 +14749,47 @@ typedef enum TA_PERFCOUNT_SEL {
     TA_PERF_SEL_RESERVED_214__GFX101                   = 0x000000d6,
     TA_PERF_SEL_RESERVED_215__GFX101                   = 0x000000d7,
     TA_PERF_SEL_RESERVED_216__GFX101                   = 0x000000d8,
     TA_PERF_SEL_RESERVED_217__GFX101                   = 0x000000d9,
     TA_PERF_SEL_RESERVED_218__GFX101                   = 0x000000da,
     TA_PERF_SEL_RESERVED_219__GFX101                   = 0x000000db,
     TA_PERF_SEL_RESERVED_220__GFX101                   = 0x000000dc,
     TA_PERF_SEL_RESERVED_221__GFX101                   = 0x000000dd,
     TA_PERF_SEL_sample_path_cycles__GFX101             = 0x000000e0,
     TA_PERF_SEL_nosample_path_cycles__GFX101           = 0x000000e1,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     TA_PERF_SEL_harvestable_register_clk_enabled_cycles__GFX103COREPLUS = 0x0000006c,
 #endif
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     TA_PERF_SEL_RESERVED_111__GFX103DERIVATIVE         = 0x0000006f,
     TA_PERF_SEL_RESERVED_147__GFX103DERIVATIVE         = 0x00000093,
     TA_PERF_SEL_RESERVED_148__GFX103DERIVATIVE         = 0x00000094,
     TA_PERF_SEL_RESERVED_152__GFX103DERIVATIVE         = 0x00000098,
 #endif
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     TA_PERF_SEL_bvh_total_cycles__GFX103PLUS           = 0x0000002b,
     TA_PERF_SEL_num_nodes_invalidated_due_to_bad_input__GFX103PLUS = 0x000000ae,
     TA_PERF_SEL_num_nodes_invalidated_due_to_oob__GFX103PLUS = 0x000000af,
     TA_PERF_SEL_num_of_bvh_valid_first_tri__GFX103PLUS = 0x000000b0,
     TA_PERF_SEL_num_of_bvh_valid_second_tri__GFX103PLUS = 0x000000b1,
     TA_PERF_SEL_num_of_bvh_valid_third_tri__GFX103PLUS = 0x000000b2,
     TA_PERF_SEL_num_of_bvh_valid_fourth_tri__GFX103PLUS = 0x000000b3,
     TA_PERF_SEL_num_of_bvh_valid_fp16_box__GFX103PLUS  = 0x000000b4,
     TA_PERF_SEL_num_of_bvh_valid_fp32_box__GFX103PLUS  = 0x000000b5,
     TA_PERF_SEL_num_of_bvh_invalidated_first_tri__GFX103PLUS = 0x000000b6,
     TA_PERF_SEL_num_of_bvh_invalidated_second_tri__GFX103PLUS = 0x000000b7,
     TA_PERF_SEL_num_of_bvh_invalidated_third_tri__GFX103PLUS = 0x000000b8,
     TA_PERF_SEL_num_of_bvh_invalidated_fourth_tri__GFX103PLUS = 0x000000b9,
     TA_PERF_SEL_num_of_bvh_invalidated_fp16_box__GFX103PLUS = 0x000000ba,
     TA_PERF_SEL_num_of_bvh_invalidated_fp32_box__GFX103PLUS = 0x000000bb,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     TA_PERF_SEL_image_sampler_has_offset_instructions__GFX103PLUSEXCLUSIVE = 0x00000001,
     TA_PERF_SEL_image_sampler_has_bias_instructions__GFX103PLUSEXCLUSIVE = 0x00000002,
     TA_PERF_SEL_image_sampler_has_reference_instructions__GFX103PLUSEXCLUSIVE = 0x00000003,
     TA_PERF_SEL_image_sampler_has_ds_instructions__GFX103PLUSEXCLUSIVE = 0x00000004,
     TA_PERF_SEL_image_sampler_has_dt_instructions__GFX103PLUSEXCLUSIVE = 0x00000005,
     TA_PERF_SEL_image_sampler_has_dr_instructions__GFX103PLUSEXCLUSIVE = 0x00000006,
     TA_PERF_SEL_image_sampler_1_input_vgpr_instructions__GFX103PLUSEXCLUSIVE = 0x00000010,
     TA_PERF_SEL_image_sampler_2_input_vgpr_instructions__GFX103PLUSEXCLUSIVE = 0x00000011,
     TA_PERF_SEL_image_sampler_3_input_vgpr_instructions__GFX103PLUSEXCLUSIVE = 0x00000012,
     TA_PERF_SEL_image_sampler_4_input_vgpr_instructions__GFX103PLUSEXCLUSIVE = 0x00000013,
@@ -11768,21 +14922,21 @@ typedef enum TA_PERFCOUNT_SEL {
     TA_PERF_SEL_vmemcmd_cycles__GFX10PLUS              = 0x00000090,
     TA_PERF_SEL_vmemreq_cycles__GFX10PLUS              = 0x00000091,
     TA_PERF_SEL_in_waiting_on_req_cycles__GFX10PLUS    = 0x00000092,
     TA_PERF_SEL_in_addr_cycles__GFX10PLUS              = 0x00000096,
     TA_PERF_SEL_in_data_cycles__GFX10PLUS              = 0x00000097,
     TA_PERF_SEL_point_sampled_quads__GFX10PLUS         = 0x000000a0,
 } TA_PERFCOUNT_SEL;
 
 constexpr unsigned int MaxTaPerfcountSelGfx09          = TA_PERF_SEL_first_xnack_on_phase3__GFX09;
 constexpr unsigned int MaxTaPerfcountSelGfx101         = TA_PERF_SEL_nosample_path_cycles__GFX101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 constexpr unsigned int MaxTaPerfcountSelGfx103PlusExclusive = TA_PERF_SEL_tcreq_clk_valid_cycles__GFX103PLUSEXCLUSIVE;
 #endif
 
 typedef enum TA_TC_ADDR_MODES {
     TA_TC_ADDR_MODE_DEFAULT                            = 0x00000000,
     TA_TC_ADDR_MODE_COMP0                              = 0x00000001,
     TA_TC_ADDR_MODE_COMP1                              = 0x00000002,
     TA_TC_ADDR_MODE_COMP2                              = 0x00000003,
     TA_TC_ADDR_MODE_COMP3                              = 0x00000004,
     TA_TC_ADDR_MODE_UNALIGNED                          = 0x00000005,
@@ -12394,20 +15548,24 @@ typedef enum TCP_PERFCOUNT_SELECT {
     TCP_PERF_SEL_GL1_GRANT_READ_STALL__GFX103          = 0x00000033,
     TCP_PERF_SEL_GL1_PENDING_STALL__GFX103             = 0x00000034,
     TCP_PERF_SEL_OFIFO_INCOMPLETE_STALL__GFX103        = 0x00000035,
     TCP_PERF_SEL_OFIFO_AGE_ORDER_STALL__GFX103         = 0x00000036,
     TCP_PERF_SEL_TD_DATA_CYCLE_STALL__GFX103           = 0x00000037,
     TCP_PERF_SEL_COMP_TEX_LOAD_STALL__GFX103           = 0x00000038,
     TCP_PERF_SEL_READ_DATACONFLICT_STALL__GFX103       = 0x00000039,
     TCP_PERF_SEL_WRITE_DATACONFLICT_STALL__GFX103      = 0x0000003a,
     TCP_PERF_SEL_TD_TCP_STALL__GFX103                  = 0x0000003b,
     TCP_PERF_SEL_BACK_COMPAT_SWITCH__GFX103            = 0x0000003c,
+#endif
+#if CHIP_HDR_NAVI31
+    TCP_PERF_SEL_REQ_NON_READ__GFX104PLUS              = 0x00000010,
+    TCP_PERF_SEL_REQ_MISS__GFX104PLUS                  = 0x00000011,
 #endif
     TCP_PERF_SEL_REQ_WRITE_MISS_LRU__GFX10CORE         = 0x00000010,
     TCP_PERF_SEL_REQ_NON_READ__GFX10CORE               = 0x00000011,
     TCP_PERF_SEL_REQ_MISS__GFX10CORE                   = 0x00000012,
     TCP_PERF_SEL_REQ_TAGBANK0__GFX10CORE               = 0x00000013,
     TCP_PERF_SEL_REQ_TAGBANK1__GFX10CORE               = 0x00000014,
     TCP_PERF_SEL_REQ_TAGBANK2__GFX10CORE               = 0x00000015,
     TCP_PERF_SEL_REQ_TAGBANK3__GFX10CORE               = 0x00000016,
     TCP_PERF_SEL_REQ_MISS_TAGBANK0__GFX10CORE          = 0x00000017,
     TCP_PERF_SEL_REQ_MISS_TAGBANK1__GFX10CORE          = 0x00000018,
@@ -12430,27 +15588,92 @@ typedef enum TCP_PERFCOUNT_SELECT {
     TCP_PERF_SEL_TA_REQ_WRITE__GFX10PLUS               = 0x00000005,
     TCP_PERF_SEL_TA_REQ_ATOMIC_WITH_RET__GFX10PLUS     = 0x00000006,
     TCP_PERF_SEL_TA_REQ_ATOMIC_WITHOUT_RET__GFX10PLUS  = 0x00000007,
     TCP_PERF_SEL_TA_REQ_GL0_INV__GFX10PLUS             = 0x00000008,
     TCP_PERF_SEL_REQ__GFX10PLUS                        = 0x00000009,
     TCP_PERF_SEL_REQ_READ__GFX10PLUS                   = 0x0000000a,
     TCP_PERF_SEL_REQ_READ_HIT_LRU__GFX10PLUS           = 0x0000000c,
     TCP_PERF_SEL_REQ_READ_MISS_EVICT__GFX10PLUS        = 0x0000000d,
     TCP_PERF_SEL_REQ_WRITE__GFX10PLUS                  = 0x0000000e,
     TCP_PERF_SEL_REQ_WRITE_MISS_EVICT__GFX10PLUS       = 0x0000000f,
+#if CHIP_HDR_NAVI31
+    TCP_PERF_SEL_REQ_TAGBANK0_SET0__GFX11              = 0x00000012,
+    TCP_PERF_SEL_REQ_TAGBANK0_SET1__GFX11              = 0x00000013,
+    TCP_PERF_SEL_REQ_TAGBANK1_SET0__GFX11              = 0x00000014,
+    TCP_PERF_SEL_REQ_TAGBANK1_SET1__GFX11              = 0x00000015,
+    TCP_PERF_SEL_REQ_TAGBANK2_SET0__GFX11              = 0x00000016,
+    TCP_PERF_SEL_REQ_TAGBANK2_SET1__GFX11              = 0x00000017,
+    TCP_PERF_SEL_REQ_TAGBANK3_SET0__GFX11              = 0x00000018,
+    TCP_PERF_SEL_REQ_TAGBANK3_SET1__GFX11              = 0x00000019,
+    TCP_PERF_SEL_REQ_MISS_TAGBANK0__GFX11              = 0x0000001a,
+    TCP_PERF_SEL_REQ_MISS_TAGBANK1__GFX11              = 0x0000001b,
+    TCP_PERF_SEL_REQ_MISS_TAGBANK2__GFX11              = 0x0000001c,
+    TCP_PERF_SEL_REQ_MISS_TAGBANK3__GFX11              = 0x0000001d,
+    TCP_PERF_SEL_GL1_REQ_READ__GFX11                   = 0x0000001e,
+    TCP_PERF_SEL_GL1_REQ_READ_128B__GFX11              = 0x0000001f,
+    TCP_PERF_SEL_GL1_REQ_READ_64B__GFX11               = 0x00000020,
+    TCP_PERF_SEL_GL1_REQ_WRITE__GFX11                  = 0x00000021,
+    TCP_PERF_SEL_GL1_REQ_ATOMIC_WITH_RET__GFX11        = 0x00000022,
+    TCP_PERF_SEL_GL1_REQ_ATOMIC_WITHOUT_RET__GFX11     = 0x00000023,
+    TCP_PERF_SEL_GL1_READ_LATENCY__GFX11               = 0x00000024,
+    TCP_PERF_SEL_GL1_WRITE_LATENCY__GFX11              = 0x00000025,
+    TCP_PERF_SEL_TCP_LATENCY__GFX11                    = 0x00000026,
+    TCP_PERF_SEL_TCP_TA_REQ_STALL__GFX11               = 0x00000027,
+    TCP_PERF_SEL_TA_TCP_REQ_STARVE__GFX11              = 0x00000028,
+    TCP_PERF_SEL_DATA_FIFO_STALL__GFX11                = 0x00000029,
+    TCP_PERF_SEL_LOD_STALL__GFX11                      = 0x0000002a,
+    TCP_PERF_SEL_POWER_STALL__GFX11                    = 0x0000002b,
+    TCP_PERF_SEL_ALLOC_STALL__GFX11                    = 0x0000002c,
+    TCP_PERF_SEL_UNORDERED_MTYPE_STALL__GFX11          = 0x0000002d,
+    TCP_PERF_SEL_READ_TAGCONFLICT_STALL__GFX11         = 0x0000002e,
+    TCP_PERF_SEL_WRITE_TAGCONFLICT_STALL__GFX11        = 0x0000002f,
+    TCP_PERF_SEL_ATOMIC_TAGCONFLICT_STALL__GFX11       = 0x00000030,
+    TCP_PERF_SEL_LFIFO_STALL__GFX11                    = 0x00000031,
+    TCP_PERF_SEL_MEM_REQ_FIFO_STALL__GFX11             = 0x00000032,
+    TCP_PERF_SEL_GL1_TCP_BACK_PRESSURE__GFX11          = 0x00000033,
+    TCP_PERF_SEL_GL1_TCP_RDRET_STALL__GFX11            = 0x00000034,
+    TCP_PERF_SEL_GL1_GRANT_READ_STALL__GFX11           = 0x00000035,
+    TCP_PERF_SEL_GL1_PENDING_STALL__GFX11              = 0x00000036,
+    TCP_PERF_SEL_OFIFO_INCOMPLETE_STALL__GFX11         = 0x00000037,
+    TCP_PERF_SEL_OFIFO_AGE_ORDER_STALL__GFX11          = 0x00000038,
+    TCP_PERF_SEL_TD_DATA_CYCLE_STALL__GFX11            = 0x00000039,
+    TCP_PERF_SEL_COMP_TEX_LOAD_STALL__GFX11            = 0x0000003a,
+    TCP_PERF_SEL_READ_DATACONFLICT_STALL__GFX11        = 0x0000003b,
+    TCP_PERF_SEL_WRITE_DATACONFLICT_STALL__GFX11       = 0x0000003c,
+    TCP_PERF_SEL_TD_TCP_STALL__GFX11                   = 0x0000003d,
+    TCP_PERF_SEL_TA_REQ_BUFFERNOP__GFX11               = 0x0000003e,
+    TCP_PERF_SEL_WRITECOMBINE_ENDCLAUSE__GFX11         = 0x0000003f,
+    TCP_PERF_SEL_TAGFAKE_EOW__GFX11                    = 0x00000040,
+    TCP_PERF_SEL_REQ_TAG_MATCH_AND_NOT_VALID__GFX11    = 0x00000041,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_0__GFX11       = 0x00000042,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_1to2__GFX11    = 0x00000043,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_3to4__GFX11    = 0x00000044,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_5to8__GFX11    = 0x00000045,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_9to16__GFX11   = 0x00000046,
+    TCP_PERF_SEL_BURST_BIN_WRITECOMBINE_gt16__GFX11    = 0x00000047,
+    TCP_PERF_SEL_BURST_BIN_READHIT_0__GFX11            = 0x00000048,
+    TCP_PERF_SEL_BURST_BIN_READHIT_1__GFX11            = 0x00000049,
+    TCP_PERF_SEL_BURST_BIN_READHIT_2to4__GFX11         = 0x0000004a,
+    TCP_PERF_SEL_BURST_BIN_READHIT_5to8__GFX11         = 0x0000004b,
+    TCP_PERF_SEL_BURST_BIN_READHIT_9to16__GFX11        = 0x0000004c,
+    TCP_PERF_SEL_BURST_BIN_READHIT_gt16__GFX11         = 0x0000004d,
+#endif
 } TCP_PERFCOUNT_SELECT;
 
 constexpr unsigned int MaxTcpPerfcountSelectGfx09      = TCP_PERF_SEL_TCC_DCC_REQ__GFX09;
 constexpr unsigned int MaxTcpPerfcountSelectGfx101     = TCP_PERF_SEL_BACK_COMPAT_SWITCH__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxTcpPerfcountSelectGfx103     = TCP_PERF_SEL_BACK_COMPAT_SWITCH__GFX103;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxTcpPerfcountSelectGfx11      = TCP_PERF_SEL_BURST_BIN_READHIT_gt16__GFX11;
+#endif
 
 typedef enum TCP_WATCH_MODES {
     TCP_WATCH_MODE_READ                                = 0x00000000,
     TCP_WATCH_MODE_NONREAD                             = 0x00000001,
     TCP_WATCH_MODE_ATOMIC                              = 0x00000002,
     TCP_WATCH_MODE_ALL                                 = 0x00000003,
 } TCP_WATCH_MODES;
 
 typedef enum TC_EA_CID {
     TC_EA_CID_RT                                       = 0x00000000,
@@ -12475,20 +15698,23 @@ typedef enum TC_MICRO_TILE_MODE {
     MICRO_TILE_MODE_LINEAR                             = 0x00000000,
     MICRO_TILE_MODE_STD_3D                             = 0x00000003,
     MICRO_TILE_MODE_DISPLAY_2D                         = 0x00000004,
     MICRO_TILE_MODE_DISPLAY_3D                         = 0x00000005,
     MICRO_TILE_MODE_STD_2D__CORE                       = 0x00000002,
     MICRO_TILE_MODE_ROTATED__GFX09                     = 0x00000001,
     MICRO_TILE_MODE_Z_2D__GFX09                        = 0x00000006,
     MICRO_TILE_MODE_Z_3D__GFX09                        = 0x00000007,
     MICRO_TILE_MODE_Z__GFX10COREPLUS                   = 0x00000006,
     MICRO_TILE_MODE_RENDER_TARGET__GFX10PLUS           = 0x00000001,
+#if CHIP_HDR_NAVI31
+    MICRO_TILE_MODE_Z_VAR__GFX11                       = 0x00000007,
+#endif
 #if CHIP_HDR_NAVI21
     MICRO_TILE_MODE_Z_VAR__NV21                        = 0x00000007,
 #endif
 #if CHIP_HDR_NAVI22
     MICRO_TILE_MODE_Z_VAR__NV22                        = 0x00000007,
 #endif
 #if CHIP_HDR_NAVI23
     MICRO_TILE_MODE_Z_VAR__NV23                        = 0x00000007,
 #endif
 #if CHIP_HDR_NAVI24
@@ -12625,20 +15851,26 @@ typedef enum TC_OP {
     TC_OP_WBINVL2_NC                                   = 0x0000007a,
     TC_OP_NOP_ACK                                      = 0x0000007b,
     TC_OP_RESERVED_NON_FLOAT_64_1                      = 0x0000007c,
     TC_OP_RESERVED_NON_FLOAT_64_2                      = 0x0000007d,
     TC_OP_RESERVED_NON_FLOAT_64_3                      = 0x0000007e,
     TC_OP_RESERVED_NON_FLOAT_64_4                      = 0x0000007f,
     TC_OP_RESERVED_FOP_RTN_32_1__GFX09_10              = 0x00000005,
     TC_OP_RESERVED_FOP_FLUSH_DENORM_RTN_32_1__GFX09_10 = 0x0000000d,
     TC_OP_RESERVED_FOP_32_1__GFX09_10                  = 0x00000045,
     TC_OP_RESERVED_FOP_FLUSH_DENORM_32_1__GFX09_10     = 0x0000004d,
+#if CHIP_HDR_NAVI31
+    TC_OP_RESERVED_FADD_RTN_32__GFX11                  = 0x00000005,
+    TC_OP_ATOMIC_FADD_FLUSH_DENORM_RTN_32__GFX11       = 0x0000000d,
+    TC_OP_RESERVED_FADD_32__GFX11                      = 0x00000045,
+    TC_OP_ATOMIC_FADD_FLUSH_DENORM_32__GFX11           = 0x0000004d,
+#endif
 } TC_OP;
 
 typedef enum TC_OP_MASKS {
     TC_OP_MASK_FLUSH_DENROM                            = 0x00000008,
     TC_OP_MASK_64                                      = 0x00000020,
     TC_OP_MASK_NO_RTN                                  = 0x00000040,
 } TC_OP_MASKS;
 
 typedef enum TD_PERFCOUNT_SEL {
     TD_PERF_SEL_none                                   = 0x00000000,
@@ -12763,39 +15995,39 @@ typedef enum TD_PERFCOUNT_SEL {
     TD_PERF_SEL_sampler_out_sclk_en__GFX103            = 0x0000000e,
     TD_PERF_SEL_nofilter_d16_sclk_en__GFX103           = 0x00000010,
     TD_PERF_SEL_RESERVED_17__GFX103                    = 0x00000011,
     TD_PERF_SEL_RESERVED_22__GFX103                    = 0x00000016,
     TD_PERF_SEL_ray_tracing_bvh4_sclk_en__GFX103       = 0x00000017,
     TD_PERF_SEL_gather4h_packed_instr__GFX103          = 0x00000034,
     TD_PERF_SEL_gather8h_packed_instr__GFX103          = 0x00000035,
     TD_PERF_SEL_address_cmd_poison__GFX103             = 0x00000057,
     TD_PERF_SEL_data_poison__GFX103                    = 0x00000058,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     TD_PERF_SEL_core_state_ram_max_cnt__GFX103COREPLUS = 0x00000020,
     TD_PERF_SEL_core_state_rams_read__GFX103COREPLUS   = 0x00000021,
     TD_PERF_SEL_gather4h_instr__GFX103COREPLUS         = 0x00000033,
     TD_PERF_SEL_mixmode_instr__GFX103COREPLUS          = 0x00000054,
     TD_PERF_SEL_mixmode_resource__GFX103COREPLUS       = 0x00000055,
     TD_PERF_SEL_nofilter_byte_cycling_4cycles__GFX103COREPLUS = 0x000000ba,
     TD_PERF_SEL_nofilter_byte_cycling_8cycles__GFX103COREPLUS = 0x000000bb,
     TD_PERF_SEL_nofilter_byte_cycling_16cycles__GFX103COREPLUS = 0x000000bc,
 #endif
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     TD_PERF_SEL_nofilter_sclk_en__GFX103DERIVATIVE     = 0x0000000f,
     TD_PERF_SEL_RESERVED_18__GFX103DERIVATIVE          = 0x00000012,
     TD_PERF_SEL_RESERVED_19__GFX103DERIVATIVE          = 0x00000013,
     TD_PERF_SEL_RESERVED_20__GFX103DERIVATIVE          = 0x00000014,
     TD_PERF_SEL_RESERVED_21__GFX103DERIVATIVE          = 0x00000015,
     TD_PERF_SEL_ldfptr_instr__GFX103DERIVATIVE         = 0x00000039,
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     TD_PERF_SEL_ray_tracing_bvh4_busy__GFX103PLUSEXCLUSIVE = 0x00000006,
     TD_PERF_SEL_sampler_core_sclk_en__GFX103PLUSEXCLUSIVE = 0x00000007,
     TD_PERF_SEL_ray_tracing_bvh4_box_sclk_en__GFX103PLUSEXCLUSIVE = 0x00000018,
     TD_PERF_SEL_ray_tracing_bvh4_tri_sclk_en__GFX103PLUSEXCLUSIVE = 0x00000019,
     TD_PERF_SEL_sampler_sclk_on_nofilter_sclk_off__GFX103PLUSEXCLUSIVE = 0x0000001a,
     TD_PERF_SEL_nofilter_sclk_on_sampler_sclk_off__GFX103PLUSEXCLUSIVE = 0x0000001b,
     TD_PERF_SEL_all_pipes_sclk_on_at_same_time__GFX103PLUSEXCLUSIVE = 0x0000001c,
     TD_PERF_SEL_sampler_and_nofilter_sclk_on_bvh4_sclk_off__GFX103PLUSEXCLUSIVE = 0x0000001d,
     TD_PERF_SEL_sampler_and_bvh4_sclk_on_nofilter_sclk_off__GFX103PLUSEXCLUSIVE = 0x0000001e,
     TD_PERF_SEL_nofilter_and_bvh4_sclk_on_sampler_sclk_off__GFX103PLUSEXCLUSIVE = 0x0000001f,
@@ -12939,31 +16171,56 @@ typedef enum TD_PERFCOUNT_SEL {
     TD_PERF_SEL_bubble_bin_lds_stall_gt15__GFX103PLUSEXCLUSIVE = 0x000000b3,
     TD_PERF_SEL_preempting_nofilter_max_cnt__GFX103PLUSEXCLUSIVE = 0x000000b4,
     TD_PERF_SEL_sampler_lerp0_active__GFX103PLUSEXCLUSIVE = 0x000000b5,
     TD_PERF_SEL_sampler_lerp1_active__GFX103PLUSEXCLUSIVE = 0x000000b6,
     TD_PERF_SEL_sampler_lerp2_active__GFX103PLUSEXCLUSIVE = 0x000000b7,
     TD_PERF_SEL_sampler_lerp3_active__GFX103PLUSEXCLUSIVE = 0x000000b8,
     TD_PERF_SEL_nofilter_total_num_comps_to_lds__GFX103PLUSEXCLUSIVE = 0x000000b9,
     TD_PERF_SEL_nofilter_dword_cycling_2cycles__GFX103PLUSEXCLUSIVE = 0x000000bd,
     TD_PERF_SEL_nofilter_dword_cycling_4cycles__GFX103PLUSEXCLUSIVE = 0x000000be,
     TD_PERF_SEL_input_bp_due_to_done_scoreboard_full__GFX103PLUSEXCLUSIVE = 0x000000bf,
+#endif
+#if CHIP_HDR_NAVI31
+    TD_PERF_SEL_sampler_preformatter_sclk_en__GFX104PLUS = 0x00000008,
+    TD_PERF_SEL_ray_tracing_bvh4_sclk_en__GFX104PLUS   = 0x00000016,
+    TD_PERF_SEL_ray_tracing_bvh4_ip_sclk_en__GFX104PLUS = 0x00000017,
 #endif
     TD_PERF_SEL_sampler_lerp_busy__GFX10PLUS           = 0x00000003,
     TD_PERF_SEL_sampler_out_busy__GFX10PLUS            = 0x00000004,
     TD_PERF_SEL_nofilter_busy__GFX10PLUS               = 0x00000005,
+#if CHIP_HDR_NAVI31
+    TD_PERF_SEL_sampler_bilerp_sclk_en__GFX11          = 0x00000009,
+    TD_PERF_SEL_sampler_bypass_sclk_en__GFX11          = 0x0000000a,
+    TD_PERF_SEL_sampler_minmax_sclk_en__GFX11          = 0x0000000b,
+    TD_PERF_SEL_sampler_accum_sclk_en__GFX11           = 0x0000000c,
+    TD_PERF_SEL_sampler_format_flt_sclk_en__GFX11      = 0x0000000d,
+    TD_PERF_SEL_sampler_format_fxdpt_sclk_en__GFX11    = 0x0000000e,
+    TD_PERF_SEL_sampler_out_sclk_en__GFX11             = 0x0000000f,
+    TD_PERF_SEL_nofilter_sclk_en__GFX11                = 0x00000010,
+    TD_PERF_SEL_nofilter_d32_sclk_en__GFX11            = 0x00000011,
+    TD_PERF_SEL_nofilter_d16_sclk_en__GFX11            = 0x00000012,
+    TD_PERF_SEL_ray_tracing_bvh4_instr_invld_thread_cnt__GFX11 = 0x000000c0,
+    TD_PERF_SEL_ray_tracing_bvh4_box_sort_closest_child__GFX11 = 0x000000c1,
+    TD_PERF_SEL_ray_tracing_bvh4_box_sort_largest_first__GFX11 = 0x000000c2,
+    TD_PERF_SEL_ray_tracing_bvh4_box_sort_closest_midpoint__GFX11 = 0x000000c3,
+    TD_PERF_SEL_store_preempts_a_load__GFX11           = 0x000000c4,
+#endif
 } TD_PERFCOUNT_SEL;
 
 constexpr unsigned int MaxTdPerfcountSelGfx09          = TD_PERF_SEL_texels_zeroed_out_by_blend_zero_prt__GFX09;
 constexpr unsigned int MaxTdPerfcountSelGfx101         = TD_PERF_SEL_nofilter_popcount_dmask_lt_num_comp_of_fmt__GFX101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 constexpr unsigned int MaxTdPerfcountSelGfx103         = TD_PERF_SEL_input_bp_due_to_done_scoreboard_full__GFX103PLUSEXCLUSIVE;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxTdPerfcountSelGfx11          = TD_PERF_SEL_store_preempts_a_load__GFX11;
+#endif
 
 typedef enum TEX_BC_SWIZZLE {
     TEX_BC_Swizzle_XYZW                                = 0x00000000,
     TEX_BC_Swizzle_XWYZ                                = 0x00000001,
     TEX_BC_Swizzle_WZYX                                = 0x00000002,
     TEX_BC_Swizzle_WXYZ                                = 0x00000003,
     TEX_BC_Swizzle_ZYXW                                = 0x00000004,
     TEX_BC_Swizzle_YXWZ                                = 0x00000005,
 } TEX_BC_SWIZZLE;
 
@@ -13373,20 +16630,113 @@ typedef enum UMC_PERFCOUNT_SELECT {
     UMC_PERF_SEL_RdRspBusyNoCrdt__NV24                 = 0x00000048,
     UMC_PERF_SEL_RdstallRdRspBufNotRdy__NV24           = 0x00000049,
     UMC_PERF_SEL_RdrspBusyVdciNotRdy__NV24             = 0x0000004a,
     UMC_PERF_SEL_DfiLpReq__NV24                        = 0x0000004b,
     UMC_PERF_SEL_DfiLpCyc__NV24                        = 0x0000004c,
     UMC_PERF_SEL_BubbleOverall__NV24                   = 0x0000004d,
     UMC_PERF_SEL_BeqEdcErrB0__NV24                     = 0x0000004e,
     UMC_PERF_SEL_BeqEdcErrB1__NV24                     = 0x0000004f,
     UMC_PERF_SEL_TempOverThresh__NV24                  = 0x00000052,
     UMC_PERF_SEL_TempCnt__NV24                         = 0x00000053,
+#endif
+#if CHIP_HDR_NAVI31
+    UMC_PERF_SEL_NONE__NV3X                            = 0x00000000,
+    UMC_PERF_SEL_SdpPh__NV3X                           = 0x00000001,
+    UMC_PERF_SEL_SdpPm__NV3X                           = 0x00000002,
+    UMC_PERF_SEL_SdpPc__NV3X                           = 0x00000003,
+    UMC_PERF_SEL_ActCmd__NV3X                          = 0x00000005,
+    UMC_PERF_SEL_PchgCmd__NV3X                         = 0x00000006,
+    UMC_PERF_SEL_SpecPchgCmd__NV3X                     = 0x00000007,
+    UMC_PERF_SEL_PchgAllCmd__NV3X                      = 0x00000008,
+    UMC_PERF_SEL_OtherPchgCmd__NV3X                    = 0x00000009,
+    UMC_PERF_SEL_CasCmd__NV3X                          = 0x0000000a,
+    UMC_PERF_SEL_CasWithAP__NV3X                       = 0x0000000b,
+    UMC_PERF_SEL_TurnRndRdWr__NV3X                     = 0x0000000d,
+    UMC_PERF_SEL_CmdSlotClks__NV3X                     = 0x00000013,
+    UMC_PERF_SEL_DataSlotClks__NV3X                    = 0x00000014,
+    UMC_PERF_SEL_CmdError__NV3X                        = 0x00000016,
+    UMC_PERF_SEL_DataError__NV3X                       = 0x00000017,
+    UMC_PERF_SEL_RetryParity__NV3X                     = 0x00000018,
+    UMC_PERF_SEL_RetryCRC__NV3X                        = 0x00000019,
+    UMC_PERF_SEL_BypassSat__NV3X                       = 0x0000001a,
+    UMC_PERF_SEL_PrechagePwrDownClks__NV3X             = 0x0000001b,
+    UMC_PERF_SEL_ThermalThrottleClks__NV3X             = 0x0000001c,
+    UMC_PERF_SEL_DcqOccupancy__NV3X                    = 0x0000001d,
+    UMC_PERF_SEL_SelfRefreshClks__NV3X                 = 0x00000022,
+    UMC_PERF_SEL_PendReqCnt__NV3X                      = 0x00000024,
+    UMC_PERF_SEL_AutoRefCnt__NV3X                      = 0x00000025,
+    UMC_PERF_SEL_BeqRdWrCmd__NV3X                      = 0x00000026,
+    UMC_PERF_SEL_BeqEdcErr__NV3X                       = 0x00000027,
+    UMC_PERF_SEL_ArbRdWrPhase__NV3X                    = 0x0000002a,
+    UMC_PERF_SEL_WriteCycle__NV3X                      = 0x0000002b,
+    UMC_PERF_SEL_ArbRefReqClks__NV3X                   = 0x0000002c,
+    UMC_PERF_SEL_UrgRefStBkClks__NV3X                  = 0x0000002d,
+    UMC_PERF_SEL_RtCalEvtCnt__NV3X                     = 0x00000030,
+    UMC_PERF_SEL_RtCalBlockClks__NV3X                  = 0x00000031,
+    UMC_PERF_SEL_SdpCoherent__NV3X                     = 0x00000033,
+    UMC_PERF_SEL_SdpChngPri__NV3X                      = 0x00000034,
+    UMC_PERF_SEL_SdpCancel__NV3X                       = 0x00000035,
+    UMC_PERF_SEL_SdpBurstLength__NV3X                  = 0x00000036,
+    UMC_PERF_SEL_SdpBurstCnt__NV3X                     = 0x00000037,
+    UMC_PERF_SEL_SdpGapLen__NV3X                       = 0x00000038,
+    UMC_PERF_SEL_SdpGapCnt__NV3X                       = 0x00000039,
+    UMC_PERF_SEL_CasCmdWSM__NV3X                       = 0x0000003a,
+    UMC_PERF_SEL_CasCmdWDM__NV3X                       = 0x0000003b,
+    UMC_PERF_SEL_CasBurstLength__NV3X                  = 0x0000003c,
+    UMC_PERF_SEL_CasBurstCnt__NV3X                     = 0x0000003d,
+    UMC_PERF_SEL_CasCmdCW__NV3X                        = 0x0000003e,
+    UMC_PERF_SEL_TurnRndRdWr_n__NV3X                   = 0x0000003f,
+    UMC_PERF_SEL_TurnRndRdWr_RdThresh__NV3X            = 0x00000040,
+    UMC_PERF_SEL_TurnRndWrRd_noWr__NV3X                = 0x00000041,
+    UMC_PERF_SEL_TurnRndWrRd_WrThresh__NV3X            = 0x00000042,
+    UMC_PERF_SEL_TurnRndWrRd_RdUrg__NV3X               = 0x00000043,
+    UMC_PERF_SEL_PrechargePwrDownEntry__NV3X           = 0x00000044,
+    UMC_PERF_SEL_ThermalThrottleEntry__NV3X            = 0x00000045,
+    UMC_PERF_SEL_PgtActiveBanksCnt__NV3X               = 0x00000046,
+    UMC_PERF_SEL_SelfRefreshEntry__NV3X                = 0x00000047,
+    UMC_PERF_SEL_RdRspBusyNoCrdt__NV3X                 = 0x00000048,
+    UMC_PERF_SEL_RdstallRdRspBufNotRdy__NV3X           = 0x00000049,
+    UMC_PERF_SEL_RdrspBusyVdciNotRdy__NV3X             = 0x0000004a,
+    UMC_PERF_SEL_DfiLpReq__NV3X                        = 0x0000004b,
+    UMC_PERF_SEL_DfiLpCyc__NV3X                        = 0x0000004c,
+    UMC_PERF_SEL_BubbleOverall__NV3X                   = 0x0000004d,
+    UMC_PERF_SEL_BeqEdcErrB0__NV3X                     = 0x0000004e,
+    UMC_PERF_SEL_BeqEdcErrB1__NV3X                     = 0x0000004f,
+    UMC_PERF_SEL_BeqEdcErrB2__NV3X                     = 0x00000050,
+    UMC_PERF_SEL_BeqEdcErrB3__NV3X                     = 0x00000051,
+    UMC_PERF_SEL_TempOverThresh__NV3X                  = 0x00000052,
+    UMC_PERF_SEL_TempCnt__NV3X                         = 0x00000053,
+    UMC_PERF_SEL_ReqFullEntry__NV3X                    = 0x00000054,
+    UMC_PERF_SEL_NumReqs__NV3X                         = 0x00000055,
+    UMC_PERF_SEL_CasWithDeAlloc__NV3X                  = 0x00000056,
+    UMC_PERF_SEL_SdpNewEntry__NV3X                     = 0x00000057,
+    UMC_PERF_SEL_SdpHitEntry__NV3X                     = 0x00000058,
+    UMC_PERF_SEL_RfmCmd__NV3X                          = 0x00000059,
+    UMC_PERF_SEL_RfmBlockClk__NV3X                     = 0x0000005a,
+    UMC_PERF_SEL_PatrolScrub__NV3X                     = 0x0000005b,
+    UMC_PERF_SEL_RedirectScrub__NV3X                   = 0x0000005c,
+    UMC_PERF_SEL_PoisonScrub__NV3X                     = 0x0000005d,
+    UMC_PERF_SEL_MemClear__NV3X                        = 0x0000005e,
+    UMC_PERF_SEL_DroppedRedirectScrub__NV3X            = 0x0000005f,
+    UMC_PERF_SEL_DroppedPoisonScrub__NV3X              = 0x00000060,
+    UMC_PERF_SEL_DroppedScrubWrite__NV3X               = 0x00000061,
+    UMC_PERF_SEL_NoRefOverThres__NV3X                  = 0x00000062,
+    UMC_PERF_SEL_StoredRefOverThres__NV3X              = 0x00000063,
+    UMC_PERF_SEL_PptRunning__NV3X                      = 0x00000064,
+    UMC_PERF_SEL_PptTrig__NV3X                         = 0x00000065,
+    UMC_PERF_SEL_PptMinWin__NV3X                       = 0x00000066,
+    UMC_PERF_SEL_CrcErr__NV3X                          = 0x00000067,
+    UMC_PERF_SEL_EccErr__NV3X                          = 0x00000068,
+    UMC_PERF_SEL_DroopCmdThrot__NV3X                   = 0x00000069,
+    UMC_PERF_SEL_DroopDetAtWin__NV3X                   = 0x0000006a,
+    UMC_PERF_SEL_DroopDetect__NV3X                     = 0x0000006b,
+    UMC_PERF_SEL_ClockCount__NV3X                      = 0x000000ff,
 #endif
     UMC_PERF_SEL_IncomingPh__VG10                      = 0x00000001,
     UMC_PERF_SEL_IncomingPm__VG10                      = 0x00000002,
     UMC_PERF_SEL_IncomingPc__VG10                      = 0x00000003,
     UMC_PERF_SEL_IncomingPgtMiss__VG10                 = 0x00000004,
     UMC_PERF_SEL_ActCmd__VG10                          = 0x00000005,
     UMC_PERF_SEL_PchgCmd__VG10                         = 0x00000006,
     UMC_PERF_SEL_SpecPchgCmd__VG10                     = 0x00000007,
     UMC_PERF_SEL_PchgAllCmd__VG10                      = 0x00000008,
     UMC_PERF_SEL_OtherPchgCmd__VG10                    = 0x00000009,
@@ -13429,20 +16779,23 @@ constexpr unsigned int MaxUmcPerfcountSelectNv24       = UMC_PERF_SEL_TempCnt__N
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxUmcPerfcountSelectNv23       = UMC_PERF_SEL_TempCnt__NV23;
 #endif
 #if CHIP_HDR_NAVI22
 constexpr unsigned int MaxUmcPerfcountSelectNv22       = UMC_PERF_SEL_TempCnt__NV22;
 #endif
 #if CHIP_HDR_NAVI21
 constexpr unsigned int MaxUmcPerfcountSelectNv21       = UMC_PERF_SEL_TempCnt__NV21;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxUmcPerfcountSelectNv3x       = UMC_PERF_SEL_ClockCount__NV3X;
+#endif
 
 typedef enum UTCL1PerfSel {
     UTCL1_PERF_SEL_NONE                                = 0x00000000,
     UTCL1_PERF_SEL_REQS                                = 0x00000001,
     UTCL1_PERF_SEL_HITS                                = 0x00000002,
     UTCL1_PERF_SEL_MISSES                              = 0x00000003,
     UTCL1_PERF_SEL_BYPASS_REQS__GFX10                  = 0x00000004,
     UTCL1_PERF_SEL_HIT_INV_FILTER_REQS__GFX10          = 0x00000005,
     UTCL1_PERF_SEL_NUM_SMALLK_PAGES__GFX101            = 0x00000006,
     UTCL1_PERF_SEL_NUM_BIGK_PAGES__GFX101              = 0x00000007,
@@ -13463,20 +16816,84 @@ typedef enum UTCL1PerfSel {
     UTCL1_PERF_SEL_UTCL2_RET_PRT_FAULT__GFX103DERIVATIVE = 0x0000000c,
     UTCL1_PERF_SEL_UTCL2_RET_XNACK_RETRY__GFX103DERIVATIVE = 0x0000000d,
     UTCL1_PERF_SEL_UTCL2_RET_FAULT__GFX103DERIVATIVE   = 0x0000000e,
     UTCL1_PERF_SEL_STALL_UTCL2_CREDITS__GFX103DERIVATIVE = 0x0000000f,
     UTCL1_PERF_SEL_STALL_MH_FULL__GFX103DERIVATIVE     = 0x00000010,
     UTCL1_PERF_SEL_CP_INVREQS__GFX103DERIVATIVE        = 0x00000011,
     UTCL1_PERF_SEL_UTCL2_UTCL1_INVREQS__GFX103DERIVATIVE = 0x00000012,
     UTCL1_PERF_SEL_RANGE_INVREQS__GFX103DERIVATIVE     = 0x00000013,
     UTCL1_PERF_SEL_INV_ALL_VMID_INVREQS__GFX103DERIVATIVE = 0x00000014,
 #endif
+#if CHIP_HDR_NAVI31
+    UTCL1_PERF_SEL_MH_RECENT_BUF_HIT__GFX11            = 0x00000004,
+    UTCL1_PERF_SEL_MH_DUPLICATE_DETECT__GFX11          = 0x00000005,
+    UTCL1_PERF_SEL_UTCL2_REQS__GFX11                   = 0x00000006,
+    UTCL1_PERF_SEL_UTCL2_RET_XNACK_RETRY__GFX11        = 0x00000007,
+    UTCL1_PERF_SEL_UTCL2_RET_FAULT__GFX11              = 0x00000008,
+    UTCL1_PERF_SEL_STALL_UTCL2_CREDITS__GFX11          = 0x00000009,
+    UTCL1_PERF_SEL_STALL_MH_FULL__GFX11                = 0x0000000a,
+    UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__GFX11 = 0x0000000b,
+    UTCL1_PERF_SEL_UTCL2_RET_CNT__GFX11                = 0x0000000c,
+    UTCL1_PERF_SEL_RTNS__GFX11                         = 0x0000000d,
+    UTCL1_PERF_SEL_XLAT_REQ_BUSY__GFX11                = 0x0000000e,
+    UTCL1_PERF_SEL_RANGE_INVREQS__GFX11                = 0x0000000f,
+    UTCL1_PERF_SEL_INV_ALL_VMID_INVREQS__GFX11         = 0x00000010,
+    UTCL1_PERF_SEL_BYPASS_REQS__GFX11                  = 0x00000011,
+    UTCL1_PERF_SEL_HIT_INV_FILTER_REQS__GFX11          = 0x00000012,
+    UTCL1_PERF_SEL_UTCL2_RET_PERM_FAULT__GFX11         = 0x00000013,
+    UTCL1_PERF_SEL_UTCL2_RET_PRT_FAULT__GFX11          = 0x00000014,
+    UTCL1_PERF_SEL_CP_INVREQS__GFX11                   = 0x00000015,
+    UTCL1_PERF_SEL_UTCL2_UTCL1_INVREQS__GFX11          = 0x00000016,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_4K_64K__GFX11    = 0x00000017,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_64K_256K__GFX11  = 0x00000018,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_256K_512K__GFX11 = 0x00000019,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_512K_1M__GFX11   = 0x0000001a,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_1M_2M__GFX11     = 0x0000001b,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_2M_4M__GFX11     = 0x0000001c,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_4M_8M__GFX11     = 0x0000001d,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_8M_16M__GFX11    = 0x0000001e,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_16M_32M__GFX11   = 0x0000001f,
+    UTCL1_PERF_SEL_NUM_UTCL2_RTN_SIZE_32M_INF__GFX11   = 0x00000020,
+    UTCL1_PERF_SEL_UTCL2_REQ_SQUASHED_NUM__GFX11       = 0x00000021,
+    UTCL1_PERF_SEL_REQ_NUM_CACHE_CORE_0__GFX11         = 0x00000022,
+    UTCL1_PERF_SEL_REQ_NUM_CACHE_CORE_1__GFX11         = 0x00000023,
+    UTCL1_PERF_SEL_REQ_NUM_CACHE_CORE_2__GFX11         = 0x00000024,
+    UTCL1_PERF_SEL_REQ_NUM_CACHE_CORE_3__GFX11         = 0x00000025,
+    UTCL1_PERF_SEL_STALL_CYCLES_CACHE_CORE_0__GFX11    = 0x00000026,
+    UTCL1_PERF_SEL_STALL_CYCLES_CACHE_CORE_1__GFX11    = 0x00000027,
+    UTCL1_PERF_SEL_STALL_CYCLES_CACHE_CORE_2__GFX11    = 0x00000028,
+    UTCL1_PERF_SEL_STALL_CYCLES_CACHE_CORE_3__GFX11    = 0x00000029,
+    UTCL1_PERF_SEL_UTCL1_UTCL2_INVACKS__GFX11          = 0x0000002a,
+    UTCL1_PERF_SEL_UTCL0_UTCL1_INVACKS__GFX11          = 0x0000002b,
+    UTCL1_PERF_SEL_HITS_PG_SIZE_1__GFX11               = 0x0000002c,
+    UTCL1_PERF_SEL_HITS_PG_SIZE_2__GFX11               = 0x0000002d,
+    UTCL1_PERF_SEL_HITS_PG_SIZE_3__GFX11               = 0x0000002e,
+    UTCL1_PERF_SEL_HITS_PG_SIZE_4__GFX11               = 0x0000002f,
+    UTCL1_PERF_SEL_REQ_TO_MISS_HNDLR_0__GFX11          = 0x00000030,
+    UTCL1_PERF_SEL_REQ_TO_MISS_HNDLR_1__GFX11          = 0x00000031,
+    UTCL1_PERF_SEL_REQ_TO_MISS_HNDLR_2__GFX11          = 0x00000032,
+    UTCL1_PERF_SEL_REQ_TO_MISS_HNDLR_3__GFX11          = 0x00000033,
+    UTCL1_PERF_SEL_AVG_INV_LATENCY__GFX11              = 0x00000034,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_RQ_EXISTS_TO_CC0__GFX11 = 0x00000035,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_RQ_EXISTS_TO_CC1__GFX11 = 0x00000036,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_RQ_EXISTS_TO_CC2__GFX11 = 0x00000037,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_RQ_EXISTS_TO_CC3__GFX11 = 0x00000038,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_W_COLLISION_CC0__GFX11 = 0x00000039,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_W_COLLISION_CC1__GFX11 = 0x0000003a,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_W_COLLISION_CC2__GFX11 = 0x0000003b,
+    UTCL1_PERF_SEL_NUM_OF_CYCLES_W_COLLISION_CC3__GFX11 = 0x0000003c,
+    UTCL1_PERF_SEL_ALOG_INTERRUPT__GFX11               = 0x0000003d,
+    UTCL1_PERF_SEL_ALOG_INTERRUPT_DROPPED__GFX11       = 0x0000003e,
+    UTCL1_PERF_SEL_ALOG_CACHE_REQ__GFX11               = 0x0000003f,
+    UTCL1_PERF_SEL_ALOG_CACHE_HIT__GFX11               = 0x00000040,
+    UTCL1_PERF_SEL_ALOG_STALL_PMM_CREDITS__GFX11       = 0x00000041,
+#endif
 #if CHIP_HDR_NAVI23
     UTCL1_PERF_SEL_SMALL_PAGE_HITS__NV23               = 0x00000015,
     UTCL1_PERF_SEL_LARGE_PAGE_HITS__NV23               = 0x00000016,
     UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__NV23  = 0x00000017,
 #endif
 #if CHIP_HDR_NAVI24
     UTCL1_PERF_SEL_SMALL_PAGE_HITS__NV24               = 0x00000015,
     UTCL1_PERF_SEL_LARGE_PAGE_HITS__NV24               = 0x00000016,
     UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__NV24  = 0x00000017,
 #endif
@@ -13488,20 +16905,23 @@ constexpr unsigned int MaxUTCL1PerfSelNv22             = UTCL1_PERF_SEL_INV_ALL_
 #endif
 #if CHIP_HDR_NAVI21
 constexpr unsigned int MaxUTCL1PerfSelNv21             = UTCL1_PERF_SEL_INV_ALL_VMID_INVREQS__GFX103DERIVATIVE;
 #endif
 #if CHIP_HDR_NAVI24
 constexpr unsigned int MaxUTCL1PerfSelNv24             = UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__NV24;
 #endif
 #if CHIP_HDR_NAVI23
 constexpr unsigned int MaxUTCL1PerfSelNv23             = UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__NV23;
 #endif
+#if CHIP_HDR_NAVI31
+constexpr unsigned int MaxUTCL1PerfSelGfx11            = UTCL1_PERF_SEL_ALOG_STALL_PMM_CREDITS__GFX11;
+#endif
 
 typedef enum VGT_CACHE_INVALID_MODE {
     VC_ONLY                                            = 0x00000000,
     TC_ONLY                                            = 0x00000001,
     VC_AND_TC                                          = 0x00000002,
 } VGT_CACHE_INVALID_MODE;
 
 typedef enum VGT_DETECT_ONE {
     ENABLE_TF1_OPT                                     = 0x00000000,
     DISABLE_TF1_OPT                                    = 0x00000001,
@@ -13640,20 +17060,24 @@ typedef enum VGT_EVENT_TYPE {
     Available_0x1d__GFX09                              = 0x0000001d,
     THREAD_TRACE_FLUSH__GFX09                          = 0x00000036,
     Reserved_0x3f__GFX09                               = 0x0000003f,
     ZPASS_DONE__GFX09_10                               = 0x00000015,
     ENABLE_LEGACY_PIPELINE__GFX09_10                   = 0x0000003e,
     Reserved_0x09__GFX10PLUS                           = 0x00000009,
     FLUSH_ES_OUTPUT__GFX10PLUS                         = 0x0000001c,
     BIN_CONF_OVERRIDE_CHECK__GFX10PLUS                 = 0x0000001d,
     THREAD_TRACE_DRAW__GFX10PLUS                       = 0x00000036,
     DRAW_DONE__GFX10PLUS                               = 0x0000003f,
+#if CHIP_HDR_NAVI31
+    WAIT_SYNC__GFX11                                   = 0x00000015,
+    ENABLE_PIPELINE_NOT_USED__GFX11                    = 0x0000003e,
+#endif
 } VGT_EVENT_TYPE;
 
 typedef enum VGT_GROUP_CONV_SEL {
     VGT_GRP_INDEX_16                                   = 0x00000000,
     VGT_GRP_INDEX_32                                   = 0x00000001,
     VGT_GRP_UINT_16                                    = 0x00000002,
     VGT_GRP_UINT_32                                    = 0x00000003,
     VGT_GRP_SINT_16                                    = 0x00000004,
     VGT_GRP_SINT_32                                    = 0x00000005,
     VGT_GRP_FLOAT_32                                   = 0x00000006,
@@ -13746,20 +17170,30 @@ typedef enum VGT_OUT_PRIM_TYPE {
     VGT_OUT_RECT_V2__GFX09_10                          = 0x00000005,
     VGT_OUT_RECT_V3__GFX09_10                          = 0x00000006,
     VGT_OUT_2D_RECT__GFX09_10                          = 0x00000007,
     VGT_TE_QUAD__GFX09_10                              = 0x00000008,
     VGT_TE_PRIM_INDEX_LINE__GFX09_10                   = 0x00000009,
     VGT_TE_PRIM_INDEX_TRI__GFX09_10                    = 0x0000000a,
     VGT_TE_PRIM_INDEX_QUAD__GFX09_10                   = 0x0000000b,
     VGT_OUT_LINE_ADJ__GFX09_10                         = 0x0000000c,
     VGT_OUT_TRI_ADJ__GFX09_10                          = 0x0000000d,
     VGT_OUT_PATCH__GFX09_10                            = 0x0000000e,
+#if CHIP_HDR_NAVI31
+    VGT_OUT_2D_RECT__GFX11                             = 0x00000003,
+    VGT_OUT_RECT_V0__GFX11                             = 0x00000004,
+    VGT_OUT_DUMMY_1__GFX11                             = 0x00000005,
+    VGT_OUT_DUMMY_2__GFX11                             = 0x00000006,
+    VGT_OUT_DUMMY_3__GFX11                             = 0x00000007,
+    VGT_OUT_PATCH__GFX11                               = 0x00000008,
+    VGT_OUT_LINE_ADJ__GFX11                            = 0x00000009,
+    VGT_OUT_TRI_ADJ__GFX11                             = 0x0000000a,
+#endif
 } VGT_OUT_PRIM_TYPE;
 
 typedef enum VGT_PERFCOUNT_SELECT {
     vgt_perf_UNUSED0                                   = 0x00000000,
     vgt_perf_VGT_SPI_ESVERT_VALID                      = 0x00000001,
     vgt_perf_VGT_SPI_ESVERT_EOV                        = 0x00000002,
     vgt_perf_VGT_SPI_ESVERT_STALLED                    = 0x00000003,
     vgt_perf_VGT_SPI_ESVERT_STARVED_BUSY               = 0x00000004,
     vgt_perf_VGT_SPI_ESVERT_STARVED_IDLE               = 0x00000005,
     vgt_perf_VGT_SPI_ESVERT_STATIC                     = 0x00000006,
@@ -13968,34 +17402,72 @@ typedef enum VGT_TESS_TYPE {
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef enum VRSCombinerMode {
     VRS_COMB_MODE_PASSTHRU                             = 0x00000000,
     VRS_COMB_MODE_OVERRIDE                             = 0x00000001,
     VRS_COMB_MODE_MIN                                  = 0x00000002,
     VRS_COMB_MODE_MAX                                  = 0x00000003,
     VRS_COMB_MODE_SATURATE                             = 0x00000004,
 } VRSCombinerMode;
 #endif
 
+#if CHIP_HDR_NAVI31
+typedef enum VRSCombinerModeSC {
+    SC_VRS_COMB_MODE_PASSTHRU                          = 0x00000000,
+    SC_VRS_COMB_MODE_OVERRIDE                          = 0x00000001,
+    SC_VRS_COMB_MODE_MIN                               = 0x00000002,
+    SC_VRS_COMB_MODE_MAX                               = 0x00000003,
+    SC_VRS_COMB_MODE_SATURATE                          = 0x00000004,
+} VRSCombinerModeSC;
+#endif
+
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef enum VRSHtileEncoding {
     VRS_HTILE_DISABLE                                  = 0x00000000,
     VRS_HTILE_2BIT_ENCODING                            = 0x00000001,
     VRS_HTILE_4BIT_ENCODING                            = 0x00000002,
 } VRSHtileEncoding;
 #endif
 
+#if CHIP_HDR_NAVI31
+typedef enum VRSrate {
+    VRS_SHADING_RATE_1X1                               = 0x00000000,
+    VRS_SHADING_RATE_1X2                               = 0x00000001,
+    VRS_SHADING_RATE_UNDEFINED0                        = 0x00000002,
+    VRS_SHADING_RATE_UNDEFINED1                        = 0x00000003,
+    VRS_SHADING_RATE_2X1                               = 0x00000004,
+    VRS_SHADING_RATE_2X2                               = 0x00000005,
+    VRS_SHADING_RATE_2X4                               = 0x00000006,
+    VRS_SHADING_RATE_UNDEFINED2                        = 0x00000007,
+    VRS_SHADING_RATE_UNDEFINED3                        = 0x00000008,
+    VRS_SHADING_RATE_4X2                               = 0x00000009,
+    VRS_SHADING_RATE_4X4                               = 0x0000000a,
+    VRS_SHADING_RATE_UNDEFINED4                        = 0x0000000b,
+    VRS_SHADING_RATE_16X_SSAA                          = 0x0000000c,
+    VRS_SHADING_RATE_8X_SSAA                           = 0x0000000d,
+    VRS_SHADING_RATE_4X_SSAA                           = 0x0000000e,
+    VRS_SHADING_RATE_2X_SSAA                           = 0x0000000f,
+} VRSrate;
+#endif
+
 typedef enum WD_IA_DRAW_REG_XFER {
     WD_IA_DRAW_REG_XFER_IA_MULTI_VGT_PARAM             = 0x00000000,
     WD_IA_DRAW_REG_XFER_VGT_MULTI_PRIM_IB_RESET_EN     = 0x00000001,
     WD_IA_DRAW_REG_XFER_VGT_INSTANCE_BASE_ID           = 0x00000002,
     WD_IA_DRAW_REG_XFER_GE_CNTL__GFX10PLUS             = 0x00000003,
     WD_IA_DRAW_REG_XFER_GE_USER_VGPR_EN__GFX10PLUS     = 0x00000004,
+#if CHIP_HDR_NAVI31
+    WD_IA_DRAW_REG_XFER_FL_MS_WG_DIM__GFX11            = 0x00000005,
+    WD_IA_DRAW_REG_XFER_FL_MS_WG_DIM_1__GFX11          = 0x00000006,
+    WD_IA_DRAW_REG_XFER_FL_MS_TG_SIZE__GFX11           = 0x00000007,
+    WD_IA_DRAW_REG_XFER_FL_MS_EXP_ALLOC__GFX11         = 0x00000008,
+    WD_IA_DRAW_REG_XFER_VGT_GS_OUT_PRIM_TYPE__GFX11    = 0x00000009,
+#endif
 } WD_IA_DRAW_REG_XFER;
 
 typedef enum WD_IA_DRAW_SOURCE {
     WD_IA_DRAW_SOURCE_DMA                              = 0x00000000,
     WD_IA_DRAW_SOURCE_IMMD                             = 0x00000001,
     WD_IA_DRAW_SOURCE_AUTO                             = 0x00000002,
     WD_IA_DRAW_SOURCE_OPAQ                             = 0x00000003,
 } WD_IA_DRAW_SOURCE;
 
 typedef enum WD_IA_DRAW_TYPE {
@@ -15910,29 +19382,39 @@ namespace Gfx101
     constexpr unsigned int GB_TILE_MODE29_GEN1                                = 0x92c00294;
     constexpr unsigned int GB_TILE_MODE30_GEN0                                = 0x92c00318;
     constexpr unsigned int GB_TILE_MODE30_GEN1                                = 0x92c00318;
     constexpr unsigned int GB_TILE_MODE31_GEN0                                = 0x00000000;
     constexpr unsigned int GB_TILE_MODE31_GEN1                                = 0x00000000;
     constexpr unsigned int INST_ID_XNACK_OVERRIDE                             = 0xfffffff5;
     constexpr unsigned int IP_USB_PD_REVISION_ID                              = 0x00000000;
     constexpr unsigned int ROM_SIGNATURE                                      = 0x0000aa55;
 } // namespace Gfx101
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 namespace Gfx103PlusExclusive
 {
     constexpr unsigned int SIMM16_WAITCNT_DEPCTR_HOLD_CNT_SIZE                = 0x00000001;
     constexpr unsigned int SIMM16_WAITCNT_DEPCTR_HOLD_CNT_START               = 0x00000007;
     constexpr unsigned int SQ_WAVE_IB_DEP_HOLD_CNT_SIZE                       = 0x00000001;
 } // namespace Gfx103PlusExclusive
 #endif
 
+#if CHIP_HDR_NAVI31
+namespace Gfx104Plus
+{
+    constexpr unsigned int SIMM16_WAITCNT_EXP_CNT_START                       = 0x00000000;
+    constexpr unsigned int SIMM16_WAITCNT_LGKM_CNT_START                      = 0x00000004;
+    constexpr unsigned int SIMM16_WAITCNT_VM_CNT_SIZE                         = 0x00000006;
+    constexpr unsigned int SIMM16_WAITCNT_VM_CNT_START                        = 0x0000000a;
+} // namespace Gfx104Plus
+#endif
+
 namespace Gfx10Core
 {
     constexpr unsigned int SIMM16_WAITCNT_EXP_CNT_START                       = 0x00000004;
     constexpr unsigned int SIMM16_WAITCNT_LGKM_CNT_START                      = 0x00000008;
     constexpr unsigned int SIMM16_WAITCNT_VM_CNT_HI_SIZE                      = 0x00000002;
     constexpr unsigned int SIMM16_WAITCNT_VM_CNT_HI_START                     = 0x0000000e;
     constexpr unsigned int SIMM16_WAITCNT_VM_CNT_SIZE                         = 0x00000004;
     constexpr unsigned int SIMM16_WAITCNT_VM_CNT_START                        = 0x00000000;
 } // namespace Gfx10Core
 
@@ -15967,20 +19449,33 @@ namespace Gfx10Plus
     constexpr unsigned int SQ_WAVE_IB_DEP_SA_EXEC_SIZE                        = 0x00000002;
     constexpr unsigned int SQ_WAVE_IB_DEP_SA_M0_SIZE                          = 0x00000001;
     constexpr unsigned int SQ_WAVE_IB_DEP_SA_SDST_SIZE                        = 0x00000004;
     constexpr unsigned int SQ_WAVE_IB_DEP_VA_EXEC_SIZE                        = 0x00000002;
     constexpr unsigned int SQ_WAVE_IB_DEP_VA_SDST_SIZE                        = 0x00000004;
     constexpr unsigned int SQ_WAVE_IB_DEP_VA_SSRC_SIZE                        = 0x00000003;
     constexpr unsigned int SQ_WAVE_IB_DEP_VA_VCC_SIZE                         = 0x00000003;
     constexpr unsigned int SQ_WAVE_IB_DEP_VM_VSRC_SIZE                        = 0x00000004;
 } // namespace Gfx10Plus
 
+#if CHIP_HDR_NAVI31
+namespace Gfx11
+{
+    constexpr unsigned int CONTEXT_SPACE_END                                  = 0x0000a3ff;
+    constexpr unsigned int INST_ID_HW_TRAP_GET_TBA                            = 0xfffffff5;
+    constexpr unsigned int PFVF_SQDEC_BEGIN                                   = 0x0000a9e0;
+    constexpr unsigned int PFVF_SQDEC_END                                     = 0x0000a9ff;
+    constexpr unsigned int SIMM16_WAIT_EVENT_EXP_RDY_SIZE                     = 0x00000001;
+    constexpr unsigned int SIMM16_WAIT_EVENT_EXP_RDY_START                    = 0x00000000;
+    constexpr unsigned int SQ_WAVE_IB_DEP_VA_VDST_SIZE                        = 0x00000005;
+} // namespace Gfx11
+#endif
+
 #if CHIP_HDR_NAVI21
 namespace Nv21
 {
     constexpr unsigned int IP_I2C_M_REVISION_ID                               = 0x00000000;
     constexpr unsigned int IP_USB_PD_REVISION_ID                              = 0x00000000;
     constexpr unsigned int ROM_SIGNATURE                                      = 0x0000aa55;
 } // namespace Nv21
 #endif
 
 #if CHIP_HDR_NAVI22
@@ -16001,20 +19496,29 @@ namespace Nv23
 } // namespace Nv23
 #endif
 
 #if CHIP_HDR_NAVI24
 namespace Nv24
 {
     constexpr unsigned int ROM_SIGNATURE                                      = 0x0000aa55;
 } // namespace Nv24
 #endif
 
+#if CHIP_HDR_NAVI31
+namespace Nv31
+{
+    constexpr unsigned int IP_I2C_M_REVISION_ID                               = 0x00000000;
+    constexpr unsigned int IP_USB_PD_REVISION_ID                              = 0x00000000;
+    constexpr unsigned int ROM_SIGNATURE                                      = 0x0000aa55;
+} // namespace Nv31
+#endif
+
 namespace Rn
 {
     constexpr unsigned int AL_REVISION_ID                                     = 0x00000012;
     constexpr unsigned int EMMC_CFG_REVISION_ID                               = 0x00000000;
     constexpr unsigned int EMMC_HC_REG_REVISION_ID                            = 0x00000000;
     constexpr unsigned int ENHIOMEMAPERTURE_REVISION_ID                       = 0x00000000;
     constexpr unsigned int ILA_REG_REVISION_ID                                = 0x00000000;
     constexpr unsigned int IP_AL2AHB_DEVICE_CFG_REVISION_ID                   = 0x00000000;
     constexpr unsigned int IP_AL2AHB_HARD_ADDR_HCLK_REVISION_ID               = 0x00000000;
     constexpr unsigned int IP_AL2AHB_HARD_ADDR_REVISION_ID                    = 0x00000000;
@@ -16080,49 +19584,58 @@ namespace Vg12_Vg20_Rn
 
 enum PerfCtrId
 {
     CBPerfSelId                              = 0,
     ChaPerfSelId                             = 1,
     ChcPerfSelId                             = 2,
     ChcgPerfSelId                            = 3,
     CpcPerfcountSelId                        = 4,
     CpfPerfcountSelId                        = 5,
     CpgPerfcountSelId                        = 6,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     DfMallPerfSelId                          = 7,
 #endif
     GCRPerfSelId                             = 8,
     GdsPerfcountSelectId                     = 9,
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     Ge1PerfcountSelectId                     = 10,
     Ge2DistPerfcountSelectId                 = 11,
     Ge2SePerfcountSelectId                   = 12,
 #endif
     GePerfcountSelectId                      = 13,
     Gl1aPerfSelId                            = 14,
     Gl1cPerfSelId                            = 15,
     Gl2aPerfSelId                            = 17,
     Gl2cPerfSelId                            = 18,
     GrbmPerfSelId                            = 19,
     GrbmSe0PerfSelId                         = 20,
     GrbmSe1PerfSelId                         = 21,
     GrbmSe2PerfSelId                         = 22,
     GrbmSe3PerfSelId                         = 23,
+#if CHIP_HDR_NAVI31
+    GrbmSe4PerfSelId                         = 24,
+    GrbmSe5PerfSelId                         = 25,
+    GrbmSe6PerfSelId                         = 26,
+    GrbmSe7PerfSelId                         = 27,
+#endif
     IaPerfcountSelectId                      = 28,
     PerfcounterValsId                        = 29,
     PhPerfcntSelId                           = 30,
     RMIPerfSelId                             = 31,
     RlcPerfcounterSelId                      = 32,
     ScPerfcntSelId                           = 33,
     SdmaPerfSelId                            = 34,
     SpiPerfcntSelId                          = 35,
     SqPerfSelId                              = 36,
+#if CHIP_HDR_NAVI31
+    SqgPerfSelId                             = 37,
+#endif
     SuPerfcntSelId                           = 38,
     SxPerfcounterValsId                      = 39,
     TaPerfcountSelId                         = 40,
     TcaPerfSelId                             = 41,
     TccPerfSelId                             = 42,
     TcpPerfcountSelectId                     = 43,
     TdPerfcountSelId                         = 44,
     UTCL1PerfSelId                           = 45,
     UmcPerfcountSelectId                     = 46,
     VgtPerfcountSelectId                     = 47,
@@ -16714,13 +20227,68 @@ constexpr unsigned int Nv24MaxPerfEventIds[MaxPerfCtrId] =
     0,
     TCP_PERF_SEL_BACK_COMPAT_SWITCH__GFX103,
     TD_PERF_SEL_input_bp_due_to_done_scoreboard_full__GFX103PLUSEXCLUSIVE,
     UTCL1_PERF_SEL_UTCL2_REQS_OUTSTANDING_ACCUM__NV24,
     UMC_PERF_SEL_TempCnt__NV24,
     0,
     0,
 };
 #endif
 
+#if CHIP_HDR_NAVI31
+constexpr unsigned int Nv31MaxPerfEventIds[MaxPerfCtrId] =
+{
+    CB_PERF_SEL_EXPORT_KILLED_BY_NULL_TARGET_SHADER_MASK__GFX11,
+    CHA_PERF_SEL_CYCLE__NV3X,
+    CHC_PERF_SEL_REQ_CLIENT23__GFX11,
+    CHCG_PERF_SEL_REQ_CLIENT23__NV3X,
+    CPC_PERF_SEL_MEC_THREAD3__GFX11,
+    CPF_PERF_SEL_CP_SDMA_MNGR_SDMABUSY__GFX11,
+    CPG_PERF_SEL_PFP_VGTDMA_DB_ROQ_DATA_STALL1__GFX11,
+    DF_MALL_PERF_SEL_MALL_SDP_LAT_HIST_GT1000__NV3X,
+    GCR_PERF_SEL_PIO_GL1_TLB_SHOOTDOWN_REQ__NV3X,
+    GDS_PERF_SEL_SE7_GS_WAVE_ID_VALID__GFX11,
+    ge1_rbiu_dr_fifo_starved_p1__GFX103COREPLUS,
+    ge_agm_gcr_combine__GFX11,
+    ge_ngg_busy_base__GFX11,
+    0,
+    GL1A_PERF_SEL_CYCLE__GFX103PLUSEXCLUSIVE,
+    GL1C_PERF_SEL_UTCL0_UTCL1_XNACK_NO_RETRY_FAULT__GFX11,
+    0,
+    GL2A_PERF_SEL_RTN_CREDIT_STALL_CLIENT15__GFX104PLUS,
+    GL2C_PERF_SEL_HIT_PASS_MISS_IN_CLIENT19__GFX11,
+    GRBM_PERF_SEL_PC_BUSY__GFX11,
+    GRBM_SE0_PERF_SEL_PC_BUSY__GFX11,
+    GRBM_SE1_PERF_SEL_PC_BUSY__GFX11,
+    GRBM_SE2_PERF_SEL_PC_BUSY__GFX11,
+    GRBM_SE3_PERF_SEL_PC_BUSY__GFX11,
+    GRBM_SE4_PERF_SEL_PC_BUSY,
+    GRBM_SE5_PERF_SEL_PC_BUSY,
+    GRBM_SE6_PERF_SEL_PC_BUSY,
+    GRBM_SE7_PERF_SEL_PC_BUSY,
+    0,
+    DB_PERF_SEL_OREO_Events_stalls__GFX11,
+    PH_PERF_SC7_FIFO_STATUS_3__GFX11,
+    RMI_PERF_SEL_CONSUMER_PROBEGEN_DB_RTS_RTR__GFX11,
+    RLC_PERF_SEL_SERDES_COMMAND_WRITE,
+    SC_SPI_WAVE_STALLED_BY_SPI__GFX11,
+    SDMA_PERF_SEL_QUEUE7_SELECT__GFX11,
+    SPI_PERF_BUSY__GFX11,
+    SQ_PERF_SEL_NONE2__GFX104PLUS,
+    SQG_PERF_SEL_DUMMY_LAST,
+    PERF_PA_BUSY__GFX11,
+    SX_PERF_SEL_DB3_4X2_DISCARD__GFX11,
+    TA_PERF_SEL_tcreq_clk_valid_cycles__GFX103PLUSEXCLUSIVE,
+    0,
+    0,
+    TCP_PERF_SEL_BURST_BIN_READHIT_gt16__GFX11,
+    TD_PERF_SEL_store_preempts_a_load__GFX11,
+    UTCL1_PERF_SEL_ALOG_STALL_PMM_CREDITS__GFX11,
+    UMC_PERF_SEL_ClockCount__NV3X,
+    0,
+    0,
+};
+#endif
+
 } // inline namespace Chip
 } // namespace Gfx9
 } // namespace Pal
diff --git a/lgc/imported/chip/gfx9/gfx9_plus_merged_offset.h b/lgc/imported/chip/gfx9/gfx9_plus_merged_offset.h
index 07cad03b1..763a47f49 100644
--- a/lgc/imported/chip/gfx9/gfx9_plus_merged_offset.h
+++ b/lgc/imported/chip/gfx9/gfx9_plus_merged_offset.h
@@ -2359,21 +2359,21 @@ namespace Gfx103
     constexpr unsigned int mmATC_PERFCOUNTER2_CFG                             = 0x0C12;
     constexpr unsigned int mmATC_PERFCOUNTER3_CFG                             = 0x0C13;
     constexpr unsigned int mmATC_PERFCOUNTER_HI                               = 0x0C16;
     constexpr unsigned int mmATC_PERFCOUNTER_LO                               = 0x0C15;
     constexpr unsigned int mmATC_PERFCOUNTER_RSLT_CNTL                        = 0x0C14;
     constexpr unsigned int mmRPB_PERF_COUNTER_CNTL                            = 0x0CE7;
     constexpr unsigned int mmSQ_THREAD_TRACE_STATUS2                          = 0x234F;
 } // namespace Gfx103
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 namespace Gfx103CorePlus
 {
     constexpr unsigned int mmGCEA_PERFCOUNTER0_CFG                            = 0xDA03;
     constexpr unsigned int mmGCEA_PERFCOUNTER1_CFG                            = 0xDA04;
     constexpr unsigned int mmGCEA_PERFCOUNTER_HI                              = 0xD263;
     constexpr unsigned int mmGCEA_PERFCOUNTER_LO                              = 0xD262;
     constexpr unsigned int mmGCEA_PERFCOUNTER_RSLT_CNTL                       = 0xDA05;
     constexpr unsigned int mmGDS_PERFCOUNTER1_SELECT1                         = 0xDA85;
     constexpr unsigned int mmGDS_PERFCOUNTER2_SELECT1                         = 0xDA86;
     constexpr unsigned int mmGDS_PERFCOUNTER3_SELECT1                         = 0xDA87;
@@ -2438,34 +2438,34 @@ namespace Gfx103Derivative
     constexpr unsigned int mmSPI_IND_INDEX                                    = 0xF052;
     constexpr unsigned int mmSPI_USER_ACCUM_VMID_CNTL                         = 0x244B;
     constexpr unsigned int mmSQ_SHADER_TBA_HI                                 = 0x2313;
     constexpr unsigned int mmSQ_SHADER_TBA_LO                                 = 0x2312;
     constexpr unsigned int mmSQ_SHADER_TMA_HI                                 = 0x2315;
     constexpr unsigned int mmSQ_SHADER_TMA_LO                                 = 0x2314;
     constexpr unsigned int mmVGT_CACHE_INVALIDATION                           = 0x2220;
 } // namespace Gfx103Derivative
 #endif
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 namespace Gfx103Plus
 {
     constexpr unsigned int mmDB_SPI_VRS_CENTER_LOCATION                       = 0xA018;
     constexpr unsigned int mmGE_VRS_RATE                                      = 0xC263;
     constexpr unsigned int mmPA_CL_VRS_CNTL                                   = 0xA212;
     constexpr unsigned int mmSPI_BARYC_SSAA_CNTL                              = 0xA1B7;
     constexpr unsigned int mmSPI_CS_CRAWLER_CONFIG                            = 0x24F7;
     constexpr unsigned int mmSPI_GFX_CRAWLER_CONFIG                           = 0x24F6;
     constexpr unsigned int mmSPI_WF_LIFETIME_STATUS_21                        = 0x24CB;
 } // namespace Gfx103Plus
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 namespace Gfx103PlusExclusive
 {
     constexpr unsigned int mmDB_RESERVED_REG_1                                = 0xA016;
     constexpr unsigned int mmDB_RESERVED_REG_2                                = 0xA00F;
     constexpr unsigned int mmDB_RESERVED_REG_3                                = 0xA017;
     constexpr unsigned int mmGE1_PERFCOUNTER0_HI                              = 0xD0A5;
     constexpr unsigned int mmGE1_PERFCOUNTER0_LO                              = 0xD0A4;
     constexpr unsigned int mmGE1_PERFCOUNTER0_SELECT                          = 0xD8A4;
     constexpr unsigned int mmGE1_PERFCOUNTER0_SELECT1                         = 0xD8A5;
     constexpr unsigned int mmGE1_PERFCOUNTER1_HI                              = 0xD0A7;
@@ -2516,20 +2516,49 @@ namespace Gfx103PlusExclusive
     constexpr unsigned int mmSPI_EXP_THROTTLE_CTRL                            = 0x2723;
     constexpr unsigned int mmSPI_WF_ACTIVE_COUNT_GFX                          = 0x24E8;
     constexpr unsigned int mmSPI_WF_ACTIVE_COUNT_HPG                          = 0x24E9;
     constexpr unsigned int mmSQ_CLK_CTRL                                      = 0xF091;
     constexpr unsigned int mmSQ_INTERRUPT_AUTO_MASK                           = 0x231E;
     constexpr unsigned int mmSQ_INTERRUPT_MSG_CTRL                            = 0x231F;
     constexpr unsigned int mmSX_PS_DOWNCONVERT_CONTROL                        = 0xA1D4;
 } // namespace Gfx103PlusExclusive
 #endif
 
+#if CHIP_HDR_NAVI31
+namespace Gfx104Plus
+{
+    constexpr unsigned int mmGE_RATE_CNTL_1                                   = 0x2254;
+    constexpr unsigned int mmGE_RATE_CNTL_2                                   = 0x2255;
+    constexpr unsigned int mmPA_RATE_CNTL                                     = 0xA188;
+    constexpr unsigned int mmPA_SC_BINNER_CNTL_2                              = 0xA315;
+    constexpr unsigned int mmRLC_SPM_GFXCLOCK_HIGHCOUNT                       = 0xDCA5;
+    constexpr unsigned int mmRLC_SPM_GFXCLOCK_LOWCOUNT                        = 0xDCA4;
+    constexpr unsigned int mmSPI_WAVE_LIMIT_CNTL                              = 0xC443;
+    constexpr unsigned int mmSQ_THREAD_TRACE_BUF0_BASE                        = 0xD9E8;
+    constexpr unsigned int mmSQ_THREAD_TRACE_BUF0_SIZE                        = 0xD9E9;
+    constexpr unsigned int mmSQ_THREAD_TRACE_BUF1_BASE                        = 0xD9EA;
+    constexpr unsigned int mmSQ_THREAD_TRACE_BUF1_SIZE                        = 0xD9EB;
+    constexpr unsigned int mmSQ_THREAD_TRACE_CTRL                             = 0xD9EC;
+    constexpr unsigned int mmSQ_THREAD_TRACE_DROPPED_CNTR                     = 0xD9FA;
+    constexpr unsigned int mmSQ_THREAD_TRACE_GFX_DRAW_CNTR                    = 0xD9F6;
+    constexpr unsigned int mmSQ_THREAD_TRACE_GFX_MARKER_CNTR                  = 0xD9F7;
+    constexpr unsigned int mmSQ_THREAD_TRACE_HP3D_DRAW_CNTR                   = 0xD9F8;
+    constexpr unsigned int mmSQ_THREAD_TRACE_HP3D_MARKER_CNTR                 = 0xD9F9;
+    constexpr unsigned int mmSQ_THREAD_TRACE_MASK                             = 0xD9ED;
+    constexpr unsigned int mmSQ_THREAD_TRACE_STATUS                           = 0xD9F4;
+    constexpr unsigned int mmSQ_THREAD_TRACE_STATUS2                          = 0xD9F5;
+    constexpr unsigned int mmSQ_THREAD_TRACE_TOKEN_MASK                       = 0xD9EE;
+    constexpr unsigned int mmSQ_THREAD_TRACE_WPTR                             = 0xD9EF;
+    constexpr unsigned int mmVGT_TF_MEMORY_BASE_HI                            = 0xC261;
+} // namespace Gfx104Plus
+#endif
+
 namespace Gfx10Core
 {
     constexpr unsigned int mmCB_COLOR0_CMASK_SLICE                            = 0xA320;
     constexpr unsigned int mmCB_COLOR0_FMASK_SLICE                            = 0xA322;
     constexpr unsigned int mmCB_COLOR0_PITCH                                  = 0xA319;
     constexpr unsigned int mmCB_COLOR0_SLICE                                  = 0xA31A;
     constexpr unsigned int mmCB_COLOR1_CMASK_SLICE                            = 0xA32F;
     constexpr unsigned int mmCB_COLOR1_FMASK_SLICE                            = 0xA331;
     constexpr unsigned int mmCB_COLOR1_PITCH                                  = 0xA328;
     constexpr unsigned int mmCB_COLOR1_SLICE                                  = 0xA329;
@@ -2968,20 +2997,521 @@ namespace Gfx10Vrs
     constexpr unsigned int mmRLC_SPM_ACCUM_SWA_DATARAM_ADDR                   = 0xDCA9;
     constexpr unsigned int mmRLC_SPM_ACCUM_SWA_DATARAM_DATA                   = 0xDCAA;
     constexpr unsigned int mmRLC_SPM_GLOBAL_MUXSEL_ADDR_OFFSET                = 0xDCA7;
     constexpr unsigned int mmRLC_SPM_PERFMON_SWA_GLB_SEGMENT_SIZE             = 0xDCAC;
     constexpr unsigned int mmRLC_SPM_PERFMON_SWA_SE3TO0_SEGMENT_SIZE          = 0xDCA6;
     constexpr unsigned int mmRLC_SPM_PERFMON_SWA_SEGMENT_SIZE                 = 0xDCA2;
     constexpr unsigned int mmRLC_SPM_SE_MUXSEL_ADDR_OFFSET                    = 0xDCA8;
 } // namespace Gfx10Vrs
 #endif
 
+#if CHIP_HDR_NAVI31
+namespace Gfx11
+{
+    constexpr unsigned int mmCB_DCC_CONFIG2                                   = 0x268B;
+    constexpr unsigned int mmCB_FDCC_CONTROL                                  = 0xA109;
+    constexpr unsigned int mmCB_FGCG_SRAM_OVERRIDE                            = 0x268A;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_0                                = 0x267A;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_1                                = 0x267B;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_2                                = 0x267C;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_3                                = 0x267D;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_4                                = 0x267E;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_5                                = 0x267F;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_6                                = 0x2680;
+    constexpr unsigned int mmCB_KEY_OVERRIDE_7                                = 0x2681;
+    constexpr unsigned int mmCOMPUTE_DISPATCH_INTERLEAVE                      = 0x2E2F;
+    constexpr unsigned int mmCOMPUTE_RELAUNCH                                 = 0x2E30;
+    constexpr unsigned int mmCOMPUTE_RELAUNCH2                                = 0x2E33;
+    constexpr unsigned int mmCOMPUTE_STATIC_THREAD_MGMT_SE4                   = 0x2E2B;
+    constexpr unsigned int mmCOMPUTE_STATIC_THREAD_MGMT_SE5                   = 0x2E2C;
+    constexpr unsigned int mmCOMPUTE_STATIC_THREAD_MGMT_SE6                   = 0x2E2D;
+    constexpr unsigned int mmCOMPUTE_STATIC_THREAD_MGMT_SE7                   = 0x2E2E;
+    constexpr unsigned int mmCOMPUTE_WAVE_RESTORE_ADDR_HI                     = 0x2E32;
+    constexpr unsigned int mmCOMPUTE_WAVE_RESTORE_ADDR_LO                     = 0x2E31;
+    constexpr unsigned int mmCP_VGT_ASINVOC_COUNT_HI                          = 0xC033;
+    constexpr unsigned int mmCP_VGT_ASINVOC_COUNT_LO                          = 0xC032;
+    constexpr unsigned int mmDB_FIFO_DEPTH4                                   = 0x2639;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER0_CFG                      = 0xDD30;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER1_CFG                      = 0xDD31;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER2_CFG                      = 0xDD32;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER3_CFG                      = 0xDD33;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER4_CFG                      = 0xDD34;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER5_CFG                      = 0xDD35;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER6_CFG                      = 0xDD36;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER7_CFG                      = 0xDD37;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER_HI                        = 0xD4E5;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER_LO                        = 0xD4E4;
+    constexpr unsigned int mmGCMC_VM_L2_PERFCOUNTER_RSLT_CNTL                 = 0xDD38;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_0_HI                         = 0xD4E2;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_0_LO                         = 0xD4E0;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_0_MODE                       = 0xDD24;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_0_SELECT                     = 0xDD20;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_0_SELECT1                    = 0xDD22;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_1_HI                         = 0xD4E3;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_1_LO                         = 0xD4E1;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_1_MODE                       = 0xDD25;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_1_SELECT                     = 0xDD21;
+    constexpr unsigned int mmGCVML2_PERFCOUNTER2_1_SELECT1                    = 0xDD23;
+    constexpr unsigned int mmGE_GS_FAST_LAUNCH_WG_DIM                         = 0xC264;
+    constexpr unsigned int mmGE_GS_FAST_LAUNCH_WG_DIM_1                       = 0xC265;
+    constexpr unsigned int mmGE_PA_IF_SAFE_REG                                = 0x2279;
+    constexpr unsigned int mmGE_SPI_IF_SAFE_REG                               = 0x2278;
+    constexpr unsigned int mmPA_PH_ENHANCE                                    = 0xA95F;
+    constexpr unsigned int mmPA_PH_INTERFACE_FIFO_SIZE                        = 0xA95E;
+    constexpr unsigned int mmPA_SC_ATM_CNTL                                   = 0xA94D;
+    constexpr unsigned int mmPA_SC_BINNER_CNTL_OVERRIDE                       = 0xA946;
+    constexpr unsigned int mmPA_SC_BINNER_EVENT_CNTL_0                        = 0xA950;
+    constexpr unsigned int mmPA_SC_BINNER_EVENT_CNTL_1                        = 0xA951;
+    constexpr unsigned int mmPA_SC_BINNER_EVENT_CNTL_2                        = 0xA952;
+    constexpr unsigned int mmPA_SC_BINNER_EVENT_CNTL_3                        = 0xA953;
+    constexpr unsigned int mmPA_SC_BINNER_PERF_CNTL_0                         = 0xA955;
+    constexpr unsigned int mmPA_SC_BINNER_PERF_CNTL_1                         = 0xA956;
+    constexpr unsigned int mmPA_SC_BINNER_PERF_CNTL_2                         = 0xA957;
+    constexpr unsigned int mmPA_SC_BINNER_PERF_CNTL_3                         = 0xA958;
+    constexpr unsigned int mmPA_SC_BINNER_TIMEOUT_COUNTER                     = 0xA954;
+    constexpr unsigned int mmPA_SC_DSM_CNTL                                   = 0xA948;
+    constexpr unsigned int mmPA_SC_ENHANCE                                    = 0xA941;
+    constexpr unsigned int mmPA_SC_ENHANCE_1                                  = 0xA942;
+    constexpr unsigned int mmPA_SC_ENHANCE_2                                  = 0xA943;
+    constexpr unsigned int mmPA_SC_ENHANCE_3                                  = 0xA944;
+    constexpr unsigned int mmPA_SC_FIFO_SIZE                                  = 0xA94A;
+    constexpr unsigned int mmPA_SC_FORCE_EOV_MAX_CNTS                         = 0xA94F;
+    constexpr unsigned int mmPA_SC_HP3D_TRAP_SCREEN_HV_LOCK                   = 0xA95C;
+    constexpr unsigned int mmPA_SC_IF_FIFO_SIZE                               = 0xA94B;
+    constexpr unsigned int mmPA_SC_P3D_TRAP_SCREEN_HV_LOCK                    = 0xA95B;
+    constexpr unsigned int mmPA_SC_PACKER_WAVE_ID_CNTL                        = 0xA94C;
+    constexpr unsigned int mmPA_SC_PBB_OVERRIDE_FLAG                          = 0xA947;
+    constexpr unsigned int mmPA_SC_PKR_WAVE_TABLE_CNTL                        = 0xA94E;
+    constexpr unsigned int mmPA_SC_TILE_STEERING_CREST_OVERRIDE               = 0xA949;
+    constexpr unsigned int mmPA_SC_TRAP_SCREEN_HV_LOCK                        = 0xA95D;
+    constexpr unsigned int mmPA_SC_VRS_OVERRIDE_CNTL                          = 0xA0F4;
+    constexpr unsigned int mmPA_SC_VRS_RATE_BASE                              = 0xA0FC;
+    constexpr unsigned int mmPA_SC_VRS_RATE_BASE_EXT                          = 0xA0FD;
+    constexpr unsigned int mmPA_SC_VRS_RATE_CACHE_CNTL                        = 0xA0F9;
+    constexpr unsigned int mmPA_SC_VRS_RATE_FEEDBACK_BASE                     = 0xA0F5;
+    constexpr unsigned int mmPA_SC_VRS_RATE_FEEDBACK_BASE_EXT                 = 0xA0F6;
+    constexpr unsigned int mmPA_SC_VRS_RATE_FEEDBACK_SIZE_XY                  = 0xA0F7;
+    constexpr unsigned int mmPA_SC_VRS_RATE_SIZE_XY                           = 0xA0FE;
+    constexpr unsigned int mmPA_SC_VRS_SURFACE_CNTL                           = 0xA940;
+    constexpr unsigned int mmPA_SC_VRS_SURFACE_CNTL_1                         = 0xA960;
+    constexpr unsigned int mmPerfMonCtl1                                      = 0x14341;
+    constexpr unsigned int mmPerfMonCtl2                                      = 0x14342;
+    constexpr unsigned int mmPerfMonCtl3                                      = 0x14343;
+    constexpr unsigned int mmPerfMonCtl4                                      = 0x14344;
+    constexpr unsigned int mmPerfMonCtl5                                      = 0x14345;
+    constexpr unsigned int mmPerfMonCtlClk                                    = 0x14340;
+    constexpr unsigned int mmPerfMonCtr1_Hi                                   = 0x1434B;
+    constexpr unsigned int mmPerfMonCtr1_Lo                                   = 0x1434A;
+    constexpr unsigned int mmPerfMonCtr2_Hi                                   = 0x1434D;
+    constexpr unsigned int mmPerfMonCtr2_Lo                                   = 0x1434C;
+    constexpr unsigned int mmPerfMonCtr3_Hi                                   = 0x1434F;
+    constexpr unsigned int mmPerfMonCtr3_Lo                                   = 0x1434E;
+    constexpr unsigned int mmPerfMonCtr4_Hi                                   = 0x14351;
+    constexpr unsigned int mmPerfMonCtr4_Lo                                   = 0x14350;
+    constexpr unsigned int mmPerfMonCtr5_Hi                                   = 0x14353;
+    constexpr unsigned int mmPerfMonCtr5_Lo                                   = 0x14352;
+    constexpr unsigned int mmPerfMonCtrClk_Hi                                 = 0x14349;
+    constexpr unsigned int mmPerfMonCtrClk_Lo                                 = 0x14348;
+    constexpr unsigned int mmRLC_SPM_ACCUM_CTRLRAM_ADDR                       = 0xDC96;
+    constexpr unsigned int mmRLC_SPM_ACCUM_CTRLRAM_ADDR_OFFSET                = 0xDC98;
+    constexpr unsigned int mmRLC_SPM_ACCUM_CTRLRAM_DATA                       = 0xDC97;
+    constexpr unsigned int mmRLC_SPM_ACCUM_DATARAM_32BITCNTRS_REGIONS         = 0xDC9F;
+    constexpr unsigned int mmRLC_SPM_ACCUM_DATARAM_ADDR                       = 0xDC92;
+    constexpr unsigned int mmRLC_SPM_ACCUM_DATARAM_DATA                       = 0xDC93;
+    constexpr unsigned int mmRLC_SPM_ACCUM_SWA_DATARAM_ADDR                   = 0xDC94;
+    constexpr unsigned int mmRLC_SPM_ACCUM_SWA_DATARAM_DATA                   = 0xDC95;
+    constexpr unsigned int mmRLC_SPM_GLOBAL_DELAY_IND_ADDR                    = 0xED64;
+    constexpr unsigned int mmRLC_SPM_GLOBAL_DELAY_IND_DATA                    = 0xED65;
+    constexpr unsigned int mmRLC_SPM_GLOBAL_MUXSEL_ADDR                       = 0xDC88;
+    constexpr unsigned int mmRLC_SPM_GLOBAL_MUXSEL_DATA                       = 0xDC89;
+    constexpr unsigned int mmRLC_SPM_INT_CNTL                                 = 0xA983;
+    constexpr unsigned int mmRLC_SPM_INT_INFO_1                               = 0xA985;
+    constexpr unsigned int mmRLC_SPM_INT_INFO_2                               = 0xA986;
+    constexpr unsigned int mmRLC_SPM_INT_STATUS                               = 0xA984;
+    constexpr unsigned int mmRLC_SPM_MC_CNTL                                  = 0xA982;
+    constexpr unsigned int mmRLC_SPM_MODE                                     = 0xDCAD;
+    constexpr unsigned int mmRLC_SPM_PAUSE                                    = 0xDCA2;
+    constexpr unsigned int mmRLC_SPM_PERFMON_SEGMENT_SIZE                     = 0xDC87;
+    constexpr unsigned int mmRLC_SPM_RING_WRPTR                               = 0xDC84;
+    constexpr unsigned int mmRLC_SPM_RSPM_CMD                                 = 0xDCB8;
+    constexpr unsigned int mmRLC_SPM_RSPM_CMD_ACK                             = 0xDCB9;
+    constexpr unsigned int mmRLC_SPM_RSPM_REQ_DATA_HI                         = 0xDCAF;
+    constexpr unsigned int mmRLC_SPM_RSPM_REQ_DATA_LO                         = 0xDCAE;
+    constexpr unsigned int mmRLC_SPM_RSPM_REQ_OP                              = 0xDCB0;
+    constexpr unsigned int mmRLC_SPM_RSPM_RET_DATA                            = 0xDCB1;
+    constexpr unsigned int mmRLC_SPM_RSPM_RET_OP                              = 0xDCB2;
+    constexpr unsigned int mmRLC_SPM_SAMPLE_CNT                               = 0xA981;
+    constexpr unsigned int mmRLC_SPM_SE_DELAY_IND_ADDR                        = 0xED66;
+    constexpr unsigned int mmRLC_SPM_SE_DELAY_IND_DATA                        = 0xED67;
+    constexpr unsigned int mmRLC_SPM_SE_MUXSEL_ADDR                           = 0xDC8A;
+    constexpr unsigned int mmRLC_SPM_SE_MUXSEL_DATA                           = 0xDC8B;
+    constexpr unsigned int mmRLC_SPM_SE_RSPM_REQ_DATA_HI                      = 0xDCB4;
+    constexpr unsigned int mmRLC_SPM_SE_RSPM_REQ_DATA_LO                      = 0xDCB3;
+    constexpr unsigned int mmRLC_SPM_SE_RSPM_REQ_OP                           = 0xDCB5;
+    constexpr unsigned int mmRLC_SPM_SE_RSPM_RET_DATA                         = 0xDCB6;
+    constexpr unsigned int mmRLC_SPM_SE_RSPM_RET_OP                           = 0xDCB7;
+    constexpr unsigned int mmRLC_SPM_SPARE                                    = 0xDCBF;
+    constexpr unsigned int mmRLC_SPM_STATUS                                   = 0xDCA3;
+    constexpr unsigned int mmSPI_ARB_CNTL_0                                   = 0xB949;
+    constexpr unsigned int mmSPI_ATTRIBUTE_RING_BASE                          = 0xC446;
+    constexpr unsigned int mmSPI_ATTRIBUTE_RING_SIZE                          = 0xC447;
+    constexpr unsigned int mmSPI_COMPUTE_QUEUE_RESET                          = 0x31D3;
+    constexpr unsigned int mmSPI_COMPUTE_WF_CTX_SAVE                          = 0x31D4;
+    constexpr unsigned int mmSPI_COMPUTE_WF_CTX_SAVE_STATUS                   = 0xB94E;
+    constexpr unsigned int mmSPI_FEATURE_CTRL                                 = 0xB94A;
+    constexpr unsigned int mmSPI_GFX_SCRATCH_BASE_HI                          = 0xA1BC;
+    constexpr unsigned int mmSPI_GFX_SCRATCH_BASE_LO                          = 0xA1BB;
+    constexpr unsigned int mmSPI_GS_THROTTLE_CNTL1                            = 0xC444;
+    constexpr unsigned int mmSPI_GS_THROTTLE_CNTL2                            = 0xC445;
+    constexpr unsigned int mmSPI_LB_DATA_PERWGP_WAVE_PS                       = 0x24E6;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_0                        = 0xBC00;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_1                        = 0xBC01;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_2                        = 0xBC02;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_3                        = 0xBC03;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_4                        = 0xBC04;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_5                        = 0xBC05;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_6                        = 0xBC06;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_7                        = 0xBC07;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_8                        = 0xBC08;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_9                        = 0xBC09;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_10                       = 0xBC0A;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_11                       = 0xBC0B;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_12                       = 0xBC0C;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_13                       = 0xBC0D;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_14                       = 0xBC0E;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_CU_15                       = 0xBC0F;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_0                     = 0xBC10;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_1                     = 0xBC11;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_2                     = 0xBC12;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_3                     = 0xBC13;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_4                     = 0xBC14;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_5                     = 0xBC15;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_6                     = 0xBC16;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_7                     = 0xBC17;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_8                     = 0xBC18;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_9                     = 0xBC19;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_10                    = 0xBC1A;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_11                    = 0xBC1B;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_12                    = 0xBC1C;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_13                    = 0xBC1D;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_14                    = 0xBC1E;
+    constexpr unsigned int mmSPI_RESOURCE_RESERVE_EN_CU_15                    = 0xBC1F;
+    constexpr unsigned int mmSPI_SHADER_GS_MESHLET_DIM                        = 0x2CAC;
+    constexpr unsigned int mmSPI_SHADER_GS_MESHLET_EXP_ALLOC                  = 0x2CAD;
+    constexpr unsigned int mmSPI_SHADER_RSRC_LIMIT_CTRL                       = 0xB94B;
+    constexpr unsigned int mmSPI_USER_ACCUM_VMID_CNTL                         = 0x31D1;
+    constexpr unsigned int mmSQG_GL1H_STATUS                                  = 0x2319;
+    constexpr unsigned int mmSQG_PERFCOUNTER0_HI                              = 0xD1E5;
+    constexpr unsigned int mmSQG_PERFCOUNTER0_LO                              = 0xD1E4;
+    constexpr unsigned int mmSQG_PERFCOUNTER0_SELECT                          = 0xD9D0;
+    constexpr unsigned int mmSQG_PERFCOUNTER1_HI                              = 0xD1E7;
+    constexpr unsigned int mmSQG_PERFCOUNTER1_LO                              = 0xD1E6;
+    constexpr unsigned int mmSQG_PERFCOUNTER1_SELECT                          = 0xD9D1;
+    constexpr unsigned int mmSQG_PERFCOUNTER2_HI                              = 0xD1E9;
+    constexpr unsigned int mmSQG_PERFCOUNTER2_LO                              = 0xD1E8;
+    constexpr unsigned int mmSQG_PERFCOUNTER2_SELECT                          = 0xD9D2;
+    constexpr unsigned int mmSQG_PERFCOUNTER3_HI                              = 0xD1EB;
+    constexpr unsigned int mmSQG_PERFCOUNTER3_LO                              = 0xD1EA;
+    constexpr unsigned int mmSQG_PERFCOUNTER3_SELECT                          = 0xD9D3;
+    constexpr unsigned int mmSQG_PERFCOUNTER4_HI                              = 0xD1ED;
+    constexpr unsigned int mmSQG_PERFCOUNTER4_LO                              = 0xD1EC;
+    constexpr unsigned int mmSQG_PERFCOUNTER4_SELECT                          = 0xD9D4;
+    constexpr unsigned int mmSQG_PERFCOUNTER5_HI                              = 0xD1EF;
+    constexpr unsigned int mmSQG_PERFCOUNTER5_LO                              = 0xD1EE;
+    constexpr unsigned int mmSQG_PERFCOUNTER5_SELECT                          = 0xD9D5;
+    constexpr unsigned int mmSQG_PERFCOUNTER6_HI                              = 0xD1F1;
+    constexpr unsigned int mmSQG_PERFCOUNTER6_LO                              = 0xD1F0;
+    constexpr unsigned int mmSQG_PERFCOUNTER6_SELECT                          = 0xD9D6;
+    constexpr unsigned int mmSQG_PERFCOUNTER7_HI                              = 0xD1F3;
+    constexpr unsigned int mmSQG_PERFCOUNTER7_LO                              = 0xD1F2;
+    constexpr unsigned int mmSQG_PERFCOUNTER7_SELECT                          = 0xD9D7;
+    constexpr unsigned int mmSQG_PERFCOUNTER_CTRL                             = 0xD9D8;
+    constexpr unsigned int mmSQG_PERFCOUNTER_CTRL2                            = 0xD9DA;
+    constexpr unsigned int mmSQG_PERF_SAMPLE_FINISH                           = 0xD9DB;
+    constexpr unsigned int mmSQ_PERF_SNAPSHOT_CTRL                            = 0x231B;
+    constexpr unsigned int mmSQ_RUNTIME_CONFIG                                = 0xA9E0;
+    constexpr unsigned int mmSQ_SHADER_TBA_HI                                 = 0xA9E7;
+    constexpr unsigned int mmSQ_SHADER_TBA_LO                                 = 0xA9E6;
+    constexpr unsigned int mmSQ_SHADER_TMA_HI                                 = 0xA9E9;
+    constexpr unsigned int mmSQ_SHADER_TMA_LO                                 = 0xA9E8;
+    constexpr unsigned int mmTA_CNTL2                                         = 0x2545;
+    constexpr unsigned int mmTCP_PERFCOUNTER_FILTER                           = 0xD348;
+    constexpr unsigned int mmTCP_PERFCOUNTER_FILTER2                          = 0xD349;
+    constexpr unsigned int mmTCP_PERFCOUNTER_FILTER_EN                        = 0xD34A;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl1                               = 0x14741;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl2                               = 0x14742;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl3                               = 0x14743;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl4                               = 0x14744;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl5                               = 0x14745;
+    constexpr unsigned int mmUMCCH1_PerfMonCtlClk                             = 0x14740;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr1_Hi                            = 0x1474B;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr1_Lo                            = 0x1474A;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr2_Hi                            = 0x1474D;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr2_Lo                            = 0x1474C;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr3_Hi                            = 0x1474F;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr3_Lo                            = 0x1474E;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr4_Hi                            = 0x14751;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr4_Lo                            = 0x14750;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr5_Hi                            = 0x14753;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr5_Lo                            = 0x14752;
+    constexpr unsigned int mmUMCCH1_PerfMonCtrClk_Hi                          = 0x14749;
+    constexpr unsigned int mmUMCCH1_PerfMonCtrClk_Lo                          = 0x14748;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl1                               = 0x54741;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl2                               = 0x54742;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl3                               = 0x54743;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl4                               = 0x54744;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl5                               = 0x54745;
+    constexpr unsigned int mmUMCCH3_PerfMonCtlClk                             = 0x54740;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr1_Hi                            = 0x5474B;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr1_Lo                            = 0x5474A;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr2_Hi                            = 0x5474D;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr2_Lo                            = 0x5474C;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr3_Hi                            = 0x5474F;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr3_Lo                            = 0x5474E;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr4_Hi                            = 0x54751;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr4_Lo                            = 0x54750;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr5_Hi                            = 0x54753;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr5_Lo                            = 0x54752;
+    constexpr unsigned int mmUMCCH3_PerfMonCtrClk_Hi                          = 0x54749;
+    constexpr unsigned int mmUMCCH3_PerfMonCtrClk_Lo                          = 0x54748;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl1                               = 0x94341;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl2                               = 0x94342;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl3                               = 0x94343;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl4                               = 0x94344;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl5                               = 0x94345;
+    constexpr unsigned int mmUMCCH4_PerfMonCtlClk                             = 0x94340;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr1_Hi                            = 0x9434B;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr1_Lo                            = 0x9434A;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr2_Hi                            = 0x9434D;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr2_Lo                            = 0x9434C;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr3_Hi                            = 0x9434F;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr3_Lo                            = 0x9434E;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr4_Hi                            = 0x94351;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr4_Lo                            = 0x94350;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr5_Hi                            = 0x94353;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr5_Lo                            = 0x94352;
+    constexpr unsigned int mmUMCCH4_PerfMonCtrClk_Hi                          = 0x94349;
+    constexpr unsigned int mmUMCCH4_PerfMonCtrClk_Lo                          = 0x94348;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl1                               = 0x94741;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl2                               = 0x94742;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl3                               = 0x94743;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl4                               = 0x94744;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl5                               = 0x94745;
+    constexpr unsigned int mmUMCCH5_PerfMonCtlClk                             = 0x94740;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr1_Hi                            = 0x9474B;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr1_Lo                            = 0x9474A;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr2_Hi                            = 0x9474D;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr2_Lo                            = 0x9474C;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr3_Hi                            = 0x9474F;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr3_Lo                            = 0x9474E;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr4_Hi                            = 0x94751;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr4_Lo                            = 0x94750;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr5_Hi                            = 0x94753;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr5_Lo                            = 0x94752;
+    constexpr unsigned int mmUMCCH5_PerfMonCtrClk_Hi                          = 0x94749;
+    constexpr unsigned int mmUMCCH5_PerfMonCtrClk_Lo                          = 0x94748;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl1                               = 0xD4341;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl2                               = 0xD4342;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl3                               = 0xD4343;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl4                               = 0xD4344;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl5                               = 0xD4345;
+    constexpr unsigned int mmUMCCH6_PerfMonCtlClk                             = 0xD4340;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr1_Hi                            = 0xD434B;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr1_Lo                            = 0xD434A;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr2_Hi                            = 0xD434D;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr2_Lo                            = 0xD434C;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr3_Hi                            = 0xD434F;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr3_Lo                            = 0xD434E;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr4_Hi                            = 0xD4351;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr4_Lo                            = 0xD4350;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr5_Hi                            = 0xD4353;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr5_Lo                            = 0xD4352;
+    constexpr unsigned int mmUMCCH6_PerfMonCtrClk_Hi                          = 0xD4349;
+    constexpr unsigned int mmUMCCH6_PerfMonCtrClk_Lo                          = 0xD4348;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl1                               = 0xD4741;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl2                               = 0xD4742;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl3                               = 0xD4743;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl4                               = 0xD4744;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl5                               = 0xD4745;
+    constexpr unsigned int mmUMCCH7_PerfMonCtlClk                             = 0xD4740;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr1_Hi                            = 0xD474B;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr1_Lo                            = 0xD474A;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr2_Hi                            = 0xD474D;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr2_Lo                            = 0xD474C;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr3_Hi                            = 0xD474F;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr3_Lo                            = 0xD474E;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr4_Hi                            = 0xD4751;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr4_Lo                            = 0xD4750;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr5_Hi                            = 0xD4753;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr5_Lo                            = 0xD4752;
+    constexpr unsigned int mmUMCCH7_PerfMonCtrClk_Hi                          = 0xD4749;
+    constexpr unsigned int mmUMCCH7_PerfMonCtrClk_Lo                          = 0xD4748;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl1                               = 0x114341;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl2                               = 0x114342;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl3                               = 0x114343;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl4                               = 0x114344;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl5                               = 0x114345;
+    constexpr unsigned int mmUMCCH8_PerfMonCtlClk                             = 0x114340;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr1_Hi                            = 0x11434B;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr1_Lo                            = 0x11434A;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr2_Hi                            = 0x11434D;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr2_Lo                            = 0x11434C;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr3_Hi                            = 0x11434F;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr3_Lo                            = 0x11434E;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr4_Hi                            = 0x114351;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr4_Lo                            = 0x114350;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr5_Hi                            = 0x114353;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr5_Lo                            = 0x114352;
+    constexpr unsigned int mmUMCCH8_PerfMonCtrClk_Hi                          = 0x114349;
+    constexpr unsigned int mmUMCCH8_PerfMonCtrClk_Lo                          = 0x114348;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl1                               = 0x114741;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl2                               = 0x114742;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl3                               = 0x114743;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl4                               = 0x114744;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl5                               = 0x114745;
+    constexpr unsigned int mmUMCCH9_PerfMonCtlClk                             = 0x114740;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr1_Hi                            = 0x11474B;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr1_Lo                            = 0x11474A;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr2_Hi                            = 0x11474D;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr2_Lo                            = 0x11474C;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr3_Hi                            = 0x11474F;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr3_Lo                            = 0x11474E;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr4_Hi                            = 0x114751;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr4_Lo                            = 0x114750;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr5_Hi                            = 0x114753;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr5_Lo                            = 0x114752;
+    constexpr unsigned int mmUMCCH9_PerfMonCtrClk_Hi                          = 0x114749;
+    constexpr unsigned int mmUMCCH9_PerfMonCtrClk_Lo                          = 0x114748;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl1                              = 0x154341;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl2                              = 0x154342;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl3                              = 0x154343;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl4                              = 0x154344;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl5                              = 0x154345;
+    constexpr unsigned int mmUMCCH10_PerfMonCtlClk                            = 0x154340;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr1_Hi                           = 0x15434B;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr1_Lo                           = 0x15434A;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr2_Hi                           = 0x15434D;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr2_Lo                           = 0x15434C;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr3_Hi                           = 0x15434F;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr3_Lo                           = 0x15434E;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr4_Hi                           = 0x154351;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr4_Lo                           = 0x154350;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr5_Hi                           = 0x154353;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr5_Lo                           = 0x154352;
+    constexpr unsigned int mmUMCCH10_PerfMonCtrClk_Hi                         = 0x154349;
+    constexpr unsigned int mmUMCCH10_PerfMonCtrClk_Lo                         = 0x154348;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl1                              = 0x154741;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl2                              = 0x154742;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl3                              = 0x154743;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl4                              = 0x154744;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl5                              = 0x154745;
+    constexpr unsigned int mmUMCCH11_PerfMonCtlClk                            = 0x154740;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr1_Hi                           = 0x15474B;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr1_Lo                           = 0x15474A;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr2_Hi                           = 0x15474D;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr2_Lo                           = 0x15474C;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr3_Hi                           = 0x15474F;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr3_Lo                           = 0x15474E;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr4_Hi                           = 0x154751;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr4_Lo                           = 0x154750;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr5_Hi                           = 0x154753;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr5_Lo                           = 0x154752;
+    constexpr unsigned int mmUMCCH11_PerfMonCtrClk_Hi                         = 0x154749;
+    constexpr unsigned int mmUMCCH11_PerfMonCtrClk_Lo                         = 0x154748;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl1                              = 0x194341;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl2                              = 0x194342;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl3                              = 0x194343;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl4                              = 0x194344;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl5                              = 0x194345;
+    constexpr unsigned int mmUMCCH12_PerfMonCtlClk                            = 0x194340;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr1_Hi                           = 0x19434B;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr1_Lo                           = 0x19434A;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr2_Hi                           = 0x19434D;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr2_Lo                           = 0x19434C;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr3_Hi                           = 0x19434F;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr3_Lo                           = 0x19434E;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr4_Hi                           = 0x194351;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr4_Lo                           = 0x194350;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr5_Hi                           = 0x194353;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr5_Lo                           = 0x194352;
+    constexpr unsigned int mmUMCCH12_PerfMonCtrClk_Hi                         = 0x194349;
+    constexpr unsigned int mmUMCCH12_PerfMonCtrClk_Lo                         = 0x194348;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl1                              = 0x194741;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl2                              = 0x194742;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl3                              = 0x194743;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl4                              = 0x194744;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl5                              = 0x194745;
+    constexpr unsigned int mmUMCCH13_PerfMonCtlClk                            = 0x194740;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr1_Hi                           = 0x19474B;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr1_Lo                           = 0x19474A;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr2_Hi                           = 0x19474D;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr2_Lo                           = 0x19474C;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr3_Hi                           = 0x19474F;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr3_Lo                           = 0x19474E;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr4_Hi                           = 0x194751;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr4_Lo                           = 0x194750;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr5_Hi                           = 0x194753;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr5_Lo                           = 0x194752;
+    constexpr unsigned int mmUMCCH13_PerfMonCtrClk_Hi                         = 0x194749;
+    constexpr unsigned int mmUMCCH13_PerfMonCtrClk_Lo                         = 0x194748;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl1                              = 0x1D4341;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl2                              = 0x1D4342;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl3                              = 0x1D4343;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl4                              = 0x1D4344;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl5                              = 0x1D4345;
+    constexpr unsigned int mmUMCCH14_PerfMonCtlClk                            = 0x1D4340;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr1_Hi                           = 0x1D434B;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr1_Lo                           = 0x1D434A;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr2_Hi                           = 0x1D434D;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr2_Lo                           = 0x1D434C;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr3_Hi                           = 0x1D434F;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr3_Lo                           = 0x1D434E;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr4_Hi                           = 0x1D4351;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr4_Lo                           = 0x1D4350;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr5_Hi                           = 0x1D4353;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr5_Lo                           = 0x1D4352;
+    constexpr unsigned int mmUMCCH14_PerfMonCtrClk_Hi                         = 0x1D4349;
+    constexpr unsigned int mmUMCCH14_PerfMonCtrClk_Lo                         = 0x1D4348;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl1                              = 0x1D4741;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl2                              = 0x1D4742;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl3                              = 0x1D4743;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl4                              = 0x1D4744;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl5                              = 0x1D4745;
+    constexpr unsigned int mmUMCCH15_PerfMonCtlClk                            = 0x1D4740;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr1_Hi                           = 0x1D474B;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr1_Lo                           = 0x1D474A;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr2_Hi                           = 0x1D474D;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr2_Lo                           = 0x1D474C;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr3_Hi                           = 0x1D474F;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr3_Lo                           = 0x1D474E;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr4_Hi                           = 0x1D4751;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr4_Lo                           = 0x1D4750;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr5_Hi                           = 0x1D4753;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr5_Lo                           = 0x1D4752;
+    constexpr unsigned int mmUMCCH15_PerfMonCtrClk_Hi                         = 0x1D4749;
+    constexpr unsigned int mmUMCCH15_PerfMonCtrClk_Lo                         = 0x1D4748;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER0_HI                            = 0xD5A1;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER0_LO                            = 0xD5A0;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER0_SELECT                        = 0xDDA0;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER1_HI                            = 0xD5A3;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER1_LO                            = 0xD5A2;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER1_SELECT                        = 0xDDA1;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER2_HI                            = 0xD5A5;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER2_LO                            = 0xD5A4;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER2_SELECT                        = 0xDDA2;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER3_HI                            = 0xD5A7;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER3_LO                            = 0xD5A6;
+    constexpr unsigned int mmUTCL1_PERFCOUNTER3_SELECT                        = 0xDDA3;
+    constexpr unsigned int mmVGT_GS_OUT_PRIM_TYPE                             = 0xC266;
+} // namespace Gfx11
+#endif
+
 namespace HasHwVs
 {
     constexpr unsigned int mmSPI_SHADER_LATE_ALLOC_VS                         = 0x2C47;
     constexpr unsigned int mmSPI_SHADER_PGM_HI_VS                             = 0x2C49;
     constexpr unsigned int mmSPI_SHADER_PGM_LO_VS                             = 0x2C48;
     constexpr unsigned int mmSPI_SHADER_PGM_RSRC1_VS                          = 0x2C4A;
     constexpr unsigned int mmSPI_SHADER_PGM_RSRC2_VS                          = 0x2C4B;
     constexpr unsigned int mmSPI_SHADER_PGM_RSRC3_VS                          = 0x2C46;
     constexpr unsigned int mmSPI_SHADER_USER_DATA_VS_0                        = 0x2C4C;
     constexpr unsigned int mmSPI_SHADER_USER_DATA_VS_1                        = 0x2C4D;
@@ -4170,20 +4700,596 @@ namespace Nv24
     constexpr unsigned int mmVGT_HS_OFFCHIP_PARAM_UMD                         = 0xC24F;
     constexpr unsigned int mmVGT_TF_MEMORY_BASE                               = 0x2225;
     constexpr unsigned int mmVGT_TF_MEMORY_BASE_HI                            = 0x2226;
     constexpr unsigned int mmVGT_TF_MEMORY_BASE_HI_UMD                        = 0xC261;
     constexpr unsigned int mmVGT_TF_MEMORY_BASE_UMD                           = 0xC250;
     constexpr unsigned int mmVGT_TF_RING_SIZE                                 = 0x2223;
     constexpr unsigned int mmVGT_TF_RING_SIZE_UMD                             = 0xC24E;
 } // namespace Nv24
 #endif
 
+#if CHIP_HDR_NAVI31
+namespace Nv31
+{
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi0                         = 0x12400C81;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi1                         = 0x12400C83;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi2                         = 0x12400C85;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi3                         = 0x12400C87;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi4                         = 0x12400C89;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi5                         = 0x12400C8B;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi6                         = 0x12400C8D;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlHi7                         = 0x12400C8F;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo0                         = 0x12400C80;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo1                         = 0x12400C82;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo2                         = 0x12400C84;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo3                         = 0x12400C86;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo4                         = 0x12400C88;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo5                         = 0x12400C8A;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo6                         = 0x12400C8C;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtlLo7                         = 0x12400C8E;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi0                         = 0x12400CC1;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi1                         = 0x12400CC3;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi2                         = 0x12400CC5;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi3                         = 0x12400CC7;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi4                         = 0x12400CC9;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi5                         = 0x12400CCB;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi6                         = 0x12400CCD;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrHi7                         = 0x12400CCF;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo0                         = 0x12400CC0;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo1                         = 0x12400CC2;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo2                         = 0x12400CC4;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo3                         = 0x12400CC6;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo4                         = 0x12400CC8;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo5                         = 0x12400CCA;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo6                         = 0x12400CCC;
+    constexpr unsigned int mmDF_PIE_AON_PerfMonCtrLo7                         = 0x12400CCE;
+    constexpr unsigned int mmGRBM_SE3_PERFCOUNTER_HI                          = 0xD04C;
+    constexpr unsigned int mmGRBM_SE3_PERFCOUNTER_LO                          = 0xD04B;
+    constexpr unsigned int mmGRBM_SE3_PERFCOUNTER_SELECT                      = 0xD845;
+    constexpr unsigned int mmGRBM_SE4_PERFCOUNTER_HI                          = 0xD04E;
+    constexpr unsigned int mmGRBM_SE4_PERFCOUNTER_LO                          = 0xD04D;
+    constexpr unsigned int mmGRBM_SE4_PERFCOUNTER_SELECT                      = 0xD846;
+    constexpr unsigned int mmGRBM_SE5_PERFCOUNTER_HI                          = 0xD050;
+    constexpr unsigned int mmGRBM_SE5_PERFCOUNTER_LO                          = 0xD04F;
+    constexpr unsigned int mmGRBM_SE5_PERFCOUNTER_SELECT                      = 0xD847;
+    constexpr unsigned int mmGRBM_SE6_PERFCOUNTER_HI                          = 0xD052;
+    constexpr unsigned int mmGRBM_SE6_PERFCOUNTER_LO                          = 0xD051;
+    constexpr unsigned int mmGRBM_SE6_PERFCOUNTER_SELECT                      = 0xD848;
+    constexpr unsigned int mmMP1_SMN_FPS_CNT                                  = 0x162C4;
+    constexpr unsigned int mmPerfMonCtl1                                      = 0xC400344;
+    constexpr unsigned int mmPerfMonCtl2                                      = 0xC400347;
+    constexpr unsigned int mmPerfMonCtl3                                      = 0xC40034A;
+    constexpr unsigned int mmPerfMonCtl4                                      = 0xC40034D;
+    constexpr unsigned int mmPerfMonCtl5                                      = 0xC400350;
+    constexpr unsigned int mmPerfMonCtl6                                      = 0xC400353;
+    constexpr unsigned int mmPerfMonCtl7                                      = 0xC400356;
+    constexpr unsigned int mmPerfMonCtl8                                      = 0xC400359;
+    constexpr unsigned int mmPerfMonCtl9                                      = 0xC40035C;
+    constexpr unsigned int mmPerfMonCtl10                                     = 0xC40035F;
+    constexpr unsigned int mmPerfMonCtl11                                     = 0xC400362;
+    constexpr unsigned int mmPerfMonCtl12                                     = 0xC400365;
+    constexpr unsigned int mmPerfMonCtlClk                                    = 0xC400340;
+    constexpr unsigned int mmPerfMonCtr1_Hi                                   = 0xC400346;
+    constexpr unsigned int mmPerfMonCtr1_Lo                                   = 0xC400345;
+    constexpr unsigned int mmPerfMonCtr2_Hi                                   = 0xC400349;
+    constexpr unsigned int mmPerfMonCtr2_Lo                                   = 0xC400348;
+    constexpr unsigned int mmPerfMonCtr3_Hi                                   = 0xC40034C;
+    constexpr unsigned int mmPerfMonCtr3_Lo                                   = 0xC40034B;
+    constexpr unsigned int mmPerfMonCtr4_Hi                                   = 0xC40034F;
+    constexpr unsigned int mmPerfMonCtr4_Lo                                   = 0xC40034E;
+    constexpr unsigned int mmPerfMonCtr5_Hi                                   = 0xC400352;
+    constexpr unsigned int mmPerfMonCtr5_Lo                                   = 0xC400351;
+    constexpr unsigned int mmPerfMonCtr6_Hi                                   = 0xC400355;
+    constexpr unsigned int mmPerfMonCtr6_Lo                                   = 0xC400354;
+    constexpr unsigned int mmPerfMonCtr7_Hi                                   = 0xC400358;
+    constexpr unsigned int mmPerfMonCtr7_Lo                                   = 0xC400357;
+    constexpr unsigned int mmPerfMonCtr8_Hi                                   = 0xC40035B;
+    constexpr unsigned int mmPerfMonCtr8_Lo                                   = 0xC40035A;
+    constexpr unsigned int mmPerfMonCtr9_Hi                                   = 0xC40035E;
+    constexpr unsigned int mmPerfMonCtr9_Lo                                   = 0xC40035D;
+    constexpr unsigned int mmPerfMonCtr10_Hi                                  = 0xC400361;
+    constexpr unsigned int mmPerfMonCtr10_Lo                                  = 0xC400360;
+    constexpr unsigned int mmPerfMonCtr11_Hi                                  = 0xC400364;
+    constexpr unsigned int mmPerfMonCtr11_Lo                                  = 0xC400363;
+    constexpr unsigned int mmPerfMonCtr12_Hi                                  = 0xC400367;
+    constexpr unsigned int mmPerfMonCtr12_Lo                                  = 0xC400366;
+    constexpr unsigned int mmPerfMonCtrClk_Hi                                 = 0xC400342;
+    constexpr unsigned int mmPerfMonCtrClk_Lo                                 = 0xC400341;
+    constexpr unsigned int mmRPB_PERFCOUNTER0_CFG                             = 0x0C82;
+    constexpr unsigned int mmRPB_PERFCOUNTER1_CFG                             = 0x0C83;
+    constexpr unsigned int mmRPB_PERFCOUNTER2_CFG                             = 0x0C84;
+    constexpr unsigned int mmRPB_PERFCOUNTER3_CFG                             = 0x0C85;
+    constexpr unsigned int mmRPB_PERFCOUNTER_HI                               = 0x0C81;
+    constexpr unsigned int mmRPB_PERFCOUNTER_LO                               = 0x0C80;
+    constexpr unsigned int mmRPB_PERFCOUNTER_RSLT_CNTL                        = 0x0C86;
+    constexpr unsigned int mmRPB_PERF_COUNTER_CNTL                            = 0x0C7E;
+    constexpr unsigned int mmUMCCH0_PerfMonCtl1                               = 0xC400344;
+    constexpr unsigned int mmUMCCH0_PerfMonCtl2                               = 0xC400347;
+    constexpr unsigned int mmUMCCH0_PerfMonCtl3                               = 0xC40034A;
+    constexpr unsigned int mmUMCCH0_PerfMonCtl4                               = 0xC40034D;
+    constexpr unsigned int mmUMCCH0_PerfMonCtl5                               = 0xC400350;
+    constexpr unsigned int mmUMCCH0_PerfMonCtlClk                             = 0xC400340;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr1_Hi                            = 0xC400346;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr1_Lo                            = 0xC400345;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr2_Hi                            = 0xC400349;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr2_Lo                            = 0xC400348;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr3_Hi                            = 0xC40034C;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr3_Lo                            = 0xC40034B;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr4_Hi                            = 0xC40034F;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr4_Lo                            = 0xC40034E;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr5_Hi                            = 0xC400352;
+    constexpr unsigned int mmUMCCH0_PerfMonCtr5_Lo                            = 0xC400351;
+    constexpr unsigned int mmUMCCH0_PerfMonCtrClk_Hi                          = 0xC400342;
+    constexpr unsigned int mmUMCCH0_PerfMonCtrClk_Lo                          = 0xC400341;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl1                               = 0xC400744;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl2                               = 0xC400747;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl3                               = 0xC40074A;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl4                               = 0xC40074D;
+    constexpr unsigned int mmUMCCH1_PerfMonCtl5                               = 0xC400750;
+    constexpr unsigned int mmUMCCH1_PerfMonCtlClk                             = 0xC400740;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr1_Hi                            = 0xC400746;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr1_Lo                            = 0xC400745;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr2_Hi                            = 0xC400749;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr2_Lo                            = 0xC400748;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr3_Hi                            = 0xC40074C;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr3_Lo                            = 0xC40074B;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr4_Hi                            = 0xC40074F;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr4_Lo                            = 0xC40074E;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr5_Hi                            = 0xC400752;
+    constexpr unsigned int mmUMCCH1_PerfMonCtr5_Lo                            = 0xC400751;
+    constexpr unsigned int mmUMCCH1_PerfMonCtrClk_Hi                          = 0xC400742;
+    constexpr unsigned int mmUMCCH1_PerfMonCtrClk_Lo                          = 0xC400741;
+    constexpr unsigned int mmUMCCH2_PerfMonCtl1                               = 0xC404344;
+    constexpr unsigned int mmUMCCH2_PerfMonCtl2                               = 0xC404347;
+    constexpr unsigned int mmUMCCH2_PerfMonCtl3                               = 0xC40434A;
+    constexpr unsigned int mmUMCCH2_PerfMonCtl4                               = 0xC40434D;
+    constexpr unsigned int mmUMCCH2_PerfMonCtl5                               = 0xC404350;
+    constexpr unsigned int mmUMCCH2_PerfMonCtlClk                             = 0xC404340;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr1_Hi                            = 0xC404346;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr1_Lo                            = 0xC404345;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr2_Hi                            = 0xC404349;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr2_Lo                            = 0xC404348;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr3_Hi                            = 0xC40434C;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr3_Lo                            = 0xC40434B;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr4_Hi                            = 0xC40434F;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr4_Lo                            = 0xC40434E;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr5_Hi                            = 0xC404352;
+    constexpr unsigned int mmUMCCH2_PerfMonCtr5_Lo                            = 0xC404351;
+    constexpr unsigned int mmUMCCH2_PerfMonCtrClk_Hi                          = 0xC404342;
+    constexpr unsigned int mmUMCCH2_PerfMonCtrClk_Lo                          = 0xC404341;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl1                               = 0xC404744;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl2                               = 0xC404747;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl3                               = 0xC40474A;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl4                               = 0xC40474D;
+    constexpr unsigned int mmUMCCH3_PerfMonCtl5                               = 0xC404750;
+    constexpr unsigned int mmUMCCH3_PerfMonCtlClk                             = 0xC404740;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr1_Hi                            = 0xC404746;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr1_Lo                            = 0xC404745;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr2_Hi                            = 0xC404749;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr2_Lo                            = 0xC404748;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr3_Hi                            = 0xC40474C;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr3_Lo                            = 0xC40474B;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr4_Hi                            = 0xC40474F;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr4_Lo                            = 0xC40474E;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr5_Hi                            = 0xC404752;
+    constexpr unsigned int mmUMCCH3_PerfMonCtr5_Lo                            = 0xC404751;
+    constexpr unsigned int mmUMCCH3_PerfMonCtrClk_Hi                          = 0xC404742;
+    constexpr unsigned int mmUMCCH3_PerfMonCtrClk_Lo                          = 0xC404741;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl1                               = 0xCC00344;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl2                               = 0xCC00347;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl3                               = 0xCC0034A;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl4                               = 0xCC0034D;
+    constexpr unsigned int mmUMCCH4_PerfMonCtl5                               = 0xCC00350;
+    constexpr unsigned int mmUMCCH4_PerfMonCtlClk                             = 0xCC00340;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr1_Hi                            = 0xCC00346;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr1_Lo                            = 0xCC00345;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr2_Hi                            = 0xCC00349;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr2_Lo                            = 0xCC00348;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr3_Hi                            = 0xCC0034C;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr3_Lo                            = 0xCC0034B;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr4_Hi                            = 0xCC0034F;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr4_Lo                            = 0xCC0034E;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr5_Hi                            = 0xCC00352;
+    constexpr unsigned int mmUMCCH4_PerfMonCtr5_Lo                            = 0xCC00351;
+    constexpr unsigned int mmUMCCH4_PerfMonCtrClk_Hi                          = 0xCC00342;
+    constexpr unsigned int mmUMCCH4_PerfMonCtrClk_Lo                          = 0xCC00341;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl1                               = 0xCC00744;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl2                               = 0xCC00747;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl3                               = 0xCC0074A;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl4                               = 0xCC0074D;
+    constexpr unsigned int mmUMCCH5_PerfMonCtl5                               = 0xCC00750;
+    constexpr unsigned int mmUMCCH5_PerfMonCtlClk                             = 0xCC00740;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr1_Hi                            = 0xCC00746;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr1_Lo                            = 0xCC00745;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr2_Hi                            = 0xCC00749;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr2_Lo                            = 0xCC00748;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr3_Hi                            = 0xCC0074C;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr3_Lo                            = 0xCC0074B;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr4_Hi                            = 0xCC0074F;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr4_Lo                            = 0xCC0074E;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr5_Hi                            = 0xCC00752;
+    constexpr unsigned int mmUMCCH5_PerfMonCtr5_Lo                            = 0xCC00751;
+    constexpr unsigned int mmUMCCH5_PerfMonCtrClk_Hi                          = 0xCC00742;
+    constexpr unsigned int mmUMCCH5_PerfMonCtrClk_Lo                          = 0xCC00741;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl1                               = 0xCC04344;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl2                               = 0xCC04347;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl3                               = 0xCC0434A;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl4                               = 0xCC0434D;
+    constexpr unsigned int mmUMCCH6_PerfMonCtl5                               = 0xCC04350;
+    constexpr unsigned int mmUMCCH6_PerfMonCtlClk                             = 0xCC04340;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr1_Hi                            = 0xCC04346;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr1_Lo                            = 0xCC04345;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr2_Hi                            = 0xCC04349;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr2_Lo                            = 0xCC04348;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr3_Hi                            = 0xCC0434C;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr3_Lo                            = 0xCC0434B;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr4_Hi                            = 0xCC0434F;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr4_Lo                            = 0xCC0434E;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr5_Hi                            = 0xCC04352;
+    constexpr unsigned int mmUMCCH6_PerfMonCtr5_Lo                            = 0xCC04351;
+    constexpr unsigned int mmUMCCH6_PerfMonCtrClk_Hi                          = 0xCC04342;
+    constexpr unsigned int mmUMCCH6_PerfMonCtrClk_Lo                          = 0xCC04341;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl1                               = 0xCC04744;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl2                               = 0xCC04747;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl3                               = 0xCC0474A;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl4                               = 0xCC0474D;
+    constexpr unsigned int mmUMCCH7_PerfMonCtl5                               = 0xCC04750;
+    constexpr unsigned int mmUMCCH7_PerfMonCtlClk                             = 0xCC04740;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr1_Hi                            = 0xCC04746;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr1_Lo                            = 0xCC04745;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr2_Hi                            = 0xCC04749;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr2_Lo                            = 0xCC04748;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr3_Hi                            = 0xCC0474C;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr3_Lo                            = 0xCC0474B;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr4_Hi                            = 0xCC0474F;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr4_Lo                            = 0xCC0474E;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr5_Hi                            = 0xCC04752;
+    constexpr unsigned int mmUMCCH7_PerfMonCtr5_Lo                            = 0xCC04751;
+    constexpr unsigned int mmUMCCH7_PerfMonCtrClk_Hi                          = 0xCC04742;
+    constexpr unsigned int mmUMCCH7_PerfMonCtrClk_Lo                          = 0xCC04741;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl1                               = 0xD400344;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl2                               = 0xD400347;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl3                               = 0xD40034A;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl4                               = 0xD40034D;
+    constexpr unsigned int mmUMCCH8_PerfMonCtl5                               = 0xD400350;
+    constexpr unsigned int mmUMCCH8_PerfMonCtlClk                             = 0xD400340;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr1_Hi                            = 0xD400346;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr1_Lo                            = 0xD400345;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr2_Hi                            = 0xD400349;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr2_Lo                            = 0xD400348;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr3_Hi                            = 0xD40034C;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr3_Lo                            = 0xD40034B;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr4_Hi                            = 0xD40034F;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr4_Lo                            = 0xD40034E;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr5_Hi                            = 0xD400352;
+    constexpr unsigned int mmUMCCH8_PerfMonCtr5_Lo                            = 0xD400351;
+    constexpr unsigned int mmUMCCH8_PerfMonCtrClk_Hi                          = 0xD400342;
+    constexpr unsigned int mmUMCCH8_PerfMonCtrClk_Lo                          = 0xD400341;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl1                               = 0xD400744;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl2                               = 0xD400747;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl3                               = 0xD40074A;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl4                               = 0xD40074D;
+    constexpr unsigned int mmUMCCH9_PerfMonCtl5                               = 0xD400750;
+    constexpr unsigned int mmUMCCH9_PerfMonCtlClk                             = 0xD400740;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr1_Hi                            = 0xD400746;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr1_Lo                            = 0xD400745;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr2_Hi                            = 0xD400749;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr2_Lo                            = 0xD400748;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr3_Hi                            = 0xD40074C;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr3_Lo                            = 0xD40074B;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr4_Hi                            = 0xD40074F;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr4_Lo                            = 0xD40074E;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr5_Hi                            = 0xD400752;
+    constexpr unsigned int mmUMCCH9_PerfMonCtr5_Lo                            = 0xD400751;
+    constexpr unsigned int mmUMCCH9_PerfMonCtrClk_Hi                          = 0xD400742;
+    constexpr unsigned int mmUMCCH9_PerfMonCtrClk_Lo                          = 0xD400741;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl1                              = 0xD404344;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl2                              = 0xD404347;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl3                              = 0xD40434A;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl4                              = 0xD40434D;
+    constexpr unsigned int mmUMCCH10_PerfMonCtl5                              = 0xD404350;
+    constexpr unsigned int mmUMCCH10_PerfMonCtlClk                            = 0xD404340;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr1_Hi                           = 0xD404346;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr1_Lo                           = 0xD404345;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr2_Hi                           = 0xD404349;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr2_Lo                           = 0xD404348;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr3_Hi                           = 0xD40434C;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr3_Lo                           = 0xD40434B;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr4_Hi                           = 0xD40434F;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr4_Lo                           = 0xD40434E;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr5_Hi                           = 0xD404352;
+    constexpr unsigned int mmUMCCH10_PerfMonCtr5_Lo                           = 0xD404351;
+    constexpr unsigned int mmUMCCH10_PerfMonCtrClk_Hi                         = 0xD404342;
+    constexpr unsigned int mmUMCCH10_PerfMonCtrClk_Lo                         = 0xD404341;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl1                              = 0xD404744;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl2                              = 0xD404747;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl3                              = 0xD40474A;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl4                              = 0xD40474D;
+    constexpr unsigned int mmUMCCH11_PerfMonCtl5                              = 0xD404750;
+    constexpr unsigned int mmUMCCH11_PerfMonCtlClk                            = 0xD404740;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr1_Hi                           = 0xD404746;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr1_Lo                           = 0xD404745;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr2_Hi                           = 0xD404749;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr2_Lo                           = 0xD404748;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr3_Hi                           = 0xD40474C;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr3_Lo                           = 0xD40474B;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr4_Hi                           = 0xD40474F;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr4_Lo                           = 0xD40474E;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr5_Hi                           = 0xD404752;
+    constexpr unsigned int mmUMCCH11_PerfMonCtr5_Lo                           = 0xD404751;
+    constexpr unsigned int mmUMCCH11_PerfMonCtrClk_Hi                         = 0xD404742;
+    constexpr unsigned int mmUMCCH11_PerfMonCtrClk_Lo                         = 0xD404741;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl1                              = 0xDC00344;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl2                              = 0xDC00347;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl3                              = 0xDC0034A;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl4                              = 0xDC0034D;
+    constexpr unsigned int mmUMCCH12_PerfMonCtl5                              = 0xDC00350;
+    constexpr unsigned int mmUMCCH12_PerfMonCtlClk                            = 0xDC00340;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr1_Hi                           = 0xDC00346;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr1_Lo                           = 0xDC00345;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr2_Hi                           = 0xDC00349;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr2_Lo                           = 0xDC00348;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr3_Hi                           = 0xDC0034C;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr3_Lo                           = 0xDC0034B;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr4_Hi                           = 0xDC0034F;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr4_Lo                           = 0xDC0034E;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr5_Hi                           = 0xDC00352;
+    constexpr unsigned int mmUMCCH12_PerfMonCtr5_Lo                           = 0xDC00351;
+    constexpr unsigned int mmUMCCH12_PerfMonCtrClk_Hi                         = 0xDC00342;
+    constexpr unsigned int mmUMCCH12_PerfMonCtrClk_Lo                         = 0xDC00341;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl1                              = 0xDC00744;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl2                              = 0xDC00747;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl3                              = 0xDC0074A;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl4                              = 0xDC0074D;
+    constexpr unsigned int mmUMCCH13_PerfMonCtl5                              = 0xDC00750;
+    constexpr unsigned int mmUMCCH13_PerfMonCtlClk                            = 0xDC00740;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr1_Hi                           = 0xDC00746;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr1_Lo                           = 0xDC00745;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr2_Hi                           = 0xDC00749;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr2_Lo                           = 0xDC00748;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr3_Hi                           = 0xDC0074C;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr3_Lo                           = 0xDC0074B;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr4_Hi                           = 0xDC0074F;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr4_Lo                           = 0xDC0074E;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr5_Hi                           = 0xDC00752;
+    constexpr unsigned int mmUMCCH13_PerfMonCtr5_Lo                           = 0xDC00751;
+    constexpr unsigned int mmUMCCH13_PerfMonCtrClk_Hi                         = 0xDC00742;
+    constexpr unsigned int mmUMCCH13_PerfMonCtrClk_Lo                         = 0xDC00741;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl1                              = 0xDC04344;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl2                              = 0xDC04347;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl3                              = 0xDC0434A;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl4                              = 0xDC0434D;
+    constexpr unsigned int mmUMCCH14_PerfMonCtl5                              = 0xDC04350;
+    constexpr unsigned int mmUMCCH14_PerfMonCtlClk                            = 0xDC04340;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr1_Hi                           = 0xDC04346;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr1_Lo                           = 0xDC04345;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr2_Hi                           = 0xDC04349;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr2_Lo                           = 0xDC04348;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr3_Hi                           = 0xDC0434C;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr3_Lo                           = 0xDC0434B;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr4_Hi                           = 0xDC0434F;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr4_Lo                           = 0xDC0434E;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr5_Hi                           = 0xDC04352;
+    constexpr unsigned int mmUMCCH14_PerfMonCtr5_Lo                           = 0xDC04351;
+    constexpr unsigned int mmUMCCH14_PerfMonCtrClk_Hi                         = 0xDC04342;
+    constexpr unsigned int mmUMCCH14_PerfMonCtrClk_Lo                         = 0xDC04341;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl1                              = 0xDC04744;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl2                              = 0xDC04747;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl3                              = 0xDC0474A;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl4                              = 0xDC0474D;
+    constexpr unsigned int mmUMCCH15_PerfMonCtl5                              = 0xDC04750;
+    constexpr unsigned int mmUMCCH15_PerfMonCtlClk                            = 0xDC04740;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr1_Hi                           = 0xDC04746;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr1_Lo                           = 0xDC04745;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr2_Hi                           = 0xDC04749;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr2_Lo                           = 0xDC04748;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr3_Hi                           = 0xDC0474C;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr3_Lo                           = 0xDC0474B;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr4_Hi                           = 0xDC0474F;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr4_Lo                           = 0xDC0474E;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr5_Hi                           = 0xDC04752;
+    constexpr unsigned int mmUMCCH15_PerfMonCtr5_Lo                           = 0xDC04751;
+    constexpr unsigned int mmUMCCH15_PerfMonCtrClk_Hi                         = 0xDC04742;
+    constexpr unsigned int mmUMCCH15_PerfMonCtrClk_Lo                         = 0xDC04741;
+    constexpr unsigned int mmUMCCH16_PerfMonCtl1                              = 0xE400344;
+    constexpr unsigned int mmUMCCH16_PerfMonCtl2                              = 0xE400347;
+    constexpr unsigned int mmUMCCH16_PerfMonCtl3                              = 0xE40034A;
+    constexpr unsigned int mmUMCCH16_PerfMonCtl4                              = 0xE40034D;
+    constexpr unsigned int mmUMCCH16_PerfMonCtl5                              = 0xE400350;
+    constexpr unsigned int mmUMCCH16_PerfMonCtlClk                            = 0xE400340;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr1_Hi                           = 0xE400346;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr1_Lo                           = 0xE400345;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr2_Hi                           = 0xE400349;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr2_Lo                           = 0xE400348;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr3_Hi                           = 0xE40034C;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr3_Lo                           = 0xE40034B;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr4_Hi                           = 0xE40034F;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr4_Lo                           = 0xE40034E;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr5_Hi                           = 0xE400352;
+    constexpr unsigned int mmUMCCH16_PerfMonCtr5_Lo                           = 0xE400351;
+    constexpr unsigned int mmUMCCH16_PerfMonCtrClk_Hi                         = 0xE400342;
+    constexpr unsigned int mmUMCCH16_PerfMonCtrClk_Lo                         = 0xE400341;
+    constexpr unsigned int mmUMCCH17_PerfMonCtl1                              = 0xE400744;
+    constexpr unsigned int mmUMCCH17_PerfMonCtl2                              = 0xE400747;
+    constexpr unsigned int mmUMCCH17_PerfMonCtl3                              = 0xE40074A;
+    constexpr unsigned int mmUMCCH17_PerfMonCtl4                              = 0xE40074D;
+    constexpr unsigned int mmUMCCH17_PerfMonCtl5                              = 0xE400750;
+    constexpr unsigned int mmUMCCH17_PerfMonCtlClk                            = 0xE400740;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr1_Hi                           = 0xE400746;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr1_Lo                           = 0xE400745;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr2_Hi                           = 0xE400749;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr2_Lo                           = 0xE400748;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr3_Hi                           = 0xE40074C;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr3_Lo                           = 0xE40074B;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr4_Hi                           = 0xE40074F;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr4_Lo                           = 0xE40074E;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr5_Hi                           = 0xE400752;
+    constexpr unsigned int mmUMCCH17_PerfMonCtr5_Lo                           = 0xE400751;
+    constexpr unsigned int mmUMCCH17_PerfMonCtrClk_Hi                         = 0xE400742;
+    constexpr unsigned int mmUMCCH17_PerfMonCtrClk_Lo                         = 0xE400741;
+    constexpr unsigned int mmUMCCH18_PerfMonCtl1                              = 0xE404344;
+    constexpr unsigned int mmUMCCH18_PerfMonCtl2                              = 0xE404347;
+    constexpr unsigned int mmUMCCH18_PerfMonCtl3                              = 0xE40434A;
+    constexpr unsigned int mmUMCCH18_PerfMonCtl4                              = 0xE40434D;
+    constexpr unsigned int mmUMCCH18_PerfMonCtl5                              = 0xE404350;
+    constexpr unsigned int mmUMCCH18_PerfMonCtlClk                            = 0xE404340;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr1_Hi                           = 0xE404346;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr1_Lo                           = 0xE404345;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr2_Hi                           = 0xE404349;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr2_Lo                           = 0xE404348;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr3_Hi                           = 0xE40434C;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr3_Lo                           = 0xE40434B;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr4_Hi                           = 0xE40434F;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr4_Lo                           = 0xE40434E;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr5_Hi                           = 0xE404352;
+    constexpr unsigned int mmUMCCH18_PerfMonCtr5_Lo                           = 0xE404351;
+    constexpr unsigned int mmUMCCH18_PerfMonCtrClk_Hi                         = 0xE404342;
+    constexpr unsigned int mmUMCCH18_PerfMonCtrClk_Lo                         = 0xE404341;
+    constexpr unsigned int mmUMCCH19_PerfMonCtl1                              = 0xE404744;
+    constexpr unsigned int mmUMCCH19_PerfMonCtl2                              = 0xE404747;
+    constexpr unsigned int mmUMCCH19_PerfMonCtl3                              = 0xE40474A;
+    constexpr unsigned int mmUMCCH19_PerfMonCtl4                              = 0xE40474D;
+    constexpr unsigned int mmUMCCH19_PerfMonCtl5                              = 0xE404750;
+    constexpr unsigned int mmUMCCH19_PerfMonCtlClk                            = 0xE404740;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr1_Hi                           = 0xE404746;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr1_Lo                           = 0xE404745;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr2_Hi                           = 0xE404749;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr2_Lo                           = 0xE404748;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr3_Hi                           = 0xE40474C;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr3_Lo                           = 0xE40474B;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr4_Hi                           = 0xE40474F;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr4_Lo                           = 0xE40474E;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr5_Hi                           = 0xE404752;
+    constexpr unsigned int mmUMCCH19_PerfMonCtr5_Lo                           = 0xE404751;
+    constexpr unsigned int mmUMCCH19_PerfMonCtrClk_Hi                         = 0xE404742;
+    constexpr unsigned int mmUMCCH19_PerfMonCtrClk_Lo                         = 0xE404741;
+    constexpr unsigned int mmUMCCH20_PerfMonCtl1                              = 0xEC00344;
+    constexpr unsigned int mmUMCCH20_PerfMonCtl2                              = 0xEC00347;
+    constexpr unsigned int mmUMCCH20_PerfMonCtl3                              = 0xEC0034A;
+    constexpr unsigned int mmUMCCH20_PerfMonCtl4                              = 0xEC0034D;
+    constexpr unsigned int mmUMCCH20_PerfMonCtl5                              = 0xEC00350;
+    constexpr unsigned int mmUMCCH20_PerfMonCtlClk                            = 0xEC00340;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr1_Hi                           = 0xEC00346;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr1_Lo                           = 0xEC00345;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr2_Hi                           = 0xEC00349;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr2_Lo                           = 0xEC00348;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr3_Hi                           = 0xEC0034C;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr3_Lo                           = 0xEC0034B;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr4_Hi                           = 0xEC0034F;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr4_Lo                           = 0xEC0034E;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr5_Hi                           = 0xEC00352;
+    constexpr unsigned int mmUMCCH20_PerfMonCtr5_Lo                           = 0xEC00351;
+    constexpr unsigned int mmUMCCH20_PerfMonCtrClk_Hi                         = 0xEC00342;
+    constexpr unsigned int mmUMCCH20_PerfMonCtrClk_Lo                         = 0xEC00341;
+    constexpr unsigned int mmUMCCH21_PerfMonCtl1                              = 0xEC00744;
+    constexpr unsigned int mmUMCCH21_PerfMonCtl2                              = 0xEC00747;
+    constexpr unsigned int mmUMCCH21_PerfMonCtl3                              = 0xEC0074A;
+    constexpr unsigned int mmUMCCH21_PerfMonCtl4                              = 0xEC0074D;
+    constexpr unsigned int mmUMCCH21_PerfMonCtl5                              = 0xEC00750;
+    constexpr unsigned int mmUMCCH21_PerfMonCtlClk                            = 0xEC00740;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr1_Hi                           = 0xEC00746;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr1_Lo                           = 0xEC00745;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr2_Hi                           = 0xEC00749;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr2_Lo                           = 0xEC00748;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr3_Hi                           = 0xEC0074C;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr3_Lo                           = 0xEC0074B;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr4_Hi                           = 0xEC0074F;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr4_Lo                           = 0xEC0074E;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr5_Hi                           = 0xEC00752;
+    constexpr unsigned int mmUMCCH21_PerfMonCtr5_Lo                           = 0xEC00751;
+    constexpr unsigned int mmUMCCH21_PerfMonCtrClk_Hi                         = 0xEC00742;
+    constexpr unsigned int mmUMCCH21_PerfMonCtrClk_Lo                         = 0xEC00741;
+    constexpr unsigned int mmUMCCH22_PerfMonCtl1                              = 0xEC04344;
+    constexpr unsigned int mmUMCCH22_PerfMonCtl2                              = 0xEC04347;
+    constexpr unsigned int mmUMCCH22_PerfMonCtl3                              = 0xEC0434A;
+    constexpr unsigned int mmUMCCH22_PerfMonCtl4                              = 0xEC0434D;
+    constexpr unsigned int mmUMCCH22_PerfMonCtl5                              = 0xEC04350;
+    constexpr unsigned int mmUMCCH22_PerfMonCtlClk                            = 0xEC04340;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr1_Hi                           = 0xEC04346;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr1_Lo                           = 0xEC04345;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr2_Hi                           = 0xEC04349;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr2_Lo                           = 0xEC04348;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr3_Hi                           = 0xEC0434C;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr3_Lo                           = 0xEC0434B;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr4_Hi                           = 0xEC0434F;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr4_Lo                           = 0xEC0434E;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr5_Hi                           = 0xEC04352;
+    constexpr unsigned int mmUMCCH22_PerfMonCtr5_Lo                           = 0xEC04351;
+    constexpr unsigned int mmUMCCH22_PerfMonCtrClk_Hi                         = 0xEC04342;
+    constexpr unsigned int mmUMCCH22_PerfMonCtrClk_Lo                         = 0xEC04341;
+    constexpr unsigned int mmUMCCH23_PerfMonCtl1                              = 0xEC04744;
+    constexpr unsigned int mmUMCCH23_PerfMonCtl2                              = 0xEC04747;
+    constexpr unsigned int mmUMCCH23_PerfMonCtl3                              = 0xEC0474A;
+    constexpr unsigned int mmUMCCH23_PerfMonCtl4                              = 0xEC0474D;
+    constexpr unsigned int mmUMCCH23_PerfMonCtl5                              = 0xEC04750;
+    constexpr unsigned int mmUMCCH23_PerfMonCtlClk                            = 0xEC04740;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr1_Hi                           = 0xEC04746;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr1_Lo                           = 0xEC04745;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr2_Hi                           = 0xEC04749;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr2_Lo                           = 0xEC04748;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr3_Hi                           = 0xEC0474C;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr3_Lo                           = 0xEC0474B;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr4_Hi                           = 0xEC0474F;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr4_Lo                           = 0xEC0474E;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr5_Hi                           = 0xEC04752;
+    constexpr unsigned int mmUMCCH23_PerfMonCtr5_Lo                           = 0xEC04751;
+    constexpr unsigned int mmUMCCH23_PerfMonCtrClk_Hi                         = 0xEC04742;
+    constexpr unsigned int mmUMCCH23_PerfMonCtrClk_Lo                         = 0xEC04741;
+} // namespace Nv31
+#endif
+
+#if CHIP_HDR_NAVI31
+namespace Nv3x
+{
+    constexpr unsigned int mmCHCG_PERFCOUNTER0_HI                             = 0xD3C9;
+    constexpr unsigned int mmCHCG_PERFCOUNTER0_LO                             = 0xD3C8;
+    constexpr unsigned int mmCHCG_PERFCOUNTER0_SELECT                         = 0xDBC6;
+    constexpr unsigned int mmCHCG_PERFCOUNTER0_SELECT1                        = 0xDBC7;
+    constexpr unsigned int mmCHCG_PERFCOUNTER1_HI                             = 0xD3CB;
+    constexpr unsigned int mmCHCG_PERFCOUNTER1_LO                             = 0xD3CA;
+    constexpr unsigned int mmCHCG_PERFCOUNTER1_SELECT                         = 0xDBC8;
+    constexpr unsigned int mmCHCG_PERFCOUNTER2_HI                             = 0xD3CD;
+    constexpr unsigned int mmCHCG_PERFCOUNTER2_LO                             = 0xD3CC;
+    constexpr unsigned int mmCHCG_PERFCOUNTER2_SELECT                         = 0xDBC9;
+    constexpr unsigned int mmCHCG_PERFCOUNTER3_HI                             = 0xD3CF;
+    constexpr unsigned int mmCHCG_PERFCOUNTER3_LO                             = 0xD3CE;
+    constexpr unsigned int mmCHCG_PERFCOUNTER3_SELECT                         = 0xDBCA;
+    constexpr unsigned int mmGRBM_SE2_PERFCOUNTER_HI                          = 0xD04A;
+    constexpr unsigned int mmGRBM_SE2_PERFCOUNTER_LO                          = 0xD049;
+    constexpr unsigned int mmGRBM_SE2_PERFCOUNTER_SELECT                      = 0xD844;
+    constexpr unsigned int mmGUS_PERFCOUNTER0_CFG                             = 0xDE03;
+    constexpr unsigned int mmGUS_PERFCOUNTER1_CFG                             = 0xDE04;
+    constexpr unsigned int mmGUS_PERFCOUNTER2_HI                              = 0xD641;
+    constexpr unsigned int mmGUS_PERFCOUNTER2_LO                              = 0xD640;
+    constexpr unsigned int mmGUS_PERFCOUNTER2_MODE                            = 0xDE02;
+    constexpr unsigned int mmGUS_PERFCOUNTER2_SELECT                          = 0xDE00;
+    constexpr unsigned int mmGUS_PERFCOUNTER2_SELECT1                         = 0xDE01;
+    constexpr unsigned int mmGUS_PERFCOUNTER_HI                               = 0xD643;
+    constexpr unsigned int mmGUS_PERFCOUNTER_LO                               = 0xD642;
+    constexpr unsigned int mmGUS_PERFCOUNTER_RSLT_CNTL                        = 0xDE05;
+    constexpr unsigned int mmSDMA1_PERFCNT_MISC_CNTL                          = 0xDE2F;
+    constexpr unsigned int mmSDMA1_PERFCNT_PERFCOUNTER0_CFG                   = 0xDE2C;
+    constexpr unsigned int mmSDMA1_PERFCNT_PERFCOUNTER1_CFG                   = 0xDE2D;
+    constexpr unsigned int mmSDMA1_PERFCNT_PERFCOUNTER_HI                     = 0xD66D;
+    constexpr unsigned int mmSDMA1_PERFCNT_PERFCOUNTER_LO                     = 0xD66C;
+    constexpr unsigned int mmSDMA1_PERFCNT_PERFCOUNTER_RSLT_CNTL              = 0xDE2E;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER0_HI                            = 0xD66F;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER0_LO                            = 0xD66E;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER0_SELECT                        = 0xDE30;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER0_SELECT1                       = 0xDE31;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER1_HI                            = 0xD671;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER1_LO                            = 0xD670;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER1_SELECT                        = 0xDE32;
+    constexpr unsigned int mmSDMA1_PERFCOUNTER1_SELECT1                       = 0xDE33;
+} // namespace Nv3x
+#endif
+
 namespace Oss50
 {
     constexpr unsigned int mmSDMA0_PERFCOUNTER0_HI                            = 0x12CB;
     constexpr unsigned int mmSDMA0_PERFCOUNTER0_LO                            = 0x12CA;
     constexpr unsigned int mmSDMA0_PERFCOUNTER0_RESULT                        = 0x12B8;
     constexpr unsigned int mmSDMA0_PERFCOUNTER0_SELECT                        = 0x12C8;
     constexpr unsigned int mmSDMA0_PERFCOUNTER0_SELECT1                       = 0x12C9;
     constexpr unsigned int mmSDMA0_PERFCOUNTER1_HI                            = 0x12CF;
     constexpr unsigned int mmSDMA0_PERFCOUNTER1_LO                            = 0x12CE;
     constexpr unsigned int mmSDMA0_PERFCOUNTER1_RESULT                        = 0x12B9;
diff --git a/lgc/imported/chip/gfx9/gfx9_plus_merged_registers.h b/lgc/imported/chip/gfx9/gfx9_plus_merged_registers.h
index fb01373e3..9f5739002 100644
--- a/lgc/imported/chip/gfx9/gfx9_plus_merged_registers.h
+++ b/lgc/imported/chip/gfx9/gfx9_plus_merged_registers.h
@@ -406,20 +406,27 @@ union CB_CACHE_EVICT_POINTS {
     struct {
         unsigned int                                                              : 16;
         unsigned int DCC_CACHE_EVICT_POINT                                        :  8;
         unsigned int CC_CACHE_EVICT_POINT                                         :  8;
     } bits, bitfields;
     struct {
         unsigned int CM_CACHE_EVICT_POINT                                         :  8;
         unsigned int FC_CACHE_EVICT_POINT                                         :  8;
         unsigned int                                                              : 16;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int CC_COLOR_EVICT_POINT                                         :  8;
+        unsigned int CC_FMASK_EVICT_POINT                                         :  8;
+        unsigned int                                                              : 16;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_CGTT_SCLK_CTRL {
     struct {
         unsigned int ON_DELAY                                                     :  4;
         unsigned int OFF_HYSTERESIS                                               :  8;
@@ -499,20 +506,30 @@ union CB_COLOR0_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR0_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -682,27 +699,40 @@ union CB_COLOR0_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR0_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -775,20 +805,26 @@ union CB_COLOR0_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR0_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -852,20 +888,30 @@ union CB_COLOR1_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR1_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -1035,27 +1081,40 @@ union CB_COLOR1_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR1_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -1128,20 +1187,26 @@ union CB_COLOR1_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR1_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -1205,20 +1270,30 @@ union CB_COLOR2_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR2_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -1388,27 +1463,40 @@ union CB_COLOR2_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR2_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -1481,20 +1569,26 @@ union CB_COLOR2_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR2_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -1558,20 +1652,30 @@ union CB_COLOR3_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR3_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -1741,27 +1845,40 @@ union CB_COLOR3_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR3_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -1834,20 +1951,26 @@ union CB_COLOR3_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR3_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -1911,20 +2034,30 @@ union CB_COLOR4_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR4_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -2094,27 +2227,40 @@ union CB_COLOR4_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR4_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -2187,20 +2333,26 @@ union CB_COLOR4_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR4_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -2264,20 +2416,30 @@ union CB_COLOR5_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR5_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -2447,27 +2609,40 @@ union CB_COLOR5_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR5_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -2540,20 +2715,26 @@ union CB_COLOR5_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR5_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -2617,20 +2798,30 @@ union CB_COLOR6_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR6_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -2800,27 +2991,40 @@ union CB_COLOR6_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR6_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -2893,20 +3097,26 @@ union CB_COLOR6_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR6_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -2970,20 +3180,30 @@ union CB_COLOR7_ATTRIB {
     } gfx09;
     struct {
         unsigned int TILE_MODE_INDEX                                              :  5;
         unsigned int FMASK_TILE_MODE_INDEX                                        :  5;
         unsigned int FMASK_BANK_HEIGHT                                            :  2;
         unsigned int                                                              :  6;
         unsigned int DISABLE_FMASK_NOFETCH_OPT                                    :  1;
         unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int NUM_FRAGMENTS                                                :  2;
+        unsigned int FORCE_DST_ALPHA_1                                            :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int LIMIT_COLOR_FETCH_TO_256B_MAX                                :  1;
+        unsigned int FORCE_LIMIT_COLOR_SECTOR_TO_256B_MAX                         :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR7_ATTRIB2 {
     struct {
         unsigned int MIP0_HEIGHT                                                  : 14;
         unsigned int MIP0_WIDTH                                                   : 14;
@@ -3153,27 +3373,40 @@ union CB_COLOR7_DCC_CONTROL {
         unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
         unsigned int                                                              : 11;
     } gfx10;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 22;
         unsigned int DCC_COMPRESS_DISABLE                                         :  1;
         unsigned int                                                              :  9;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 21;
         unsigned int SKIP_LOW_COMP_RATIO                                          :  1;
         unsigned int                                                              : 10;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SAMPLE_MASK_TRACKER_FEA_FORCE                                :  1;
+        unsigned int                                                              :  8;
+        unsigned int INDEPENDENT_128B_BLOCKS                                      :  1;
+        unsigned int                                                              : 11;
+        unsigned int FDCC_ENABLE                                                  :  1;
+        unsigned int DCC_COMPRESS_DISABLE                                         :  1;
+        unsigned int FRAGMENT_COMPRESS_DISABLE                                    :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR7_FMASK {
     struct {
         unsigned int BASE_256B                                                    : 32;
     } bits, bitfields;
@@ -3246,20 +3479,26 @@ union CB_COLOR7_INFO {
     struct {
         unsigned int                                                              : 19;
         unsigned int CMASK_IS_LINEAR                                              :  1;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int                                                              :  7;
         unsigned int LINEAR_GENERAL                                               :  1;
         unsigned int                                                              : 24;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int FORMAT                                                       :  5;
+        unsigned int                                                              : 27;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_COLOR7_PITCH {
     struct {
         unsigned int TILE_MAX                                                     : 11;
         unsigned int                                                              :  9;
@@ -3306,21 +3545,21 @@ union CB_COLOR7_VIEW {
 union CB_COLOR_CONTROL {
     struct {
         unsigned int DISABLE_DUAL_QUAD                                            :  1;
         unsigned int                                                              :  2;
         unsigned int DEGAMMA_ENABLE                                               :  1;
         unsigned int MODE                                                         :  3;
         unsigned int                                                              :  9;
         unsigned int ROP3                                                         :  8;
         unsigned int                                                              :  8;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  1;
         unsigned int                                                              :  1;
         unsigned int                                                              : 30;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -3359,36 +3598,61 @@ union CB_DCC_CONFIG {
         unsigned int OVERWRITE_COMBINER_CC_POP_DISABLE                            :  1;
         unsigned int                                                              :  1;
         unsigned int FC_RDLAT_KEYID_FIFO_DEPTH                                    :  8;
         unsigned int                                                              : 16;
     } gfx09_10;
     struct {
         unsigned int                                                              :  7;
         unsigned int DISABLE_CONSTANT_ENCODE                                      :  1;
         unsigned int                                                              : 24;
     } gfx09_1xPlus;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 25;
         unsigned int DCC_CACHE_NUM_TAGS                                           :  7;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int READ_RETURN_SKID_FIFO_DEPTH                                  :  9;
         unsigned int                                                              :  7;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DEPTH                                    :  5;
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int SPARE_13                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPARE_14                                                     :  8;
+        unsigned int                                                              : 16;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+#if CHIP_HDR_NAVI31
+union CB_DCC_CONFIG2 {
+    struct {
+        unsigned int INVALID_KEY_ERROR_CODE                                       :  8;
+        unsigned int CLEAR_FRAG2DCC_KEY_ERROR_CODE                                :  1;
+        unsigned int ENABLE_COMP_KEY_ERROR_DETECTION                              :  1;
+        unsigned int                                                              : 22;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
+#endif
 
 union CB_DCC_CONTROL {
     struct {
         unsigned int OVERWRITE_COMBINER_DISABLE                                   :  1;
         unsigned int                                                              :  1;
         unsigned int OVERWRITE_COMBINER_WATERMARK                                 :  5;
         unsigned int                                                              : 25;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  8;
@@ -3405,20 +3669,56 @@ union CB_DCC_CONTROL {
         unsigned int                                                              :  1;
         unsigned int OVERWRITE_COMBINER_MRT_SHARING_DISABLE                       :  1;
         unsigned int                                                              : 30;
     } gfx09;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union CB_FDCC_CONTROL {
+    struct {
+        unsigned int SAMPLE_MASK_TRACKER_DISABLE                                  :  1;
+        unsigned int                                                              :  1;
+        unsigned int SAMPLE_MASK_TRACKER_WATERMARK                                :  5;
+        unsigned int                                                              :  1;
+        unsigned int DISABLE_CONSTANT_ENCODE_AC01                                 :  1;
+        unsigned int DISABLE_CONSTANT_ENCODE_SINGLE                               :  1;
+        unsigned int DISABLE_CONSTANT_ENCODE_REG                                  :  1;
+        unsigned int                                                              :  1;
+        unsigned int DISABLE_ELIMFC_SKIP_OF_AC01                                  :  1;
+        unsigned int DISABLE_ELIMFC_SKIP_OF_SINGLE                                :  1;
+        unsigned int ENABLE_ELIMFC_SKIP_OF_REG                                    :  1;
+        unsigned int                                                              : 17;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_FGCG_SRAM_OVERRIDE {
+    struct {
+        unsigned int DISABLE_FGCG                                                 : 20;
+        unsigned int                                                              : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union CB_HW_CONTROL {
     struct {
         unsigned int                                                              : 19;
         unsigned int FORCE_NEEDS_DST                                              :  1;
         unsigned int                                                              :  1;
         unsigned int DISABLE_BLEND_OPT_RESULT_EQ_DEST                             :  1;
         unsigned int                                                              :  2;
         unsigned int DISABLE_BLEND_OPT_DONT_RD_DST                                :  1;
         unsigned int DISABLE_BLEND_OPT_BYPASS                                     :  1;
         unsigned int DISABLE_BLEND_OPT_DISCARD_PIXEL                              :  1;
@@ -3465,35 +3765,52 @@ union CB_HW_CONTROL {
         unsigned int DISABLE_FILLRATE_OPT_FIX_WITH_CFC                            :  1;
         unsigned int DISABLE_POST_DCC_WITH_CFC_FIX                                :  1;
         unsigned int DISABLE_COMPRESS_1FRAG_WHEN_VRS_RATE_HINT_EN                 :  1;
         unsigned int                                                              :  6;
         unsigned int CHICKEN_BITS                                                 :  3;
         unsigned int                                                              :  1;
         unsigned int DISABLE_CMASK_CACHE_BYTEMASKING                              :  1;
         unsigned int                                                              : 15;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  1;
         unsigned int DISABLE_VRS_FILLRATE_OPTIMIZATION                            :  1;
         unsigned int                                                              :  4;
         unsigned int RMI_CREDITS                                                  :  6;
         unsigned int                                                              :  5;
         unsigned int DISABLE_DCC_CACHE_BYTEMASKING                                :  1;
         unsigned int                                                              : 14;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int ALLOW_MRT_WITH_DUAL_SOURCE                                   :  1;
         unsigned int                                                              : 31;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  2;
+        unsigned int DISABLE_SMT_WHEN_NO_FDCC_FIX                                 :  1;
+        unsigned int                                                              :  9;
+        unsigned int NUM_CCC_SKID_FIFO_ENTRIES                                    :  3;
+        unsigned int FORCE_FEA_HIGH                                               :  1;
+        unsigned int FORCE_EVICT_ALL_VALID                                        :  1;
+        unsigned int                                                              :  3;
+        unsigned int DISABLE_USE_OF_SET_HASH                                      :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPARE_2                                                      :  1;
+        unsigned int                                                              :  6;
+        unsigned int SPARE_3                                                      :  1;
+        unsigned int                                                              :  2;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_HW_CONTROL_1 {
     struct {
         unsigned int                                                              :  5;
         unsigned int FC_CACHE_NUM_TAGS                                            :  6;
@@ -3516,20 +3833,26 @@ union CB_HW_CONTROL_1 {
         unsigned int RMI_CREDITS                                                  :  6;
     } gfx101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 12;
         unsigned int CC_CACHE_NUM_TAGS                                            :  6;
         unsigned int CM_TILE_FIFO_DEPTH                                           :  9;
         unsigned int                                                              :  5;
     } gfx103Derivative;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int CC_CACHE_NUM_TAGS                                            :  6;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              :  5;
         unsigned int FC_CACHE_NUM_TAGS                                            :  7;
         unsigned int                                                              : 20;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int                                                              :  5;
@@ -3571,20 +3894,27 @@ union CB_HW_CONTROL_2 {
         unsigned int                                                              :  8;
         unsigned int FC_RDLAT_TILE_FIFO_DEPTH                                     :  7;
         unsigned int FC_RDLAT_QUAD_FIFO_DEPTH                                     :  8;
         unsigned int                                                              :  9;
     } gfx09_10;
     struct {
         unsigned int                                                              : 24;
         unsigned int DRR_ASSUMED_FIFO_DEPTH_DIV8                                  :  6;
         unsigned int CHICKEN_BITS                                                 :  2;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SPARE_4                                                      :  8;
+        unsigned int DRR_ASSUMED_FIFO_DEPTH_DIV8                                  :  6;
+        unsigned int SPARE                                                        : 18;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_HW_CONTROL_3 {
     struct {
         unsigned int                                                              :  1;
         unsigned int RAM_ADDRESS_CONFLICTS_DISALLOWED                             :  1;
@@ -3650,20 +3980,45 @@ union CB_HW_CONTROL_3 {
         unsigned int                                                              : 31;
         unsigned int DISABLE_FMASK_NOFETCH_OPT_BC                                 :  1;
     } gfx10Core;
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 28;
         unsigned int DISABLE_DCC_VRS_OPT                                          :  1;
         unsigned int                                                              :  3;
     } gfx10Vrs;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SPARE_5                                                      :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPARE_6                                                      :  1;
+        unsigned int SPARE_7                                                      :  1;
+        unsigned int DISABLE_CC_CACHE_OVWR_STATUS_ACCUM                           :  1;
+        unsigned int DISABLE_CC_CACHE_PANIC_GATING                                :  1;
+        unsigned int SPLIT_ALL_FAST_MODE_TRANSFERS                                :  1;
+        unsigned int DISABLE_SHADER_BLEND_OPTS                                    :  1;
+        unsigned int                                                              :  3;
+        unsigned int FORCE_RMI_LAST_HIGH                                          :  1;
+        unsigned int FORCE_RMI_CLKEN_HIGH                                         :  1;
+        unsigned int DISABLE_EARLY_WRACKS_CC                                      :  1;
+        unsigned int DISABLE_EARLY_WRACKS_DC                                      :  1;
+        unsigned int DISABLE_NACK_PROCESSING_CC                                   :  1;
+        unsigned int DISABLE_NACK_PROCESSING_DC                                   :  1;
+        unsigned int SPARE_8                                                      :  1;
+        unsigned int SPARE_9                                                      :  1;
+        unsigned int                                                              :  1;
+        unsigned int DISABLE_DCC_VRS_OPT                                          :  1;
+        unsigned int DISABLE_FMASK_NOALLOC_OPT                                    :  1;
+        unsigned int                                                              : 10;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_HW_CONTROL_4 {
     struct {
         unsigned int COLOR_CACHE_FETCH_NUM_CLS_LOG2                               :  3;
         unsigned int FMASK_CACHE_FETCH_NUM_CLS_LOG2                               :  2;
@@ -3684,20 +4039,37 @@ union CB_HW_CONTROL_4 {
     } gfx10;
     struct {
         unsigned int                                                              :  6;
         unsigned int DISABLE_CMASK_CLOCK_GATING                                   :  1;
         unsigned int DISABLE_FMASK_CLOCK_GATING                                   :  1;
         unsigned int DISABLE_COLOR_CLOCK_GATING                                   :  1;
         unsigned int                                                              :  5;
         unsigned int DISABLE_BC_COLOR_CACHE_PREFETCH                              :  1;
         unsigned int                                                              : 17;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int COLOR_CACHE_FETCH_NUM_QB_LOG2                                :  3;
+        unsigned int COLOR_CACHE_FETCH_ALGORITHM                                  :  2;
+        unsigned int DISABLE_USE_OF_SMT_SCORE                                     :  1;
+        unsigned int SPARE_10                                                     :  1;
+        unsigned int SPARE_11                                                     :  1;
+        unsigned int SPARE_12                                                     :  1;
+        unsigned int DISABLE_MA_WAIT_FOR_LAST                                     :  1;
+        unsigned int SMT_TIMEOUT_THRESHOLD                                        :  3;
+        unsigned int SMT_QPFIFO_THRESHOLD                                         :  3;
+        unsigned int ENABLE_FRAGOP_STALLING_ON_RAW_HAZARD                         :  1;
+        unsigned int ENABLE_FRAGOP_STALLING_ON_COARSE_RAW_HAZARD                  :  1;
+        unsigned int ENABLE_FRAGOP_STALLING_ON_DS_RAW_HAZARD                      :  1;
+        unsigned int                                                              : 13;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_HW_MEM_ARBITER_RD {
     struct {
         unsigned int MODE                                                         :  2;
         unsigned int IGNORE_URGENT_AGE                                            :  4;
@@ -3711,20 +4083,33 @@ union CB_HW_MEM_ARBITER_RD {
         unsigned int WEIGHT_CM                                                    :  2;
         unsigned int WEIGHT_DC                                                    :  2;
         unsigned int WEIGHT_DECAY_REQS                                            :  2;
         unsigned int WEIGHT_DECAY_NOREQS                                          :  2;
         unsigned int WEIGHT_IGNORE_NUM_TIDS                                       :  1;
         unsigned int SCALE_AGE                                                    :  3;
         unsigned int SCALE_WEIGHT                                                 :  3;
         unsigned int SEND_LASTS_WITHIN_GROUPS                                     :  1;
         unsigned int                                                              :  2;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int WEIGHT_DC                                                    :  2;
+        unsigned int WEIGHT_DECAY_REQS                                            :  2;
+        unsigned int WEIGHT_DECAY_NOREQS                                          :  2;
+        unsigned int WEIGHT_IGNORE_NUM_TIDS                                       :  1;
+        unsigned int SCALE_AGE                                                    :  3;
+        unsigned int SCALE_WEIGHT                                                 :  3;
+        unsigned int SEND_LASTS_WITHIN_GROUPS                                     :  1;
+        unsigned int                                                              :  6;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_HW_MEM_ARBITER_WR {
     struct {
         unsigned int MODE                                                         :  2;
         unsigned int IGNORE_URGENT_AGE                                            :  4;
@@ -3738,25 +4123,134 @@ union CB_HW_MEM_ARBITER_WR {
         unsigned int WEIGHT_CM                                                    :  2;
         unsigned int WEIGHT_DC                                                    :  2;
         unsigned int WEIGHT_DECAY_REQS                                            :  2;
         unsigned int WEIGHT_DECAY_NOREQS                                          :  2;
         unsigned int WEIGHT_IGNORE_BYTE_MASK                                      :  1;
         unsigned int SCALE_AGE                                                    :  3;
         unsigned int SCALE_WEIGHT                                                 :  3;
         unsigned int SEND_LASTS_WITHIN_GROUPS                                     :  1;
         unsigned int                                                              :  2;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int WEIGHT_DC                                                    :  2;
+        unsigned int WEIGHT_DECAY_REQS                                            :  2;
+        unsigned int WEIGHT_DECAY_NOREQS                                          :  2;
+        unsigned int WEIGHT_IGNORE_BYTE_MASK                                      :  1;
+        unsigned int SCALE_AGE                                                    :  3;
+        unsigned int SCALE_WEIGHT                                                 :  3;
+        unsigned int SEND_LASTS_WITHIN_GROUPS                                     :  1;
+        unsigned int                                                              :  6;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_0 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_1 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_2 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_3 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_4 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_5 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_6 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
+#endif
+
+#if CHIP_HDR_NAVI31
+union CB_KEY_OVERRIDE_7 {
+    struct {
+        unsigned int OVERRIDE                                                     : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
 
 union CB_MRT0_EPITCH {
     struct {
         unsigned int EPITCH                                                       : 16;
         unsigned int                                                              : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -3865,38 +4359,52 @@ union CB_PERFCOUNTER0_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL1                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int PERF_SEL1                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL3                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL2                                                    : 10;
+        unsigned int PERF_SEL3                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -3918,20 +4426,26 @@ union CB_PERFCOUNTER1_LO {
 
 union CB_PERFCOUNTER1_SELECT {
     struct {
         unsigned int                                                              : 28;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 23;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -3953,20 +4467,26 @@ union CB_PERFCOUNTER2_LO {
 
 union CB_PERFCOUNTER2_SELECT {
     struct {
         unsigned int                                                              : 28;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 23;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -3988,20 +4508,26 @@ union CB_PERFCOUNTER3_LO {
 
 union CB_PERFCOUNTER3_SELECT {
     struct {
         unsigned int                                                              : 28;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 23;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CB_PERFCOUNTER_FILTER {
     struct {
         unsigned int OP_FILTER_ENABLE                                             :  1;
         unsigned int OP_FILTER_SEL                                                :  3;
@@ -4057,20 +4583,27 @@ union CB_RMI_GL2_CACHE_CONTROL {
         unsigned int FMASK_WR_POLICY                                              :  2;
         unsigned int DCC_WR_POLICY                                                :  2;
         unsigned int COLOR_WR_POLICY                                              :  2;
         unsigned int                                                              :  8;
         unsigned int CMASK_RD_POLICY                                              :  2;
         unsigned int FMASK_RD_POLICY                                              :  2;
         unsigned int                                                              : 10;
         unsigned int FMASK_BIG_PAGE                                               :  1;
         unsigned int                                                              :  1;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int DCC_WR_POLICY                                                :  2;
+        unsigned int COLOR_WR_POLICY                                              :  2;
+        unsigned int                                                              : 28;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              : 24;
         unsigned int CMASK_L3_BYPASS                                              :  1;
         unsigned int FMASK_L3_BYPASS                                              :  1;
         unsigned int                                                              :  6;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
@@ -4089,21 +4622,21 @@ union CB_RMI_GL2_CACHE_CONTROL {
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int CMASK_L3_BYPASS                                              :  1;
         unsigned int FMASK_L3_BYPASS                                              :  1;
         unsigned int                                                              :  6;
     } nv24;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 26;
         unsigned int DCC_L3_BYPASS                                                :  1;
         unsigned int COLOR_L3_BYPASS                                              :  1;
         unsigned int                                                              :  4;
     } mall;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
@@ -4832,25 +5365,46 @@ union COMPUTE_DISPATCH_INITIATOR {
         unsigned int RESTORE                                                      :  1;
         unsigned int                                                              : 17;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int TUNNEL_ENABLE                                                :  1;
         unsigned int                                                              :  1;
         unsigned int CS_W32_EN                                                    :  1;
         unsigned int                                                              : 16;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int AMP_SHADER_EN                                                :  1;
+        unsigned int DISABLE_DISP_PREMPT_EN                                       :  1;
+        unsigned int                                                              : 14;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+#if CHIP_HDR_NAVI31
+union COMPUTE_DISPATCH_INTERLEAVE {
+    struct {
+        unsigned int INTERLEAVE                                                   : 10;
+        unsigned int                                                              : 22;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
+#endif
 
 union COMPUTE_DISPATCH_PKT_ADDR_HI {
     struct {
         unsigned int DATA                                                         :  8;
         unsigned int                                                              : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -4905,20 +5459,26 @@ union COMPUTE_MISC_RESERVED {
         unsigned int RESERVED3                                                    :  1;
         unsigned int RESERVED4                                                    :  1;
         unsigned int WAVE_ID_BASE                                                 : 12;
         unsigned int                                                              : 15;
     } bits, bitfields;
     struct {
         unsigned int SEND_SEID                                                    :  2;
         unsigned int RESERVED2                                                    :  1;
         unsigned int                                                              : 29;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SEND_SEID                                                    :  3;
+        unsigned int                                                              : 29;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union COMPUTE_NOWHERE {
     struct {
         unsigned int DATA                                                         : 32;
     } bits, bitfields;
@@ -5043,20 +5603,36 @@ union COMPUTE_PGM_RSRC2 {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union COMPUTE_PGM_RSRC3 {
     struct {
         unsigned int SHARED_VGPR_CNT                                              :  4;
         unsigned int                                                              : 28;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  4;
+        unsigned int INST_PREF_SIZE                                               :  6;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 10;
+        unsigned int TRAP_ON_START                                                :  1;
+        unsigned int TRAP_ON_END                                                  :  1;
+        unsigned int                                                              : 19;
+        unsigned int IMAGE_OP                                                     :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union COMPUTE_PIPELINESTAT_ENABLE {
     struct {
         unsigned int PIPELINESTAT_ENABLE                                          :  1;
         unsigned int                                                              : 31;
@@ -5339,20 +5915,72 @@ union COMPUTE_STATIC_THREAD_MGMT_SE3 {
     struct {
         unsigned int SA0_CU_EN                                                    : 16;
         unsigned int SA1_CU_EN                                                    : 16;
     } gfx10Plus;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union COMPUTE_STATIC_THREAD_MGMT_SE4 {
+    struct {
+        unsigned int SA0_CU_EN                                                    : 16;
+        unsigned int SA1_CU_EN                                                    : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union COMPUTE_STATIC_THREAD_MGMT_SE5 {
+    struct {
+        unsigned int SA0_CU_EN                                                    : 16;
+        unsigned int SA1_CU_EN                                                    : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union COMPUTE_STATIC_THREAD_MGMT_SE6 {
+    struct {
+        unsigned int SA0_CU_EN                                                    : 16;
+        unsigned int SA1_CU_EN                                                    : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union COMPUTE_STATIC_THREAD_MGMT_SE7 {
+    struct {
+        unsigned int SA0_CU_EN                                                    : 16;
+        unsigned int SA1_CU_EN                                                    : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union COMPUTE_THREADGROUP_ID {
     struct {
         unsigned int THREADGROUP_ID                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -5370,20 +5998,27 @@ union COMPUTE_THREAD_TRACE_ENABLE {
 union COMPUTE_TMPRING_SIZE {
     struct {
         unsigned int WAVES                                                        : 12;
         unsigned int                                                              : 20;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 12;
         unsigned int WAVESIZE                                                     : 13;
         unsigned int                                                              :  7;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int WAVESIZE                                                     : 15;
+        unsigned int                                                              :  5;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union COMPUTE_USER_ACCUM_0 {
     struct {
         unsigned int CONTRIBUTION                                                 :  7;
         unsigned int                                                              : 25;
@@ -5726,20 +6361,26 @@ union CPC_PERFCOUNTER1_SELECT {
     } gfx09_10;
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int CNTR_MODE                                                    :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CPF_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -5846,20 +6487,26 @@ union CPF_PERFCOUNTER1_SELECT {
     } gfx09_10;
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int CNTR_MODE                                                    :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CPG_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -5966,20 +6613,26 @@ union CPG_PERFCOUNTER1_SELECT {
     } gfx09_10;
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx10Core;
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int CNTR_MODE                                                    :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union CP_COHER_BASE {
     struct {
         unsigned int COHER_BASE_256B                                              : 32;
     } bits, bitfields;
@@ -6382,20 +7035,44 @@ union CP_STRMOUT_CNTL {
     struct {
         unsigned int OFFSET_UPDATE_DONE                                           :  1;
         unsigned int                                                              : 31;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union CP_VGT_ASINVOC_COUNT_HI {
+    struct {
+        unsigned int ASINVOC_COUNT_HI                                             : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union CP_VGT_ASINVOC_COUNT_LO {
+    struct {
+        unsigned int ASINVOC_COUNT_LO                                             : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union CP_VGT_CSINVOC_COUNT_HI {
     struct {
         unsigned int CSINVOC_COUNT_HI                                             : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -6586,25 +7263,45 @@ union DB_CGTT_CLK_CTRL_0 {
         unsigned int SOFT_OVERRIDE3                                               :  1;
         unsigned int SOFT_OVERRIDE2                                               :  1;
         unsigned int SOFT_OVERRIDE1                                               :  1;
         unsigned int SOFT_OVERRIDE0                                               :  1;
     } most;
     struct {
         unsigned int                                                              : 12;
         unsigned int RESERVED                                                     :  4;
         unsigned int                                                              : 16;
     } gfx09;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SOFT_OVERRIDE0                                               :  1;
+        unsigned int SOFT_OVERRIDE1                                               :  1;
+        unsigned int SOFT_OVERRIDE2                                               :  1;
+        unsigned int SOFT_OVERRIDE3                                               :  1;
+        unsigned int SOFT_OVERRIDE4                                               :  1;
+        unsigned int SOFT_OVERRIDE5                                               :  1;
+        unsigned int SOFT_OVERRIDE6                                               :  1;
+        unsigned int SOFT_OVERRIDE7                                               :  1;
+        unsigned int SOFT_OVERRIDE8                                               :  1;
+        unsigned int                                                              : 23;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int                                                              : 12;
         unsigned int RESERVED                                                     :  4;
         unsigned int                                                              : 16;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int RESERVED                                                     : 23;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DB_COUNT_CONTROL {
     struct {
         unsigned int                                                              :  1;
         unsigned int PERFECT_ZPASS_COUNTS                                         :  1;
@@ -6639,20 +7336,28 @@ union DB_CREDIT_LIMIT {
         unsigned int DB_SC_TILE_CREDITS                                           :  5;
         unsigned int DB_SC_QUAD_CREDITS                                           :  5;
         unsigned int DB_CB_LQUAD_CREDITS                                          :  3;
         unsigned int                                                              : 19;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 24;
         unsigned int DB_CB_TILE_CREDITS                                           :  7;
         unsigned int                                                              :  1;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int DB_SC_WAVE_CREDITS                                           :  5;
+        unsigned int DB_SC_FREE_WAVE_CREDITS                                      :  5;
+        unsigned int                                                              :  9;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DB_DEPTH_BOUNDS_MAX {
     struct {
         unsigned int MAX                                                          : 32;
     } bits, bitfields;
@@ -6989,20 +7694,30 @@ union DB_FGCG_INTERFACES_CLK_CTRL {
         unsigned int DB_SC_TILE_OVERRIDE                                          :  1;
         unsigned int DB_CB_RMIRET_OVERRIDE                                        :  1;
         unsigned int                                                              : 25;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  1;
         unsigned int DB_CB_TILE_OVERRIDE                                          :  1;
         unsigned int DB_CB_LQUAD_OVERRIDE                                         :  1;
         unsigned int                                                              : 29;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  2;
+        unsigned int DB_CB_EXPORT_OVERRIDE                                        :  1;
+        unsigned int                                                              :  4;
+        unsigned int DB_SC_WAVE_OVERRIDE                                          :  1;
+        unsigned int DB_SC_FREE_WAVE_OVERRIDE                                     :  1;
+        unsigned int                                                              : 23;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DB_FGCG_SRAMS_CLK_CTRL {
     struct {
         unsigned int OVERRIDE0                                                    :  1;
         unsigned int OVERRIDE1                                                    :  1;
@@ -7026,20 +7741,36 @@ union DB_FGCG_SRAMS_CLK_CTRL {
         unsigned int OVERRIDE19                                                   :  1;
         unsigned int OVERRIDE20                                                   :  1;
         unsigned int OVERRIDE21                                                   :  1;
         unsigned int OVERRIDE22                                                   :  1;
         unsigned int OVERRIDE23                                                   :  1;
         unsigned int OVERRIDE24                                                   :  1;
         unsigned int OVERRIDE25                                                   :  1;
         unsigned int OVERRIDE26                                                   :  1;
         unsigned int                                                              :  5;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 27;
+        unsigned int OVERRIDE27                                                   :  1;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int OVERRIDE28                                                   :  1;
+        unsigned int OVERRIDE29                                                   :  1;
+        unsigned int OVERRIDE30                                                   :  1;
+        unsigned int OVERRIDE31                                                   :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DB_FIFO_DEPTH1 {
     struct {
         unsigned int DB_RMI_RDREQ_CREDITS                                         :  5;
         unsigned int DB_RMI_WRREQ_CREDITS                                         :  5;
@@ -7083,25 +7814,48 @@ union DB_FIFO_DEPTH2 {
     signed int   i32All;
     float        f32All;
 };
 
 union DB_FIFO_DEPTH3 {
     struct {
         unsigned int LTILE_PROBE_FIFO_DEPTH                                       :  8;
         unsigned int                                                              : 16;
         unsigned int QUAD_READ_REQS                                               :  8;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  8;
+        unsigned int OSB_WAVE_TABLE_DEPTH                                         :  8;
+        unsigned int OREO_WAVE_HIDE_DEPTH                                         :  8;
+        unsigned int                                                              :  8;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+#if CHIP_HDR_NAVI31
+union DB_FIFO_DEPTH4 {
+    struct {
+        unsigned int OSB_SQUAD_TABLE_DEPTH                                        :  8;
+        unsigned int OSB_TILE_TABLE_DEPTH                                         :  8;
+        unsigned int OSB_SCORE_BOARD_DEPTH                                        :  8;
+        unsigned int OSB_EVENT_FIFO_DEPTH                                         :  8;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
+#endif
 
 union DB_FREE_CACHELINES {
     struct {
         unsigned int FREE_DTILE_DEPTH                                             :  7;
         unsigned int FREE_PLANE_DEPTH                                             :  7;
         unsigned int FREE_Z_DEPTH                                                 :  6;
         unsigned int FREE_HTILE_DEPTH                                             :  4;
         unsigned int QUAD_READ_REQS                                               :  8;
     } gfx09;
     struct {
@@ -7164,21 +7918,21 @@ union DB_HTILE_SURFACE {
         unsigned int RESERVED_FIELD_1                                             :  1;
         unsigned int                                                              :  1;
         unsigned int RESERVED_FIELD_2                                             :  1;
         unsigned int RESERVED_FIELD_3                                             :  1;
         unsigned int RESERVED_FIELD_4                                             :  6;
         unsigned int RESERVED_FIELD_5                                             :  6;
         unsigned int                                                              :  1;
         unsigned int RESERVED_FIELD_6                                             :  1;
         unsigned int                                                              : 14;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int RESERVED_FIELD_1                                             :  1;
         unsigned int                                                              :  1;
         unsigned int RESERVED_FIELD_2                                             :  1;
         unsigned int RESERVED_FIELD_3                                             :  1;
         unsigned int RESERVED_FIELD_4                                             :  6;
         unsigned int RESERVED_FIELD_5                                             :  6;
         unsigned int                                                              :  1;
         unsigned int RESERVED_FIELD_6                                             :  1;
         unsigned int                                                              : 14;
@@ -7226,21 +7980,21 @@ union DB_LAST_OF_BURST_CONFIG {
     struct {
         unsigned int                                                              : 16;
         unsigned int DBCB_LOB_USES_MAXBURST                                       :  1;
         unsigned int                                                              :  7;
         unsigned int ENABLE_TIMEOUT_CB_LOB_GEN                                    :  1;
         unsigned int                                                              :  2;
         unsigned int ENABLE_TIMEOUT_RD_BA_ACCUM                                   :  1;
         unsigned int                                                              :  4;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int DBCB_LOB_SWITCH_TIMEOUT                                      :  5;
         unsigned int                                                              :  1;
         unsigned int ENABLE_FG_DEFAULT_TIMEOUT                                    :  1;
         unsigned int DISABLE_MCC_BURST_COUNT_RESET_ON_LOB                         :  1;
         unsigned int DISABLE_FLQ_LOB_EVERY_256B                                   :  1;
         unsigned int DISABLE_ZCACHE_FL_OP_EVEN_ARB                                :  1;
         unsigned int DISABLE_MCC_BURST_FORCE_FLUSH_BEFORE_FIFO                    :  1;
         unsigned int ENABLE_TIMEOUT_DKG_LOB_GEN                                   :  1;
@@ -7578,20 +8332,32 @@ union DB_RENDER_CONTROL {
         unsigned int DECOMPRESS_ENABLE                                            :  1;
         unsigned int                                                              : 19;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 13;
         unsigned int                                                              :  1;
         unsigned int                                                              : 18;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 14;
+        unsigned int                                                              :  1;
+        unsigned int                                                              :  1;
+        unsigned int OREO_MODE                                                    :  2;
+        unsigned int FORCE_OREO_MODE                                              :  1;
+        unsigned int FORCE_EXPORT_ORDER                                           :  1;
+        unsigned int MAX_ALLOWED_TILES_IN_WAVE                                    :  4;
+        unsigned int                                                              :  8;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DB_RENDER_OVERRIDE {
     struct {
         unsigned int FORCE_HIZ_ENABLE                                             :  2;
         unsigned int FORCE_HIS_ENABLE0                                            :  2;
@@ -7642,27 +8408,34 @@ union DB_RENDER_OVERRIDE2 {
         unsigned int HIZ_ZFUNC                                                    :  3;
         unsigned int HIS_SFUNC_FF                                                 :  3;
         unsigned int HIS_SFUNC_BF                                                 :  3;
         unsigned int PRESERVE_ZRANGE                                              :  1;
         unsigned int PRESERVE_SRESULTS                                            :  1;
         unsigned int DISABLE_FAST_PASS                                            :  1;
         unsigned int                                                              :  1;
         unsigned int ALLOW_PARTIAL_RES_HIER_KILL                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 27;
         unsigned int CENTROID_COMPUTATION_MODE                                    :  2;
         unsigned int                                                              :  3;
     } gfx103Plus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 29;
+        unsigned int DISABLE_NOZ                                                  :  1;
+        unsigned int                                                              :  2;
+    } gfx104Plus;
+#endif
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 26;
         unsigned int FORCE_VRS_RATE_FINE                                          :  1;
         unsigned int                                                              :  5;
     } gfx10Vrs;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
@@ -7776,21 +8549,21 @@ union DB_RMI_L2_CACHE_CONTROL {
         unsigned int ZPCPSD_WR_POLICY                                             :  2;
         unsigned int                                                              :  8;
         unsigned int Z_RD_POLICY                                                  :  2;
         unsigned int S_RD_POLICY                                                  :  2;
         unsigned int HTILE_RD_POLICY                                              :  2;
         unsigned int                                                              :  2;
         unsigned int Z_BIG_PAGE                                                   :  1;
         unsigned int S_BIG_PAGE                                                   :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 26;
         unsigned int Z_NOALLOC                                                    :  1;
         unsigned int S_NOALLOC                                                    :  1;
         unsigned int HTILE_NOALLOC                                                :  1;
         unsigned int ZPCPSD_NOALLOC                                               :  1;
         unsigned int                                                              :  2;
     } mall;
 #endif
 
@@ -7823,27 +8596,36 @@ union DB_SHADER_CONTROL {
         unsigned int EXEC_IF_OVERLAPPED                                           :  1;
         unsigned int                                                              :  2;
         unsigned int POPS_OVERLAP_NUM_SAMPLES                                     :  3;
         unsigned int                                                              :  9;
     } gfx09_10;
     struct {
         unsigned int                                                              : 23;
         unsigned int PRE_SHADER_DEPTH_COVERAGE_ENABLE                             :  1;
         unsigned int                                                              :  8;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int OREO_BLEND_ENABLE                                            :  1;
+        unsigned int OVERRIDE_INTRINSIC_RATE_ENABLE                               :  1;
+        unsigned int OVERRIDE_INTRINSIC_RATE                                      :  3;
+        unsigned int                                                              :  3;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union DB_SPI_VRS_CENTER_LOCATION {
     struct {
         unsigned int CENTER_X_OFFSET_1X1                                          :  4;
         unsigned int CENTER_Y_OFFSET_1X1                                          :  4;
         unsigned int CENTER_X_OFFSET_2X1                                          :  4;
         unsigned int CENTER_Y_OFFSET_2X1                                          :  4;
         unsigned int CENTER_X_OFFSET_1X2                                          :  4;
         unsigned int CENTER_Y_OFFSET_1X2                                          :  4;
         unsigned int CENTER_X_OFFSET_2X2                                          :  4;
         unsigned int CENTER_Y_OFFSET_2X2                                          :  4;
@@ -7959,21 +8741,21 @@ union DB_STENCIL_INFO {
         unsigned int ITERATE_FLUSH                                                :  1;
         unsigned int                                                              : 14;
         unsigned int CLEAR_DISALLOWED                                             :  1;
         unsigned int                                                              :  1;
     } gfx09;
     struct {
         unsigned int                                                              : 13;
         unsigned int RESERVED_FIELD_1                                             :  3;
         unsigned int                                                              : 16;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 13;
         unsigned int RESERVED_FIELD_1                                             :  3;
         unsigned int                                                              : 16;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              :  9;
         unsigned int FAULT_BEHAVIOR                                               :  2;
         unsigned int ITERATE_FLUSH                                                :  1;
@@ -8143,21 +8925,21 @@ union DB_Z_INFO {
         unsigned int ITERATE_FLUSH                                                :  1;
         unsigned int                                                              : 14;
         unsigned int CLEAR_DISALLOWED                                             :  1;
         unsigned int                                                              :  1;
     } gfx09;
     struct {
         unsigned int                                                              : 13;
         unsigned int RESERVED_FIELD_1                                             :  3;
         unsigned int                                                              : 16;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 13;
         unsigned int RESERVED_FIELD_1                                             :  3;
         unsigned int                                                              : 16;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              :  9;
         unsigned int FAULT_BEHAVIOR                                               :  2;
         unsigned int ITERATE_FLUSH                                                :  1;
@@ -8224,111 +9006,167 @@ union DB_Z_WRITE_BASE_HI {
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi0 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi1 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi2 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi3 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi4 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi5 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi6 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlHi7 {
     struct {
         unsigned int EventSelect_11_8                                             :  4;
         unsigned int                                                              : 25;
         unsigned int EventSelect_13_12                                            :  2;
         unsigned int BypassEn                                                     :  1;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int EventSelectHi                                                :  6;
+        unsigned int                                                              :  2;
+        unsigned int Filter                                                       : 24;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union DF_PIE_AON_PerfMonCtlLo0 {
     struct {
         unsigned int EventSelect_7_0                                              :  8;
         unsigned int UnitMaskLo                                                   :  8;
@@ -8363,20 +9201,30 @@ union DF_PIE_AON_PerfMonCtlLo0 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8417,20 +9265,30 @@ union DF_PIE_AON_PerfMonCtlLo1 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8471,20 +9329,30 @@ union DF_PIE_AON_PerfMonCtlLo2 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8525,20 +9393,30 @@ union DF_PIE_AON_PerfMonCtlLo3 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8579,20 +9457,30 @@ union DF_PIE_AON_PerfMonCtlLo4 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8633,20 +9521,30 @@ union DF_PIE_AON_PerfMonCtlLo5 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8687,20 +9585,30 @@ union DF_PIE_AON_PerfMonCtlLo6 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8741,20 +9649,30 @@ union DF_PIE_AON_PerfMonCtlLo7 {
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int Mp1Int                                                       :  1;
+        unsigned int BypassEn                                                     :  1;
+        unsigned int                                                              :  2;
+        unsigned int UnitMaskHi                                                   :  4;
+        unsigned int                                                              :  4;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 21;
         unsigned int Mp1Int                                                       :  1;
         unsigned int                                                              : 10;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8947,21 +9865,21 @@ union GB_ADDR_CONFIG {
         unsigned int                                                              :  1;
         unsigned int SHADER_ENGINE_TILE_SIZE                                      :  3;
         unsigned int                                                              :  2;
         unsigned int NUM_GPUS                                                     :  3;
         unsigned int MULTI_GPU_TILE_SIZE                                          :  2;
         unsigned int                                                              :  2;
         unsigned int ROW_SIZE                                                     :  2;
         unsigned int NUM_LOWER_PIPES                                              :  1;
         unsigned int SE_ENABLE                                                    :  1;
     } gfx09;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  8;
         unsigned int NUM_PKRS                                                     :  3;
         unsigned int                                                              : 21;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -8986,21 +9904,21 @@ union GB_ADDR_CONFIG_READ {
         unsigned int                                                              :  1;
         unsigned int SHADER_ENGINE_TILE_SIZE                                      :  3;
         unsigned int                                                              :  2;
         unsigned int NUM_GPUS                                                     :  3;
         unsigned int MULTI_GPU_TILE_SIZE                                          :  2;
         unsigned int                                                              :  2;
         unsigned int ROW_SIZE                                                     :  2;
         unsigned int NUM_LOWER_PIPES                                              :  1;
         unsigned int SE_ENABLE                                                    :  1;
     } gfx09;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  8;
         unsigned int NUM_PKRS                                                     :  3;
         unsigned int                                                              : 21;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -9334,38 +10252,52 @@ union GCR_PERFCOUNTER0_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL1                                                    :  9;
         unsigned int                                                              : 13;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int PERF_SEL1                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GCR_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL3                                                    :  9;
         unsigned int                                                              : 13;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL2                                                    : 10;
+        unsigned int PERF_SEL3                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GCR_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -9385,20 +10317,29 @@ union GCR_PERFCOUNTER1_LO {
     float        f32All;
 };
 
 union GCR_PERFCOUNTER1_SELECT {
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 15;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int CNTL_MODE                                                    :  4;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 10;
+        unsigned int CNTR_MODE                                                    :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GCVML2_PERFCOUNTER2_0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -9771,21 +10712,21 @@ union GDS_PERFCOUNTER1_SELECT {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx09_0;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GDS_PERFCOUNTER1_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              :  4;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
 
     unsigned int u32All;
@@ -9831,21 +10772,21 @@ union GDS_PERFCOUNTER2_SELECT {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx09_0;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GDS_PERFCOUNTER2_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              :  4;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
 
     unsigned int u32All;
@@ -9891,924 +10832,1176 @@ union GDS_PERFCOUNTER3_SELECT {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx09_0;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GDS_PERFCOUNTER3_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              :  4;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER0_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER0_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER1_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER1_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER1_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER2_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER2_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER2_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER3_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER3_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE1_PERFCOUNTER3_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER0_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER0_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER1_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER1_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER1_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER2_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER2_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER2_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER3_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER3_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_DIST_PERFCOUNTER3_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER0_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER0_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER1_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER1_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER1_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER2_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER2_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER2_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER3_LO {
     struct {
         unsigned int PERFCOUNTER_LO                                               : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER3_SELECT {
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int                                                              :  8;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE0                                                   :  4;
         unsigned int PERF_MODE1                                                   :  4;
     } gfx103;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL0                                                    : 10;
         unsigned int                                                              : 22;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE1                                                   :  4;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int PERF_MODE0                                                   :  4;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE2_SE_PERFCOUNTER3_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE2                                                   :  4;
         unsigned int PERF_MODE3                                                   :  4;
     } gfx103;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int PERF_MODE3                                                   :  4;
+        unsigned int PERF_MODE2                                                   :  4;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union GE_CNTL {
     struct {
         unsigned int                                                              : 19;
         unsigned int PACKET_TO_ONE_PA                                             :  1;
         unsigned int                                                              : 12;
     } bits, bitfields;
     struct {
         unsigned int PRIM_GRP_SIZE                                                :  9;
         unsigned int VERT_GRP_SIZE                                                :  9;
         unsigned int BREAK_WAVE_AT_EOI                                            :  1;
         unsigned int                                                              : 13;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PRIMS_PER_SUBGRP                                             :  9;
+        unsigned int VERTS_PER_SUBGRP                                             :  9;
+        unsigned int BREAK_SUBGRP_AT_EOI                                          :  1;
+        unsigned int                                                              :  1;
+        unsigned int BREAK_PRIMGRP_AT_EOI                                         :  1;
+        unsigned int PRIM_GRP_SIZE                                                :  9;
+        unsigned int GCR_DISABLE                                                  :  1;
+        unsigned int DIS_PG_SIZE_ADJUST_FOR_STRIP                                 :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GE_DMA_FIRST_INDEX {
     struct {
         unsigned int FIRST_INDEX                                                  : 32;
     } bits, bitfields;
@@ -10827,20 +12020,46 @@ union GE_FAST_CLKS {
     struct {
         unsigned int HYSTERESIS                                                   : 30;
         unsigned int                                                              :  2;
     } gfx101;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union GE_GS_FAST_LAUNCH_WG_DIM {
+    struct {
+        unsigned int GS_FL_DIM_X                                                  : 16;
+        unsigned int GS_FL_DIM_Y                                                  : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GE_GS_FAST_LAUNCH_WG_DIM_1 {
+    struct {
+        unsigned int GS_FL_DIM_Z                                                  : 16;
+        unsigned int                                                              : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union GE_INDX_OFFSET {
     struct {
         unsigned int INDX_OFFSET                                                  : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -10874,38 +12093,59 @@ union GE_MIN_VTX_INDX {
     signed int   i32All;
     float        f32All;
 };
 
 union GE_MULTI_PRIM_IB_RESET_EN {
     struct {
         unsigned int RESET_EN                                                     :  1;
         unsigned int MATCH_ALL_BITS                                               :  1;
         unsigned int                                                              : 30;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  2;
+        unsigned int DISABLE_FOR_AUTO_INDEX                                       :  1;
+        unsigned int                                                              : 29;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GE_NGG_SUBGRP_CNTL {
     struct {
         unsigned int PRIM_AMP_FACTOR                                              :  9;
         unsigned int THDS_PER_SUBGRP                                              :  9;
         unsigned int                                                              : 14;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union GE_PA_IF_SAFE_REG {
+    struct {
+        unsigned int GE_PA_CSB                                                    : 10;
+        unsigned int GE_PA_PAYLOAD                                                : 10;
+        unsigned int                                                              : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union GE_PC_ALLOC {
     struct {
         unsigned int OVERSUB_EN                                                   :  1;
         unsigned int NUM_PC_LINES                                                 : 10;
         unsigned int                                                              : 21;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -11393,34 +12633,98 @@ union GE_PRIV_CONTROL {
     struct {
         unsigned int                                                              :  1;
         unsigned int CLAMP_PRIMGRP_SIZE                                           :  9;
         unsigned int RESET_ON_PIPELINE_CHANGE                                     :  1;
         unsigned int                                                              : 21;
     } bits, bitfields;
     struct {
         unsigned int DISCARD_LEGACY                                               :  1;
         unsigned int                                                              : 31;
     } gfx10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 15;
         unsigned int FGCG_OVERRIDE                                                :  1;
         unsigned int CLAMP_HS_OFFCHIP_PER_SE_OVERRIDE                             :  1;
         unsigned int                                                              : 15;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int RESERVED                                                     :  1;
+        unsigned int                                                              : 16;
+        unsigned int DISABLE_ACCUM_AGM                                            :  1;
+        unsigned int                                                              : 14;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union GE_RATE_CNTL_1 {
+    struct {
+        unsigned int ADD_X_CLKS_LS_VERT                                           :  4;
+        unsigned int AFTER_Y_TRANS_LS_VERT                                        :  4;
+        unsigned int ADD_X_CLKS_HS_VERT                                           :  4;
+        unsigned int AFTER_Y_TRANS_HS_VERT                                        :  4;
+        unsigned int ADD_X_CLKS_ES_VERT                                           :  4;
+        unsigned int AFTER_Y_TRANS_ES_VERT                                        :  4;
+        unsigned int ADD_X_CLKS_GS_PRIM                                           :  4;
+        unsigned int AFTER_Y_TRANS_GS_PRIM                                        :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GE_RATE_CNTL_2 {
+    struct {
+        unsigned int ADD_X_CLKS_VS_VERT                                           :  4;
+        unsigned int AFTER_Y_TRANS_VS_VERT                                        :  4;
+        unsigned int ADD_X_CLKS_PA_PRIM                                           :  4;
+        unsigned int AFTER_Y_TRANS_PA_PRIM                                        :  4;
+        unsigned int ADD_X_CLKS_MERGED_HS_GS                                      :  4;
+        unsigned int ADD_X_CLKS_MERGED_LS_ES                                      :  4;
+        unsigned int MERGED_HS_GS_MODE                                            :  1;
+        unsigned int MERGED_LS_ES_MODE                                            :  1;
+        unsigned int ENABLE_RATE_CNTL                                             :  1;
+        unsigned int SWAP_PRIORITY                                                :  1;
+        unsigned int                                                              :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GE_SPI_IF_SAFE_REG {
+    struct {
+        unsigned int GE_SPI_LS_ES_DATA                                            :  6;
+        unsigned int GE_SPI_HS_GS_DATA                                            :  6;
+        unsigned int GE_SPI_GRP                                                   :  6;
+        unsigned int                                                              : 14;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union GE_STATUS {
     struct {
         unsigned int PERFCOUNTER_STATUS                                           :  1;
         unsigned int THREAD_TRACE_STATUS                                          :  1;
         unsigned int                                                              : 30;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -11476,21 +12780,21 @@ union GE_USER_VGPR_EN {
         unsigned int EN_USER_VGPR2                                                :  1;
         unsigned int EN_USER_VGPR3                                                :  1;
         unsigned int                                                              : 29;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union GE_VRS_RATE {
     struct {
         unsigned int RATE_X                                                       :  2;
         unsigned int                                                              :  2;
         unsigned int RATE_Y                                                       :  2;
         unsigned int                                                              : 26;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
@@ -12193,21 +13497,21 @@ union GRBM_GFX_INDEX_SR_DATA {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_GFX_INDEX_SR_SELECT {
     struct {
         unsigned int INDEX                                                        :  3;
         unsigned int                                                              : 29;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 31;
         unsigned int VF_PF                                                        :  1;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -12296,20 +13600,27 @@ union GRBM_PERFCOUNTER0_SELECT_HI {
         unsigned int                                                              :  2;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              : 23;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  6;
         unsigned int PMM_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GUS_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 24;
     } gfx10CorePlus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              : 22;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -12393,20 +13704,27 @@ union GRBM_PERFCOUNTER1_SELECT_HI {
         unsigned int                                                              :  2;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              : 23;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  6;
         unsigned int PMM_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GUS_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 24;
     } gfx10CorePlus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              : 22;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_SE0_PERFCOUNTER_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -12450,20 +13768,35 @@ union GRBM_SE0_PERFCOUNTER_SELECT {
         unsigned int VGT_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 12;
     } gfx09;
     struct {
         unsigned int                                                              : 23;
         unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              :  6;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 26;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  4;
+    } gfx11;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_SE1_PERFCOUNTER_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -12507,20 +13840,35 @@ union GRBM_SE1_PERFCOUNTER_SELECT {
         unsigned int VGT_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 12;
     } gfx09;
     struct {
         unsigned int                                                              : 23;
         unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              :  6;
     } gfx10CorePlus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 26;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  4;
+    } gfx11;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_SE2_PERFCOUNTER_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } most;
@@ -12564,20 +13912,38 @@ union GRBM_SE2_PERFCOUNTER_SELECT {
         unsigned int VGT_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 12;
     } gfx09;
     struct {
         unsigned int                                                              : 23;
         unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              :  6;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } nv31;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 23;
+        unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  4;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union GRBM_SE3_PERFCOUNTER_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } most;
@@ -12621,25 +13987,208 @@ union GRBM_SE3_PERFCOUNTER_SELECT {
         unsigned int VGT_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int                                                              : 12;
     } gfx09;
     struct {
         unsigned int                                                              : 23;
         unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
         unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
         unsigned int                                                              :  6;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 23;
+        unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } nv31;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE4_PERFCOUNTER_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE4_PERFCOUNTER_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE4_PERFCOUNTER_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  6;
+        unsigned int                                                              :  4;
+        unsigned int DB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int CB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int TA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SX_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int SC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int DB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int CB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int PA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int BCI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int RMI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE5_PERFCOUNTER_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE5_PERFCOUNTER_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE5_PERFCOUNTER_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  6;
+        unsigned int                                                              :  4;
+        unsigned int DB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int CB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int TA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SX_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int SC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int DB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int CB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int PA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int BCI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int RMI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE6_PERFCOUNTER_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE6_PERFCOUNTER_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union GRBM_SE6_PERFCOUNTER_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  6;
+        unsigned int                                                              :  4;
+        unsigned int DB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int CB_CLEAN_USER_DEFINED_MASK                                   :  1;
+        unsigned int TA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SX_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int SPI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int SC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int DB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int CB_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int                                                              :  1;
+        unsigned int PA_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int BCI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int RMI_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int UTCL1_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int TCP_BUSY_USER_DEFINED_MASK                                   :  1;
+        unsigned int GL1CC_BUSY_USER_DEFINED_MASK                                 :  1;
+        unsigned int GL1H_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int PC_BUSY_USER_DEFINED_MASK                                    :  1;
+        unsigned int SEDC_BUSY_USER_DEFINED_MASK                                  :  1;
+        unsigned int                                                              :  3;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
 
 union GUS_PERFCOUNTER0_CFG {
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
@@ -13034,20 +14583,27 @@ union IA_UTCL1_CNTL {
         unsigned int                                                              :  1;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 30;
         unsigned int LLC_NOALLOC_OVERRIDE                                         :  1;
         unsigned int                                                              :  1;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 30;
+        unsigned int LLC_NOALLOC_OVERRIDE                                         :  1;
+        unsigned int                                                              :  1;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union IA_UTCL1_STATUS {
     struct {
         unsigned int FAULT_DETECTED                                               :  1;
         unsigned int RETRY_DETECTED                                               :  1;
@@ -13361,20 +14917,32 @@ union PA_CL_ENHANCE {
         unsigned int                                                              :  1;
         unsigned int                                                              :  8;
     } gfx101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 24;
         unsigned int CLAMP_NEGATIVE_BB_TO_ZERO                                    :  1;
         unsigned int                                                              :  7;
     } gfx103Derivative;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int POLY_INNER_EDGE_FLAG_DISABLE                                 :  1;
+        unsigned int TC_REQUEST_PERF_CNTR_ENABLE                                  :  1;
+        unsigned int DISABLE_PA_PH_INTF_FINE_CLOCK_GATE                           :  1;
+        unsigned int DISABLE_PA_SX_REQ_INTF_FINE_CLOCK_GATE                       :  1;
+        unsigned int ENABLE_PA_RATE_CNTL                                          :  1;
+        unsigned int CLAMP_NEGATIVE_BB_TO_ZERO                                    :  1;
+        unsigned int                                                              :  8;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_CL_GB_HORZ_CLIP_ADJ {
     struct {
         unsigned int DATA_REGISTER                                                : 32;
     } bits, bitfields;
@@ -13440,21 +15008,21 @@ union PA_CL_NANINF_CNTL {
     signed int   i32All;
     float        f32All;
 };
 
 union PA_CL_NGG_CNTL {
     struct {
         unsigned int VERTEX_REUSE_OFF                                             :  1;
         unsigned int INDEX_BUF_EDGE_FLAG_ENA                                      :  1;
         unsigned int                                                              : 30;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  2;
         unsigned int VERTEX_REUSE_DEPTH                                           :  8;
         unsigned int                                                              : 22;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -14703,21 +16271,21 @@ union PA_CL_VPORT_ZSCALE_14 {
 union PA_CL_VPORT_ZSCALE_15 {
     struct {
         unsigned int VPORT_ZSCALE                                                 : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union PA_CL_VRS_CNTL {
     struct {
         unsigned int VERTEX_RATE_COMBINER_MODE                                    :  3;
         unsigned int PRIMITIVE_RATE_COMBINER_MODE                                 :  3;
         unsigned int HTILE_RATE_COMBINER_MODE                                     :  3;
         unsigned int SAMPLE_ITER_COMBINER_MODE                                    :  3;
         unsigned int                                                              :  1;
         unsigned int EXPOSE_VRS_PIXELS_MASK                                       :  1;
         unsigned int CMASK_RATE_HINT_FORCE_ZERO                                   :  1;
         unsigned int                                                              : 17;
@@ -14767,34 +16335,40 @@ union PA_CL_VS_OUT_CNTL {
         unsigned int                                                              : 26;
         unsigned int USE_VTX_LINE_WIDTH                                           :  1;
         unsigned int                                                              :  1;
         unsigned int                                                              :  4;
     } gfx09;
     struct {
         unsigned int                                                              : 25;
         unsigned int USE_VTX_GS_CUT_FLAG                                          :  1;
         unsigned int                                                              :  6;
     } gfx09_10;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 28;
         unsigned int USE_VTX_VRS_RATE                                             :  1;
         unsigned int BYPASS_VTX_RATE_COMBINER                                     :  1;
         unsigned int BYPASS_PRIM_RATE_COMBINER                                    :  1;
         unsigned int                                                              :  1;
     } gfx103Plus;
 #endif
     struct {
         unsigned int                                                              : 27;
         unsigned int USE_VTX_LINE_WIDTH                                           :  1;
         unsigned int                                                              :  4;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 31;
+        unsigned int USE_VTX_FSR_SELECT                                           :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_CL_VTE_CNTL {
     struct {
         unsigned int VPORT_X_SCALE_ENA                                            :  1;
         unsigned int VPORT_X_OFFSET_ENA                                           :  1;
@@ -14823,27 +16397,44 @@ union PA_PH_ENHANCE {
         unsigned int ECO_SPARE3                                                   :  1;
         unsigned int DISABLE_PH_SC_INTF_FINE_CLOCK_GATE                           :  1;
         unsigned int DISABLE_FOPKT                                                :  1;
         unsigned int DISABLE_FOPKT_SCAN_POST_RESET                                :  1;
         unsigned int DISABLE_PH_SC_INTF_CLKEN_CLOCK_GATE                          :  1;
         unsigned int                                                              :  1;
         unsigned int DISABLE_PH_PERF_REG_FGCG                                     :  1;
         unsigned int ENABLE_PH_INTF_CLKEN_STRETCH                                 :  3;
         unsigned int                                                              : 19;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 13;
         unsigned int DISABLE_USE_LAST_PH_ARBITER_PERFCOUNTER_SAMPLE_EVENT         :  1;
         unsigned int                                                              : 18;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 14;
+        unsigned int USE_PERFCOUNTER_START_STOP_EVENTS                            :  1;
+        unsigned int FORCE_PH_PERFCOUNTER_SAMPLE_ENABLE_ON                        :  1;
+        unsigned int                                                              : 16;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int PH_SPI_GE_THROTTLE_MODE                                      :  1;
+        unsigned int PH_SPI_GE_THROTTLE_MODE_DISABLE                              :  1;
+        unsigned int PH_SPI_GE_THROTTLE_PERFCOUNTER_COUNT_MODE                    :  1;
+        unsigned int                                                              : 13;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_PH_INTERFACE_FIFO_SIZE {
     struct {
         unsigned int PA_PH_IF_FIFO_SIZE                                           : 10;
         unsigned int                                                              :  6;
@@ -15165,35 +16756,51 @@ union PA_PH_PERFCOUNTER7_SELECT {
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PA_RATE_CNTL {
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int VERTEX_RATE                                                  :  4;
+        unsigned int PRIM_RATE                                                    :  4;
+        unsigned int                                                              : 24;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PA_SC_AA_CONFIG {
     struct {
         unsigned int MSAA_NUM_SAMPLES                                             :  3;
         unsigned int                                                              :  1;
         unsigned int AA_MASK_CENTROID_DTMN                                        :  1;
         unsigned int                                                              :  8;
         unsigned int MAX_SAMPLE_DIST                                              :  4;
         unsigned int                                                              :  3;
         unsigned int MSAA_EXPOSED_SAMPLES                                         :  3;
         unsigned int                                                              :  1;
         unsigned int DETAIL_TO_EXPOSED_MODE                                       :  2;
         unsigned int COVERAGE_TO_SHADER_SELECT                                    :  2;
         unsigned int                                                              :  4;
     } bits, bitfields;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 28;
         unsigned int SAMPLE_COVERAGE_ENCODING                                     :  1;
         unsigned int COVERED_CENTROID_IS_CENTER                                   :  1;
         unsigned int                                                              :  2;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
@@ -15487,20 +17094,38 @@ union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_3 {
         unsigned int S14_Y                                                        :  4;
         unsigned int S15_X                                                        :  4;
         unsigned int S15_Y                                                        :  4;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PA_SC_ATM_CNTL {
+    struct {
+        unsigned int SC_PC_IF_SIZE                                                :  6;
+        unsigned int                                                              :  1;
+        unsigned int DISABLE_SC_PC_IF_FGCG_EN                                     :  1;
+        unsigned int MAX_ATTRIBUTES_IN_WAVE                                       :  8;
+        unsigned int DISABLE_MAX_ATTRIBUTES                                       :  1;
+        unsigned int SELECT_MAX_ATTRIBUTES                                        :  1;
+        unsigned int                                                              : 14;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PA_SC_BC_WAVE_BREAK {
     struct {
         unsigned int MAX_DEALLOCS_IN_WAVE                                         : 11;
         unsigned int                                                              :  5;
         unsigned int MAX_FPOVS_IN_WAVE                                            :  8;
         unsigned int                                                              :  8;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
@@ -15541,20 +17166,49 @@ union PA_SC_BINNER_CNTL_1 {
     struct {
         unsigned int MAX_ALLOC_COUNT                                              : 16;
         unsigned int MAX_PRIM_PER_BATCH                                           : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PA_SC_BINNER_CNTL_2 {
+    struct {
+        unsigned int BIN_SIZE_X_MULT_BY_1P5X                                      :  1;
+        unsigned int BIN_SIZE_Y_MULT_BY_1P5X                                      :  1;
+        unsigned int ENABLE_LIGHT_VOLUME_RENDERING_OPTIMIZATION                   :  1;
+        unsigned int DUAL_LIGHT_SHAFT_IN_DRAW                                     :  1;
+        unsigned int                                                              :  3;
+        unsigned int CONTEXT_DONE_EVENTS_PER_BIN                                  :  4;
+        unsigned int ZPP_ENABLED                                                  :  1;
+        unsigned int ZPP_OPTIMIZATION_ENABLED                                     :  1;
+        unsigned int ZPP_AREA_THRESHOLD                                           :  8;
+        unsigned int DISABLE_NOPCEXPORT_BREAKBATCH_CONDITION                      :  1;
+        unsigned int                                                              : 10;
+    } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  4;
+        unsigned int LIGHT_SHAFT_DRAW_CALL_LIMIT                                  :  3;
+        unsigned int                                                              : 25;
+    } nv3x;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PA_SC_BINNER_CNTL_OVERRIDE {
     struct {
         unsigned int BINNING_MODE                                                 :  2;
         unsigned int                                                              :  8;
         unsigned int CONTEXT_STATES_PER_BIN                                       :  3;
         unsigned int PERSISTENT_STATES_PER_BIN                                    :  5;
         unsigned int                                                              :  1;
         unsigned int FPOVS_PER_BATCH                                              :  8;
         unsigned int DIRECT_OVERRIDE_MODE                                         :  1;
         unsigned int OVERRIDE                                                     :  4;
@@ -15617,20 +17271,27 @@ union PA_SC_BINNER_EVENT_CNTL_1 {
     struct {
         unsigned int                                                              : 10;
         unsigned int ZPASS_DONE                                                   :  2;
         unsigned int                                                              : 20;
     } gfx09_10;
     struct {
         unsigned int                                                              : 26;
         unsigned int BIN_CONF_OVERRIDE_CHECK                                      :  2;
         unsigned int                                                              :  4;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 10;
+        unsigned int WAIT_SYNC                                                    :  2;
+        unsigned int                                                              : 20;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SC_BINNER_EVENT_CNTL_2 {
     struct {
         unsigned int SAMPLE_STREAMOUTSTATS                                        :  2;
         unsigned int RESET_VTX_CNT                                                :  2;
@@ -15701,20 +17362,27 @@ union PA_SC_BINNER_EVENT_CNTL_3 {
         unsigned int                                                              :  2;
     } gfx09_10;
     struct {
         unsigned int                                                              :  4;
         unsigned int RESERVED_50                                                  :  2;
         unsigned int                                                              :  6;
         unsigned int THREAD_TRACE_DRAW                                            :  2;
         unsigned int                                                              : 16;
         unsigned int DRAW_DONE                                                    :  2;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 28;
+        unsigned int ENABLE_PIPELINE_NOT_USED                                     :  2;
+        unsigned int                                                              :  2;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SC_BINNER_PERF_CNTL_0 {
     struct {
         unsigned int BIN_HIST_NUM_PRIMS_THRESHOLD                                 : 10;
         unsigned int BATCH_HIST_NUM_PRIMS_THRESHOLD                               : 10;
@@ -16092,20 +17760,27 @@ union PA_SC_ENHANCE_1 {
         unsigned int DISABLE_SC_PS_PA_ARBITER_FIX                                 :  1;
         unsigned int DISABLE_SC_PS_PA_ARBITER_FIX_1                               :  1;
         unsigned int PASS_VPZ_EVENT_TO_SPI                                        :  1;
         unsigned int                                                              :  1;
     } gfx09_1xPlus;
     struct {
         unsigned int                                                              : 13;
         unsigned int DEBUG_PIXEL_PICKER_COUNT_PIXELS                              :  1;
         unsigned int                                                              : 18;
     } gfx10CorePlus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  5;
+        unsigned int DISABLE_NONBINNED_LIVE_PRIM_DG1_LS0_CL0_EOPKT_POKE           :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SC_ENHANCE_2 {
     struct {
         unsigned int                                                              : 11;
         unsigned int PBB_TIMEOUT_THRESHOLD_MODE                                   :  1;
@@ -16118,21 +17793,21 @@ union PA_SC_ENHANCE_2 {
         unsigned int                                                              :  6;
     } gfx10;
     struct {
         unsigned int ECO_SPARE0                                                   :  1;
         unsigned int ECO_SPARE1                                                   :  1;
         unsigned int ECO_SPARE2                                                   :  1;
         unsigned int ECO_SPARE3                                                   :  1;
         unsigned int                                                              : 26;
         unsigned int RSVD                                                         :  2;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int DISABLE_SC_MEM_MACRO_FINE_CLOCK_GATE                         :  1;
         unsigned int DISABLE_SC_DB_QUAD_INTF_FINE_CLOCK_GATE                      :  1;
         unsigned int DISABLE_SC_BCI_QUAD_INTF_FINE_CLOCK_GATE                     :  1;
         unsigned int DISABLE_SC_BCI_PRIM_INTF_FINE_CLOCK_GATE                     :  1;
         unsigned int                                                              : 26;
         unsigned int DISABLE_MAX_DEALLOC_FORCE_EOV_RESET_N_WAVES_COUNT            :  1;
         unsigned int RSVD                                                         :  1;
     } gfx103PlusExclusive;
 #endif
@@ -16183,42 +17858,81 @@ union PA_SC_ENHANCE_2 {
         unsigned int RESERVED_4                                                   :  1;
         unsigned int RESERVED_5                                                   :  1;
         unsigned int                                                              : 26;
     } vg12_Vg20_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union PA_SC_ENHANCE_3 {
     struct {
         unsigned int FORCE_USE_OF_SC_CENTROID_DATA                                :  1;
         unsigned int                                                              : 31;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              :  2;
         unsigned int DISABLE_RB_MASK_COPY_FOR_NONP2_SA_HARVEST                    :  1;
         unsigned int                                                              : 29;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  3;
         unsigned int FORCE_PBB_WORKLOAD_MODE_TO_ZERO                              :  1;
         unsigned int DISABLE_PKR_BCI_QUAD_NEW_PRIM_DATA_LOAD_OPTIMIZATION         :  1;
         unsigned int DISABLE_CP_CONTEXT_DONE_PERFCOUNT_SAMPLE_EN                  :  1;
         unsigned int                                                              : 26;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  6;
+        unsigned int ENABLE_SINGLE_PA_EOPKT_FIRST_PHASE_FILTER                    :  1;
+        unsigned int ENABLE_SINGLE_PA_EOPKT_LAST_PHASE_FILTER                     :  1;
+        unsigned int ENABLE_SINGLE_PA_EOPKT_LAST_PHASE_FILTER_FOR_PBB_BINNED_PRIMS :  1;
+        unsigned int DISABLE_SET_VPZ_DIRTY_EOPKT_LAST_PHASE_ONLY                  :  1;
+        unsigned int DISABLE_PBB_EOP_OPTIMIZATION_WITH_SAME_CONTEXT_BATCHES       :  1;
+        unsigned int DISABLE_FAST_NULL_PRIM_OPTIMIZATION                          :  1;
+        unsigned int USE_PBB_PRIM_STORAGE_WHEN_STALLED                            :  1;
+        unsigned int DISABLE_LIGHT_VOLUME_RENDERING_OPTIMIZATION                  :  1;
+        unsigned int                                                              : 18;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  2;
+        unsigned int DISABLE_RB_MASK_COPY_FOR_NONP2_SA_PAIR_HARVEST               :  1;
+        unsigned int                                                              : 11;
+        unsigned int DISABLE_ZPRE_PASS_OPTIMIZATION                               :  1;
+        unsigned int DISABLE_EVENT_INCLUSION_IN_CONTEXT_STATES_PER_BIN            :  1;
+        unsigned int DISABLE_PIXEL_WAIT_SYNC_COUNTERS                             :  1;
+        unsigned int DISABLE_SC_CPG_PSINVOC_SEDC_ISOLATION_ACCUM                  :  1;
+        unsigned int DISABLE_SC_QP_VRS_RATE_FB_FINE_CLOCK_GATE                    :  1;
+        unsigned int DISABLE_SC_QP_VRS_RATE_CACHE_RD_FINE_CLOCK_GATE              :  1;
+        unsigned int DISABLE_PKR_FORCE_EOV_MAX_REZ_CNT_FOR_SPI_BACKPRESSURE_ONLY  :  1;
+        unsigned int DISABLE_PKR_FORCE_EOV_MAX_CLK_CNT_FOR_SPI_BACKPRESSURE_ONLY  :  1;
+        unsigned int DO_NOT_INCLUDE_OREO_WAVEID_IN_FORCE_EOV_MAX_CNT_DISABLE      :  1;
+        unsigned int DISABLE_PWS_PRE_DEPTH_WAIT_SYNC_VPZ_INSERTION                :  1;
+        unsigned int PKR_CNT_FORCE_EOV_AT_QS_EMPTY_ONLY                           :  1;
+        unsigned int PKR_S0_FORCE_EOV_STALL                                       :  1;
+        unsigned int PKR_S1_FORCE_EOV_STALL                                       :  1;
+        unsigned int PKR_S2_FORCE_EOV_STALL                                       :  1;
+        unsigned int ECO_SPARE0                                                   :  1;
+        unsigned int ECO_SPARE1                                                   :  1;
+        unsigned int ECO_SPARE2                                                   :  1;
+        unsigned int ECO_SPARE3                                                   :  1;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              :  6;
         unsigned int RSVD                                                         : 26;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int                                                              :  6;
         unsigned int RSVD                                                         : 26;
@@ -16516,20 +18230,30 @@ union PA_SC_MODE_CNTL_1 {
 union PA_SC_NGG_MODE_CNTL {
     struct {
         unsigned int MAX_DEALLOCS_IN_WAVE                                         : 11;
         unsigned int                                                              : 21;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 16;
         unsigned int MAX_FPOVS_IN_WAVE                                            :  8;
         unsigned int                                                              :  8;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int DISABLE_FPOG_AND_DEALLOC_CONFLICT                            :  1;
+        unsigned int DISABLE_MAX_DEALLOC                                          :  1;
+        unsigned int DISABLE_MAX_ATTRIBUTES                                       :  1;
+        unsigned int                                                              :  9;
+        unsigned int MAX_ATTRIBUTES_IN_WAVE                                       :  8;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SC_P3D_TRAP_SCREEN_COUNT {
     struct {
         unsigned int COUNT                                                        : 16;
         unsigned int                                                              : 16;
@@ -16589,20 +18313,39 @@ union PA_SC_P3D_TRAP_SCREEN_V {
     struct {
         unsigned int Y_COORD                                                      : 14;
         unsigned int                                                              : 18;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PA_SC_PACKER_WAVE_ID_CNTL {
+    struct {
+        unsigned int WAVE_TABLE_SIZE                                              : 10;
+        unsigned int SC_DB_WAVE_IF_FIFO_SIZE                                      :  6;
+        unsigned int DISABLE_SC_DB_WAVE_IF_FGCG_EN                                :  1;
+        unsigned int SC_SPI_WAVE_IF_FIFO_SIZE                                     :  6;
+        unsigned int DISABLE_SC_SPI_WAVE_IF_FGCG_EN                               :  1;
+        unsigned int DEBUG_CONFLICT_QUAD                                          :  4;
+        unsigned int                                                              :  3;
+        unsigned int DISABLE_OREO_CONFLICT_QUAD                                   :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PA_SC_PBB_OVERRIDE_FLAG {
     struct {
         unsigned int OVERRIDE                                                     :  1;
         unsigned int PIPE_ID                                                      :  1;
         unsigned int                                                              : 30;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -16980,20 +18723,27 @@ union PA_SC_SHADER_CONTROL {
         unsigned int                                                              :  2;
         unsigned int LOAD_COLLISION_WAVEID                                        :  1;
         unsigned int LOAD_INTRAWAVE_COLLISION                                     :  1;
         unsigned int                                                              : 28;
     } core;
     struct {
         unsigned int                                                              :  5;
         unsigned int WAVE_BREAK_REGION_SIZE                                       :  2;
         unsigned int                                                              : 25;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  7;
+        unsigned int DISABLE_OREO_CONFLICT_QUAD                                   :  1;
+        unsigned int                                                              : 24;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SC_TILE_STEERING_CREST_OVERRIDE {
     struct {
         unsigned int ONE_RB_MODE_ENABLE                                           :  1;
         unsigned int SE_SELECT                                                    :  2;
@@ -17023,20 +18773,27 @@ union PA_SC_TILE_STEERING_OVERRIDE {
         unsigned int NUM_SE                                                       :  2;
         unsigned int                                                              :  2;
         unsigned int NUM_RB_PER_SE                                                :  2;
         unsigned int                                                              : 25;
     } most;
     struct {
         unsigned int                                                              : 20;
         unsigned int NUM_PACKER_PER_SC                                            :  1;
         unsigned int                                                              : 11;
     } gfx101;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 20;
+        unsigned int NUM_PACKER_PER_SC                                            :  2;
+        unsigned int                                                              : 10;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int                                                              : 12;
         unsigned int NUM_SC                                                       :  2;
         unsigned int                                                              :  2;
         unsigned int NUM_RB_PER_SC                                                :  2;
         unsigned int                                                              : 14;
     } gfx10Plus;
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              : 20;
@@ -17867,20 +19624,204 @@ union PA_SC_VPORT_ZMIN_14 {
 union PA_SC_VPORT_ZMIN_15 {
     struct {
         unsigned int VPORT_ZMIN                                                   : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_OVERRIDE_CNTL {
+    struct {
+        unsigned int VRS_OVERRIDE_RATE_COMBINER_MODE                              :  3;
+        unsigned int                                                              :  1;
+        unsigned int VRS_RATE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int VRS_SURFACE_ENABLE                                           :  1;
+        unsigned int RATE_HINT_WRITE_BACK_ENABLE                                  :  1;
+        unsigned int VRS_FEEDBACK_RATE_OVERRIDE                                   :  1;
+        unsigned int                                                              : 17;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_BASE {
+    struct {
+        unsigned int BASE_256B                                                    : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_BASE_EXT {
+    struct {
+        unsigned int BASE_256B                                                    :  8;
+        unsigned int                                                              : 20;
+        unsigned int TB_SYNC_SIM_ID                                               :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_CACHE_CNTL {
+    struct {
+        unsigned int BIG_PAGE_RD                                                  :  1;
+        unsigned int BIG_PAGE_WR                                                  :  1;
+        unsigned int L1_RD_POLICY                                                 :  2;
+        unsigned int L2_RD_POLICY                                                 :  2;
+        unsigned int L2_WR_POLICY                                                 :  2;
+        unsigned int LLC_RD_NOALLOC                                               :  1;
+        unsigned int LLC_WR_NOALLOC                                               :  1;
+        unsigned int NOFILL_RD                                                    :  1;
+        unsigned int NOFILL_WR                                                    :  1;
+        unsigned int PERF_CNTR_EN_RD                                              :  1;
+        unsigned int PERF_CNTR_EN_WR                                              :  1;
+        unsigned int                                                              : 18;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_FEEDBACK_BASE {
+    struct {
+        unsigned int BASE_256B                                                    : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_FEEDBACK_BASE_EXT {
+    struct {
+        unsigned int BASE_256B                                                    :  8;
+        unsigned int                                                              : 24;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_FEEDBACK_SIZE_XY {
+    struct {
+        unsigned int X_MAX                                                        : 11;
+        unsigned int                                                              :  5;
+        unsigned int Y_MAX                                                        : 11;
+        unsigned int                                                              :  5;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_RATE_SIZE_XY {
+    struct {
+        unsigned int X_MAX                                                        : 11;
+        unsigned int                                                              :  5;
+        unsigned int Y_MAX                                                        : 11;
+        unsigned int                                                              :  5;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_SURFACE_CNTL {
+    struct {
+        unsigned int                                                              :  6;
+        unsigned int VRC_CONTEXT_DONE_SYNC_DISABLE                                :  1;
+        unsigned int VRS_FEEDBACK_RATE_OVERRIDE                                   :  1;
+        unsigned int VRC_FLUSH_EVENT_MASK_DISABLE                                 :  5;
+        unsigned int VRC_PREFETCH_DISABLE                                         :  1;
+        unsigned int VRC_FLUSH_NO_INV_DISABLE                                     :  1;
+        unsigned int VRC_NONSTALLING_FLUSH_DISABLE                                :  1;
+        unsigned int VRC_PARTIAL_FLUSH_DISABLE                                    :  1;
+        unsigned int VRC_AUTO_FLUSH                                               :  1;
+        unsigned int VRC_EOP_SYNC_DISABLE                                         :  1;
+        unsigned int VRC_MAX_TAGS                                                 :  7;
+        unsigned int VRC_EVICT_POINT                                              :  6;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PA_SC_VRS_SURFACE_CNTL_1 {
+    struct {
+        unsigned int FORCE_SC_VRS_RATE_FINE                                       :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_SHADER_KILL_ENABLE                    :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_MASK_OPS_ENABLE                       :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_RATE_16XAA                            :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_Z_OR_STENCIL                          :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_PRE_SHADER_DEPTH_COVERAGE_ENABLED     :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_POST_DEPTH_IMPORT                     :  1;
+        unsigned int FORCE_SC_VRS_RATE_FINE_POPS                                  :  1;
+        unsigned int USE_ONLY_VRS_RATE_FINE_CFG                                   :  1;
+        unsigned int                                                              :  3;
+        unsigned int DISABLE_SSAA_VRS_RATE_NORMALIZATION                          :  1;
+        unsigned int                                                              :  2;
+        unsigned int DISABLE_PS_ITER_RATE_COMBINER_PASSTHRU_OVERRIDE              :  1;
+        unsigned int                                                              :  3;
+        unsigned int DISABLE_CMASK_RATE_HINT_FORCE_ZERO_OVERRIDE                  :  1;
+        unsigned int DISABLE_SSAA_DETAIL_TO_EXPOSED_RATE_CLAMPING                 :  1;
+        unsigned int VRS_ECO_SPARE_0                                              :  1;
+        unsigned int VRS_ECO_SPARE_1                                              :  1;
+        unsigned int VRS_ECO_SPARE_2                                              :  1;
+        unsigned int VRS_ECO_SPARE_3                                              :  1;
+        unsigned int VRS_ECO_SPARE_4                                              :  1;
+        unsigned int VRS_ECO_SPARE_5                                              :  1;
+        unsigned int VRS_ECO_SPARE_6                                              :  1;
+        unsigned int VRS_ECO_SPARE_7                                              :  1;
+        unsigned int VRS_ECO_SPARE_8                                              :  1;
+        unsigned int VRS_ECO_SPARE_9                                              :  1;
+        unsigned int VRS_ECO_SPARE_10                                             :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PA_SC_WINDOW_OFFSET {
     struct {
         unsigned int WINDOW_X_OFFSET                                              : 16;
         unsigned int WINDOW_Y_OFFSET                                              : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -18048,21 +19989,21 @@ union PA_SU_OVER_RASTERIZATION_CNTL {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SU_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 16;
         unsigned int                                                              : 16;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -18109,21 +20050,21 @@ union PA_SU_PERFCOUNTER0_SELECT1 {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SU_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 16;
         unsigned int                                                              : 16;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -18170,21 +20111,21 @@ union PA_SU_PERFCOUNTER1_SELECT1 {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SU_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 16;
         unsigned int                                                              : 16;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -18234,21 +20175,21 @@ union PA_SU_PERFCOUNTER2_SELECT1 {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PA_SU_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 16;
         unsigned int                                                              : 16;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -18560,90 +20501,40 @@ union PerfMonCtl1 {
         unsigned int                                                              :  8;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 16;
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv24;
 #endif
-    struct {
-        unsigned int                                                              : 16;
-        unsigned int ChipSelMask                                                  :  4;
-        unsigned int ChipIDSel                                                    :  4;
-        unsigned int                                                              :  8;
-    } vg12_Rn;
-
-    unsigned int u32All;
-    signed int   i32All;
-    float        f32All;
-};
-
-union PerfMonCtl2 {
-    struct {
-        unsigned int EventSelect                                                  :  8;
-        unsigned int RdWrMask                                                     :  2;
-        unsigned int PriorityMask                                                 :  4;
-        unsigned int ReqSizeMask                                                  :  2;
-        unsigned int                                                              :  8;
-        unsigned int VCSel                                                        :  5;
-        unsigned int SubChanMask                                                  :  2;
-        unsigned int Enable                                                       :  1;
-    } most;
-    struct {
-        unsigned int                                                              : 16;
-        unsigned int ChipSelMask                                                  :  4;
-        unsigned int ChipIDSel                                                    :  4;
-        unsigned int                                                              :  8;
-    } gfx101;
-#if CHIP_HDR_NAVI21
-    struct {
-        unsigned int                                                              : 16;
-        unsigned int BankSel                                                      :  8;
-        unsigned int                                                              :  8;
-    } nv21;
-#endif
-#if CHIP_HDR_NAVI22
+#if CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 16;
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
-    } nv22;
-#endif
-#if CHIP_HDR_NAVI23
-    struct {
-        unsigned int                                                              : 16;
-        unsigned int BankSel                                                      :  8;
-        unsigned int                                                              :  8;
-    } nv23;
-#endif
-#if CHIP_HDR_NAVI24
-    struct {
-        unsigned int                                                              : 16;
-        unsigned int BankSel                                                      :  8;
-        unsigned int                                                              :  8;
-    } nv24;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int ChipSelMask                                                  :  4;
         unsigned int ChipIDSel                                                    :  4;
         unsigned int                                                              :  8;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-union PerfMonCtl3 {
+union PerfMonCtl2 {
     struct {
         unsigned int EventSelect                                                  :  8;
         unsigned int RdWrMask                                                     :  2;
         unsigned int PriorityMask                                                 :  4;
         unsigned int ReqSizeMask                                                  :  2;
         unsigned int                                                              :  8;
         unsigned int VCSel                                                        :  5;
         unsigned int SubChanMask                                                  :  2;
         unsigned int Enable                                                       :  1;
     } most;
@@ -18673,20 +20564,91 @@ union PerfMonCtl3 {
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 16;
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv31;
+#endif
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int ChipSelMask                                                  :  4;
+        unsigned int ChipIDSel                                                    :  4;
+        unsigned int                                                              :  8;
+    } vg12_Rn;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+union PerfMonCtl3 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int                                                              :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } most;
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int ChipSelMask                                                  :  4;
+        unsigned int ChipIDSel                                                    :  4;
+        unsigned int                                                              :  8;
+    } gfx101;
+#if CHIP_HDR_NAVI21
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv21;
+#endif
+#if CHIP_HDR_NAVI22
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv22;
+#endif
+#if CHIP_HDR_NAVI23
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv23;
+#endif
+#if CHIP_HDR_NAVI24
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int ChipSelMask                                                  :  4;
         unsigned int ChipIDSel                                                    :  4;
         unsigned int                                                              :  8;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
@@ -18730,20 +20692,27 @@ union PerfMonCtl4 {
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 16;
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int ChipSelMask                                                  :  4;
         unsigned int ChipIDSel                                                    :  4;
         unsigned int                                                              :  8;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
@@ -18787,33 +20756,173 @@ union PerfMonCtl5 {
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 16;
         unsigned int BankSel                                                      :  8;
         unsigned int                                                              :  8;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int BankSel                                                      :  8;
+        unsigned int                                                              :  8;
+    } nv31;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int ChipSelMask                                                  :  4;
         unsigned int ChipIDSel                                                    :  4;
         unsigned int                                                              :  8;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PerfMonCtl6 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl7 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl8 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl9 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl10 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl11 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtl12 {
+    struct {
+        unsigned int EventSelect                                                  :  8;
+        unsigned int RdWrMask                                                     :  2;
+        unsigned int PriorityMask                                                 :  4;
+        unsigned int ReqSizeMask                                                  :  2;
+        unsigned int BankSel                                                      :  8;
+        unsigned int VCSel                                                        :  5;
+        unsigned int SubChanMask                                                  :  2;
+        unsigned int Enable                                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PerfMonCtlClk {
     struct {
         unsigned int                                                              : 24;
         unsigned int GlblReset                                                    :  1;
         unsigned int GlblMonEn                                                    :  1;
         unsigned int                                                              :  5;
         unsigned int CtrClkEn                                                     :  1;
     } most;
     struct {
         unsigned int GlblResetMsk                                                 :  6;
@@ -18843,20 +20952,31 @@ union PerfMonCtlClk {
         unsigned int                                                              :  9;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int GlblResetMsk                                                 :  6;
         unsigned int                                                              : 16;
         unsigned int ClkGate                                                      :  1;
         unsigned int                                                              :  9;
     } nv24;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int GlblResetMsk                                                 : 13;
+        unsigned int                                                              :  9;
+        unsigned int ClkGate                                                      :  1;
+        unsigned int SpmEn                                                        :  1;
+        unsigned int                                                              :  2;
+        unsigned int NumCounters                                                  :  4;
+        unsigned int                                                              :  2;
+    } nv31;
 #endif
     struct {
         unsigned int GlblResetMsk                                                 :  6;
         unsigned int                                                              : 26;
     } vg12_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -18888,20 +21008,27 @@ union PerfMonCtr1_Hi {
         unsigned int ThreshCnt                                                    : 12;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 18;
         unsigned int ThreshCntEn                                                  :  2;
         unsigned int ThreshCnt                                                    : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PerfMonCtr1_Lo {
     struct {
         unsigned int Data                                                         : 32;
     } most;
@@ -18938,20 +21065,27 @@ union PerfMonCtr2_Hi {
         unsigned int ThreshCnt                                                    : 12;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 18;
         unsigned int ThreshCntEn                                                  :  2;
         unsigned int ThreshCnt                                                    : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PerfMonCtr2_Lo {
     struct {
         unsigned int Data                                                         : 32;
     } most;
@@ -18988,20 +21122,27 @@ union PerfMonCtr3_Hi {
         unsigned int ThreshCnt                                                    : 12;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 18;
         unsigned int ThreshCntEn                                                  :  2;
         unsigned int ThreshCnt                                                    : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PerfMonCtr3_Lo {
     struct {
         unsigned int Data                                                         : 32;
     } most;
@@ -19038,20 +21179,27 @@ union PerfMonCtr4_Hi {
         unsigned int ThreshCnt                                                    : 12;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 18;
         unsigned int ThreshCntEn                                                  :  2;
         unsigned int ThreshCnt                                                    : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PerfMonCtr4_Lo {
     struct {
         unsigned int Data                                                         : 32;
     } most;
@@ -19088,36 +21236,239 @@ union PerfMonCtr5_Hi {
         unsigned int ThreshCnt                                                    : 12;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 18;
         unsigned int ThreshCntEn                                                  :  2;
         unsigned int ThreshCnt                                                    : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 18;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } nv31;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union PerfMonCtr5_Lo {
     struct {
         unsigned int Data                                                         : 32;
     } most;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union PerfMonCtr6_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr6_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr7_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr7_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr8_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr8_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr9_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr9_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr10_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr10_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr11_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr11_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr12_Hi {
+    struct {
+        unsigned int Data                                                         : 16;
+        unsigned int Overflow                                                     :  1;
+        unsigned int                                                              :  1;
+        unsigned int ThreshCntEn                                                  :  2;
+        unsigned int ThreshCnt                                                    : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union PerfMonCtr12_Lo {
+    struct {
+        unsigned int Data                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union PerfMonCtrClk_Hi {
     struct {
         unsigned int Data                                                         : 16;
         unsigned int Overflow                                                     :  1;
         unsigned int                                                              : 15;
     } most;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -19170,20 +21521,32 @@ union RLC_CGTT_MGCG_OVERRIDE {
     struct {
         unsigned int RESERVED_0                                                   :  1;
         unsigned int                                                              : 16;
         unsigned int RESERVED_31_17                                               : 15;
     } gfx10;
     struct {
         unsigned int                                                              :  9;
         unsigned int RESERVED_15_9                                                :  7;
         unsigned int                                                              : 16;
     } gfx10Core;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int RLC_REPEATER_FGCG_OVERRIDE                                   :  1;
+        unsigned int                                                              :  8;
+        unsigned int GFXIP_REPEATER_FGCG_OVERRIDE                                 :  1;
+        unsigned int PERFMON_CLOCK_STATE                                          :  1;
+        unsigned int RESERVED_16_11                                               :  6;
+        unsigned int GC_CAC_MGCG_CLK_CNTL                                         :  1;
+        unsigned int SE_CAC_MGCG_CLK_CNTL                                         :  1;
+        unsigned int RESERVED_31_19                                               : 13;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RLC_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -19281,21 +21644,21 @@ union RLC_SPM_ACCUM_CTRL {
         unsigned int StrobeSpmDoneInt                                             :  1;
         unsigned int StrobeAccumDoneInt                                           :  1;
         unsigned int StrobeResetAccum                                             :  1;
         unsigned int StrobeStartSpm                                               :  4;
         unsigned int                                                              : 22;
     } most;
     struct {
         unsigned int                                                              : 10;
         unsigned int RESERVED                                                     : 22;
     } gfx101;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  3;
         unsigned int StrobeResetSpmBlock                                          :  1;
         unsigned int StrobeStartSpm                                               :  4;
         unsigned int StrobeRearmSwaAccum                                          :  1;
         unsigned int StrobeStartSwa                                               :  1;
         unsigned int StrobePerfmonSampleWires                                     :  1;
         unsigned int RESERVED                                                     : 21;
     } gfx103Plus;
 #endif
@@ -19316,32 +21679,38 @@ union RLC_SPM_ACCUM_CTRLRAM_ADDR {
     } most;
     struct {
         unsigned int                                                              :  9;
         unsigned int RESERVED                                                     : 23;
     } gfx101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int addr                                                         : 11;
         unsigned int RESERVED                                                     : 21;
     } gfx103;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int addr                                                         : 11;
+        unsigned int RESERVED                                                     : 21;
+    } nv3x;
 #endif
     struct {
         unsigned int addr                                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } rv2x_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_ACCUM_CTRLRAM_ADDR_OFFSET {
     struct {
         unsigned int global_offset                                                :  8;
         unsigned int spmwithaccum_se_offset                                       :  8;
         unsigned int spmwithaccum_global_offset                                   :  8;
         unsigned int RESERVED                                                     :  8;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
@@ -19353,21 +21722,21 @@ union RLC_SPM_ACCUM_CTRLRAM_DATA {
     struct {
         unsigned int data                                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_ACCUM_DATARAM_32BITCNTRS_REGIONS {
     struct {
         unsigned int spp_addr_region                                              :  8;
         unsigned int swa_addr_region                                              :  8;
         unsigned int RESERVED                                                     : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -19418,21 +21787,21 @@ union RLC_SPM_ACCUM_MODE {
         unsigned int Globals_LoadOverride                                         :  1;
         unsigned int SE0_LoadOverride                                             :  1;
         unsigned int                                                              : 27;
     } most;
     struct {
         unsigned int                                                              :  5;
         unsigned int SE1_LoadOverride                                             :  1;
         unsigned int AutoResetPerfmonDisable                                      :  1;
         unsigned int RESERVED                                                     : 25;
     } gfx101;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  1;
         unsigned int EnableSpmWithAccumMode                                       :  1;
         unsigned int EnableSPPMode                                                :  1;
         unsigned int AutoResetPerfmonDisable                                      :  1;
         unsigned int                                                              :  1;
         unsigned int AutoAccumEn                                                  :  1;
         unsigned int SwaAutoAccumEn                                               :  1;
         unsigned int AutoSpmEn                                                    :  1;
         unsigned int SwaAutoSpmEn                                                 :  1;
@@ -19470,20 +21839,42 @@ union RLC_SPM_ACCUM_MODE {
         unsigned int                                                              : 17;
     } nv22;
 #endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int                                                              : 13;
         unsigned int SE1_LoadOverride                                             :  1;
         unsigned int SE1_SwaLoadOverride                                          :  1;
         unsigned int                                                              : 17;
     } nv23;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 15;
+        unsigned int SE2_LoadOverride                                             :  1;
+        unsigned int SE2_SwaLoadOverride                                          :  1;
+        unsigned int SE3_LoadOverride                                             :  1;
+        unsigned int SE3_SwaLoadOverride                                          :  1;
+        unsigned int SE4_LoadOverride                                             :  1;
+        unsigned int SE4_SwaLoadOverride                                          :  1;
+        unsigned int SE5_LoadOverride                                             :  1;
+        unsigned int SE5_SwaLoadOverride                                          :  1;
+        unsigned int                                                              :  9;
+    } nv31;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int SE1_LoadOverride                                             :  1;
+        unsigned int SE1_SwaLoadOverride                                          :  1;
+        unsigned int                                                              : 17;
+    } nv3x;
 #endif
     struct {
         unsigned int                                                              :  5;
         unsigned int AutoResetPerfmonDisable                                      :  1;
         unsigned int RESERVED                                                     : 26;
     } rv2x_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -19518,39 +21909,46 @@ union RLC_SPM_ACCUM_STATUS {
         unsigned int SequenceInProgress                                           :  1;
         unsigned int FinalSequenceInProgress                                      :  1;
         unsigned int AllFifosEmpty                                                :  1;
         unsigned int FSMIsIdle                                                    :  1;
         unsigned int                                                              : 16;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 16;
         unsigned int RESERVED                                                     : 16;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 20;
         unsigned int AllSegsDone                                                  :  1;
         unsigned int RearmSwaPending                                              :  1;
         unsigned int RearmSppPending                                              :  1;
         unsigned int                                                              :  9;
     } gfx103CorePlus;
 #endif
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 16;
         unsigned int SwaAccumDone                                                 :  1;
         unsigned int SwaSpmDone                                                   :  1;
         unsigned int SwaAccumOverflow                                             :  1;
         unsigned int SwaAccumArmed                                                :  1;
         unsigned int                                                              : 12;
     } gfx103Plus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 23;
+        unsigned int MultiSampleAborted                                           :  1;
+        unsigned int RESERVED                                                     :  8;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              : 23;
         unsigned int RESERVED                                                     :  9;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int                                                              : 23;
         unsigned int MultiSampleAborted                                           :  1;
@@ -19574,34 +21972,34 @@ union RLC_SPM_ACCUM_STATUS {
     struct {
         unsigned int                                                              : 16;
         unsigned int RESERVED                                                     : 16;
     } rv2x_Rn;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_ACCUM_SWA_DATARAM_ADDR {
     struct {
         unsigned int addr                                                         :  7;
         unsigned int RESERVED                                                     : 25;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_ACCUM_SWA_DATARAM_DATA {
     struct {
         unsigned int data                                                         : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
@@ -19739,33 +22137,33 @@ union RLC_SPM_GDS_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_GFXCLOCK_HIGHCOUNT {
     struct {
         unsigned int GFXCLOCK_HIGHCOUNT                                           : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union RLC_SPM_GFXCLOCK_LOWCOUNT {
     struct {
         unsigned int GFXCLOCK_LOWCOUNT                                            : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
@@ -19806,28 +22204,60 @@ union RLC_SPM_GLOBALS_SAMPLE_SKEW {
     struct {
         unsigned int GLOBALS_SAMPLE_SKEW                                          :  7;
         unsigned int RESERVED                                                     : 25;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_GLOBAL_DELAY_IND_ADDR {
+    struct {
+        unsigned int ADDR                                                         : 12;
+        unsigned int                                                              : 20;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_GLOBAL_DELAY_IND_DATA {
+    struct {
+        unsigned int DATA                                                         :  6;
+        unsigned int                                                              : 26;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_GLOBAL_MUXSEL_ADDR {
     struct {
         unsigned int PERFMON_SEL_ADDR                                             : 32;
     } gfx09;
     struct {
         unsigned int PERFMON_SEL_ADDR                                             :  8;
         unsigned int RESERVED                                                     : 24;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int ADDR                                                         : 12;
+        unsigned int                                                              : 20;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 union RLC_SPM_GLOBAL_MUXSEL_ADDR_OFFSET {
     struct {
         unsigned int OFFSET                                                       : 16;
@@ -19837,20 +22267,26 @@ union RLC_SPM_GLOBAL_MUXSEL_ADDR_OFFSET {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union RLC_SPM_GLOBAL_MUXSEL_DATA {
     struct {
         unsigned int PERFMON_SEL_DATA                                             : 32;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SEL0                                                         : 16;
+        unsigned int SEL1                                                         : 16;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RLC_SPM_IA_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
@@ -19918,28 +22354,28 @@ union RLC_SPM_MC_CNTL {
         unsigned int RLC_SPM_MTYPE_OVER                                           :  1;
         unsigned int RLC_SPM_MTYPE                                                :  2;
         unsigned int RESERVED                                                     : 22;
     } gfx09;
     struct {
         unsigned int                                                              : 13;
         unsigned int RESERVED_2                                                   :  1;
         unsigned int                                                              :  2;
         unsigned int RESERVED                                                     : 16;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 16;
         unsigned int RESERVED_3                                                   :  2;
         unsigned int                                                              : 14;
     } gfx103CorePlus;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 20;
         unsigned int RESERVED                                                     : 12;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 12;
         unsigned int RLC_SPM_BC                                                   :  1;
         unsigned int                                                              :  1;
         unsigned int RLC_SPM_VOL                                                  :  1;
@@ -19989,26 +22425,63 @@ union RLC_SPM_MC_CNTL {
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 13;
         unsigned int RLC_SPM_RO                                                   :  1;
         unsigned int                                                              :  4;
         unsigned int RLC_SPM_LLC_NOALLOC                                          :  1;
         unsigned int RLC_SPM_LLC_NOALLOC_OVER                                     :  1;
         unsigned int                                                              : 12;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int RLC_SPM_RO                                                   :  1;
+        unsigned int                                                              :  4;
+        unsigned int RLC_SPM_LLC_NOALLOC                                          :  1;
+        unsigned int RLC_SPM_LLC_NOALLOC_OVER                                     :  1;
+        unsigned int                                                              : 12;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_MODE {
+    struct {
+        unsigned int MODE                                                         :  1;
+        unsigned int                                                              : 31;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_PAUSE {
+    struct {
+        unsigned int PAUSE                                                        :  1;
+        unsigned int PAUSED                                                       :  1;
+        unsigned int                                                              : 30;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_PA_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -20027,20 +22500,28 @@ union RLC_SPM_PERFMON_CNTL {
     } gfx09;
     struct {
         unsigned int                                                              : 14;
         unsigned int RESERVED                                                     :  2;
         unsigned int                                                              : 16;
     } gfx10Core;
     struct {
         unsigned int RESERVED1                                                    : 12;
         unsigned int                                                              : 20;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 14;
+        unsigned int DISABLE_GFXCLOCK_COUNT                                       :  1;
+        unsigned int RESERVED                                                     :  1;
+        unsigned int                                                              : 16;
+    } gfx11;
+#endif
     struct {
         unsigned int RLC_DBG_STRM_EN                                              :  1;
         unsigned int RLC_DBG_STRM_EXT_SAMPLE                                      :  1;
         unsigned int RESERVED1                                                    : 10;
         unsigned int                                                              : 20;
     } raven;
     struct {
         unsigned int RESERVED1                                                    : 12;
         unsigned int                                                              : 20;
     } vega;
@@ -20120,20 +22601,27 @@ union RLC_SPM_PERFMON_SE3TO0_SEGMENT_SIZE {
 union RLC_SPM_PERFMON_SEGMENT_SIZE {
     struct {
         unsigned int PERFMON_SEGMENT_SIZE                                         :  8;
         unsigned int RESERVED1                                                    :  3;
         unsigned int GLOBAL_NUM_LINE                                              :  5;
         unsigned int SE0_NUM_LINE                                                 :  5;
         unsigned int SE1_NUM_LINE                                                 :  5;
         unsigned int SE2_NUM_LINE                                                 :  5;
         unsigned int RESERVED                                                     :  1;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int TOTAL_NUM_SEGMENT                                            : 16;
+        unsigned int GLOBAL_NUM_SEGMENT                                           :  8;
+        unsigned int SE_NUM_SEGMENT                                               :  8;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 union RLC_SPM_PERFMON_SWA_GLB_SEGMENT_SIZE {
     struct {
         unsigned int PERFMON_SEGMENT_SIZE                                         :  8;
@@ -20205,20 +22693,119 @@ union RLC_SPM_RMI_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_CMD {
+    struct {
+        unsigned int CMD                                                          :  4;
+        unsigned int                                                              : 28;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_CMD_ACK {
+    struct {
+        unsigned int SE0_ACK                                                      :  1;
+        unsigned int SE1_ACK                                                      :  1;
+        unsigned int SE2_ACK                                                      :  1;
+        unsigned int SE3_ACK                                                      :  1;
+        unsigned int SE4_ACK                                                      :  1;
+        unsigned int SE5_ACK                                                      :  1;
+        unsigned int SE6_ACK                                                      :  1;
+        unsigned int SE7_ACK                                                      :  1;
+        unsigned int SPM_ACK                                                      :  1;
+        unsigned int                                                              : 23;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_REQ_DATA_HI {
+    struct {
+        unsigned int DATA                                                         : 12;
+        unsigned int                                                              : 20;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_REQ_DATA_LO {
+    struct {
+        unsigned int DATA                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_REQ_OP {
+    struct {
+        unsigned int OP                                                           :  4;
+        unsigned int                                                              : 28;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_RET_DATA {
+    struct {
+        unsigned int DATA                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_RSPM_RET_OP {
+    struct {
+        unsigned int OP                                                           :  4;
+        unsigned int                                                              :  4;
+        unsigned int VALID                                                        :  1;
+        unsigned int                                                              : 23;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_SAMPLE_CNT {
     struct {
         unsigned int COUNT                                                        : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -20240,28 +22827,60 @@ union RLC_SPM_SEGMENT_THRESHOLD {
     struct {
         unsigned int NUM_SEGMENT_THRESHOLD                                        :  8;
         unsigned int RESERVED                                                     : 24;
     } gfx10Plus;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_DELAY_IND_ADDR {
+    struct {
+        unsigned int ADDR                                                         : 12;
+        unsigned int                                                              : 20;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_DELAY_IND_DATA {
+    struct {
+        unsigned int DATA                                                         :  6;
+        unsigned int                                                              : 26;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_SE_MUXSEL_ADDR {
     struct {
         unsigned int PERFMON_SEL_ADDR                                             : 32;
     } gfx09;
     struct {
         unsigned int PERFMON_SEL_ADDR                                             :  9;
         unsigned int RESERVED                                                     : 23;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int ADDR                                                         : 12;
+        unsigned int                                                              : 20;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 union RLC_SPM_SE_MUXSEL_ADDR_OFFSET {
     struct {
         unsigned int OFFSET                                                       : 16;
@@ -20271,37 +22890,108 @@ union RLC_SPM_SE_MUXSEL_ADDR_OFFSET {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union RLC_SPM_SE_MUXSEL_DATA {
     struct {
         unsigned int PERFMON_SEL_DATA                                             : 32;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SEL0                                                         : 16;
+        unsigned int SEL1                                                         : 16;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RLC_SPM_SE_MUXSEL_SKEW {
     struct {
         unsigned int SE_MUXSEL_SKEW                                               :  7;
         unsigned int RESERVED                                                     : 25;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_RSPM_REQ_DATA_HI {
+    struct {
+        unsigned int DATA                                                         : 12;
+        unsigned int                                                              : 20;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_RSPM_REQ_DATA_LO {
+    struct {
+        unsigned int DATA                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_RSPM_REQ_OP {
+    struct {
+        unsigned int OP                                                           :  4;
+        unsigned int                                                              : 28;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_RSPM_RET_DATA {
+    struct {
+        unsigned int DATA                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SE_RSPM_RET_OP {
+    struct {
+        unsigned int OP                                                           :  4;
+        unsigned int                                                              :  4;
+        unsigned int VALID                                                        :  1;
+        unsigned int                                                              : 23;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_SE_SAMPLEDELAY_IND_ADDR {
     struct {
         unsigned int SE_SAMPLEDELAY_INDEX                                         : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
@@ -20320,20 +23010,32 @@ union RLC_SPM_SE_SAMPLE_SKEW {
     struct {
         unsigned int SE_SAMPLE_SKEW                                               :  7;
         unsigned int RESERVED                                                     : 25;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_SPARE {
+    struct {
+        unsigned int SPARE                                                        : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_SPI_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -20342,20 +23044,43 @@ union RLC_SPM_SQG_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union RLC_SPM_STATUS {
+    struct {
+        unsigned int CTL_BUSY                                                     :  1;
+        unsigned int RSPM_REG_BUSY                                                :  1;
+        unsigned int SPM_RSPM_BUSY                                                :  1;
+        unsigned int SPM_RSPM_IO_BUSY                                             :  1;
+        unsigned int SE_RSPM_IO_BUSY                                              :  8;
+        unsigned int                                                              :  3;
+        unsigned int ACCUM_BUSY                                                   :  1;
+        unsigned int FSM_MASTER_STATE                                             :  4;
+        unsigned int FSM_MEMORY_STATE                                             :  4;
+        unsigned int CTL_REQ_STATE                                                :  2;
+        unsigned int CTL_RET_STATE                                                :  1;
+        unsigned int                                                              :  5;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union RLC_SPM_SX_PERFMON_SAMPLE_DELAY {
     struct {
         unsigned int PERFMON_SAMPLE_DELAY                                         :  8;
         unsigned int RESERVED                                                     : 24;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -20531,38 +23256,52 @@ union RMI_PERFCOUNTER0_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL1                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int PERF_SEL1                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL3                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL2                                                    : 10;
+        unsigned int PERF_SEL3                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERFCOUNTER1_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -20584,20 +23323,26 @@ union RMI_PERFCOUNTER1_LO {
 
 union RMI_PERFCOUNTER1_SELECT {
     struct {
         unsigned int                                                              : 28;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 23;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERFCOUNTER2_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -20623,38 +23368,52 @@ union RMI_PERFCOUNTER2_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL1                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int PERF_SEL1                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERFCOUNTER2_SELECT1 {
     struct {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  9;
         unsigned int                                                              :  1;
         unsigned int PERF_SEL3                                                    :  9;
         unsigned int                                                              : 13;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL2                                                    : 10;
+        unsigned int PERF_SEL3                                                    : 10;
+        unsigned int                                                              : 12;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERFCOUNTER3_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
     } bits, bitfields;
@@ -20676,20 +23435,26 @@ union RMI_PERFCOUNTER3_LO {
 
 union RMI_PERFCOUNTER3_SELECT {
     struct {
         unsigned int                                                              : 28;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  9;
         unsigned int                                                              : 23;
     } most;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 22;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union RMI_PERF_COUNTER_CNTL {
     struct {
         unsigned int TRANS_BASED_PERF_EN_SEL                                      :  2;
         unsigned int EVENT_BASED_PERF_EN_SEL                                      :  2;
@@ -20820,95 +23585,95 @@ union RPB_PERF_COUNTER_CNTL {
     struct {
         unsigned int PERF_COUNTER_SELECT                                          :  2;
         unsigned int                                                              : 30;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_MISC_CNTL {
     struct {
         unsigned int CMD_OP                                                       : 16;
         unsigned int                                                              : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_PERFCOUNTER0_CFG {
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_PERFCOUNTER1_CFG {
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_PERFCOUNTER_HI {
     struct {
         unsigned int COUNTER_HI                                                   : 16;
         unsigned int COMPARE_VALUE                                                : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_PERFCOUNTER_LO {
     struct {
         unsigned int COUNTER_LO                                                   : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SDMA0_PERFCNT_PERFCOUNTER_RSLT_CNTL {
     struct {
         unsigned int PERF_COUNTER_SELECT                                          :  4;
         unsigned int                                                              :  4;
         unsigned int START_TRIGGER                                                :  8;
         unsigned int STOP_TRIGGER                                                 :  8;
         unsigned int ENABLE_ANY                                                   :  1;
         unsigned int CLEAR_ALL                                                    :  1;
         unsigned int STOP_ALL_ON_SATURATE                                         :  1;
         unsigned int                                                              :  5;
@@ -21058,48 +23823,54 @@ union SDMA0_PERFMON_CNTL {
         unsigned int PERF_CLEAR1                                                  :  1;
         unsigned int PERF_SEL1                                                    :  8;
         unsigned int                                                              : 12;
     } most;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_MISC_CNTL {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int CMD_OP                                                       : 16;
         unsigned int                                                              : 16;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int CMD_OP                                                       : 16;
         unsigned int                                                              : 16;
     } nv22;
 #endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int CMD_OP                                                       : 16;
         unsigned int                                                              : 16;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int CMD_OP                                                       : 16;
+        unsigned int                                                              : 16;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_PERFCOUNTER0_CFG {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
@@ -21120,28 +23891,39 @@ union SDMA1_PERFCNT_PERFCOUNTER0_CFG {
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     :  8;
+        unsigned int PERF_SEL_END                                                 :  8;
+        unsigned int                                                              :  8;
+        unsigned int PERF_MODE                                                    :  4;
+        unsigned int ENABLE                                                       :  1;
+        unsigned int CLEAR                                                        :  1;
+        unsigned int                                                              :  2;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_PERFCOUNTER1_CFG {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
@@ -21162,79 +23944,101 @@ union SDMA1_PERFCNT_PERFCOUNTER1_CFG {
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int PERF_SEL_END                                                 :  8;
         unsigned int                                                              :  8;
         unsigned int PERF_MODE                                                    :  4;
         unsigned int ENABLE                                                       :  1;
         unsigned int CLEAR                                                        :  1;
         unsigned int                                                              :  2;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_SEL                                                     :  8;
+        unsigned int PERF_SEL_END                                                 :  8;
+        unsigned int                                                              :  8;
+        unsigned int PERF_MODE                                                    :  4;
+        unsigned int ENABLE                                                       :  1;
+        unsigned int CLEAR                                                        :  1;
+        unsigned int                                                              :  2;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_PERFCOUNTER_HI {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int COUNTER_HI                                                   : 16;
         unsigned int COMPARE_VALUE                                                : 16;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int COUNTER_HI                                                   : 16;
         unsigned int COMPARE_VALUE                                                : 16;
     } nv22;
 #endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int COUNTER_HI                                                   : 16;
         unsigned int COMPARE_VALUE                                                : 16;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int COUNTER_HI                                                   : 16;
+        unsigned int COMPARE_VALUE                                                : 16;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_PERFCOUNTER_LO {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int COUNTER_LO                                                   : 32;
     } nv21;
 #endif
 #if CHIP_HDR_NAVI22
     struct {
         unsigned int COUNTER_LO                                                   : 32;
     } nv22;
 #endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int COUNTER_LO                                                   : 32;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int COUNTER_LO                                                   : 32;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 union SDMA1_PERFCNT_PERFCOUNTER_RSLT_CNTL {
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int PERF_COUNTER_SELECT                                          :  4;
         unsigned int                                                              :  4;
         unsigned int START_TRIGGER                                                :  8;
         unsigned int STOP_TRIGGER                                                 :  8;
         unsigned int ENABLE_ANY                                                   :  1;
         unsigned int CLEAR_ALL                                                    :  1;
         unsigned int STOP_ALL_ON_SATURATE                                         :  1;
@@ -21258,20 +24062,32 @@ union SDMA1_PERFCNT_PERFCOUNTER_RSLT_CNTL {
         unsigned int PERF_COUNTER_SELECT                                          :  4;
         unsigned int                                                              :  4;
         unsigned int START_TRIGGER                                                :  8;
         unsigned int STOP_TRIGGER                                                 :  8;
         unsigned int ENABLE_ANY                                                   :  1;
         unsigned int CLEAR_ALL                                                    :  1;
         unsigned int STOP_ALL_ON_SATURATE                                         :  1;
         unsigned int                                                              :  5;
     } nv23;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int PERF_COUNTER_SELECT                                          :  4;
+        unsigned int                                                              :  4;
+        unsigned int START_TRIGGER                                                :  8;
+        unsigned int STOP_TRIGGER                                                 :  8;
+        unsigned int ENABLE_ANY                                                   :  1;
+        unsigned int CLEAR_ALL                                                    :  1;
+        unsigned int STOP_ALL_ON_SATURATE                                         :  1;
+        unsigned int                                                              :  5;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union SDMA1_PERFCOUNTER0_HI {
     struct {
         unsigned int PERFCOUNTER_HI                                               : 32;
@@ -21873,20 +24689,51 @@ union SPI_ARB_PRIORITY {
         unsigned int TS2_DUR_MULT                                                 :  2;
         unsigned int TS3_DUR_MULT                                                 :  2;
         unsigned int                                                              : 12;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SPI_ATTRIBUTE_RING_BASE {
+    struct {
+        unsigned int BASE                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_ATTRIBUTE_RING_SIZE {
+    struct {
+        unsigned int MEM_SIZE                                                     :  8;
+        unsigned int                                                              :  8;
+        unsigned int BIG_PAGE                                                     :  1;
+        unsigned int L1_POLICY                                                    :  2;
+        unsigned int L2_POLICY                                                    :  2;
+        unsigned int LLC_NOALLOC                                                  :  1;
+        unsigned int GL1_PERF_COUNTER_DISABLE                                     :  1;
+        unsigned int                                                              :  9;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SPI_BARYC_CNTL {
     struct {
         unsigned int PERSP_CENTER_CNTL                                            :  1;
         unsigned int                                                              :  3;
         unsigned int PERSP_CENTROID_CNTL                                          :  1;
         unsigned int                                                              :  3;
         unsigned int LINEAR_CENTER_CNTL                                           :  1;
         unsigned int                                                              :  3;
         unsigned int LINEAR_CENTROID_CNTL                                         :  1;
         unsigned int                                                              :  3;
@@ -21896,21 +24743,21 @@ union SPI_BARYC_CNTL {
         unsigned int                                                              :  3;
         unsigned int FRONT_FACE_ALL_BITS                                          :  1;
         unsigned int                                                              :  7;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_BARYC_SSAA_CNTL {
     struct {
         unsigned int CENTER_SSAA_MODE                                             :  1;
         unsigned int CENTROID_SSAA_MODE                                           :  1;
         unsigned int                                                              : 30;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -21936,20 +24783,63 @@ union SPI_COMPUTE_WF_CTX_SAVE {
         unsigned int                                                              : 27;
         unsigned int GDS_REQ_BUSY                                                 :  1;
         unsigned int SAVE_BUSY                                                    :  1;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SPI_COMPUTE_WF_CTX_SAVE_STATUS {
+    struct {
+        unsigned int PIPE0_QUEUE0_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE1_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE2_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE3_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE4_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE5_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE6_SAVE_BUSY                                       :  1;
+        unsigned int PIPE0_QUEUE7_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE0_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE1_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE2_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE3_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE4_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE5_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE6_SAVE_BUSY                                       :  1;
+        unsigned int PIPE1_QUEUE7_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE0_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE1_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE2_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE3_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE4_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE5_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE6_SAVE_BUSY                                       :  1;
+        unsigned int PIPE2_QUEUE7_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE0_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE1_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE2_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE3_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE4_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE5_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE6_SAVE_BUSY                                       :  1;
+        unsigned int PIPE3_QUEUE7_SAVE_BUSY                                       :  1;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SPI_CONFIG_CNTL {
     struct {
         unsigned int GPR_WRITE_PRIORITY                                           : 21;
         unsigned int EXP_PRIORITY_ORDER                                           :  3;
         unsigned int ENABLE_SQG_TOP_EVENTS                                        :  1;
         unsigned int ENABLE_SQG_BOP_EVENTS                                        :  1;
         unsigned int                                                              :  2;
         unsigned int ALLOC_ARB_LRU_ENA                                            :  1;
         unsigned int EXP_ARB_LRU_ENA                                              :  1;
         unsigned int PS_PKR_PRIORITY_CNTL                                         :  2;
@@ -22009,35 +24899,50 @@ union SPI_CONFIG_CNTL_1 {
     struct {
         unsigned int                                                              : 22;
         unsigned int RESERVED                                                     : 10;
     } gfx101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 23;
         unsigned int RESERVED                                                     :  9;
     } gfx103;
 #endif
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 22;
         unsigned int SA_SCREEN_MAP                                                :  1;
         unsigned int                                                              :  9;
     } gfx103Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  8;
+        unsigned int PS_GROUP_TIMEOUT_MODE                                        :  1;
+        unsigned int                                                              : 14;
+        unsigned int PS_GROUP_TIMEOUT                                             :  9;
+    } gfx104Plus;
 #endif
     struct {
         unsigned int                                                              :  5;
         unsigned int PC_LIMIT_ENABLE                                              :  2;
         unsigned int                                                              :  9;
         unsigned int MAX_VTX_SYNC_CNT                                             :  5;
         unsigned int EN_USER_ACCUM                                                :  1;
         unsigned int                                                              : 10;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int OREO_EXPALLOC_STALL                                          :  1;
+        unsigned int                                                              : 22;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_CONFIG_CNTL_1_REMAP {
     struct {
         unsigned int RESERVED                                                     : 32;
     } gfx101;
@@ -22066,20 +24971,31 @@ union SPI_CONFIG_CNTL_1_REMAP {
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_CONFIG_CNTL_2 {
     struct {
         unsigned int CONTEXT_SAVE_WAIT_GDS_REQUEST_CYCLE_OVHD                     :  4;
         unsigned int CONTEXT_SAVE_WAIT_GDS_GRANT_CYCLE_OVHD                       :  4;
         unsigned int                                                              : 24;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  8;
+        unsigned int PWS_CSG_WAIT_DISABLE                                         :  1;
+        unsigned int PWS_HS_WAIT_DISABLE                                          :  1;
+        unsigned int PWS_GS_WAIT_DISABLE                                          :  1;
+        unsigned int PWS_PS_WAIT_DISABLE                                          :  1;
+        unsigned int CSC_HALT_ACK_DELAY                                           :  5;
+        unsigned int                                                              : 15;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_CONFIG_CNTL_2_REMAP {
     struct {
         unsigned int RESERVED                                                     : 32;
     } gfx101;
@@ -22138,35 +25054,43 @@ union SPI_CONFIG_CNTL_REMAP {
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_CONFIG_PS_CU_EN {
     struct {
         unsigned int ENABLE                                                       :  1;
         unsigned int PKR0_CU_EN                                                   : 15;
         unsigned int PKR1_CU_EN                                                   : 16;
     } gfx09;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PKR_OFFSET                                                   :  4;
         unsigned int                                                              : 28;
     } gfx103CorePlus;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  4;
+        unsigned int PKR2_OFFSET                                                  :  4;
+        unsigned int PKR3_OFFSET                                                  :  4;
+        unsigned int                                                              : 20;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_CSG_PIPE_CONTROL {
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int HYSTERESIS_CNT                                               : 13;
         unsigned int                                                              : 19;
     } gfx103CorePlus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -22279,21 +25203,21 @@ union SPI_CSQ_WF_ACTIVE_COUNT_7 {
 union SPI_CSQ_WF_ACTIVE_STATUS {
     struct {
         unsigned int ACTIVE                                                       : 32;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_CS_CRAWLER_CONFIG {
     struct {
         unsigned int CSG_DEPTH                                                    :  6;
         unsigned int CSC_DEPTH                                                    :  6;
         unsigned int                                                              : 20;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -22342,21 +25266,21 @@ union SPI_EDC_CNT {
     struct {
         unsigned int SPI_SR_MEM_SED_COUNT                                         :  2;
         unsigned int                                                              : 30;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_EXP_THROTTLE_CTRL {
     struct {
         unsigned int ENABLE                                                       :  1;
         unsigned int PERIOD                                                       :  4;
         unsigned int UPSTEP                                                       :  4;
         unsigned int DOWNSTEP                                                     :  4;
         unsigned int LOW_STALL_MON_HIST_COUNT                                     :  3;
         unsigned int HIGH_STALL_MON_HIST_COUNT                                    :  3;
         unsigned int EXP_STALL_THRESHOLD                                          :  7;
         unsigned int SKEW_COUNT                                                   :  3;
@@ -22379,20 +25303,31 @@ union SPI_FEATURE_CTRL {
         unsigned int CU_LOCKING_FAIRNESS_DISABLE                                  :  1;
         unsigned int                                                              :  1;
         unsigned int ALLOCATION_RATE_THROTTLE_THRESHOLD                           :  5;
         unsigned int ACTIVE_HARD_LOCK_LIMIT                                       :  5;
         unsigned int LR_IMBALANCE_THRESHOLD                                       :  6;
         unsigned int RA_PIPE_DEPTH_THRESHOLD_ALLOC_STALL_EN                       :  1;
         unsigned int BUS_ACTIVITY_THRESHOLD_ALLOC_STALL_EN                        :  1;
         unsigned int BUS_ACTIVITY_THRESHOLD                                       :  8;
         unsigned int                                                              :  4;
     } gfx101;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int TUNNELING_WAVE_LIMIT                                         :  4;
+        unsigned int RA_PROBE_IGNORE                                              :  1;
+        unsigned int PS_THROTTLE_MAX_WAVE_LIMIT                                   :  6;
+        unsigned int RA_PROBE_SKEW_WIF_CTRL                                       :  2;
+        unsigned int RA_PROBE_SKEW_OOO_CTRL                                       :  1;
+        unsigned int RA_PROBE_SKEW_DISABLE                                        :  1;
+        unsigned int                                                              : 17;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int CU_LOCKING_FAIRNESS_DISABLE                                  :  1;
         unsigned int                                                              :  1;
         unsigned int ALLOCATION_RATE_THROTTLE_THRESHOLD                           :  5;
         unsigned int ACTIVE_HARD_LOCK_LIMIT                                       :  5;
         unsigned int LR_IMBALANCE_THRESHOLD                                       :  6;
         unsigned int RA_PIPE_DEPTH_THRESHOLD_ALLOC_STALL_EN                       :  1;
         unsigned int BUS_ACTIVITY_THRESHOLD_ALLOC_STALL_EN                        :  1;
         unsigned int BUS_ACTIVITY_THRESHOLD                                       :  8;
@@ -22438,35 +25373,108 @@ union SPI_GFX_CNTL {
     struct {
         unsigned int RESET_COUNTS                                                 :  1;
         unsigned int                                                              : 31;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_GFX_CRAWLER_CONFIG {
     struct {
         unsigned int PS_DEPTH                                                     :  5;
         unsigned int GS_DEPTH                                                     :  6;
         unsigned int HS_DEPTH                                                     :  6;
         unsigned int                                                              : 15;
     } bits, bitfields;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 17;
         unsigned int VS_DEPTH                                                     :  5;
         unsigned int                                                              : 10;
     } gfx103Derivative;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 17;
+        unsigned int PS_ALLOC_DEPTH                                               :  5;
+        unsigned int PS_LDS_DONE_DEPTH                                            :  3;
+        unsigned int PS_LDS_DONE_CNTL                                             :  1;
+        unsigned int RA_PSWAVE_CREDITS                                            :  3;
+        unsigned int                                                              :  3;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_GFX_SCRATCH_BASE_HI {
+    struct {
+        unsigned int DATA                                                         :  8;
+        unsigned int                                                              : 24;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_GFX_SCRATCH_BASE_LO {
+    struct {
+        unsigned int DATA                                                         : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_GS_THROTTLE_CNTL1 {
+    struct {
+        unsigned int PH_POLL_INTERVAL                                             :  4;
+        unsigned int PH_THROTTLE_BASE                                             :  4;
+        unsigned int PH_THROTTLE_STEP_SIZE                                        :  4;
+        unsigned int SPI_VGPR_THRESHOLD                                           :  4;
+        unsigned int SPI_LDS_THRESHOLD                                            :  4;
+        unsigned int SPI_POLL_INTERVAL                                            :  4;
+        unsigned int SPI_THROTTLE_BASE                                            :  4;
+        unsigned int SPI_THROTTLE_STEP_SIZE                                       :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_GS_THROTTLE_CNTL2 {
+    struct {
+        unsigned int SPI_THROTTLE_MODE                                            :  2;
+        unsigned int GRP_LIFETIME_THRESHOLD                                       :  4;
+        unsigned int GRP_LIFETIME_THRESHOLD_FACTOR                                :  2;
+        unsigned int GRP_LIFETIME_PENALTY1                                        :  3;
+        unsigned int GRP_LIFETIME_PENALTY2                                        :  3;
+        unsigned int PS_STALL_THRESHOLD                                           :  2;
+        unsigned int PH_MODE                                                      :  1;
+        unsigned int RESERVED                                                     : 15;
+    } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 union SPI_IND_DATA {
     struct {
@@ -22581,20 +25589,33 @@ union SPI_LB_DATA_PERWGP_WAVE_HSGS {
     struct {
         unsigned int WGP_USED_HS                                                  : 16;
         unsigned int WGP_USED_GS                                                  : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SPI_LB_DATA_PERWGP_WAVE_PS {
+    struct {
+        unsigned int WGP_USED_PS                                                  : 16;
+        unsigned int                                                              : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SPI_LB_DATA_PERWGP_WAVE_VSPS {
     struct {
         unsigned int WGP_USED_VS                                                  : 16;
         unsigned int WGP_USED_PS                                                  : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -23094,27 +26115,34 @@ union SPI_PS_INPUT_CNTL_0 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_1 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23129,27 +26157,34 @@ union SPI_PS_INPUT_CNTL_1 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_2 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23164,27 +26199,34 @@ union SPI_PS_INPUT_CNTL_2 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_3 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23199,27 +26241,34 @@ union SPI_PS_INPUT_CNTL_3 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_4 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23234,69 +26283,41 @@ union SPI_PS_INPUT_CNTL_4 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
-
-    unsigned int u32All;
-    signed int   i32All;
-    float        f32All;
-};
-
-union SPI_PS_INPUT_CNTL_5 {
-    struct {
-        unsigned int OFFSET                                                       :  6;
-        unsigned int                                                              :  2;
-        unsigned int DEFAULT_VAL                                                  :  2;
-        unsigned int FLAT_SHADE                                                   :  1;
-        unsigned int                                                              :  6;
-        unsigned int PT_SPRITE_TEX                                                :  1;
-        unsigned int DUP                                                          :  1;
-        unsigned int FP16_INTERP_MODE                                             :  1;
-        unsigned int USE_DEFAULT_ATTR1                                            :  1;
-        unsigned int DEFAULT_VAL_ATTR1                                            :  2;
-        unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
-        unsigned int ATTR0_VALID                                                  :  1;
-        unsigned int ATTR1_VALID                                                  :  1;
-        unsigned int                                                              :  6;
-    } bits, bitfields;
-    struct {
-        unsigned int                                                              : 13;
-        unsigned int CYL_WRAP                                                     :  4;
-        unsigned int                                                              : 15;
-    } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI31
     struct {
-        unsigned int                                                              : 11;
-        unsigned int ROTATE_PC_PTR                                                :  1;
-        unsigned int                                                              : 20;
-    } gfx103PlusExclusive;
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-union SPI_PS_INPUT_CNTL_6 {
+union SPI_PS_INPUT_CNTL_5 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
         unsigned int DEFAULT_VAL                                                  :  2;
         unsigned int FLAT_SHADE                                                   :  1;
         unsigned int                                                              :  6;
         unsigned int PT_SPRITE_TEX                                                :  1;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
@@ -23304,69 +26325,41 @@ union SPI_PS_INPUT_CNTL_6 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
-
-    unsigned int u32All;
-    signed int   i32All;
-    float        f32All;
-};
-
-union SPI_PS_INPUT_CNTL_7 {
-    struct {
-        unsigned int OFFSET                                                       :  6;
-        unsigned int                                                              :  2;
-        unsigned int DEFAULT_VAL                                                  :  2;
-        unsigned int FLAT_SHADE                                                   :  1;
-        unsigned int                                                              :  6;
-        unsigned int PT_SPRITE_TEX                                                :  1;
-        unsigned int DUP                                                          :  1;
-        unsigned int FP16_INTERP_MODE                                             :  1;
-        unsigned int USE_DEFAULT_ATTR1                                            :  1;
-        unsigned int DEFAULT_VAL_ATTR1                                            :  2;
-        unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
-        unsigned int ATTR0_VALID                                                  :  1;
-        unsigned int ATTR1_VALID                                                  :  1;
-        unsigned int                                                              :  6;
-    } bits, bitfields;
-    struct {
-        unsigned int                                                              : 13;
-        unsigned int CYL_WRAP                                                     :  4;
-        unsigned int                                                              : 15;
-    } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI31
     struct {
-        unsigned int                                                              : 11;
-        unsigned int ROTATE_PC_PTR                                                :  1;
-        unsigned int                                                              : 20;
-    } gfx103PlusExclusive;
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-union SPI_PS_INPUT_CNTL_8 {
+union SPI_PS_INPUT_CNTL_6 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
         unsigned int DEFAULT_VAL                                                  :  2;
         unsigned int FLAT_SHADE                                                   :  1;
         unsigned int                                                              :  6;
         unsigned int PT_SPRITE_TEX                                                :  1;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
@@ -23374,27 +26367,118 @@ union SPI_PS_INPUT_CNTL_8 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 11;
+        unsigned int ROTATE_PC_PTR                                                :  1;
+        unsigned int                                                              : 20;
+    } gfx103PlusExclusive;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+union SPI_PS_INPUT_CNTL_7 {
+    struct {
+        unsigned int OFFSET                                                       :  6;
+        unsigned int                                                              :  2;
+        unsigned int DEFAULT_VAL                                                  :  2;
+        unsigned int FLAT_SHADE                                                   :  1;
+        unsigned int                                                              :  6;
+        unsigned int PT_SPRITE_TEX                                                :  1;
+        unsigned int DUP                                                          :  1;
+        unsigned int FP16_INTERP_MODE                                             :  1;
+        unsigned int USE_DEFAULT_ATTR1                                            :  1;
+        unsigned int DEFAULT_VAL_ATTR1                                            :  2;
+        unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
+        unsigned int ATTR0_VALID                                                  :  1;
+        unsigned int ATTR1_VALID                                                  :  1;
+        unsigned int                                                              :  6;
+    } bits, bitfields;
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int CYL_WRAP                                                     :  4;
+        unsigned int                                                              : 15;
+    } gfx09_10;
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+
+union SPI_PS_INPUT_CNTL_8 {
+    struct {
+        unsigned int OFFSET                                                       :  6;
+        unsigned int                                                              :  2;
+        unsigned int DEFAULT_VAL                                                  :  2;
+        unsigned int FLAT_SHADE                                                   :  1;
+        unsigned int                                                              :  6;
+        unsigned int PT_SPRITE_TEX                                                :  1;
+        unsigned int DUP                                                          :  1;
+        unsigned int FP16_INTERP_MODE                                             :  1;
+        unsigned int USE_DEFAULT_ATTR1                                            :  1;
+        unsigned int DEFAULT_VAL_ATTR1                                            :  2;
+        unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
+        unsigned int ATTR0_VALID                                                  :  1;
+        unsigned int ATTR1_VALID                                                  :  1;
+        unsigned int                                                              :  6;
+    } bits, bitfields;
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int CYL_WRAP                                                     :  4;
+        unsigned int                                                              : 15;
+    } gfx09_10;
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 11;
+        unsigned int ROTATE_PC_PTR                                                :  1;
+        unsigned int                                                              : 20;
+    } gfx103PlusExclusive;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_9 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23409,27 +26493,34 @@ union SPI_PS_INPUT_CNTL_9 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_10 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23444,27 +26535,34 @@ union SPI_PS_INPUT_CNTL_10 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_11 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23479,27 +26577,34 @@ union SPI_PS_INPUT_CNTL_11 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_12 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23514,27 +26619,34 @@ union SPI_PS_INPUT_CNTL_12 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_13 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23549,27 +26661,34 @@ union SPI_PS_INPUT_CNTL_13 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_14 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23584,27 +26703,34 @@ union SPI_PS_INPUT_CNTL_14 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_15 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23619,27 +26745,34 @@ union SPI_PS_INPUT_CNTL_15 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_16 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23654,27 +26787,34 @@ union SPI_PS_INPUT_CNTL_16 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_17 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23689,27 +26829,34 @@ union SPI_PS_INPUT_CNTL_17 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_18 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23724,27 +26871,34 @@ union SPI_PS_INPUT_CNTL_18 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_19 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23759,27 +26913,34 @@ union SPI_PS_INPUT_CNTL_19 {
         unsigned int PT_SPRITE_TEX_ATTR1                                          :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 13;
         unsigned int CYL_WRAP                                                     :  4;
         unsigned int                                                              : 15;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_20 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23788,27 +26949,34 @@ union SPI_PS_INPUT_CNTL_20 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_21 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23817,27 +26985,34 @@ union SPI_PS_INPUT_CNTL_21 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_22 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23846,27 +27021,34 @@ union SPI_PS_INPUT_CNTL_22 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_23 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23875,27 +27057,34 @@ union SPI_PS_INPUT_CNTL_23 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_24 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23904,27 +27093,34 @@ union SPI_PS_INPUT_CNTL_24 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_25 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23933,27 +27129,34 @@ union SPI_PS_INPUT_CNTL_25 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_26 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23962,27 +27165,34 @@ union SPI_PS_INPUT_CNTL_26 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_27 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -23991,27 +27201,34 @@ union SPI_PS_INPUT_CNTL_27 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_28 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -24020,27 +27237,34 @@ union SPI_PS_INPUT_CNTL_28 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_29 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -24049,27 +27273,34 @@ union SPI_PS_INPUT_CNTL_29 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_30 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -24078,27 +27309,34 @@ union SPI_PS_INPUT_CNTL_30 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_CNTL_31 {
     struct {
         unsigned int OFFSET                                                       :  6;
         unsigned int                                                              :  2;
@@ -24107,27 +27345,34 @@ union SPI_PS_INPUT_CNTL_31 {
         unsigned int                                                              :  7;
         unsigned int DUP                                                          :  1;
         unsigned int FP16_INTERP_MODE                                             :  1;
         unsigned int USE_DEFAULT_ATTR1                                            :  1;
         unsigned int DEFAULT_VAL_ATTR1                                            :  2;
         unsigned int                                                              :  1;
         unsigned int ATTR0_VALID                                                  :  1;
         unsigned int ATTR1_VALID                                                  :  1;
         unsigned int                                                              :  6;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 11;
         unsigned int ROTATE_PC_PTR                                                :  1;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int PRIM_ATTR                                                    :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_PS_INPUT_ENA {
     struct {
         unsigned int PERSP_SAMPLE_ENA                                             :  1;
         unsigned int PERSP_CENTER_ENA                                             :  1;
@@ -24156,21 +27401,21 @@ union SPI_PS_INPUT_ENA {
 union SPI_PS_IN_CONTROL {
     struct {
         unsigned int NUM_INTERP                                                   :  6;
         unsigned int PARAM_GEN                                                    :  1;
         unsigned int OFFCHIP_PARAM_EN                                             :  1;
         unsigned int LATE_PC_DEALLOC                                              :  1;
         unsigned int                                                              :  5;
         unsigned int BC_OPTIMIZE_DISABLE                                          :  1;
         unsigned int                                                              : 17;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  9;
         unsigned int NUM_PRIM_INTERP                                              :  5;
         unsigned int                                                              : 18;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 15;
         unsigned int PS_W32_EN                                                    :  1;
         unsigned int                                                              : 16;
@@ -24802,20 +28047,49 @@ union SPI_SHADER_COL_FORMAT {
         unsigned int COL5_EXPORT_FORMAT                                           :  4;
         unsigned int COL6_EXPORT_FORMAT                                           :  4;
         unsigned int COL7_EXPORT_FORMAT                                           :  4;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SPI_SHADER_GS_MESHLET_DIM {
+    struct {
+        unsigned int MESHLET_NUM_THREAD_X                                         :  8;
+        unsigned int MESHLET_NUM_THREAD_Y                                         :  8;
+        unsigned int MESHLET_NUM_THREAD_Z                                         :  8;
+        unsigned int MESHLET_THREADGROUP_SIZE                                     :  8;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SPI_SHADER_GS_MESHLET_EXP_ALLOC {
+    struct {
+        unsigned int MAX_EXP_VERTS                                                :  9;
+        unsigned int MAX_EXP_PRIMS                                                :  9;
+        unsigned int                                                              : 14;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SPI_SHADER_IDX_FORMAT {
     struct {
         unsigned int IDX0_EXPORT_FORMAT                                           :  4;
         unsigned int                                                              : 28;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -24891,31 +28165,41 @@ union SPI_SHADER_PGM_HI_ES_GS {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_HI_GS {
     struct {
         unsigned int MEM_BASE                                                     :  8;
         unsigned int                                                              : 24;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int MEM_BASE                                                     : 32;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_HI_HS {
     struct {
         unsigned int MEM_BASE                                                     :  8;
         unsigned int                                                              : 24;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int MEM_BASE                                                     : 32;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_HI_LS {
     struct {
         unsigned int MEM_BASE                                                     :  8;
         unsigned int                                                              : 24;
@@ -25150,21 +28434,21 @@ union SPI_SHADER_PGM_RSRC1_PS {
         unsigned int PRIV                                                         :  1;
         unsigned int DX10_CLAMP                                                   :  1;
         unsigned int DEBUG_MODE                                                   :  1;
         unsigned int IEEE_MODE                                                    :  1;
         unsigned int CU_GROUP_DISABLE                                             :  1;
         unsigned int                                                              :  3;
         unsigned int CDBG_USER                                                    :  1;
         unsigned int FP16_OVFL                                                    :  1;
         unsigned int                                                              :  2;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 27;
         unsigned int LOAD_PROVOKING_VTX                                           :  1;
         unsigned int                                                              :  4;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 25;
         unsigned int MEM_ORDERED                                                  :  1;
         unsigned int FWD_PROGRESS                                                 :  1;
@@ -25539,20 +28823,27 @@ union SPI_SHADER_PGM_RSRC3_PS {
     struct {
         unsigned int                                                              : 22;
         unsigned int LOCK_LOW_THRESHOLD                                           :  4;
         unsigned int                                                              :  6;
     } most;
     struct {
         unsigned int                                                              : 26;
         unsigned int SIMD_DISABLE                                                 :  4;
         unsigned int                                                              :  2;
     } gfx09;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 22;
+        unsigned int LDS_GROUP_SIZE                                               :  2;
+        unsigned int                                                              :  8;
+    } gfx104Plus;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_RSRC3_VS {
     struct {
         unsigned int CU_EN                                                        : 16;
         unsigned int WAVE_LIMIT                                                   :  6;
@@ -25573,51 +28864,100 @@ union SPI_SHADER_PGM_RSRC3_VS {
 union SPI_SHADER_PGM_RSRC4_GS {
     struct {
         unsigned int GROUP_FIFO_DEPTH                                             :  7;
         unsigned int SPI_SHADER_LATE_ALLOC_GS                                     :  7;
         unsigned int                                                              : 18;
     } gfx09;
     struct {
         unsigned int CU_EN                                                        : 16;
         unsigned int                                                              : 16;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 23;
+        unsigned int INST_PREF_SIZE                                               :  6;
+        unsigned int                                                              :  3;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int                                                              : 16;
         unsigned int SPI_SHADER_LATE_ALLOC_GS                                     :  7;
         unsigned int                                                              :  9;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int CU_EN                                                        :  1;
+        unsigned int RESERVED                                                     : 13;
+        unsigned int PH_THROTTLE_EN                                               :  1;
+        unsigned int SPI_THROTTLE_EN                                              :  1;
+        unsigned int                                                              : 13;
+        unsigned int TRAP_ON_START                                                :  1;
+        unsigned int TRAP_ON_END                                                  :  1;
+        unsigned int IMAGE_OP                                                     :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_RSRC4_HS {
     struct {
         unsigned int GROUP_FIFO_DEPTH                                             :  7;
         unsigned int                                                              : 25;
     } gfx09;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int INST_PREF_SIZE                                               :  6;
+        unsigned int                                                              : 10;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int CU_EN                                                        : 16;
         unsigned int                                                              : 16;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 29;
+        unsigned int TRAP_ON_START                                                :  1;
+        unsigned int TRAP_ON_END                                                  :  1;
+        unsigned int IMAGE_OP                                                     :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_RSRC4_PS {
     struct {
         unsigned int CU_EN                                                        : 16;
         unsigned int                                                              : 16;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int INST_PREF_SIZE                                               :  6;
+        unsigned int                                                              : 10;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 29;
+        unsigned int TRAP_ON_START                                                :  1;
+        unsigned int TRAP_ON_END                                                  :  1;
+        unsigned int IMAGE_OP                                                     :  1;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_SHADER_PGM_RSRC4_VS {
     struct {
         unsigned int CU_EN                                                        : 16;
         unsigned int                                                              : 16;
@@ -28671,20 +32011,27 @@ union SPI_SYS_WIF_CNTL {
 union SPI_TMPRING_SIZE {
     struct {
         unsigned int WAVES                                                        : 12;
         unsigned int                                                              : 20;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 12;
         unsigned int WAVESIZE                                                     : 13;
         unsigned int                                                              :  7;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int WAVESIZE                                                     : 15;
+        unsigned int                                                              :  5;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SPI_USER_ACCUM_VMID_CNTL {
     struct {
         unsigned int EN_USER_ACCUM                                                :  4;
         unsigned int                                                              : 28;
@@ -28699,21 +32046,21 @@ union SPI_VS_OUT_CONFIG {
     struct {
         unsigned int                                                              :  1;
         unsigned int VS_EXPORT_COUNT                                              :  5;
         unsigned int                                                              : 26;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  6;
         unsigned int VS_HALF_PACK                                                 :  1;
         unsigned int                                                              : 25;
     } gfx09_10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  8;
         unsigned int PRIM_EXPORT_COUNT                                            :  5;
         unsigned int                                                              : 19;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              :  7;
         unsigned int NO_PC_EXPORT                                                 :  1;
         unsigned int                                                              : 24;
@@ -28891,35 +32238,35 @@ union SPI_WCL_PIPE_PERCENT_HP3D {
         unsigned int                                                              :  5;
         unsigned int GS_GRP_VALUE                                                 :  5;
         unsigned int                                                              :  5;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_WF_ACTIVE_COUNT_GFX {
     struct {
         unsigned int WF_ALLOCATED                                                 :  8;
         unsigned int WF_ACTIVE                                                    : 16;
         unsigned int                                                              :  8;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_WF_ACTIVE_COUNT_HPG {
     struct {
         unsigned int WF_ALLOCATED                                                 :  8;
         unsigned int WF_ACTIVE                                                    : 16;
         unsigned int                                                              :  8;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -29272,59 +32619,463 @@ union SPI_WF_LIFETIME_STATUS_20 {
     struct {
         unsigned int MAX_CNT                                                      : 31;
         unsigned int INT_SENT                                                     :  1;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SPI_WF_LIFETIME_STATUS_21 {
     struct {
         unsigned int MAX_CNT                                                      : 31;
         unsigned int INT_SENT                                                     :  1;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union SQG_CONFIG {
     struct {
         unsigned int UTCL0_PREFETCH_PAGE                                          :  4;
         unsigned int UTCL0_RETRY_TIMER                                            :  7;
         unsigned int                                                              : 21;
     } gfx10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 13;
+        unsigned int SQG_ICPFT_EN                                                 :  1;
+        unsigned int SQG_ICPFT_CLR                                                :  1;
+        unsigned int                                                              : 17;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int GL1H_PREFETCH_PAGE                                           :  4;
+        unsigned int                                                              : 12;
+        unsigned int XNACK_INTR_MASK                                              : 16;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int                                                              : 12;
         unsigned int SQG_WAVEDONE_FIFO_DEPTH                                      :  1;
         unsigned int                                                              : 19;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 12;
         unsigned int SQG_WAVEDONE_FIFO_DEPTH                                      :  1;
         unsigned int                                                              : 19;
     } nv24;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SQG_GL1H_STATUS {
+    struct {
+        unsigned int R0_ACK_ERR_DETECTED                                          :  1;
+        unsigned int R0_XNACK_ERR_DETECTED                                        :  1;
+        unsigned int R1_ACK_ERR_DETECTED                                          :  1;
+        unsigned int R1_XNACK_ERR_DETECTED                                        :  1;
+        unsigned int                                                              : 28;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER0_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER0_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER0_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER1_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER1_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER1_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER2_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER2_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER2_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER3_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER3_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER3_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER4_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER4_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER4_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER5_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER5_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER5_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER6_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER6_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER6_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER7_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER7_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER7_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     :  9;
+        unsigned int                                                              : 11;
+        unsigned int SPM_MODE                                                     :  4;
+        unsigned int                                                              :  4;
+        unsigned int PERF_MODE                                                    :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER_CTRL {
+    struct {
+        unsigned int PS_EN                                                        :  1;
+        unsigned int                                                              :  1;
+        unsigned int GS_EN                                                        :  1;
+        unsigned int                                                              :  1;
+        unsigned int HS_EN                                                        :  1;
+        unsigned int                                                              :  1;
+        unsigned int CS_EN                                                        :  1;
+        unsigned int                                                              :  7;
+        unsigned int DISABLE_ME0PIPE0_PERF                                        :  1;
+        unsigned int DISABLE_ME0PIPE1_PERF                                        :  1;
+        unsigned int DISABLE_ME1PIPE0_PERF                                        :  1;
+        unsigned int DISABLE_ME1PIPE1_PERF                                        :  1;
+        unsigned int DISABLE_ME1PIPE2_PERF                                        :  1;
+        unsigned int DISABLE_ME1PIPE3_PERF                                        :  1;
+        unsigned int                                                              : 12;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERFCOUNTER_CTRL2 {
+    struct {
+        unsigned int FORCE_EN                                                     :  1;
+        unsigned int VMID_EN                                                      : 16;
+        unsigned int                                                              : 15;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQG_PERF_SAMPLE_FINISH {
+    struct {
+        unsigned int STATUS                                                       :  7;
+        unsigned int                                                              : 25;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SQG_STATUS {
     struct {
         unsigned int REG_BUSY                                                     :  1;
         unsigned int                                                              : 31;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -29480,21 +33231,21 @@ union SQ_BUF_RSRC_WORD3 {
         unsigned int NV                                                           :  1;
         unsigned int                                                              :  2;
         unsigned int TYPE                                                         :  2;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SQ_CLK_CTRL {
     struct {
         unsigned int                                                              :  2;
         unsigned int SQ_SPI_MSG_FGCG_OVERRIDE                                     :  1;
         unsigned int SQ_SPI_EXPREQ_FGCG_OVERRIDE                                  :  1;
         unsigned int SQ_SX_EXPCMD_FGCG_OVERRIDE                                   :  1;
         unsigned int SQ_SQC_TTRACE_FGCG_OVERRIDE                                  :  1;
         unsigned int WCLK_OVERRIDE                                                :  1;
         unsigned int PERFMON_OVERRIDE                                             :  1;
         unsigned int OVERRIDE_LDS_IDX_BUSY                                        :  1;
@@ -29509,20 +33260,37 @@ union SQ_CLK_CTRL {
         unsigned int PIPE2DCLK_OVERRIDE                                           :  1;
         unsigned int                                                              : 30;
     } gfx103;
 #endif
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int WCLK2DCLK_OVERRIDE                                           :  1;
         unsigned int                                                              : 31;
     } gfx103Derivative;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int SQ_LDS_DIRECT_FGCG_OVERRIDE                                  :  1;
+        unsigned int                                                              : 15;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int SQ_SP_CMD_FGCG_OVERRIDE                                      :  1;
+        unsigned int SQ_SP_CONST_FGCG_OVERRIDE                                    :  1;
+        unsigned int SQ_SP_EXP_FGCG_OVERRIDE                                      :  1;
+        unsigned int SQ_SP_VMEM_FGCG_OVERRIDE                                     :  1;
+        unsigned int                                                              : 16;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union SQ_CMD {
     struct {
         unsigned int                                                              :  4;
@@ -29612,28 +33380,47 @@ union SQ_CONFIG {
         unsigned int                                                              : 25;
     } gfx101;
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
     struct {
         unsigned int UNUSED                                                       :  5;
         unsigned int CHICKEN_BIT_DEGGIGXX0_8637                                   :  1;
         unsigned int UNUSED_6                                                     :  1;
         unsigned int                                                              : 25;
     } gfx103Derivative;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 10;
         unsigned int DISABLE_SGPR_RD_KILL                                         :  1;
         unsigned int                                                              : 10;
         unsigned int WCLK_HYSTERESIS_CNT                                          :  2;
         unsigned int                                                              :  9;
     } gfx103PlusExclusive;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int DISABLE_VMEM_EXEC_ZERO_SKIP                                  :  1;
+        unsigned int                                                              : 17;
+        unsigned int DISABLE_END_CLAUSE_TX                                        :  1;
+        unsigned int                                                              :  4;
+    } gfx104Plus;
+#endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int ECO_SPARE                                                    :  8;
+        unsigned int NEW_TRANS_ARB_SCHEME                                         :  1;
+        unsigned int                                                              :  9;
+        unsigned int ENABLE_HIPRIO_ON_EXP_RDY_GS                                  :  1;
+        unsigned int PRIO_VAL_ON_EXP_RDY_GS                                       :  2;
+        unsigned int                                                              : 11;
+    } gfx11;
 #endif
     struct {
         unsigned int UNUSED                                                       :  7;
         unsigned int                                                              : 25;
     } vg10_Vg12_Rv1x_Rv2x;
     struct {
         unsigned int DISABLE_BARRIER_WAITCNT                                      :  1;
         unsigned int UNUSED                                                       :  6;
         unsigned int                                                              : 25;
     } vg20_Rn;
@@ -29845,20 +33632,29 @@ union SQ_FIFO_SIZES {
         unsigned int                                                              : 18;
     } gfx10;
     struct {
         unsigned int                                                              :  8;
         unsigned int TTRACE_FIFO_SIZE                                             :  2;
         unsigned int                                                              :  4;
         unsigned int EXPORT_BUF_PS_RESERVED                                       :  2;
         unsigned int EXPORT_BUF_REDUCE                                            :  2;
         unsigned int                                                              : 14;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 12;
+        unsigned int EXPORT_BUF_GS_RESERVED                                       :  2;
+        unsigned int                                                              :  6;
+        unsigned int EXPORT_BUF_PRIMPOS_LIMIT                                     :  2;
+        unsigned int                                                              : 10;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SQ_FLAT_0 {
     struct {
         unsigned int OFFSET                                                       : 12;
         unsigned int                                                              :  1;
@@ -31356,21 +35152,21 @@ union SQ_PERFCOUNTER_CTRL {
         unsigned int VS_EN                                                        :  1;
         unsigned int                                                              : 11;
         unsigned int DISABLE_FLUSH                                                :  1;
         unsigned int                                                              : 18;
     } gfx09_10;
     struct {
         unsigned int                                                              :  8;
         unsigned int CNTR_RATE                                                    :  2;
         unsigned int                                                              : 22;
     } gfx10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 14;
         unsigned int DISABLE_ME0PIPE0_PERF                                        :  1;
         unsigned int DISABLE_ME0PIPE1_PERF                                        :  1;
         unsigned int DISABLE_ME1PIPE0_PERF                                        :  1;
         unsigned int DISABLE_ME1PIPE1_PERF                                        :  1;
         unsigned int DISABLE_ME1PIPE2_PERF                                        :  1;
         unsigned int DISABLE_ME1PIPE3_PERF                                        :  1;
         unsigned int                                                              : 12;
     } gfx103PlusExclusive;
@@ -31379,37 +35175,104 @@ union SQ_PERFCOUNTER_CTRL {
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SQ_PERFCOUNTER_CTRL2 {
     struct {
         unsigned int FORCE_EN                                                     :  1;
         unsigned int                                                              : 31;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  1;
+        unsigned int VMID_EN                                                      : 16;
+        unsigned int                                                              : 15;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SQ_PERFCOUNTER_MASK {
     struct {
         unsigned int SH0_MASK                                                     : 16;
         unsigned int SH1_MASK                                                     : 16;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union SQ_PERF_SNAPSHOT_CTRL {
+    struct {
+        unsigned int TIMER_ON_OFF                                                 :  1;
+        unsigned int VMID_MASK                                                    : 16;
+        unsigned int COUNT_SEL                                                    :  1;
+        unsigned int COUNT_INTERVAL                                               :  4;
+        unsigned int                                                              : 10;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQ_PERF_SNAPSHOT_DATA {
+    struct {
+        unsigned int VALID                                                        :  1;
+        unsigned int WAVE_ISSUE                                                   :  1;
+        unsigned int INST_TYPE                                                    :  4;
+        unsigned int NO_ISSUE_REASON                                              :  3;
+        unsigned int ARB_STATE                                                    : 14;
+        unsigned int SAMPLING_ERR                                                 :  1;
+        unsigned int WAVE_ID                                                      :  5;
+        unsigned int                                                              :  3;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQ_PERF_SNAPSHOT_PC_HI {
+    struct {
+        unsigned int PC_HI                                                        : 16;
+        unsigned int                                                              : 16;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union SQ_PERF_SNAPSHOT_PC_LO {
+    struct {
+        unsigned int PC_LO                                                        : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union SQ_POWER_THROTTLE {
     struct {
         unsigned int MIN_POWER                                                    : 14;
         unsigned int                                                              :  2;
         unsigned int MAX_POWER                                                    : 14;
         unsigned int PHASE_OFFSET                                                 :  2;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
@@ -31435,21 +35298,21 @@ union SQ_RANDOM_WAVE_PRI {
     struct {
         unsigned int RET                                                          :  7;
         unsigned int RUI                                                          :  3;
         unsigned int                                                              : 22;
     } bits, bitfields;
     struct {
         unsigned int                                                              : 10;
         unsigned int RNG                                                          : 13;
         unsigned int                                                              :  9;
     } gfx09;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 31;
         unsigned int FORCE_IB_ARB_PRIO_MSK_VALID                                  :  1;
     } gfx103Plus;
 #endif
     struct {
         unsigned int                                                              : 10;
         unsigned int RNG                                                          : 14;
         unsigned int                                                              :  8;
     } gfx10Plus;
@@ -31776,28 +35639,28 @@ union SQ_THREAD_TRACE_CTRL {
         unsigned int CH_PERF_EN                                                   :  1;
         unsigned int                                                              :  5;
         unsigned int REG_STALL_EN                                                 :  1;
         unsigned int SPI_STALL_EN                                                 :  1;
         unsigned int SQ_STALL_EN                                                  :  1;
         unsigned int REG_DROP_ON_STALL                                            :  1;
         unsigned int                                                              : 17;
         unsigned int CAPTURE_ALL                                                  :  1;
         unsigned int                                                              :  1;
     } gfx10;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 28;
         unsigned int AUTO_FLUSH_PADDING_DIS                                       :  1;
         unsigned int                                                              :  3;
     } gfx103Plus;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 20;
         unsigned int LOWATER_OFFSET                                               :  3;
         unsigned int                                                              :  6;
         unsigned int AUTO_FLUSH_MODE                                              :  1;
         unsigned int                                                              :  2;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int MODE                                                         :  2;
@@ -31808,20 +35671,31 @@ union SQ_THREAD_TRACE_CTRL {
         unsigned int HIWATER                                                      :  3;
         unsigned int                                                              :  4;
         unsigned int UTIL_TIMER                                                   :  1;
         unsigned int WAVESTART_MODE                                               :  2;
         unsigned int RT_FREQ                                                      :  2;
         unsigned int SYNC_COUNT_MARKERS                                           :  1;
         unsigned int SYNC_COUNT_DRAWS                                             :  1;
         unsigned int                                                              : 11;
         unsigned int DRAW_EVENT_EN                                                :  1;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  3;
+        unsigned int GL1_PERF_EN                                                  :  1;
+        unsigned int                                                              :  5;
+        unsigned int REG_AT_HWM                                                   :  2;
+        unsigned int SPI_STALL_EN                                                 :  1;
+        unsigned int SQ_STALL_EN                                                  :  1;
+        unsigned int                                                              : 19;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SQ_THREAD_TRACE_DROPPED_CNTR {
     struct {
         unsigned int CNTR                                                         : 32;
     } bits, bitfields;
@@ -31887,20 +35761,27 @@ union SQ_THREAD_TRACE_MASK {
         unsigned int CU_SEL                                                       :  5;
         unsigned int SH_SEL                                                       :  1;
         unsigned int                                                              :  1;
         unsigned int REG_STALL_EN                                                 :  1;
         unsigned int SIMD_EN                                                      :  4;
         unsigned int VM_ID_MASK                                                   :  2;
         unsigned int SPI_STALL_EN                                                 :  1;
         unsigned int SQ_STALL_EN                                                  :  1;
         unsigned int                                                              : 16;
     } gfx09;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 17;
+        unsigned int EXCLUDE_NONDETAIL_SHADERDATA                                 :  1;
+        unsigned int                                                              : 14;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int SIMD_SEL                                                     :  2;
         unsigned int                                                              :  2;
         unsigned int WGP_SEL                                                      :  4;
         unsigned int                                                              :  1;
         unsigned int SA_SEL                                                       :  1;
         unsigned int WTYPE_INCLUDE                                                :  7;
         unsigned int                                                              : 15;
     } gfx10Plus;
 
@@ -31964,89 +35845,112 @@ union SQ_THREAD_TRACE_STATUS {
         unsigned int UTC_ERROR                                                    :  1;
         unsigned int NEW_BUF                                                      :  1;
         unsigned int BUSY                                                         :  1;
         unsigned int FULL                                                         :  1;
     } gfx09;
     struct {
         unsigned int                                                              : 24;
         unsigned int UTC_ERR                                                      :  1;
         unsigned int                                                              :  7;
     } gfx10;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 28;
         unsigned int OWNER_VMID                                                   :  4;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 26;
         unsigned int EVENT_CNTR_OVERFLOW                                          :  1;
         unsigned int EVENT_CNTR_STALL                                             :  1;
         unsigned int                                                              :  4;
     } gfx10Core;
     struct {
         unsigned int FINISH_PENDING                                               : 12;
         unsigned int FINISH_DONE                                                  : 12;
         unsigned int                                                              :  1;
         unsigned int BUSY                                                         :  1;
         unsigned int                                                              :  6;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 24;
+        unsigned int WRITE_ERROR                                                  :  1;
+        unsigned int                                                              :  7;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SQ_THREAD_TRACE_STATUS2 {
     struct {
         unsigned int BUF0_FULL                                                    :  1;
         unsigned int BUF1_FULL                                                    :  1;
         unsigned int                                                              :  2;
         unsigned int PACKET_LOST_BUF_NO_LOCKDOWN                                  :  1;
         unsigned int                                                              : 27;
     } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  8;
+        unsigned int BUF_ISSUE_STATUS                                             :  5;
+        unsigned int BUF_ISSUE                                                    :  1;
+        unsigned int WRITE_BUF_FULL                                               :  1;
+        unsigned int                                                              : 17;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 #endif
 
 union SQ_THREAD_TRACE_TOKEN_MASK {
     struct {
         unsigned int TOKEN_MASK                                                   : 16;
         unsigned int REG_MASK                                                     :  8;
         unsigned int REG_DROP_ON_STALL                                            :  1;
         unsigned int                                                              :  7;
     } gfx09;
     struct {
         unsigned int TOKEN_EXCLUDE                                                : 12;
         unsigned int                                                              : 20;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int TOKEN_EXCLUDE                                                : 11;
         unsigned int                                                              :  1;
         unsigned int BOP_EVENTS_TOKEN_INCLUDE                                     :  1;
         unsigned int                                                              : 13;
         unsigned int REG_EXCLUDE                                                  :  3;
         unsigned int                                                              :  3;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              : 16;
         unsigned int REG_INCLUDE                                                  :  8;
         unsigned int INST_EXCLUDE                                                 :  2;
         unsigned int                                                              :  5;
         unsigned int REG_DETAIL_ALL                                               :  1;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 11;
+        unsigned int TTRACE_EXEC                                                  :  1;
+        unsigned int                                                              : 20;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union SQ_THREAD_TRACE_TOKEN_MASK2 {
     struct {
         unsigned int INST_MASK                                                    : 32;
     } bits, bitfields;
@@ -33155,21 +37059,21 @@ union SX_PERFCOUNTER0_SELECT {
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33189,21 +37093,21 @@ union SX_PERFCOUNTER0_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT2                                          : 10;
         unsigned int PERFCOUNTER_SELECT3                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33248,21 +37152,21 @@ union SX_PERFCOUNTER1_SELECT {
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33282,21 +37186,21 @@ union SX_PERFCOUNTER1_SELECT1 {
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT2                                          : 10;
         unsigned int PERFCOUNTER_SELECT3                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33339,21 +37243,21 @@ union SX_PERFCOUNTER2_SELECT {
     } gfx09_0;
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -33395,21 +37299,21 @@ union SX_PERFCOUNTER3_SELECT {
     } gfx09_0;
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx09_1x;
     struct {
         unsigned int PERFCOUNTER_SELECT                                           : 10;
         unsigned int PERFCOUNTER_SELECT1                                          : 10;
         unsigned int                                                              : 12;
     } gfx101;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -33424,21 +37328,21 @@ union SX_PS_DOWNCONVERT {
         unsigned int MRT5                                                         :  4;
         unsigned int MRT6                                                         :  4;
         unsigned int MRT7                                                         :  4;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 union SX_PS_DOWNCONVERT_CONTROL {
     struct {
         unsigned int MRT0_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT1_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT2_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT3_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT4_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT5_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT6_FMT_MAPPING_DISABLE                                     :  1;
         unsigned int MRT7_FMT_MAPPING_DISABLE                                     :  1;
@@ -33513,38 +37417,68 @@ union TA_CNTL {
     struct {
         unsigned int                                                              : 22;
         unsigned int TD_FIFO_CREDIT                                               : 10;
     } core;
     struct {
         unsigned int                                                              :  9;
         unsigned int SQ_XNACK_CREDIT                                              :  4;
         unsigned int TC_DATA_CREDIT                                               :  3;
         unsigned int                                                              : 16;
     } gfx09;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int TA_SQ_XNACK_FGCG_DISABLE                                     :  1;
+        unsigned int                                                              : 31;
+    } gfx104Plus;
+#endif
 #if CHIP_HDR_NAVI23
     struct {
         unsigned int TA_SQ_XNACK_FGCG_DISABLE                                     :  1;
         unsigned int                                                              : 31;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int TA_SQ_XNACK_FGCG_DISABLE                                     :  1;
         unsigned int                                                              : 31;
     } nv24;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union TA_CNTL2 {
+    struct {
+        unsigned int                                                              : 16;
+        unsigned int POINT_SAMPLE_ACCEL_DIS                                       :  1;
+        unsigned int                                                              :  2;
+        unsigned int ELIMINATE_UNLIT_QUAD_DIS                                     :  1;
+        unsigned int                                                              : 12;
+    } bits, bitfields;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 17;
+        unsigned int ELEMSIZE_HASH_DIS                                            :  1;
+        unsigned int TRUNCATE_COORD_MODE                                          :  1;
+        unsigned int                                                              : 13;
+    } gfx11;
+#endif
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union TA_CNTL_AUX {
     struct {
         unsigned int SCOAL_DSWIZZLE_N                                             :  1;
         unsigned int                                                              :  4;
         unsigned int TFAULT_EN_OVERRIDE                                           :  1;
         unsigned int                                                              :  1;
         unsigned int DISABLE_GATHER4_BC_SWIZZLE                                   :  1;
         unsigned int                                                              :  2;
         unsigned int ANISO_HALF_THRESH                                            :  2;
         unsigned int ANISO_ERROR_FP_VBIAS                                         :  1;
@@ -33584,29 +37518,29 @@ union TA_CNTL_AUX {
         unsigned int NONIMG_ANISO_BYPASS                                          :  1;
         unsigned int                                                              :  9;
         unsigned int ANISO_MIP_ADJ_MODE                                           :  1;
         unsigned int                                                              : 12;
     } gfx09;
     struct {
         unsigned int                                                              :  1;
         unsigned int RESERVED                                                     :  3;
         unsigned int                                                              : 28;
     } gfx101;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  2;
         unsigned int CORNER_SAMPLES_MIN_DIM                                       :  1;
         unsigned int OVERRIDE_QUAD_MODE_DIS                                       :  1;
         unsigned int                                                              : 28;
     } gfx103Plus;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  1;
         unsigned int DEPTH_AS_PITCH_DIS                                           :  1;
         unsigned int                                                              : 30;
     } gfx103PlusExclusive;
 #endif
     struct {
         unsigned int                                                              :  4;
         unsigned int DERIV_ADJUST_DIS                                             :  1;
         unsigned int                                                              : 27;
@@ -33727,21 +37661,21 @@ union TA_PERFCOUNTER0_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int                                                              :  2;
         unsigned int PERF_SEL1                                                    :  8;
         unsigned int                                                              : 14;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33752,21 +37686,21 @@ union TA_PERFCOUNTER0_SELECT1 {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  8;
         unsigned int                                                              :  2;
         unsigned int PERF_SEL3                                                    :  8;
         unsigned int                                                              : 14;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -33803,21 +37737,21 @@ union TA_PERFCOUNTER1_SELECT {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int                                                              : 24;
     } most;
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    :  8;
         unsigned int                                                              :  6;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int                                                              :  4;
     } gfx09_0;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -34509,21 +38443,21 @@ union TD_PERFCOUNTER0_SELECT {
         unsigned int CNTR_MODE                                                    :  4;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int PERF_MODE                                                    :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int                                                              :  2;
         unsigned int PERF_SEL1                                                    :  8;
         unsigned int                                                              : 14;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int PERF_SEL1                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -34534,21 +38468,21 @@ union TD_PERFCOUNTER0_SELECT1 {
         unsigned int                                                              : 24;
         unsigned int PERF_MODE3                                                   :  4;
         unsigned int PERF_MODE2                                                   :  4;
     } bits, bitfields;
     struct {
         unsigned int PERF_SEL2                                                    :  8;
         unsigned int                                                              :  2;
         unsigned int PERF_SEL3                                                    :  8;
         unsigned int                                                              : 14;
     } most;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL2                                                    : 10;
         unsigned int PERF_SEL3                                                    : 10;
         unsigned int                                                              : 12;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -34585,21 +38519,21 @@ union TD_PERFCOUNTER1_SELECT {
         unsigned int PERF_SEL                                                     :  8;
         unsigned int                                                              : 24;
     } most;
     struct {
         unsigned int                                                              : 10;
         unsigned int PERF_SEL1                                                    :  8;
         unsigned int                                                              :  6;
         unsigned int PERF_MODE1                                                   :  4;
         unsigned int                                                              :  4;
     } gfx09_0;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 22;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
@@ -42245,20 +46179,96 @@ union UTCL1_PERFCOUNTER1_SELECT {
         unsigned int PERF_SEL                                                     : 10;
         unsigned int                                                              : 18;
         unsigned int COUNTER_MODE                                                 :  4;
     } bits, bitfields;
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER2_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER2_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER2_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 18;
+        unsigned int COUNTER_MODE                                                 :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER3_HI {
+    struct {
+        unsigned int PERFCOUNTER_HI                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER3_LO {
+    struct {
+        unsigned int PERFCOUNTER_LO                                               : 32;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
+#if CHIP_HDR_NAVI31
+union UTCL1_PERFCOUNTER3_SELECT {
+    struct {
+        unsigned int PERF_SEL                                                     : 10;
+        unsigned int                                                              : 18;
+        unsigned int COUNTER_MODE                                                 :  4;
+    } bits, bitfields;
+
+    unsigned int u32All;
+    signed int   i32All;
+    float        f32All;
+};
+#endif
+
 union VGT_CACHE_INVALIDATION {
     struct {
         unsigned int CACHE_INVALIDATION                                           :  2;
         unsigned int                                                              :  2;
         unsigned int DIS_INSTANCING_OPT                                           :  1;
         unsigned int VS_NO_EXTRA_BUFFER                                           :  1;
         unsigned int AUTO_INVLD_EN                                                :  2;
         unsigned int                                                              :  1;
         unsigned int USE_GS_DONE                                                  :  1;
         unsigned int                                                              :  1;
@@ -42395,21 +46405,21 @@ union VGT_DMA_INDEX_TYPE {
         unsigned int REQ_PATH                                                     :  1;
         unsigned int                                                              : 21;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  6;
         unsigned int RDREQ_POLICY                                                 :  1;
         unsigned int                                                              :  1;
         unsigned int PRIMGEN_EN                                                   :  1;
         unsigned int                                                              : 23;
     } gfx09;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 14;
         unsigned int DISABLE_INSTANCE_PACKING                                     :  1;
         unsigned int                                                              : 17;
     } gfx103Plus;
 #endif
     struct {
         unsigned int                                                              :  6;
         unsigned int RDREQ_POLICY                                                 :  2;
         unsigned int ATC                                                          :  1;
@@ -42533,21 +46543,21 @@ union VGT_DRAW_PAYLOAD_CNTL {
     struct {
         unsigned int                                                              :  2;
         unsigned int                                                              :  2;
         unsigned int                                                              : 28;
     } gfx09;
     struct {
         unsigned int                                                              :  2;
         unsigned int                                                              :  1;
         unsigned int                                                              : 29;
     } gfx101;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  6;
         unsigned int EN_VRS_RATE                                                  :  1;
         unsigned int                                                              : 25;
     } gfx103Plus;
 #endif
     struct {
         unsigned int                                                              :  3;
         unsigned int EN_PRIM_PAYLOAD                                              :  1;
         unsigned int EN_DRAW_VP                                                   :  1;
@@ -43066,21 +47076,21 @@ union VGT_HOS_REUSE_DEPTH {
     signed int   i32All;
     float        f32All;
 };
 
 union VGT_HS_OFFCHIP_PARAM {
     struct {
         unsigned int OFFCHIP_BUFFERING                                            :  9;
         unsigned int OFFCHIP_GRANULARITY                                          :  2;
         unsigned int                                                              : 21;
     } most;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int OFFCHIP_BUFFERING                                            : 10;
         unsigned int OFFCHIP_GRANULARITY                                          :  2;
         unsigned int                                                              : 20;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -43139,21 +47149,21 @@ union VGT_IMMED_DATA {
 union VGT_INDEX_TYPE {
     struct {
         unsigned int INDEX_TYPE                                                   :  2;
         unsigned int                                                              : 30;
     } bits, bitfields;
     struct {
         unsigned int                                                              :  8;
         unsigned int PRIMGEN_EN                                                   :  1;
         unsigned int                                                              : 23;
     } gfx09;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              : 14;
         unsigned int DISABLE_INSTANCE_PACKING                                     :  1;
         unsigned int                                                              : 17;
     } gfx103Plus;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -43560,20 +47570,27 @@ union VGT_SHADER_STAGES_EN {
     struct {
         unsigned int                                                              : 19;
         unsigned int GS_FAST_LAUNCH                                               :  1;
         unsigned int                                                              : 12;
     } gfx09_0;
     struct {
         unsigned int                                                              : 19;
         unsigned int GS_FAST_LAUNCH                                               :  2;
         unsigned int                                                              : 11;
     } gfx09_1xPlus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 26;
+        unsigned int PRIMGEN_PASSTHRU_NO_MSG                                      :  1;
+        unsigned int                                                              :  5;
+    } gfx104Plus;
+#endif
     struct {
         unsigned int                                                              :  8;
         unsigned int DYNAMIC_HS                                                   :  1;
         unsigned int                                                              : 12;
         unsigned int HS_W32_EN                                                    :  1;
         unsigned int GS_W32_EN                                                    :  1;
         unsigned int VS_W32_EN                                                    :  1;
         unsigned int NGG_WAVE_ID_EN                                               :  1;
         unsigned int PRIMGEN_PASSTHRU_EN                                          :  1;
         unsigned int                                                              :  6;
@@ -43840,21 +47857,21 @@ union VGT_STRMOUT_VTX_STRIDE_3 {
     float        f32All;
 };
 
 union VGT_SYS_CONFIG {
     struct {
         unsigned int DUAL_CORE_EN                                                 :  1;
         unsigned int MAX_LS_HS_THDGRP                                             :  6;
         unsigned int ADC_EVENT_FILTER_DISABLE                                     :  1;
         unsigned int                                                              : 24;
     } bits, bitfields;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
     struct {
         unsigned int                                                              :  8;
         unsigned int NUM_SUBGROUPS_IN_FLIGHT                                      : 11;
         unsigned int                                                              : 13;
     } gfx103PlusExclusive;
 #endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
@@ -43943,31 +47960,44 @@ union VGT_TF_PARAM {
         unsigned int NUM_DS_WAVES_PER_SIMD                                        :  4;
         unsigned int                                                              :  1;
         unsigned int RDREQ_POLICY                                                 :  2;
         unsigned int                                                              :  2;
         unsigned int DETECT_ONE                                                   :  1;
         unsigned int DETECT_ZERO                                                  :  1;
         unsigned int                                                              :  2;
         unsigned int MTYPE                                                        :  3;
         unsigned int                                                              :  6;
     } gfx10Plus;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              :  9;
+        unsigned int NOT_USED                                                     :  1;
+        unsigned int                                                              : 22;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union VGT_TF_RING_SIZE {
     struct {
         unsigned int SIZE                                                         : 16;
         unsigned int                                                              : 16;
     } gfx09_10;
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int SIZE                                                         : 17;
+        unsigned int                                                              : 15;
+    } gfx11;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union VGT_TF_RING_SIZE_UMD {
     struct {
         unsigned int SIZE                                                         : 16;
         unsigned int                                                              : 16;
@@ -44100,20 +48130,31 @@ union WD_CNTL_STATUS {
         unsigned int DIST_BUSY                                                    :  1;
         unsigned int DIST_BE_BUSY                                                 :  1;
         unsigned int                                                              :  6;
         unsigned int TE3_BUSY                                                     :  1;
         unsigned int TE2_BUSY                                                     :  1;
         unsigned int TE1_BUSY                                                     :  1;
         unsigned int TE0_BUSY                                                     :  1;
         unsigned int                                                              :  4;
     } gfx103Derivative;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int DIST_BUSY                                                    :  1;
+        unsigned int DIST_BE_BUSY                                                 :  1;
+        unsigned int GE_UTCL1_BUSY                                                :  1;
+        unsigned int WD_TE11_BUSY                                                 :  1;
+        unsigned int PC_MANAGER_BUSY                                              :  1;
+        unsigned int WLC_BUSY                                                     :  1;
+        unsigned int                                                              : 26;
+    } gfx11;
+#endif
 #if CHIP_HDR_NAVI21
     struct {
         unsigned int                                                              : 18;
         unsigned int WD_TE11_BUSY                                                 :  1;
         unsigned int SA3_OUTPUT_BLOCK_BUSY                                        :  1;
         unsigned int SA2_OUTPUT_BLOCK_BUSY                                        :  1;
         unsigned int SA1_OUTPUT_BLOCK_BUSY                                        :  1;
         unsigned int SA0_OUTPUT_BLOCK_BUSY                                        :  1;
         unsigned int GE_UTCL1_BUSY                                                :  1;
         unsigned int                                                              :  4;
@@ -44407,20 +48448,27 @@ union WD_UTCL1_CNTL {
         unsigned int                                                              :  1;
     } nv23;
 #endif
 #if CHIP_HDR_NAVI24
     struct {
         unsigned int                                                              : 30;
         unsigned int LLC_NOALLOC_OVERRIDE                                         :  1;
         unsigned int                                                              :  1;
     } nv24;
 #endif
+#if CHIP_HDR_NAVI31
+    struct {
+        unsigned int                                                              : 30;
+        unsigned int LLC_NOALLOC_OVERRIDE                                         :  1;
+        unsigned int                                                              :  1;
+    } nv3x;
+#endif
 
     unsigned int u32All;
     signed int   i32All;
     float        f32All;
 };
 
 union WD_UTCL1_STATUS {
     struct {
         unsigned int FAULT_DETECTED                                               :  1;
         unsigned int RETRY_DETECTED                                               :  1;
diff --git a/lgc/imported/chip/gfx9/gfx9_plus_merged_typedef.h b/lgc/imported/chip/gfx9/gfx9_plus_merged_typedef.h
index 8670e14d9..00a317e39 100644
--- a/lgc/imported/chip/gfx9/gfx9_plus_merged_typedef.h
+++ b/lgc/imported/chip/gfx9/gfx9_plus_merged_typedef.h
@@ -216,28 +216,45 @@ typedef union CB_COLOR7_DCC_CONTROL                              regCB_COLOR7_DC
 typedef union CB_COLOR7_FMASK                                    regCB_COLOR7_FMASK;
 typedef union CB_COLOR7_FMASK_BASE_EXT                           regCB_COLOR7_FMASK_BASE_EXT;
 typedef union CB_COLOR7_FMASK_SLICE                              regCB_COLOR7_FMASK_SLICE;
 typedef union CB_COLOR7_INFO                                     regCB_COLOR7_INFO;
 typedef union CB_COLOR7_PITCH                                    regCB_COLOR7_PITCH;
 typedef union CB_COLOR7_SLICE                                    regCB_COLOR7_SLICE;
 typedef union CB_COLOR7_VIEW                                     regCB_COLOR7_VIEW;
 typedef union CB_COLOR_CONTROL                                   regCB_COLOR_CONTROL;
 typedef union CB_COVERAGE_OUT_CONTROL                            regCB_COVERAGE_OUT_CONTROL;
 typedef union CB_DCC_CONFIG                                      regCB_DCC_CONFIG;
+#if CHIP_HDR_NAVI31
+typedef union CB_DCC_CONFIG2                                     regCB_DCC_CONFIG2;
+#endif
 typedef union CB_DCC_CONTROL                                     regCB_DCC_CONTROL;
+#if CHIP_HDR_NAVI31
+typedef union CB_FDCC_CONTROL                                    regCB_FDCC_CONTROL;
+typedef union CB_FGCG_SRAM_OVERRIDE                              regCB_FGCG_SRAM_OVERRIDE;
+#endif
 typedef union CB_HW_CONTROL                                      regCB_HW_CONTROL;
 typedef union CB_HW_CONTROL_1                                    regCB_HW_CONTROL_1;
 typedef union CB_HW_CONTROL_2                                    regCB_HW_CONTROL_2;
 typedef union CB_HW_CONTROL_3                                    regCB_HW_CONTROL_3;
 typedef union CB_HW_CONTROL_4                                    regCB_HW_CONTROL_4;
 typedef union CB_HW_MEM_ARBITER_RD                               regCB_HW_MEM_ARBITER_RD;
 typedef union CB_HW_MEM_ARBITER_WR                               regCB_HW_MEM_ARBITER_WR;
+#if CHIP_HDR_NAVI31
+typedef union CB_KEY_OVERRIDE_0                                  regCB_KEY_OVERRIDE_0;
+typedef union CB_KEY_OVERRIDE_1                                  regCB_KEY_OVERRIDE_1;
+typedef union CB_KEY_OVERRIDE_2                                  regCB_KEY_OVERRIDE_2;
+typedef union CB_KEY_OVERRIDE_3                                  regCB_KEY_OVERRIDE_3;
+typedef union CB_KEY_OVERRIDE_4                                  regCB_KEY_OVERRIDE_4;
+typedef union CB_KEY_OVERRIDE_5                                  regCB_KEY_OVERRIDE_5;
+typedef union CB_KEY_OVERRIDE_6                                  regCB_KEY_OVERRIDE_6;
+typedef union CB_KEY_OVERRIDE_7                                  regCB_KEY_OVERRIDE_7;
+#endif
 typedef union CB_MRT0_EPITCH                                     regCB_MRT0_EPITCH;
 typedef union CB_MRT1_EPITCH                                     regCB_MRT1_EPITCH;
 typedef union CB_MRT2_EPITCH                                     regCB_MRT2_EPITCH;
 typedef union CB_MRT3_EPITCH                                     regCB_MRT3_EPITCH;
 typedef union CB_MRT4_EPITCH                                     regCB_MRT4_EPITCH;
 typedef union CB_MRT5_EPITCH                                     regCB_MRT5_EPITCH;
 typedef union CB_MRT6_EPITCH                                     regCB_MRT6_EPITCH;
 typedef union CB_MRT7_EPITCH                                     regCB_MRT7_EPITCH;
 typedef union CB_PERFCOUNTER0_HI                                 regCB_PERFCOUNTER0_HI;
 typedef union CB_PERFCOUNTER0_LO                                 regCB_PERFCOUNTER0_LO;
@@ -311,20 +328,23 @@ typedef union COMPUTE_DDID_INDEX                                 regCOMPUTE_DDID
 typedef union COMPUTE_DESTINATION_EN_SE0                         regCOMPUTE_DESTINATION_EN_SE0;
 typedef union COMPUTE_DESTINATION_EN_SE1                         regCOMPUTE_DESTINATION_EN_SE1;
 typedef union COMPUTE_DESTINATION_EN_SE2                         regCOMPUTE_DESTINATION_EN_SE2;
 typedef union COMPUTE_DESTINATION_EN_SE3                         regCOMPUTE_DESTINATION_EN_SE3;
 typedef union COMPUTE_DIM_X                                      regCOMPUTE_DIM_X;
 typedef union COMPUTE_DIM_Y                                      regCOMPUTE_DIM_Y;
 typedef union COMPUTE_DIM_Z                                      regCOMPUTE_DIM_Z;
 typedef union COMPUTE_DISPATCH_END                               regCOMPUTE_DISPATCH_END;
 typedef union COMPUTE_DISPATCH_ID                                regCOMPUTE_DISPATCH_ID;
 typedef union COMPUTE_DISPATCH_INITIATOR                         regCOMPUTE_DISPATCH_INITIATOR;
+#if CHIP_HDR_NAVI31
+typedef union COMPUTE_DISPATCH_INTERLEAVE                        regCOMPUTE_DISPATCH_INTERLEAVE;
+#endif
 typedef union COMPUTE_DISPATCH_PKT_ADDR_HI                       regCOMPUTE_DISPATCH_PKT_ADDR_HI;
 typedef union COMPUTE_DISPATCH_PKT_ADDR_LO                       regCOMPUTE_DISPATCH_PKT_ADDR_LO;
 typedef union COMPUTE_DISPATCH_SCRATCH_BASE_HI                   regCOMPUTE_DISPATCH_SCRATCH_BASE_HI;
 typedef union COMPUTE_DISPATCH_SCRATCH_BASE_LO                   regCOMPUTE_DISPATCH_SCRATCH_BASE_LO;
 typedef union COMPUTE_DISPATCH_TUNNEL                            regCOMPUTE_DISPATCH_TUNNEL;
 typedef union COMPUTE_MISC_RESERVED                              regCOMPUTE_MISC_RESERVED;
 typedef union COMPUTE_NOWHERE                                    regCOMPUTE_NOWHERE;
 typedef union COMPUTE_NUM_THREAD_X                               regCOMPUTE_NUM_THREAD_X;
 typedef union COMPUTE_NUM_THREAD_Y                               regCOMPUTE_NUM_THREAD_Y;
 typedef union COMPUTE_NUM_THREAD_Z                               regCOMPUTE_NUM_THREAD_Z;
@@ -347,20 +367,26 @@ typedef union COMPUTE_RESTART_X                                  regCOMPUTE_REST
 typedef union COMPUTE_RESTART_Y                                  regCOMPUTE_RESTART_Y;
 typedef union COMPUTE_RESTART_Z                                  regCOMPUTE_RESTART_Z;
 typedef union COMPUTE_SHADER_CHKSUM                              regCOMPUTE_SHADER_CHKSUM;
 typedef union COMPUTE_START_X                                    regCOMPUTE_START_X;
 typedef union COMPUTE_START_Y                                    regCOMPUTE_START_Y;
 typedef union COMPUTE_START_Z                                    regCOMPUTE_START_Z;
 typedef union COMPUTE_STATIC_THREAD_MGMT_SE0                     regCOMPUTE_STATIC_THREAD_MGMT_SE0;
 typedef union COMPUTE_STATIC_THREAD_MGMT_SE1                     regCOMPUTE_STATIC_THREAD_MGMT_SE1;
 typedef union COMPUTE_STATIC_THREAD_MGMT_SE2                     regCOMPUTE_STATIC_THREAD_MGMT_SE2;
 typedef union COMPUTE_STATIC_THREAD_MGMT_SE3                     regCOMPUTE_STATIC_THREAD_MGMT_SE3;
+#if CHIP_HDR_NAVI31
+typedef union COMPUTE_STATIC_THREAD_MGMT_SE4                     regCOMPUTE_STATIC_THREAD_MGMT_SE4;
+typedef union COMPUTE_STATIC_THREAD_MGMT_SE5                     regCOMPUTE_STATIC_THREAD_MGMT_SE5;
+typedef union COMPUTE_STATIC_THREAD_MGMT_SE6                     regCOMPUTE_STATIC_THREAD_MGMT_SE6;
+typedef union COMPUTE_STATIC_THREAD_MGMT_SE7                     regCOMPUTE_STATIC_THREAD_MGMT_SE7;
+#endif
 typedef union COMPUTE_THREADGROUP_ID                             regCOMPUTE_THREADGROUP_ID;
 typedef union COMPUTE_THREAD_TRACE_ENABLE                        regCOMPUTE_THREAD_TRACE_ENABLE;
 typedef union COMPUTE_TMPRING_SIZE                               regCOMPUTE_TMPRING_SIZE;
 typedef union COMPUTE_USER_ACCUM_0                               regCOMPUTE_USER_ACCUM_0;
 typedef union COMPUTE_USER_ACCUM_1                               regCOMPUTE_USER_ACCUM_1;
 typedef union COMPUTE_USER_ACCUM_2                               regCOMPUTE_USER_ACCUM_2;
 typedef union COMPUTE_USER_ACCUM_3                               regCOMPUTE_USER_ACCUM_3;
 typedef union COMPUTE_USER_DATA_0                                regCOMPUTE_USER_DATA_0;
 typedef union COMPUTE_USER_DATA_1                                regCOMPUTE_USER_DATA_1;
 typedef union COMPUTE_USER_DATA_2                                regCOMPUTE_USER_DATA_2;
@@ -430,20 +456,24 @@ typedef union CP_NUM_PRIM_WRITTEN_COUNT2_HI                      regCP_NUM_PRIM_
 typedef union CP_NUM_PRIM_WRITTEN_COUNT2_LO                      regCP_NUM_PRIM_WRITTEN_COUNT2_LO;
 typedef union CP_NUM_PRIM_WRITTEN_COUNT3_HI                      regCP_NUM_PRIM_WRITTEN_COUNT3_HI;
 typedef union CP_NUM_PRIM_WRITTEN_COUNT3_LO                      regCP_NUM_PRIM_WRITTEN_COUNT3_LO;
 typedef union CP_PERFMON_CNTL                                    regCP_PERFMON_CNTL;
 typedef union CP_PERFMON_CNTX_CNTL                               regCP_PERFMON_CNTX_CNTL;
 typedef union CP_SC_PSINVOC_COUNT0_HI                            regCP_SC_PSINVOC_COUNT0_HI;
 typedef union CP_SC_PSINVOC_COUNT0_LO                            regCP_SC_PSINVOC_COUNT0_LO;
 typedef union CP_SC_PSINVOC_COUNT1_HI                            regCP_SC_PSINVOC_COUNT1_HI;
 typedef union CP_SC_PSINVOC_COUNT1_LO                            regCP_SC_PSINVOC_COUNT1_LO;
 typedef union CP_STRMOUT_CNTL                                    regCP_STRMOUT_CNTL;
+#if CHIP_HDR_NAVI31
+typedef union CP_VGT_ASINVOC_COUNT_HI                            regCP_VGT_ASINVOC_COUNT_HI;
+typedef union CP_VGT_ASINVOC_COUNT_LO                            regCP_VGT_ASINVOC_COUNT_LO;
+#endif
 typedef union CP_VGT_CSINVOC_COUNT_HI                            regCP_VGT_CSINVOC_COUNT_HI;
 typedef union CP_VGT_CSINVOC_COUNT_LO                            regCP_VGT_CSINVOC_COUNT_LO;
 typedef union CP_VGT_DSINVOC_COUNT_HI                            regCP_VGT_DSINVOC_COUNT_HI;
 typedef union CP_VGT_DSINVOC_COUNT_LO                            regCP_VGT_DSINVOC_COUNT_LO;
 typedef union CP_VGT_GSINVOC_COUNT_HI                            regCP_VGT_GSINVOC_COUNT_HI;
 typedef union CP_VGT_GSINVOC_COUNT_LO                            regCP_VGT_GSINVOC_COUNT_LO;
 typedef union CP_VGT_GSPRIM_COUNT_HI                             regCP_VGT_GSPRIM_COUNT_HI;
 typedef union CP_VGT_GSPRIM_COUNT_LO                             regCP_VGT_GSPRIM_COUNT_LO;
 typedef union CP_VGT_HSINVOC_COUNT_HI                            regCP_VGT_HSINVOC_COUNT_HI;
 typedef union CP_VGT_HSINVOC_COUNT_LO                            regCP_VGT_HSINVOC_COUNT_LO;
@@ -474,20 +504,23 @@ typedef union DB_DFSM_WATCHDOG                                   regDB_DFSM_WATC
 typedef union DB_DFSM_WATERMARK                                  regDB_DFSM_WATERMARK;
 typedef union DB_EQAA                                            regDB_EQAA;
 typedef union DB_EQUAD_STUTTER_CONTROL                           regDB_EQUAD_STUTTER_CONTROL;
 typedef union DB_ETILE_STUTTER_CONTROL                           regDB_ETILE_STUTTER_CONTROL;
 typedef union DB_EXCEPTION_CONTROL                               regDB_EXCEPTION_CONTROL;
 typedef union DB_FGCG_INTERFACES_CLK_CTRL                        regDB_FGCG_INTERFACES_CLK_CTRL;
 typedef union DB_FGCG_SRAMS_CLK_CTRL                             regDB_FGCG_SRAMS_CLK_CTRL;
 typedef union DB_FIFO_DEPTH1                                     regDB_FIFO_DEPTH1;
 typedef union DB_FIFO_DEPTH2                                     regDB_FIFO_DEPTH2;
 typedef union DB_FIFO_DEPTH3                                     regDB_FIFO_DEPTH3;
+#if CHIP_HDR_NAVI31
+typedef union DB_FIFO_DEPTH4                                     regDB_FIFO_DEPTH4;
+#endif
 typedef union DB_FREE_CACHELINES                                 regDB_FREE_CACHELINES;
 typedef union DB_HTILE_DATA_BASE                                 regDB_HTILE_DATA_BASE;
 typedef union DB_HTILE_DATA_BASE_HI                              regDB_HTILE_DATA_BASE_HI;
 typedef union DB_HTILE_SURFACE                                   regDB_HTILE_SURFACE;
 typedef union DB_LAST_OF_BURST_CONFIG                            regDB_LAST_OF_BURST_CONFIG;
 typedef union DB_LQUAD_STUTTER_CONTROL                           regDB_LQUAD_STUTTER_CONTROL;
 typedef union DB_LTILE_STUTTER_CONTROL                           regDB_LTILE_STUTTER_CONTROL;
 typedef union DB_MEM_ARB_WATERMARKS                              regDB_MEM_ARB_WATERMARKS;
 typedef union DB_OCCLUSION_COUNT0_HI                             regDB_OCCLUSION_COUNT0_HI;
 typedef union DB_OCCLUSION_COUNT0_LOW                            regDB_OCCLUSION_COUNT0_LOW;
@@ -516,21 +549,21 @@ typedef union DB_RENDER_CONTROL                                  regDB_RENDER_CO
 typedef union DB_RENDER_OVERRIDE                                 regDB_RENDER_OVERRIDE;
 typedef union DB_RENDER_OVERRIDE2                                regDB_RENDER_OVERRIDE2;
 typedef union DB_RESERVED_REG_1                                  regDB_RESERVED_REG_1;
 typedef union DB_RESERVED_REG_2                                  regDB_RESERVED_REG_2;
 typedef union DB_RESERVED_REG_3                                  regDB_RESERVED_REG_3;
 typedef union DB_RING_CONTROL                                    regDB_RING_CONTROL;
 typedef union DB_RMI_BC_GL2_CACHE_CONTROL                        regDB_RMI_BC_GL2_CACHE_CONTROL;
 typedef union DB_RMI_CACHE_POLICY                                regDB_RMI_CACHE_POLICY;
 typedef union DB_RMI_L2_CACHE_CONTROL                            regDB_RMI_L2_CACHE_CONTROL;
 typedef union DB_SHADER_CONTROL                                  regDB_SHADER_CONTROL;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union DB_SPI_VRS_CENTER_LOCATION                         regDB_SPI_VRS_CENTER_LOCATION;
 #endif
 typedef union DB_SRESULTS_COMPARE_STATE0                         regDB_SRESULTS_COMPARE_STATE0;
 typedef union DB_SRESULTS_COMPARE_STATE1                         regDB_SRESULTS_COMPARE_STATE1;
 typedef union DB_STENCILREFMASK                                  regDB_STENCILREFMASK;
 typedef union DB_STENCILREFMASK_BF                               regDB_STENCILREFMASK_BF;
 typedef union DB_STENCIL_CLEAR                                   regDB_STENCIL_CLEAR;
 typedef union DB_STENCIL_CONTROL                                 regDB_STENCIL_CONTROL;
 typedef union DB_STENCIL_INFO                                    regDB_STENCIL_INFO;
 typedef union DB_STENCIL_INFO2                                   regDB_STENCIL_INFO2;
@@ -633,36 +666,36 @@ typedef union GC_ATC_L2_PERFCOUNTER2_SELECT1                     regGC_ATC_L2_PE
 typedef union GC_ATC_L2_PERFCOUNTER_HI                           regGC_ATC_L2_PERFCOUNTER_HI;
 typedef union GC_ATC_L2_PERFCOUNTER_LO                           regGC_ATC_L2_PERFCOUNTER_LO;
 typedef union GC_ATC_L2_PERFCOUNTER_RSLT_CNTL                    regGC_ATC_L2_PERFCOUNTER_RSLT_CNTL;
 typedef union GDS_PERFCOUNTER0_HI                                regGDS_PERFCOUNTER0_HI;
 typedef union GDS_PERFCOUNTER0_LO                                regGDS_PERFCOUNTER0_LO;
 typedef union GDS_PERFCOUNTER0_SELECT                            regGDS_PERFCOUNTER0_SELECT;
 typedef union GDS_PERFCOUNTER0_SELECT1                           regGDS_PERFCOUNTER0_SELECT1;
 typedef union GDS_PERFCOUNTER1_HI                                regGDS_PERFCOUNTER1_HI;
 typedef union GDS_PERFCOUNTER1_LO                                regGDS_PERFCOUNTER1_LO;
 typedef union GDS_PERFCOUNTER1_SELECT                            regGDS_PERFCOUNTER1_SELECT;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union GDS_PERFCOUNTER1_SELECT1                           regGDS_PERFCOUNTER1_SELECT1;
 #endif
 typedef union GDS_PERFCOUNTER2_HI                                regGDS_PERFCOUNTER2_HI;
 typedef union GDS_PERFCOUNTER2_LO                                regGDS_PERFCOUNTER2_LO;
 typedef union GDS_PERFCOUNTER2_SELECT                            regGDS_PERFCOUNTER2_SELECT;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union GDS_PERFCOUNTER2_SELECT1                           regGDS_PERFCOUNTER2_SELECT1;
 #endif
 typedef union GDS_PERFCOUNTER3_HI                                regGDS_PERFCOUNTER3_HI;
 typedef union GDS_PERFCOUNTER3_LO                                regGDS_PERFCOUNTER3_LO;
 typedef union GDS_PERFCOUNTER3_SELECT                            regGDS_PERFCOUNTER3_SELECT;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union GDS_PERFCOUNTER3_SELECT1                           regGDS_PERFCOUNTER3_SELECT1;
 #endif
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union GE1_PERFCOUNTER0_HI                                regGE1_PERFCOUNTER0_HI;
 typedef union GE1_PERFCOUNTER0_LO                                regGE1_PERFCOUNTER0_LO;
 typedef union GE1_PERFCOUNTER0_SELECT                            regGE1_PERFCOUNTER0_SELECT;
 typedef union GE1_PERFCOUNTER0_SELECT1                           regGE1_PERFCOUNTER0_SELECT1;
 typedef union GE1_PERFCOUNTER1_HI                                regGE1_PERFCOUNTER1_HI;
 typedef union GE1_PERFCOUNTER1_LO                                regGE1_PERFCOUNTER1_LO;
 typedef union GE1_PERFCOUNTER1_SELECT                            regGE1_PERFCOUNTER1_SELECT;
 typedef union GE1_PERFCOUNTER1_SELECT1                           regGE1_PERFCOUNTER1_SELECT1;
 typedef union GE1_PERFCOUNTER2_HI                                regGE1_PERFCOUNTER2_HI;
 typedef union GE1_PERFCOUNTER2_LO                                regGE1_PERFCOUNTER2_LO;
@@ -701,26 +734,33 @@ typedef union GE2_SE_PERFCOUNTER2_LO                             regGE2_SE_PERFC
 typedef union GE2_SE_PERFCOUNTER2_SELECT                         regGE2_SE_PERFCOUNTER2_SELECT;
 typedef union GE2_SE_PERFCOUNTER2_SELECT1                        regGE2_SE_PERFCOUNTER2_SELECT1;
 typedef union GE2_SE_PERFCOUNTER3_HI                             regGE2_SE_PERFCOUNTER3_HI;
 typedef union GE2_SE_PERFCOUNTER3_LO                             regGE2_SE_PERFCOUNTER3_LO;
 typedef union GE2_SE_PERFCOUNTER3_SELECT                         regGE2_SE_PERFCOUNTER3_SELECT;
 typedef union GE2_SE_PERFCOUNTER3_SELECT1                        regGE2_SE_PERFCOUNTER3_SELECT1;
 #endif
 typedef union GE_CNTL                                            regGE_CNTL;
 typedef union GE_DMA_FIRST_INDEX                                 regGE_DMA_FIRST_INDEX;
 typedef union GE_FAST_CLKS                                       regGE_FAST_CLKS;
+#if CHIP_HDR_NAVI31
+typedef union GE_GS_FAST_LAUNCH_WG_DIM                           regGE_GS_FAST_LAUNCH_WG_DIM;
+typedef union GE_GS_FAST_LAUNCH_WG_DIM_1                         regGE_GS_FAST_LAUNCH_WG_DIM_1;
+#endif
 typedef union GE_INDX_OFFSET                                     regGE_INDX_OFFSET;
 typedef union GE_MAX_OUTPUT_PER_SUBGROUP                         regGE_MAX_OUTPUT_PER_SUBGROUP;
 typedef union GE_MAX_VTX_INDX                                    regGE_MAX_VTX_INDX;
 typedef union GE_MIN_VTX_INDX                                    regGE_MIN_VTX_INDX;
 typedef union GE_MULTI_PRIM_IB_RESET_EN                          regGE_MULTI_PRIM_IB_RESET_EN;
 typedef union GE_NGG_SUBGRP_CNTL                                 regGE_NGG_SUBGRP_CNTL;
+#if CHIP_HDR_NAVI31
+typedef union GE_PA_IF_SAFE_REG                                  regGE_PA_IF_SAFE_REG;
+#endif
 typedef union GE_PC_ALLOC                                        regGE_PC_ALLOC;
 typedef union GE_PC_CNTL                                         regGE_PC_CNTL;
 typedef union GE_PERFCOUNTER0_HI                                 regGE_PERFCOUNTER0_HI;
 typedef union GE_PERFCOUNTER0_LO                                 regGE_PERFCOUNTER0_LO;
 typedef union GE_PERFCOUNTER0_SELECT                             regGE_PERFCOUNTER0_SELECT;
 typedef union GE_PERFCOUNTER0_SELECT1                            regGE_PERFCOUNTER0_SELECT1;
 typedef union GE_PERFCOUNTER1_HI                                 regGE_PERFCOUNTER1_HI;
 typedef union GE_PERFCOUNTER1_LO                                 regGE_PERFCOUNTER1_LO;
 typedef union GE_PERFCOUNTER1_SELECT                             regGE_PERFCOUNTER1_SELECT;
 typedef union GE_PERFCOUNTER1_SELECT1                            regGE_PERFCOUNTER1_SELECT1;
@@ -750,27 +790,34 @@ typedef union GE_PERFCOUNTER8_SELECT                             regGE_PERFCOUNT
 typedef union GE_PERFCOUNTER9_HI                                 regGE_PERFCOUNTER9_HI;
 typedef union GE_PERFCOUNTER9_LO                                 regGE_PERFCOUNTER9_LO;
 typedef union GE_PERFCOUNTER9_SELECT                             regGE_PERFCOUNTER9_SELECT;
 typedef union GE_PERFCOUNTER10_HI                                regGE_PERFCOUNTER10_HI;
 typedef union GE_PERFCOUNTER10_LO                                regGE_PERFCOUNTER10_LO;
 typedef union GE_PERFCOUNTER10_SELECT                            regGE_PERFCOUNTER10_SELECT;
 typedef union GE_PERFCOUNTER11_HI                                regGE_PERFCOUNTER11_HI;
 typedef union GE_PERFCOUNTER11_LO                                regGE_PERFCOUNTER11_LO;
 typedef union GE_PERFCOUNTER11_SELECT                            regGE_PERFCOUNTER11_SELECT;
 typedef union GE_PRIV_CONTROL                                    regGE_PRIV_CONTROL;
+#if CHIP_HDR_NAVI31
+typedef union GE_RATE_CNTL_1                                     regGE_RATE_CNTL_1;
+typedef union GE_RATE_CNTL_2                                     regGE_RATE_CNTL_2;
+#endif
+#if CHIP_HDR_NAVI31
+typedef union GE_SPI_IF_SAFE_REG                                 regGE_SPI_IF_SAFE_REG;
+#endif
 typedef union GE_STATUS                                          regGE_STATUS;
 typedef union GE_STEREO_CNTL                                     regGE_STEREO_CNTL;
 typedef union GE_USER_VGPR1                                      regGE_USER_VGPR1;
 typedef union GE_USER_VGPR2                                      regGE_USER_VGPR2;
 typedef union GE_USER_VGPR3                                      regGE_USER_VGPR3;
 typedef union GE_USER_VGPR_EN                                    regGE_USER_VGPR_EN;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union GE_VRS_RATE                                        regGE_VRS_RATE;
 #endif
 typedef union GL1A_PERFCOUNTER0_HI                               regGL1A_PERFCOUNTER0_HI;
 typedef union GL1A_PERFCOUNTER0_LO                               regGL1A_PERFCOUNTER0_LO;
 typedef union GL1A_PERFCOUNTER0_SELECT                           regGL1A_PERFCOUNTER0_SELECT;
 typedef union GL1A_PERFCOUNTER0_SELECT1                          regGL1A_PERFCOUNTER0_SELECT1;
 typedef union GL1A_PERFCOUNTER1_HI                               regGL1A_PERFCOUNTER1_HI;
 typedef union GL1A_PERFCOUNTER1_LO                               regGL1A_PERFCOUNTER1_LO;
 typedef union GL1A_PERFCOUNTER1_SELECT                           regGL1A_PERFCOUNTER1_SELECT;
 typedef union GL1A_PERFCOUNTER2_HI                               regGL1A_PERFCOUNTER2_HI;
@@ -837,20 +884,31 @@ typedef union GRBM_SE0_PERFCOUNTER_LO                            regGRBM_SE0_PER
 typedef union GRBM_SE0_PERFCOUNTER_SELECT                        regGRBM_SE0_PERFCOUNTER_SELECT;
 typedef union GRBM_SE1_PERFCOUNTER_HI                            regGRBM_SE1_PERFCOUNTER_HI;
 typedef union GRBM_SE1_PERFCOUNTER_LO                            regGRBM_SE1_PERFCOUNTER_LO;
 typedef union GRBM_SE1_PERFCOUNTER_SELECT                        regGRBM_SE1_PERFCOUNTER_SELECT;
 typedef union GRBM_SE2_PERFCOUNTER_HI                            regGRBM_SE2_PERFCOUNTER_HI;
 typedef union GRBM_SE2_PERFCOUNTER_LO                            regGRBM_SE2_PERFCOUNTER_LO;
 typedef union GRBM_SE2_PERFCOUNTER_SELECT                        regGRBM_SE2_PERFCOUNTER_SELECT;
 typedef union GRBM_SE3_PERFCOUNTER_HI                            regGRBM_SE3_PERFCOUNTER_HI;
 typedef union GRBM_SE3_PERFCOUNTER_LO                            regGRBM_SE3_PERFCOUNTER_LO;
 typedef union GRBM_SE3_PERFCOUNTER_SELECT                        regGRBM_SE3_PERFCOUNTER_SELECT;
+#if CHIP_HDR_NAVI31
+typedef union GRBM_SE4_PERFCOUNTER_HI                            regGRBM_SE4_PERFCOUNTER_HI;
+typedef union GRBM_SE4_PERFCOUNTER_LO                            regGRBM_SE4_PERFCOUNTER_LO;
+typedef union GRBM_SE4_PERFCOUNTER_SELECT                        regGRBM_SE4_PERFCOUNTER_SELECT;
+typedef union GRBM_SE5_PERFCOUNTER_HI                            regGRBM_SE5_PERFCOUNTER_HI;
+typedef union GRBM_SE5_PERFCOUNTER_LO                            regGRBM_SE5_PERFCOUNTER_LO;
+typedef union GRBM_SE5_PERFCOUNTER_SELECT                        regGRBM_SE5_PERFCOUNTER_SELECT;
+typedef union GRBM_SE6_PERFCOUNTER_HI                            regGRBM_SE6_PERFCOUNTER_HI;
+typedef union GRBM_SE6_PERFCOUNTER_LO                            regGRBM_SE6_PERFCOUNTER_LO;
+typedef union GRBM_SE6_PERFCOUNTER_SELECT                        regGRBM_SE6_PERFCOUNTER_SELECT;
+#endif
 typedef union GUS_PERFCOUNTER0_CFG                               regGUS_PERFCOUNTER0_CFG;
 typedef union GUS_PERFCOUNTER1_CFG                               regGUS_PERFCOUNTER1_CFG;
 typedef union GUS_PERFCOUNTER2_HI                                regGUS_PERFCOUNTER2_HI;
 typedef union GUS_PERFCOUNTER2_LO                                regGUS_PERFCOUNTER2_LO;
 typedef union GUS_PERFCOUNTER2_MODE                              regGUS_PERFCOUNTER2_MODE;
 typedef union GUS_PERFCOUNTER2_SELECT                            regGUS_PERFCOUNTER2_SELECT;
 typedef union GUS_PERFCOUNTER2_SELECT1                           regGUS_PERFCOUNTER2_SELECT1;
 typedef union GUS_PERFCOUNTER_HI                                 regGUS_PERFCOUNTER_HI;
 typedef union GUS_PERFCOUNTER_LO                                 regGUS_PERFCOUNTER_LO;
 typedef union GUS_PERFCOUNTER_RSLT_CNTL                          regGUS_PERFCOUNTER_RSLT_CNTL;
@@ -1014,21 +1072,21 @@ typedef union PA_CL_VPORT_ZSCALE_5                               regPA_CL_VPORT_
 typedef union PA_CL_VPORT_ZSCALE_6                               regPA_CL_VPORT_ZSCALE_6;
 typedef union PA_CL_VPORT_ZSCALE_7                               regPA_CL_VPORT_ZSCALE_7;
 typedef union PA_CL_VPORT_ZSCALE_8                               regPA_CL_VPORT_ZSCALE_8;
 typedef union PA_CL_VPORT_ZSCALE_9                               regPA_CL_VPORT_ZSCALE_9;
 typedef union PA_CL_VPORT_ZSCALE_10                              regPA_CL_VPORT_ZSCALE_10;
 typedef union PA_CL_VPORT_ZSCALE_11                              regPA_CL_VPORT_ZSCALE_11;
 typedef union PA_CL_VPORT_ZSCALE_12                              regPA_CL_VPORT_ZSCALE_12;
 typedef union PA_CL_VPORT_ZSCALE_13                              regPA_CL_VPORT_ZSCALE_13;
 typedef union PA_CL_VPORT_ZSCALE_14                              regPA_CL_VPORT_ZSCALE_14;
 typedef union PA_CL_VPORT_ZSCALE_15                              regPA_CL_VPORT_ZSCALE_15;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union PA_CL_VRS_CNTL                                     regPA_CL_VRS_CNTL;
 #endif
 typedef union PA_CL_VS_OUT_CNTL                                  regPA_CL_VS_OUT_CNTL;
 typedef union PA_CL_VTE_CNTL                                     regPA_CL_VTE_CNTL;
 typedef union PA_PH_ENHANCE                                      regPA_PH_ENHANCE;
 typedef union PA_PH_INTERFACE_FIFO_SIZE                          regPA_PH_INTERFACE_FIFO_SIZE;
 typedef union PA_PH_PERFCOUNTER0_HI                              regPA_PH_PERFCOUNTER0_HI;
 typedef union PA_PH_PERFCOUNTER0_LO                              regPA_PH_PERFCOUNTER0_LO;
 typedef union PA_PH_PERFCOUNTER0_SELECT                          regPA_PH_PERFCOUNTER0_SELECT;
 typedef union PA_PH_PERFCOUNTER0_SELECT1                         regPA_PH_PERFCOUNTER0_SELECT1;
@@ -1049,42 +1107,51 @@ typedef union PA_PH_PERFCOUNTER4_LO                              regPA_PH_PERFCO
 typedef union PA_PH_PERFCOUNTER4_SELECT                          regPA_PH_PERFCOUNTER4_SELECT;
 typedef union PA_PH_PERFCOUNTER5_HI                              regPA_PH_PERFCOUNTER5_HI;
 typedef union PA_PH_PERFCOUNTER5_LO                              regPA_PH_PERFCOUNTER5_LO;
 typedef union PA_PH_PERFCOUNTER5_SELECT                          regPA_PH_PERFCOUNTER5_SELECT;
 typedef union PA_PH_PERFCOUNTER6_HI                              regPA_PH_PERFCOUNTER6_HI;
 typedef union PA_PH_PERFCOUNTER6_LO                              regPA_PH_PERFCOUNTER6_LO;
 typedef union PA_PH_PERFCOUNTER6_SELECT                          regPA_PH_PERFCOUNTER6_SELECT;
 typedef union PA_PH_PERFCOUNTER7_HI                              regPA_PH_PERFCOUNTER7_HI;
 typedef union PA_PH_PERFCOUNTER7_LO                              regPA_PH_PERFCOUNTER7_LO;
 typedef union PA_PH_PERFCOUNTER7_SELECT                          regPA_PH_PERFCOUNTER7_SELECT;
+#if CHIP_HDR_NAVI31
+typedef union PA_RATE_CNTL                                       regPA_RATE_CNTL;
+#endif
 typedef union PA_SC_AA_CONFIG                                    regPA_SC_AA_CONFIG;
 typedef union PA_SC_AA_MASK_X0Y0_X1Y0                            regPA_SC_AA_MASK_X0Y0_X1Y0;
 typedef union PA_SC_AA_MASK_X0Y1_X1Y1                            regPA_SC_AA_MASK_X0Y1_X1Y1;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_0                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_0;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_1                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_1;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_2                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_2;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_3                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y0_3;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_0                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_0;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_1                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_1;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_2                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_2;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_3                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X0Y1_3;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_0                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_0;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_1                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_1;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_2                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_2;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_3                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y0_3;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_0                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_0;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_1                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_1;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_2                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_2;
 typedef union PA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_3                  regPA_SC_AA_SAMPLE_LOCS_PIXEL_X1Y1_3;
+#if CHIP_HDR_NAVI31
+typedef union PA_SC_ATM_CNTL                                     regPA_SC_ATM_CNTL;
+#endif
 typedef union PA_SC_BC_WAVE_BREAK                                regPA_SC_BC_WAVE_BREAK;
 typedef union PA_SC_BINNER_CNTL_0                                regPA_SC_BINNER_CNTL_0;
 typedef union PA_SC_BINNER_CNTL_1                                regPA_SC_BINNER_CNTL_1;
+#if CHIP_HDR_NAVI31
+typedef union PA_SC_BINNER_CNTL_2                                regPA_SC_BINNER_CNTL_2;
+#endif
 typedef union PA_SC_BINNER_CNTL_OVERRIDE                         regPA_SC_BINNER_CNTL_OVERRIDE;
 typedef union PA_SC_BINNER_EVENT_CNTL_0                          regPA_SC_BINNER_EVENT_CNTL_0;
 typedef union PA_SC_BINNER_EVENT_CNTL_1                          regPA_SC_BINNER_EVENT_CNTL_1;
 typedef union PA_SC_BINNER_EVENT_CNTL_2                          regPA_SC_BINNER_EVENT_CNTL_2;
 typedef union PA_SC_BINNER_EVENT_CNTL_3                          regPA_SC_BINNER_EVENT_CNTL_3;
 typedef union PA_SC_BINNER_PERF_CNTL_0                           regPA_SC_BINNER_PERF_CNTL_0;
 typedef union PA_SC_BINNER_PERF_CNTL_1                           regPA_SC_BINNER_PERF_CNTL_1;
 typedef union PA_SC_BINNER_PERF_CNTL_2                           regPA_SC_BINNER_PERF_CNTL_2;
 typedef union PA_SC_BINNER_PERF_CNTL_3                           regPA_SC_BINNER_PERF_CNTL_3;
 typedef union PA_SC_BINNER_TIMEOUT_COUNTER                       regPA_SC_BINNER_TIMEOUT_COUNTER;
@@ -1098,21 +1165,21 @@ typedef union PA_SC_CLIPRECT_2_BR                                regPA_SC_CLIPRE
 typedef union PA_SC_CLIPRECT_2_TL                                regPA_SC_CLIPRECT_2_TL;
 typedef union PA_SC_CLIPRECT_3_BR                                regPA_SC_CLIPRECT_3_BR;
 typedef union PA_SC_CLIPRECT_3_TL                                regPA_SC_CLIPRECT_3_TL;
 typedef union PA_SC_CLIPRECT_RULE                                regPA_SC_CLIPRECT_RULE;
 typedef union PA_SC_CONSERVATIVE_RASTERIZATION_CNTL              regPA_SC_CONSERVATIVE_RASTERIZATION_CNTL;
 typedef union PA_SC_DSM_CNTL                                     regPA_SC_DSM_CNTL;
 typedef union PA_SC_EDGERULE                                     regPA_SC_EDGERULE;
 typedef union PA_SC_ENHANCE                                      regPA_SC_ENHANCE;
 typedef union PA_SC_ENHANCE_1                                    regPA_SC_ENHANCE_1;
 typedef union PA_SC_ENHANCE_2                                    regPA_SC_ENHANCE_2;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union PA_SC_ENHANCE_3                                    regPA_SC_ENHANCE_3;
 #endif
 typedef union PA_SC_ENHANCE_INTERNAL                             regPA_SC_ENHANCE_INTERNAL;
 typedef union PA_SC_FIFO_DEPTH_CNTL                              regPA_SC_FIFO_DEPTH_CNTL;
 typedef union PA_SC_FIFO_SIZE                                    regPA_SC_FIFO_SIZE;
 typedef union PA_SC_FORCE_EOV_MAX_CNTS                           regPA_SC_FORCE_EOV_MAX_CNTS;
 typedef union PA_SC_GENERIC_SCISSOR_BR                           regPA_SC_GENERIC_SCISSOR_BR;
 typedef union PA_SC_GENERIC_SCISSOR_TL                           regPA_SC_GENERIC_SCISSOR_TL;
 typedef union PA_SC_HP3D_TRAP_SCREEN_COUNT                       regPA_SC_HP3D_TRAP_SCREEN_COUNT;
 typedef union PA_SC_HP3D_TRAP_SCREEN_H                           regPA_SC_HP3D_TRAP_SCREEN_H;
@@ -1126,20 +1193,23 @@ typedef union PA_SC_LINE_STIPPLE                                 regPA_SC_LINE_S
 typedef union PA_SC_LINE_STIPPLE_STATE                           regPA_SC_LINE_STIPPLE_STATE;
 typedef union PA_SC_MODE_CNTL_0                                  regPA_SC_MODE_CNTL_0;
 typedef union PA_SC_MODE_CNTL_1                                  regPA_SC_MODE_CNTL_1;
 typedef union PA_SC_NGG_MODE_CNTL                                regPA_SC_NGG_MODE_CNTL;
 typedef union PA_SC_P3D_TRAP_SCREEN_COUNT                        regPA_SC_P3D_TRAP_SCREEN_COUNT;
 typedef union PA_SC_P3D_TRAP_SCREEN_H                            regPA_SC_P3D_TRAP_SCREEN_H;
 typedef union PA_SC_P3D_TRAP_SCREEN_HV_EN                        regPA_SC_P3D_TRAP_SCREEN_HV_EN;
 typedef union PA_SC_P3D_TRAP_SCREEN_HV_LOCK                      regPA_SC_P3D_TRAP_SCREEN_HV_LOCK;
 typedef union PA_SC_P3D_TRAP_SCREEN_OCCURRENCE                   regPA_SC_P3D_TRAP_SCREEN_OCCURRENCE;
 typedef union PA_SC_P3D_TRAP_SCREEN_V                            regPA_SC_P3D_TRAP_SCREEN_V;
+#if CHIP_HDR_NAVI31
+typedef union PA_SC_PACKER_WAVE_ID_CNTL                          regPA_SC_PACKER_WAVE_ID_CNTL;
+#endif
 typedef union PA_SC_PBB_OVERRIDE_FLAG                            regPA_SC_PBB_OVERRIDE_FLAG;
 typedef union PA_SC_PERFCOUNTER0_HI                              regPA_SC_PERFCOUNTER0_HI;
 typedef union PA_SC_PERFCOUNTER0_LO                              regPA_SC_PERFCOUNTER0_LO;
 typedef union PA_SC_PERFCOUNTER0_SELECT                          regPA_SC_PERFCOUNTER0_SELECT;
 typedef union PA_SC_PERFCOUNTER0_SELECT1                         regPA_SC_PERFCOUNTER0_SELECT1;
 typedef union PA_SC_PERFCOUNTER1_HI                              regPA_SC_PERFCOUNTER1_HI;
 typedef union PA_SC_PERFCOUNTER1_LO                              regPA_SC_PERFCOUNTER1_LO;
 typedef union PA_SC_PERFCOUNTER1_SELECT                          regPA_SC_PERFCOUNTER1_SELECT;
 typedef union PA_SC_PERFCOUNTER2_HI                              regPA_SC_PERFCOUNTER2_HI;
 typedef union PA_SC_PERFCOUNTER2_LO                              regPA_SC_PERFCOUNTER2_LO;
@@ -1230,20 +1300,32 @@ typedef union PA_SC_VPORT_ZMIN_5                                 regPA_SC_VPORT_
 typedef union PA_SC_VPORT_ZMIN_6                                 regPA_SC_VPORT_ZMIN_6;
 typedef union PA_SC_VPORT_ZMIN_7                                 regPA_SC_VPORT_ZMIN_7;
 typedef union PA_SC_VPORT_ZMIN_8                                 regPA_SC_VPORT_ZMIN_8;
 typedef union PA_SC_VPORT_ZMIN_9                                 regPA_SC_VPORT_ZMIN_9;
 typedef union PA_SC_VPORT_ZMIN_10                                regPA_SC_VPORT_ZMIN_10;
 typedef union PA_SC_VPORT_ZMIN_11                                regPA_SC_VPORT_ZMIN_11;
 typedef union PA_SC_VPORT_ZMIN_12                                regPA_SC_VPORT_ZMIN_12;
 typedef union PA_SC_VPORT_ZMIN_13                                regPA_SC_VPORT_ZMIN_13;
 typedef union PA_SC_VPORT_ZMIN_14                                regPA_SC_VPORT_ZMIN_14;
 typedef union PA_SC_VPORT_ZMIN_15                                regPA_SC_VPORT_ZMIN_15;
+#if CHIP_HDR_NAVI31
+typedef union PA_SC_VRS_OVERRIDE_CNTL                            regPA_SC_VRS_OVERRIDE_CNTL;
+typedef union PA_SC_VRS_RATE_BASE                                regPA_SC_VRS_RATE_BASE;
+typedef union PA_SC_VRS_RATE_BASE_EXT                            regPA_SC_VRS_RATE_BASE_EXT;
+typedef union PA_SC_VRS_RATE_CACHE_CNTL                          regPA_SC_VRS_RATE_CACHE_CNTL;
+typedef union PA_SC_VRS_RATE_FEEDBACK_BASE                       regPA_SC_VRS_RATE_FEEDBACK_BASE;
+typedef union PA_SC_VRS_RATE_FEEDBACK_BASE_EXT                   regPA_SC_VRS_RATE_FEEDBACK_BASE_EXT;
+typedef union PA_SC_VRS_RATE_FEEDBACK_SIZE_XY                    regPA_SC_VRS_RATE_FEEDBACK_SIZE_XY;
+typedef union PA_SC_VRS_RATE_SIZE_XY                             regPA_SC_VRS_RATE_SIZE_XY;
+typedef union PA_SC_VRS_SURFACE_CNTL                             regPA_SC_VRS_SURFACE_CNTL;
+typedef union PA_SC_VRS_SURFACE_CNTL_1                           regPA_SC_VRS_SURFACE_CNTL_1;
+#endif
 typedef union PA_SC_WINDOW_OFFSET                                regPA_SC_WINDOW_OFFSET;
 typedef union PA_SC_WINDOW_SCISSOR_BR                            regPA_SC_WINDOW_SCISSOR_BR;
 typedef union PA_SC_WINDOW_SCISSOR_TL                            regPA_SC_WINDOW_SCISSOR_TL;
 typedef union PA_SIDEBAND_REQUEST_DELAYS                         regPA_SIDEBAND_REQUEST_DELAYS;
 typedef union PA_STATE_STEREO_X                                  regPA_STATE_STEREO_X;
 typedef union PA_STEREO_CNTL                                     regPA_STEREO_CNTL;
 typedef union PA_SU_CNTL_STATUS                                  regPA_SU_CNTL_STATUS;
 typedef union PA_SU_HARDWARE_SCREEN_OFFSET                       regPA_SU_HARDWARE_SCREEN_OFFSET;
 typedef union PA_SU_LINE_CNTL                                    regPA_SU_LINE_CNTL;
 typedef union PA_SU_LINE_STIPPLE_CNTL                            regPA_SU_LINE_STIPPLE_CNTL;
@@ -1278,123 +1360,182 @@ typedef union PA_SU_PRIM_FILTER_CNTL                             regPA_SU_PRIM_F
 typedef union PA_SU_SC_MODE_CNTL                                 regPA_SU_SC_MODE_CNTL;
 typedef union PA_SU_SMALL_PRIM_FILTER_CNTL                       regPA_SU_SMALL_PRIM_FILTER_CNTL;
 typedef union PA_SU_VTX_CNTL                                     regPA_SU_VTX_CNTL;
 typedef union PA_UTCL1_CNTL1                                     regPA_UTCL1_CNTL1;
 typedef union PA_UTCL1_CNTL2                                     regPA_UTCL1_CNTL2;
 typedef union PerfMonCtl1                                        regPerfMonCtl1;
 typedef union PerfMonCtl2                                        regPerfMonCtl2;
 typedef union PerfMonCtl3                                        regPerfMonCtl3;
 typedef union PerfMonCtl4                                        regPerfMonCtl4;
 typedef union PerfMonCtl5                                        regPerfMonCtl5;
+#if CHIP_HDR_NAVI31
+typedef union PerfMonCtl6                                        regPerfMonCtl6;
+typedef union PerfMonCtl7                                        regPerfMonCtl7;
+typedef union PerfMonCtl8                                        regPerfMonCtl8;
+typedef union PerfMonCtl9                                        regPerfMonCtl9;
+typedef union PerfMonCtl10                                       regPerfMonCtl10;
+typedef union PerfMonCtl11                                       regPerfMonCtl11;
+typedef union PerfMonCtl12                                       regPerfMonCtl12;
+#endif
 typedef union PerfMonCtlClk                                      regPerfMonCtlClk;
 typedef union PerfMonCtr1_Hi                                     regPerfMonCtr1_Hi;
 typedef union PerfMonCtr1_Lo                                     regPerfMonCtr1_Lo;
 typedef union PerfMonCtr2_Hi                                     regPerfMonCtr2_Hi;
 typedef union PerfMonCtr2_Lo                                     regPerfMonCtr2_Lo;
 typedef union PerfMonCtr3_Hi                                     regPerfMonCtr3_Hi;
 typedef union PerfMonCtr3_Lo                                     regPerfMonCtr3_Lo;
 typedef union PerfMonCtr4_Hi                                     regPerfMonCtr4_Hi;
 typedef union PerfMonCtr4_Lo                                     regPerfMonCtr4_Lo;
 typedef union PerfMonCtr5_Hi                                     regPerfMonCtr5_Hi;
 typedef union PerfMonCtr5_Lo                                     regPerfMonCtr5_Lo;
+#if CHIP_HDR_NAVI31
+typedef union PerfMonCtr6_Hi                                     regPerfMonCtr6_Hi;
+typedef union PerfMonCtr6_Lo                                     regPerfMonCtr6_Lo;
+typedef union PerfMonCtr7_Hi                                     regPerfMonCtr7_Hi;
+typedef union PerfMonCtr7_Lo                                     regPerfMonCtr7_Lo;
+typedef union PerfMonCtr8_Hi                                     regPerfMonCtr8_Hi;
+typedef union PerfMonCtr8_Lo                                     regPerfMonCtr8_Lo;
+typedef union PerfMonCtr9_Hi                                     regPerfMonCtr9_Hi;
+typedef union PerfMonCtr9_Lo                                     regPerfMonCtr9_Lo;
+typedef union PerfMonCtr10_Hi                                    regPerfMonCtr10_Hi;
+typedef union PerfMonCtr10_Lo                                    regPerfMonCtr10_Lo;
+typedef union PerfMonCtr11_Hi                                    regPerfMonCtr11_Hi;
+typedef union PerfMonCtr11_Lo                                    regPerfMonCtr11_Lo;
+typedef union PerfMonCtr12_Hi                                    regPerfMonCtr12_Hi;
+typedef union PerfMonCtr12_Lo                                    regPerfMonCtr12_Lo;
+#endif
 typedef union PerfMonCtrClk_Hi                                   regPerfMonCtrClk_Hi;
 typedef union PerfMonCtrClk_Lo                                   regPerfMonCtrClk_Lo;
 typedef union RLC_CGTT_MGCG_OVERRIDE                             regRLC_CGTT_MGCG_OVERRIDE;
 typedef union RLC_PERFCOUNTER0_HI                                regRLC_PERFCOUNTER0_HI;
 typedef union RLC_PERFCOUNTER0_LO                                regRLC_PERFCOUNTER0_LO;
 typedef union RLC_PERFCOUNTER0_SELECT                            regRLC_PERFCOUNTER0_SELECT;
 typedef union RLC_PERFCOUNTER1_HI                                regRLC_PERFCOUNTER1_HI;
 typedef union RLC_PERFCOUNTER1_LO                                regRLC_PERFCOUNTER1_LO;
 typedef union RLC_PERFCOUNTER1_SELECT                            regRLC_PERFCOUNTER1_SELECT;
 typedef union RLC_PERFMON_CLK_CNTL                               regRLC_PERFMON_CLK_CNTL;
 typedef union RLC_PERFMON_CNTL                                   regRLC_PERFMON_CNTL;
 typedef union RLC_SPM_ACCUM_CTRL                                 regRLC_SPM_ACCUM_CTRL;
 typedef union RLC_SPM_ACCUM_CTRLRAM_ADDR                         regRLC_SPM_ACCUM_CTRLRAM_ADDR;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union RLC_SPM_ACCUM_CTRLRAM_ADDR_OFFSET                  regRLC_SPM_ACCUM_CTRLRAM_ADDR_OFFSET;
 #endif
 typedef union RLC_SPM_ACCUM_CTRLRAM_DATA                         regRLC_SPM_ACCUM_CTRLRAM_DATA;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union RLC_SPM_ACCUM_DATARAM_32BITCNTRS_REGIONS           regRLC_SPM_ACCUM_DATARAM_32BITCNTRS_REGIONS;
 #endif
 typedef union RLC_SPM_ACCUM_DATARAM_ADDR                         regRLC_SPM_ACCUM_DATARAM_ADDR;
 typedef union RLC_SPM_ACCUM_DATARAM_DATA                         regRLC_SPM_ACCUM_DATARAM_DATA;
 typedef union RLC_SPM_ACCUM_DATARAM_WRCOUNT                      regRLC_SPM_ACCUM_DATARAM_WRCOUNT;
 typedef union RLC_SPM_ACCUM_MODE                                 regRLC_SPM_ACCUM_MODE;
 typedef union RLC_SPM_ACCUM_SAMPLES_REQUESTED                    regRLC_SPM_ACCUM_SAMPLES_REQUESTED;
 typedef union RLC_SPM_ACCUM_STATUS                               regRLC_SPM_ACCUM_STATUS;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union RLC_SPM_ACCUM_SWA_DATARAM_ADDR                     regRLC_SPM_ACCUM_SWA_DATARAM_ADDR;
 typedef union RLC_SPM_ACCUM_SWA_DATARAM_DATA                     regRLC_SPM_ACCUM_SWA_DATARAM_DATA;
 #endif
 typedef union RLC_SPM_ACCUM_THRESHOLD                            regRLC_SPM_ACCUM_THRESHOLD;
 typedef union RLC_SPM_CBR0_PERFMON_SAMPLE_DELAY                  regRLC_SPM_CBR0_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_CBR1_PERFMON_SAMPLE_DELAY                  regRLC_SPM_CBR1_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_CB_PERFMON_SAMPLE_DELAY                    regRLC_SPM_CB_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_CPC_PERFMON_SAMPLE_DELAY                   regRLC_SPM_CPC_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_CPF_PERFMON_SAMPLE_DELAY                   regRLC_SPM_CPF_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_CPG_PERFMON_SAMPLE_DELAY                   regRLC_SPM_CPG_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_DBR0_PERFMON_SAMPLE_DELAY                  regRLC_SPM_DBR0_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_DBR1_PERFMON_SAMPLE_DELAY                  regRLC_SPM_DBR1_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_DB_PERFMON_SAMPLE_DELAY                    regRLC_SPM_DB_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_DESER_START_SKEW                           regRLC_SPM_DESER_START_SKEW;
 typedef union RLC_SPM_GDS_PERFMON_SAMPLE_DELAY                   regRLC_SPM_GDS_PERFMON_SAMPLE_DELAY;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union RLC_SPM_GFXCLOCK_HIGHCOUNT                         regRLC_SPM_GFXCLOCK_HIGHCOUNT;
 typedef union RLC_SPM_GFXCLOCK_LOWCOUNT                          regRLC_SPM_GFXCLOCK_LOWCOUNT;
 #endif
 typedef union RLC_SPM_GLB_SAMPLEDELAY_IND_ADDR                   regRLC_SPM_GLB_SAMPLEDELAY_IND_ADDR;
 typedef union RLC_SPM_GLB_SAMPLEDELAY_IND_DATA                   regRLC_SPM_GLB_SAMPLEDELAY_IND_DATA;
 typedef union RLC_SPM_GLOBALS_MUXSEL_SKEW                        regRLC_SPM_GLOBALS_MUXSEL_SKEW;
 typedef union RLC_SPM_GLOBALS_SAMPLE_SKEW                        regRLC_SPM_GLOBALS_SAMPLE_SKEW;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_GLOBAL_DELAY_IND_ADDR                      regRLC_SPM_GLOBAL_DELAY_IND_ADDR;
+typedef union RLC_SPM_GLOBAL_DELAY_IND_DATA                      regRLC_SPM_GLOBAL_DELAY_IND_DATA;
+#endif
 typedef union RLC_SPM_GLOBAL_MUXSEL_ADDR                         regRLC_SPM_GLOBAL_MUXSEL_ADDR;
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef union RLC_SPM_GLOBAL_MUXSEL_ADDR_OFFSET                  regRLC_SPM_GLOBAL_MUXSEL_ADDR_OFFSET;
 #endif
 typedef union RLC_SPM_GLOBAL_MUXSEL_DATA                         regRLC_SPM_GLOBAL_MUXSEL_DATA;
 typedef union RLC_SPM_IA_PERFMON_SAMPLE_DELAY                    regRLC_SPM_IA_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_INT_CNTL                                   regRLC_SPM_INT_CNTL;
 typedef union RLC_SPM_INT_INFO_1                                 regRLC_SPM_INT_INFO_1;
 typedef union RLC_SPM_INT_INFO_2                                 regRLC_SPM_INT_INFO_2;
 typedef union RLC_SPM_INT_STATUS                                 regRLC_SPM_INT_STATUS;
 typedef union RLC_SPM_MC_CNTL                                    regRLC_SPM_MC_CNTL;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_MODE                                       regRLC_SPM_MODE;
+typedef union RLC_SPM_PAUSE                                      regRLC_SPM_PAUSE;
+#endif
 typedef union RLC_SPM_PA_PERFMON_SAMPLE_DELAY                    regRLC_SPM_PA_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_PERFMON_CNTL                               regRLC_SPM_PERFMON_CNTL;
 typedef union RLC_SPM_PERFMON_GLB_SEGMENT_SIZE                   regRLC_SPM_PERFMON_GLB_SEGMENT_SIZE;
 typedef union RLC_SPM_PERFMON_RING_BASE_HI                       regRLC_SPM_PERFMON_RING_BASE_HI;
 typedef union RLC_SPM_PERFMON_RING_BASE_LO                       regRLC_SPM_PERFMON_RING_BASE_LO;
 typedef union RLC_SPM_PERFMON_RING_SIZE                          regRLC_SPM_PERFMON_RING_SIZE;
 typedef union RLC_SPM_PERFMON_SAMPLE_DELAY_MAX                   regRLC_SPM_PERFMON_SAMPLE_DELAY_MAX;
 typedef union RLC_SPM_PERFMON_SE3TO0_SEGMENT_SIZE                regRLC_SPM_PERFMON_SE3TO0_SEGMENT_SIZE;
 typedef union RLC_SPM_PERFMON_SEGMENT_SIZE                       regRLC_SPM_PERFMON_SEGMENT_SIZE;
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef union RLC_SPM_PERFMON_SWA_GLB_SEGMENT_SIZE               regRLC_SPM_PERFMON_SWA_GLB_SEGMENT_SIZE;
 typedef union RLC_SPM_PERFMON_SWA_SE3TO0_SEGMENT_SIZE            regRLC_SPM_PERFMON_SWA_SE3TO0_SEGMENT_SIZE;
 typedef union RLC_SPM_PERFMON_SWA_SEGMENT_SIZE                   regRLC_SPM_PERFMON_SWA_SEGMENT_SIZE;
 #endif
 typedef union RLC_SPM_RING_RDPTR                                 regRLC_SPM_RING_RDPTR;
 typedef union RLC_SPM_RING_WRPTR                                 regRLC_SPM_RING_WRPTR;
 typedef union RLC_SPM_RMI_PERFMON_SAMPLE_DELAY                   regRLC_SPM_RMI_PERFMON_SAMPLE_DELAY;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_RSPM_CMD                                   regRLC_SPM_RSPM_CMD;
+typedef union RLC_SPM_RSPM_CMD_ACK                               regRLC_SPM_RSPM_CMD_ACK;
+typedef union RLC_SPM_RSPM_REQ_DATA_HI                           regRLC_SPM_RSPM_REQ_DATA_HI;
+typedef union RLC_SPM_RSPM_REQ_DATA_LO                           regRLC_SPM_RSPM_REQ_DATA_LO;
+typedef union RLC_SPM_RSPM_REQ_OP                                regRLC_SPM_RSPM_REQ_OP;
+typedef union RLC_SPM_RSPM_RET_DATA                              regRLC_SPM_RSPM_RET_DATA;
+typedef union RLC_SPM_RSPM_RET_OP                                regRLC_SPM_RSPM_RET_OP;
+#endif
 typedef union RLC_SPM_SAMPLE_CNT                                 regRLC_SPM_SAMPLE_CNT;
 typedef union RLC_SPM_SC_PERFMON_SAMPLE_DELAY                    regRLC_SPM_SC_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_SEGMENT_THRESHOLD                          regRLC_SPM_SEGMENT_THRESHOLD;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_SE_DELAY_IND_ADDR                          regRLC_SPM_SE_DELAY_IND_ADDR;
+typedef union RLC_SPM_SE_DELAY_IND_DATA                          regRLC_SPM_SE_DELAY_IND_DATA;
+#endif
 typedef union RLC_SPM_SE_MUXSEL_ADDR                             regRLC_SPM_SE_MUXSEL_ADDR;
 #if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef union RLC_SPM_SE_MUXSEL_ADDR_OFFSET                      regRLC_SPM_SE_MUXSEL_ADDR_OFFSET;
 #endif
 typedef union RLC_SPM_SE_MUXSEL_DATA                             regRLC_SPM_SE_MUXSEL_DATA;
 typedef union RLC_SPM_SE_MUXSEL_SKEW                             regRLC_SPM_SE_MUXSEL_SKEW;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_SE_RSPM_REQ_DATA_HI                        regRLC_SPM_SE_RSPM_REQ_DATA_HI;
+typedef union RLC_SPM_SE_RSPM_REQ_DATA_LO                        regRLC_SPM_SE_RSPM_REQ_DATA_LO;
+typedef union RLC_SPM_SE_RSPM_REQ_OP                             regRLC_SPM_SE_RSPM_REQ_OP;
+typedef union RLC_SPM_SE_RSPM_RET_DATA                           regRLC_SPM_SE_RSPM_RET_DATA;
+typedef union RLC_SPM_SE_RSPM_RET_OP                             regRLC_SPM_SE_RSPM_RET_OP;
+#endif
 typedef union RLC_SPM_SE_SAMPLEDELAY_IND_ADDR                    regRLC_SPM_SE_SAMPLEDELAY_IND_ADDR;
 typedef union RLC_SPM_SE_SAMPLEDELAY_IND_DATA                    regRLC_SPM_SE_SAMPLEDELAY_IND_DATA;
 typedef union RLC_SPM_SE_SAMPLE_SKEW                             regRLC_SPM_SE_SAMPLE_SKEW;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_SPARE                                      regRLC_SPM_SPARE;
+#endif
 typedef union RLC_SPM_SPI_PERFMON_SAMPLE_DELAY                   regRLC_SPM_SPI_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_SQG_PERFMON_SAMPLE_DELAY                   regRLC_SPM_SQG_PERFMON_SAMPLE_DELAY;
+#if CHIP_HDR_NAVI31
+typedef union RLC_SPM_STATUS                                     regRLC_SPM_STATUS;
+#endif
 typedef union RLC_SPM_SX_PERFMON_SAMPLE_DELAY                    regRLC_SPM_SX_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_TA_PERFMON_SAMPLE_DELAY                    regRLC_SPM_TA_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_TCA_PERFMON_SAMPLE_DELAY                   regRLC_SPM_TCA_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_TCC_PERFMON_SAMPLE_DELAY                   regRLC_SPM_TCC_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_TCP_PERFMON_SAMPLE_DELAY                   regRLC_SPM_TCP_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_TD_PERFMON_SAMPLE_DELAY                    regRLC_SPM_TD_PERFMON_SAMPLE_DELAY;
 typedef union RLC_SPM_THREAD_TRACE_CTRL                          regRLC_SPM_THREAD_TRACE_CTRL;
 typedef union RLC_SPM_UTCL1_CNTL                                 regRLC_SPM_UTCL1_CNTL;
 typedef union RLC_SPM_UTCL1_ERROR_1                              regRLC_SPM_UTCL1_ERROR_1;
 typedef union RLC_SPM_UTCL1_ERROR_2                              regRLC_SPM_UTCL1_ERROR_2;
@@ -1417,41 +1558,41 @@ typedef union RMI_PERFCOUNTER3_LO                                regRMI_PERFCOUN
 typedef union RMI_PERFCOUNTER3_SELECT                            regRMI_PERFCOUNTER3_SELECT;
 typedef union RMI_PERF_COUNTER_CNTL                              regRMI_PERF_COUNTER_CNTL;
 typedef union RPB_PERFCOUNTER0_CFG                               regRPB_PERFCOUNTER0_CFG;
 typedef union RPB_PERFCOUNTER1_CFG                               regRPB_PERFCOUNTER1_CFG;
 typedef union RPB_PERFCOUNTER2_CFG                               regRPB_PERFCOUNTER2_CFG;
 typedef union RPB_PERFCOUNTER3_CFG                               regRPB_PERFCOUNTER3_CFG;
 typedef union RPB_PERFCOUNTER_HI                                 regRPB_PERFCOUNTER_HI;
 typedef union RPB_PERFCOUNTER_LO                                 regRPB_PERFCOUNTER_LO;
 typedef union RPB_PERFCOUNTER_RSLT_CNTL                          regRPB_PERFCOUNTER_RSLT_CNTL;
 typedef union RPB_PERF_COUNTER_CNTL                              regRPB_PERF_COUNTER_CNTL;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SDMA0_PERFCNT_MISC_CNTL                            regSDMA0_PERFCNT_MISC_CNTL;
 typedef union SDMA0_PERFCNT_PERFCOUNTER0_CFG                     regSDMA0_PERFCNT_PERFCOUNTER0_CFG;
 typedef union SDMA0_PERFCNT_PERFCOUNTER1_CFG                     regSDMA0_PERFCNT_PERFCOUNTER1_CFG;
 typedef union SDMA0_PERFCNT_PERFCOUNTER_HI                       regSDMA0_PERFCNT_PERFCOUNTER_HI;
 typedef union SDMA0_PERFCNT_PERFCOUNTER_LO                       regSDMA0_PERFCNT_PERFCOUNTER_LO;
 typedef union SDMA0_PERFCNT_PERFCOUNTER_RSLT_CNTL                regSDMA0_PERFCNT_PERFCOUNTER_RSLT_CNTL;
 #endif
 typedef union SDMA0_PERFCOUNTER0_HI                              regSDMA0_PERFCOUNTER0_HI;
 typedef union SDMA0_PERFCOUNTER0_LO                              regSDMA0_PERFCOUNTER0_LO;
 typedef union SDMA0_PERFCOUNTER0_RESULT                          regSDMA0_PERFCOUNTER0_RESULT;
 typedef union SDMA0_PERFCOUNTER0_SELECT                          regSDMA0_PERFCOUNTER0_SELECT;
 typedef union SDMA0_PERFCOUNTER0_SELECT1                         regSDMA0_PERFCOUNTER0_SELECT1;
 typedef union SDMA0_PERFCOUNTER1_HI                              regSDMA0_PERFCOUNTER1_HI;
 typedef union SDMA0_PERFCOUNTER1_LO                              regSDMA0_PERFCOUNTER1_LO;
 typedef union SDMA0_PERFCOUNTER1_RESULT                          regSDMA0_PERFCOUNTER1_RESULT;
 typedef union SDMA0_PERFCOUNTER1_SELECT                          regSDMA0_PERFCOUNTER1_SELECT;
 typedef union SDMA0_PERFCOUNTER1_SELECT1                         regSDMA0_PERFCOUNTER1_SELECT1;
 typedef union SDMA0_PERFCOUNTER_TAG_DELAY_RANGE                  regSDMA0_PERFCOUNTER_TAG_DELAY_RANGE;
 typedef union SDMA0_PERFMON_CNTL                                 regSDMA0_PERFMON_CNTL;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI31
 typedef union SDMA1_PERFCNT_MISC_CNTL                            regSDMA1_PERFCNT_MISC_CNTL;
 typedef union SDMA1_PERFCNT_PERFCOUNTER0_CFG                     regSDMA1_PERFCNT_PERFCOUNTER0_CFG;
 typedef union SDMA1_PERFCNT_PERFCOUNTER1_CFG                     regSDMA1_PERFCNT_PERFCOUNTER1_CFG;
 typedef union SDMA1_PERFCNT_PERFCOUNTER_HI                       regSDMA1_PERFCNT_PERFCOUNTER_HI;
 typedef union SDMA1_PERFCNT_PERFCOUNTER_LO                       regSDMA1_PERFCNT_PERFCOUNTER_LO;
 typedef union SDMA1_PERFCNT_PERFCOUNTER_RSLT_CNTL                regSDMA1_PERFCNT_PERFCOUNTER_RSLT_CNTL;
 #endif
 typedef union SDMA1_PERFCOUNTER0_HI                              regSDMA1_PERFCOUNTER0_HI;
 typedef union SDMA1_PERFCOUNTER0_LO                              regSDMA1_PERFCOUNTER0_LO;
 typedef union SDMA1_PERFCOUNTER0_RESULT                          regSDMA1_PERFCOUNTER0_RESULT;
@@ -1491,72 +1632,88 @@ typedef union SDMA3_PERFCOUNTER0_SELECT                          regSDMA3_PERFCO
 typedef union SDMA3_PERFCOUNTER0_SELECT1                         regSDMA3_PERFCOUNTER0_SELECT1;
 typedef union SDMA3_PERFCOUNTER1_HI                              regSDMA3_PERFCOUNTER1_HI;
 typedef union SDMA3_PERFCOUNTER1_LO                              regSDMA3_PERFCOUNTER1_LO;
 typedef union SDMA3_PERFCOUNTER1_SELECT                          regSDMA3_PERFCOUNTER1_SELECT;
 typedef union SDMA3_PERFCOUNTER1_SELECT1                         regSDMA3_PERFCOUNTER1_SELECT1;
 #endif
 typedef union SPI_ARB_CNTL_0                                     regSPI_ARB_CNTL_0;
 typedef union SPI_ARB_CYCLES_0                                   regSPI_ARB_CYCLES_0;
 typedef union SPI_ARB_CYCLES_1                                   regSPI_ARB_CYCLES_1;
 typedef union SPI_ARB_PRIORITY                                   regSPI_ARB_PRIORITY;
+#if CHIP_HDR_NAVI31
+typedef union SPI_ATTRIBUTE_RING_BASE                            regSPI_ATTRIBUTE_RING_BASE;
+typedef union SPI_ATTRIBUTE_RING_SIZE                            regSPI_ATTRIBUTE_RING_SIZE;
+#endif
 typedef union SPI_BARYC_CNTL                                     regSPI_BARYC_CNTL;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_BARYC_SSAA_CNTL                                regSPI_BARYC_SSAA_CNTL;
 #endif
 typedef union SPI_COMPUTE_QUEUE_RESET                            regSPI_COMPUTE_QUEUE_RESET;
 typedef union SPI_COMPUTE_WF_CTX_SAVE                            regSPI_COMPUTE_WF_CTX_SAVE;
+#if CHIP_HDR_NAVI31
+typedef union SPI_COMPUTE_WF_CTX_SAVE_STATUS                     regSPI_COMPUTE_WF_CTX_SAVE_STATUS;
+#endif
 typedef union SPI_CONFIG_CNTL                                    regSPI_CONFIG_CNTL;
 typedef union SPI_CONFIG_CNTL_1                                  regSPI_CONFIG_CNTL_1;
 typedef union SPI_CONFIG_CNTL_1_REMAP                            regSPI_CONFIG_CNTL_1_REMAP;
 typedef union SPI_CONFIG_CNTL_2                                  regSPI_CONFIG_CNTL_2;
 typedef union SPI_CONFIG_CNTL_2_REMAP                            regSPI_CONFIG_CNTL_2_REMAP;
 typedef union SPI_CONFIG_CNTL_REMAP                              regSPI_CONFIG_CNTL_REMAP;
 typedef union SPI_CONFIG_PS_CU_EN                                regSPI_CONFIG_PS_CU_EN;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_CSG_PIPE_CONTROL                               regSPI_CSG_PIPE_CONTROL;
 #endif
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_0                          regSPI_CSQ_WF_ACTIVE_COUNT_0;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_1                          regSPI_CSQ_WF_ACTIVE_COUNT_1;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_2                          regSPI_CSQ_WF_ACTIVE_COUNT_2;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_3                          regSPI_CSQ_WF_ACTIVE_COUNT_3;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_4                          regSPI_CSQ_WF_ACTIVE_COUNT_4;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_5                          regSPI_CSQ_WF_ACTIVE_COUNT_5;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_6                          regSPI_CSQ_WF_ACTIVE_COUNT_6;
 typedef union SPI_CSQ_WF_ACTIVE_COUNT_7                          regSPI_CSQ_WF_ACTIVE_COUNT_7;
 typedef union SPI_CSQ_WF_ACTIVE_STATUS                           regSPI_CSQ_WF_ACTIVE_STATUS;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_CS_CRAWLER_CONFIG                              regSPI_CS_CRAWLER_CONFIG;
 #endif
 typedef union SPI_DSM_CNTL                                       regSPI_DSM_CNTL;
 typedef union SPI_DSM_CNTL2                                      regSPI_DSM_CNTL2;
 typedef union SPI_EDC_CNT                                        regSPI_EDC_CNT;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_EXP_THROTTLE_CTRL                              regSPI_EXP_THROTTLE_CTRL;
 #endif
 typedef union SPI_FEATURE_CTRL                                   regSPI_FEATURE_CTRL;
 typedef union SPI_GDS_CREDITS                                    regSPI_GDS_CREDITS;
 typedef union SPI_GFX_CNTL                                       regSPI_GFX_CNTL;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_GFX_CRAWLER_CONFIG                             regSPI_GFX_CRAWLER_CONFIG;
 #endif
+#if CHIP_HDR_NAVI31
+typedef union SPI_GFX_SCRATCH_BASE_HI                            regSPI_GFX_SCRATCH_BASE_HI;
+typedef union SPI_GFX_SCRATCH_BASE_LO                            regSPI_GFX_SCRATCH_BASE_LO;
+typedef union SPI_GS_THROTTLE_CNTL1                              regSPI_GS_THROTTLE_CNTL1;
+typedef union SPI_GS_THROTTLE_CNTL2                              regSPI_GS_THROTTLE_CNTL2;
+#endif
 #if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
 typedef union SPI_IND_DATA                                       regSPI_IND_DATA;
 typedef union SPI_IND_INDEX                                      regSPI_IND_INDEX;
 #endif
 typedef union SPI_INTERP_CONTROL_0                               regSPI_INTERP_CONTROL_0;
 typedef union SPI_LB_CTR_CTRL                                    regSPI_LB_CTR_CTRL;
 typedef union SPI_LB_CU_MASK                                     regSPI_LB_CU_MASK;
 typedef union SPI_LB_DATA_PERCU_WAVE_CS                          regSPI_LB_DATA_PERCU_WAVE_CS;
 typedef union SPI_LB_DATA_PERCU_WAVE_HSGS                        regSPI_LB_DATA_PERCU_WAVE_HSGS;
 typedef union SPI_LB_DATA_PERCU_WAVE_VSPS                        regSPI_LB_DATA_PERCU_WAVE_VSPS;
 typedef union SPI_LB_DATA_PERWGP_WAVE_CS                         regSPI_LB_DATA_PERWGP_WAVE_CS;
 typedef union SPI_LB_DATA_PERWGP_WAVE_HSGS                       regSPI_LB_DATA_PERWGP_WAVE_HSGS;
+#if CHIP_HDR_NAVI31
+typedef union SPI_LB_DATA_PERWGP_WAVE_PS                         regSPI_LB_DATA_PERWGP_WAVE_PS;
+#endif
 typedef union SPI_LB_DATA_PERWGP_WAVE_VSPS                       regSPI_LB_DATA_PERWGP_WAVE_VSPS;
 typedef union SPI_LB_DATA_REG                                    regSPI_LB_DATA_REG;
 typedef union SPI_LB_DATA_WAVES                                  regSPI_LB_DATA_WAVES;
 typedef union SPI_LB_WGP_MASK                                    regSPI_LB_WGP_MASK;
 typedef union SPI_P0_TRAP_SCREEN_GPR_MIN                         regSPI_P0_TRAP_SCREEN_GPR_MIN;
 typedef union SPI_P0_TRAP_SCREEN_PSBA_HI                         regSPI_P0_TRAP_SCREEN_PSBA_HI;
 typedef union SPI_P0_TRAP_SCREEN_PSBA_LO                         regSPI_P0_TRAP_SCREEN_PSBA_LO;
 typedef union SPI_P0_TRAP_SCREEN_PSMA_HI                         regSPI_P0_TRAP_SCREEN_PSMA_HI;
 typedef union SPI_P0_TRAP_SCREEN_PSMA_LO                         regSPI_P0_TRAP_SCREEN_PSMA_LO;
 typedef union SPI_P1_TRAP_SCREEN_GPR_MIN                         regSPI_P1_TRAP_SCREEN_GPR_MIN;
@@ -1652,20 +1809,24 @@ typedef union SPI_RESOURCE_RESERVE_EN_CU_6                       regSPI_RESOURCE
 typedef union SPI_RESOURCE_RESERVE_EN_CU_7                       regSPI_RESOURCE_RESERVE_EN_CU_7;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_8                       regSPI_RESOURCE_RESERVE_EN_CU_8;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_9                       regSPI_RESOURCE_RESERVE_EN_CU_9;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_10                      regSPI_RESOURCE_RESERVE_EN_CU_10;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_11                      regSPI_RESOURCE_RESERVE_EN_CU_11;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_12                      regSPI_RESOURCE_RESERVE_EN_CU_12;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_13                      regSPI_RESOURCE_RESERVE_EN_CU_13;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_14                      regSPI_RESOURCE_RESERVE_EN_CU_14;
 typedef union SPI_RESOURCE_RESERVE_EN_CU_15                      regSPI_RESOURCE_RESERVE_EN_CU_15;
 typedef union SPI_SHADER_COL_FORMAT                              regSPI_SHADER_COL_FORMAT;
+#if CHIP_HDR_NAVI31
+typedef union SPI_SHADER_GS_MESHLET_DIM                          regSPI_SHADER_GS_MESHLET_DIM;
+typedef union SPI_SHADER_GS_MESHLET_EXP_ALLOC                    regSPI_SHADER_GS_MESHLET_EXP_ALLOC;
+#endif
 typedef union SPI_SHADER_IDX_FORMAT                              regSPI_SHADER_IDX_FORMAT;
 typedef union SPI_SHADER_LATE_ALLOC_VS                           regSPI_SHADER_LATE_ALLOC_VS;
 typedef union SPI_SHADER_PGM_CHKSUM_GS                           regSPI_SHADER_PGM_CHKSUM_GS;
 typedef union SPI_SHADER_PGM_CHKSUM_HS                           regSPI_SHADER_PGM_CHKSUM_HS;
 typedef union SPI_SHADER_PGM_CHKSUM_PS                           regSPI_SHADER_PGM_CHKSUM_PS;
 typedef union SPI_SHADER_PGM_CHKSUM_VS                           regSPI_SHADER_PGM_CHKSUM_VS;
 typedef union SPI_SHADER_PGM_HI_ES                               regSPI_SHADER_PGM_HI_ES;
 typedef union SPI_SHADER_PGM_HI_ES_GS                            regSPI_SHADER_PGM_HI_ES_GS;
 typedef union SPI_SHADER_PGM_HI_GS                               regSPI_SHADER_PGM_HI_GS;
 typedef union SPI_SHADER_PGM_HI_HS                               regSPI_SHADER_PGM_HI_HS;
@@ -1993,21 +2154,21 @@ typedef union SPI_WAVE_LIMIT_CNTL_REMAP                          regSPI_WAVE_LIM
 typedef union SPI_WCL_PIPE_PERCENT_CS0                           regSPI_WCL_PIPE_PERCENT_CS0;
 typedef union SPI_WCL_PIPE_PERCENT_CS1                           regSPI_WCL_PIPE_PERCENT_CS1;
 typedef union SPI_WCL_PIPE_PERCENT_CS2                           regSPI_WCL_PIPE_PERCENT_CS2;
 typedef union SPI_WCL_PIPE_PERCENT_CS3                           regSPI_WCL_PIPE_PERCENT_CS3;
 typedef union SPI_WCL_PIPE_PERCENT_CS4                           regSPI_WCL_PIPE_PERCENT_CS4;
 typedef union SPI_WCL_PIPE_PERCENT_CS5                           regSPI_WCL_PIPE_PERCENT_CS5;
 typedef union SPI_WCL_PIPE_PERCENT_CS6                           regSPI_WCL_PIPE_PERCENT_CS6;
 typedef union SPI_WCL_PIPE_PERCENT_CS7                           regSPI_WCL_PIPE_PERCENT_CS7;
 typedef union SPI_WCL_PIPE_PERCENT_GFX                           regSPI_WCL_PIPE_PERCENT_GFX;
 typedef union SPI_WCL_PIPE_PERCENT_HP3D                          regSPI_WCL_PIPE_PERCENT_HP3D;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_WF_ACTIVE_COUNT_GFX                            regSPI_WF_ACTIVE_COUNT_GFX;
 typedef union SPI_WF_ACTIVE_COUNT_HPG                            regSPI_WF_ACTIVE_COUNT_HPG;
 #endif
 typedef union SPI_WF_LIFETIME_CNTL                               regSPI_WF_LIFETIME_CNTL;
 typedef union SPI_WF_LIFETIME_LIMIT_0                            regSPI_WF_LIFETIME_LIMIT_0;
 typedef union SPI_WF_LIFETIME_LIMIT_1                            regSPI_WF_LIFETIME_LIMIT_1;
 typedef union SPI_WF_LIFETIME_LIMIT_2                            regSPI_WF_LIFETIME_LIMIT_2;
 typedef union SPI_WF_LIFETIME_LIMIT_3                            regSPI_WF_LIFETIME_LIMIT_3;
 typedef union SPI_WF_LIFETIME_LIMIT_4                            regSPI_WF_LIFETIME_LIMIT_4;
 typedef union SPI_WF_LIFETIME_LIMIT_5                            regSPI_WF_LIFETIME_LIMIT_5;
@@ -2029,35 +2190,65 @@ typedef union SPI_WF_LIFETIME_STATUS_10                          regSPI_WF_LIFET
 typedef union SPI_WF_LIFETIME_STATUS_11                          regSPI_WF_LIFETIME_STATUS_11;
 typedef union SPI_WF_LIFETIME_STATUS_12                          regSPI_WF_LIFETIME_STATUS_12;
 typedef union SPI_WF_LIFETIME_STATUS_13                          regSPI_WF_LIFETIME_STATUS_13;
 typedef union SPI_WF_LIFETIME_STATUS_14                          regSPI_WF_LIFETIME_STATUS_14;
 typedef union SPI_WF_LIFETIME_STATUS_15                          regSPI_WF_LIFETIME_STATUS_15;
 typedef union SPI_WF_LIFETIME_STATUS_16                          regSPI_WF_LIFETIME_STATUS_16;
 typedef union SPI_WF_LIFETIME_STATUS_17                          regSPI_WF_LIFETIME_STATUS_17;
 typedef union SPI_WF_LIFETIME_STATUS_18                          regSPI_WF_LIFETIME_STATUS_18;
 typedef union SPI_WF_LIFETIME_STATUS_19                          regSPI_WF_LIFETIME_STATUS_19;
 typedef union SPI_WF_LIFETIME_STATUS_20                          regSPI_WF_LIFETIME_STATUS_20;
-#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if  CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SPI_WF_LIFETIME_STATUS_21                          regSPI_WF_LIFETIME_STATUS_21;
 #endif
 typedef union SQG_CONFIG                                         regSQG_CONFIG;
+#if CHIP_HDR_NAVI31
+typedef union SQG_GL1H_STATUS                                    regSQG_GL1H_STATUS;
+typedef union SQG_PERFCOUNTER0_HI                                regSQG_PERFCOUNTER0_HI;
+typedef union SQG_PERFCOUNTER0_LO                                regSQG_PERFCOUNTER0_LO;
+typedef union SQG_PERFCOUNTER0_SELECT                            regSQG_PERFCOUNTER0_SELECT;
+typedef union SQG_PERFCOUNTER1_HI                                regSQG_PERFCOUNTER1_HI;
+typedef union SQG_PERFCOUNTER1_LO                                regSQG_PERFCOUNTER1_LO;
+typedef union SQG_PERFCOUNTER1_SELECT                            regSQG_PERFCOUNTER1_SELECT;
+typedef union SQG_PERFCOUNTER2_HI                                regSQG_PERFCOUNTER2_HI;
+typedef union SQG_PERFCOUNTER2_LO                                regSQG_PERFCOUNTER2_LO;
+typedef union SQG_PERFCOUNTER2_SELECT                            regSQG_PERFCOUNTER2_SELECT;
+typedef union SQG_PERFCOUNTER3_HI                                regSQG_PERFCOUNTER3_HI;
+typedef union SQG_PERFCOUNTER3_LO                                regSQG_PERFCOUNTER3_LO;
+typedef union SQG_PERFCOUNTER3_SELECT                            regSQG_PERFCOUNTER3_SELECT;
+typedef union SQG_PERFCOUNTER4_HI                                regSQG_PERFCOUNTER4_HI;
+typedef union SQG_PERFCOUNTER4_LO                                regSQG_PERFCOUNTER4_LO;
+typedef union SQG_PERFCOUNTER4_SELECT                            regSQG_PERFCOUNTER4_SELECT;
+typedef union SQG_PERFCOUNTER5_HI                                regSQG_PERFCOUNTER5_HI;
+typedef union SQG_PERFCOUNTER5_LO                                regSQG_PERFCOUNTER5_LO;
+typedef union SQG_PERFCOUNTER5_SELECT                            regSQG_PERFCOUNTER5_SELECT;
+typedef union SQG_PERFCOUNTER6_HI                                regSQG_PERFCOUNTER6_HI;
+typedef union SQG_PERFCOUNTER6_LO                                regSQG_PERFCOUNTER6_LO;
+typedef union SQG_PERFCOUNTER6_SELECT                            regSQG_PERFCOUNTER6_SELECT;
+typedef union SQG_PERFCOUNTER7_HI                                regSQG_PERFCOUNTER7_HI;
+typedef union SQG_PERFCOUNTER7_LO                                regSQG_PERFCOUNTER7_LO;
+typedef union SQG_PERFCOUNTER7_SELECT                            regSQG_PERFCOUNTER7_SELECT;
+typedef union SQG_PERFCOUNTER_CTRL                               regSQG_PERFCOUNTER_CTRL;
+typedef union SQG_PERFCOUNTER_CTRL2                              regSQG_PERFCOUNTER_CTRL2;
+typedef union SQG_PERF_SAMPLE_FINISH                             regSQG_PERF_SAMPLE_FINISH;
+#endif
 typedef union SQG_STATUS                                         regSQG_STATUS;
 typedef union SQG_UTCL0_CNTL1                                    regSQG_UTCL0_CNTL1;
 typedef union SQG_UTCL0_CNTL2                                    regSQG_UTCL0_CNTL2;
 typedef union SQG_UTCL0_STATUS                                   regSQG_UTCL0_STATUS;
 typedef union SQ_ALU_CLK_CTRL                                    regSQ_ALU_CLK_CTRL;
 typedef union SQ_ARB_CONFIG                                      regSQ_ARB_CONFIG;
 typedef union SQ_BUF_RSRC_WORD0                                  regSQ_BUF_RSRC_WORD0;
 typedef union SQ_BUF_RSRC_WORD1                                  regSQ_BUF_RSRC_WORD1;
 typedef union SQ_BUF_RSRC_WORD2                                  regSQ_BUF_RSRC_WORD2;
 typedef union SQ_BUF_RSRC_WORD3                                  regSQ_BUF_RSRC_WORD3;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SQ_CLK_CTRL                                        regSQ_CLK_CTRL;
 #endif
 typedef union SQ_CMD                                             regSQ_CMD;
 typedef union SQ_CMD_TIMESTAMP                                   regSQ_CMD_TIMESTAMP;
 typedef union SQ_CONFIG                                          regSQ_CONFIG;
 typedef union SQ_DSM_CNTL                                        regSQ_DSM_CNTL;
 typedef union SQ_DSM_CNTL2                                       regSQ_DSM_CNTL2;
 typedef union SQ_DS_0                                            regSQ_DS_0;
 typedef union SQ_DS_1                                            regSQ_DS_1;
 typedef union SQ_EDC_CNT                                         regSQ_EDC_CNT;
@@ -2163,20 +2354,26 @@ typedef union SQ_PERFCOUNTER13_LO                                regSQ_PERFCOUNT
 typedef union SQ_PERFCOUNTER13_SELECT                            regSQ_PERFCOUNTER13_SELECT;
 typedef union SQ_PERFCOUNTER14_HI                                regSQ_PERFCOUNTER14_HI;
 typedef union SQ_PERFCOUNTER14_LO                                regSQ_PERFCOUNTER14_LO;
 typedef union SQ_PERFCOUNTER14_SELECT                            regSQ_PERFCOUNTER14_SELECT;
 typedef union SQ_PERFCOUNTER15_HI                                regSQ_PERFCOUNTER15_HI;
 typedef union SQ_PERFCOUNTER15_LO                                regSQ_PERFCOUNTER15_LO;
 typedef union SQ_PERFCOUNTER15_SELECT                            regSQ_PERFCOUNTER15_SELECT;
 typedef union SQ_PERFCOUNTER_CTRL                                regSQ_PERFCOUNTER_CTRL;
 typedef union SQ_PERFCOUNTER_CTRL2                               regSQ_PERFCOUNTER_CTRL2;
 typedef union SQ_PERFCOUNTER_MASK                                regSQ_PERFCOUNTER_MASK;
+#if CHIP_HDR_NAVI31
+typedef union SQ_PERF_SNAPSHOT_CTRL                              regSQ_PERF_SNAPSHOT_CTRL;
+typedef union SQ_PERF_SNAPSHOT_DATA                              regSQ_PERF_SNAPSHOT_DATA;
+typedef union SQ_PERF_SNAPSHOT_PC_HI                             regSQ_PERF_SNAPSHOT_PC_HI;
+typedef union SQ_PERF_SNAPSHOT_PC_LO                             regSQ_PERF_SNAPSHOT_PC_LO;
+#endif
 typedef union SQ_POWER_THROTTLE                                  regSQ_POWER_THROTTLE;
 typedef union SQ_POWER_THROTTLE2                                 regSQ_POWER_THROTTLE2;
 typedef union SQ_RANDOM_WAVE_PRI                                 regSQ_RANDOM_WAVE_PRI;
 typedef union SQ_REG_CREDITS                                     regSQ_REG_CREDITS;
 typedef union SQ_REG_TIMESTAMP                                   regSQ_REG_TIMESTAMP;
 typedef union SQ_RUNTIME_CONFIG                                  regSQ_RUNTIME_CONFIG;
 typedef union SQ_SCRATCH_0                                       regSQ_SCRATCH_0;
 typedef union SQ_SCRATCH_1                                       regSQ_SCRATCH_1;
 typedef union SQ_SHADER_TBA_HI                                   regSQ_SHADER_TBA_HI;
 typedef union SQ_SHADER_TBA_LO                                   regSQ_SHADER_TBA_LO;
@@ -2202,21 +2399,21 @@ typedef union SQ_THREAD_TRACE_DROPPED_CNTR                       regSQ_THREAD_TR
 typedef union SQ_THREAD_TRACE_GFX_DRAW_CNTR                      regSQ_THREAD_TRACE_GFX_DRAW_CNTR;
 typedef union SQ_THREAD_TRACE_GFX_MARKER_CNTR                    regSQ_THREAD_TRACE_GFX_MARKER_CNTR;
 typedef union SQ_THREAD_TRACE_HIWATER                            regSQ_THREAD_TRACE_HIWATER;
 typedef union SQ_THREAD_TRACE_HP3D_DRAW_CNTR                     regSQ_THREAD_TRACE_HP3D_DRAW_CNTR;
 typedef union SQ_THREAD_TRACE_HP3D_MARKER_CNTR                   regSQ_THREAD_TRACE_HP3D_MARKER_CNTR;
 typedef union SQ_THREAD_TRACE_MASK                               regSQ_THREAD_TRACE_MASK;
 typedef union SQ_THREAD_TRACE_MODE                               regSQ_THREAD_TRACE_MODE;
 typedef union SQ_THREAD_TRACE_PERF_MASK                          regSQ_THREAD_TRACE_PERF_MASK;
 typedef union SQ_THREAD_TRACE_SIZE                               regSQ_THREAD_TRACE_SIZE;
 typedef union SQ_THREAD_TRACE_STATUS                             regSQ_THREAD_TRACE_STATUS;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SQ_THREAD_TRACE_STATUS2                            regSQ_THREAD_TRACE_STATUS2;
 #endif
 typedef union SQ_THREAD_TRACE_TOKEN_MASK                         regSQ_THREAD_TRACE_TOKEN_MASK;
 typedef union SQ_THREAD_TRACE_TOKEN_MASK2                        regSQ_THREAD_TRACE_TOKEN_MASK2;
 typedef union SQ_THREAD_TRACE_USERDATA_0                         regSQ_THREAD_TRACE_USERDATA_0;
 typedef union SQ_THREAD_TRACE_USERDATA_1                         regSQ_THREAD_TRACE_USERDATA_1;
 typedef union SQ_THREAD_TRACE_USERDATA_2                         regSQ_THREAD_TRACE_USERDATA_2;
 typedef union SQ_THREAD_TRACE_USERDATA_3                         regSQ_THREAD_TRACE_USERDATA_3;
 typedef union SQ_THREAD_TRACE_USERDATA_4                         regSQ_THREAD_TRACE_USERDATA_4;
 typedef union SQ_THREAD_TRACE_USERDATA_5                         regSQ_THREAD_TRACE_USERDATA_5;
@@ -2291,27 +2488,30 @@ typedef union SX_PERFCOUNTER1_HI                                 regSX_PERFCOUNT
 typedef union SX_PERFCOUNTER1_LO                                 regSX_PERFCOUNTER1_LO;
 typedef union SX_PERFCOUNTER1_SELECT                             regSX_PERFCOUNTER1_SELECT;
 typedef union SX_PERFCOUNTER1_SELECT1                            regSX_PERFCOUNTER1_SELECT1;
 typedef union SX_PERFCOUNTER2_HI                                 regSX_PERFCOUNTER2_HI;
 typedef union SX_PERFCOUNTER2_LO                                 regSX_PERFCOUNTER2_LO;
 typedef union SX_PERFCOUNTER2_SELECT                             regSX_PERFCOUNTER2_SELECT;
 typedef union SX_PERFCOUNTER3_HI                                 regSX_PERFCOUNTER3_HI;
 typedef union SX_PERFCOUNTER3_LO                                 regSX_PERFCOUNTER3_LO;
 typedef union SX_PERFCOUNTER3_SELECT                             regSX_PERFCOUNTER3_SELECT;
 typedef union SX_PS_DOWNCONVERT                                  regSX_PS_DOWNCONVERT;
-#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24
+#if CHIP_HDR_NAVI21|| CHIP_HDR_NAVI22|| CHIP_HDR_NAVI23|| CHIP_HDR_NAVI24|| CHIP_HDR_NAVI31
 typedef union SX_PS_DOWNCONVERT_CONTROL                          regSX_PS_DOWNCONVERT_CONTROL;
 #endif
 typedef union TA_BC_BASE_ADDR                                    regTA_BC_BASE_ADDR;
 typedef union TA_BC_BASE_ADDR_HI                                 regTA_BC_BASE_ADDR_HI;
 typedef union TA_CGTT_CTRL                                       regTA_CGTT_CTRL;
 typedef union TA_CNTL                                            regTA_CNTL;
+#if CHIP_HDR_NAVI31
+typedef union TA_CNTL2                                           regTA_CNTL2;
+#endif
 typedef union TA_CNTL_AUX                                        regTA_CNTL_AUX;
 typedef union TA_CS_BC_BASE_ADDR                                 regTA_CS_BC_BASE_ADDR;
 typedef union TA_CS_BC_BASE_ADDR_HI                              regTA_CS_BC_BASE_ADDR_HI;
 typedef union TA_DSM_CNTL                                        regTA_DSM_CNTL;
 typedef union TA_DSM_CNTL2                                       regTA_DSM_CNTL2;
 typedef union TA_EDC_CNT                                         regTA_EDC_CNT;
 typedef union TA_PERFCOUNTER0_HI                                 regTA_PERFCOUNTER0_HI;
 typedef union TA_PERFCOUNTER0_LO                                 regTA_PERFCOUNTER0_LO;
 typedef union TA_PERFCOUNTER0_SELECT                             regTA_PERFCOUNTER0_SELECT;
 typedef union TA_PERFCOUNTER0_SELECT1                            regTA_PERFCOUNTER0_SELECT1;
@@ -2949,20 +3149,28 @@ typedef union UMCCH31_PerfMonCtr4_Lo                             regUMCCH31_Perf
 typedef union UMCCH31_PerfMonCtr5_Hi                             regUMCCH31_PerfMonCtr5_Hi;
 typedef union UMCCH31_PerfMonCtr5_Lo                             regUMCCH31_PerfMonCtr5_Lo;
 typedef union UMCCH31_PerfMonCtrClk_Hi                           regUMCCH31_PerfMonCtrClk_Hi;
 typedef union UMCCH31_PerfMonCtrClk_Lo                           regUMCCH31_PerfMonCtrClk_Lo;
 typedef union UTCL1_PERFCOUNTER0_HI                              regUTCL1_PERFCOUNTER0_HI;
 typedef union UTCL1_PERFCOUNTER0_LO                              regUTCL1_PERFCOUNTER0_LO;
 typedef union UTCL1_PERFCOUNTER0_SELECT                          regUTCL1_PERFCOUNTER0_SELECT;
 typedef union UTCL1_PERFCOUNTER1_HI                              regUTCL1_PERFCOUNTER1_HI;
 typedef union UTCL1_PERFCOUNTER1_LO                              regUTCL1_PERFCOUNTER1_LO;
 typedef union UTCL1_PERFCOUNTER1_SELECT                          regUTCL1_PERFCOUNTER1_SELECT;
+#if CHIP_HDR_NAVI31
+typedef union UTCL1_PERFCOUNTER2_HI                              regUTCL1_PERFCOUNTER2_HI;
+typedef union UTCL1_PERFCOUNTER2_LO                              regUTCL1_PERFCOUNTER2_LO;
+typedef union UTCL1_PERFCOUNTER2_SELECT                          regUTCL1_PERFCOUNTER2_SELECT;
+typedef union UTCL1_PERFCOUNTER3_HI                              regUTCL1_PERFCOUNTER3_HI;
+typedef union UTCL1_PERFCOUNTER3_LO                              regUTCL1_PERFCOUNTER3_LO;
+typedef union UTCL1_PERFCOUNTER3_SELECT                          regUTCL1_PERFCOUNTER3_SELECT;
+#endif
 typedef union VGT_CACHE_INVALIDATION                             regVGT_CACHE_INVALIDATION;
 typedef union VGT_CNTL_STATUS                                    regVGT_CNTL_STATUS;
 typedef union VGT_DISPATCH_DRAW_INDEX                            regVGT_DISPATCH_DRAW_INDEX;
 typedef union VGT_DMA_BASE                                       regVGT_DMA_BASE;
 typedef union VGT_DMA_BASE_HI                                    regVGT_DMA_BASE_HI;
 typedef union VGT_DMA_CONTROL                                    regVGT_DMA_CONTROL;
 typedef union VGT_DMA_DATA_FIFO_DEPTH                            regVGT_DMA_DATA_FIFO_DEPTH;
 typedef union VGT_DMA_EVENT_INITIATOR                            regVGT_DMA_EVENT_INITIATOR;
 typedef union VGT_DMA_INDEX_TYPE                                 regVGT_DMA_INDEX_TYPE;
 typedef union VGT_DMA_LS_HS_CONFIG                               regVGT_DMA_LS_HS_CONFIG;
diff --git a/lgc/include/lgc/builder/BuilderRecorder.h b/lgc/include/lgc/builder/BuilderRecorder.h
index 31ba4383b..31e2cf508 100644
--- a/lgc/include/lgc/builder/BuilderRecorder.h
+++ b/lgc/include/lgc/builder/BuilderRecorder.h
@@ -146,22 +146,24 @@ public:
     ImageSample,
     ImageSampleConvert,
     ImageGather,
     ImageAtomic,
     ImageAtomicCompareSwap,
     ImageQueryLevels,
     ImageQuerySamples,
     ImageQuerySize,
     ImageGetLod,
 #if VKI_RAY_TRACING
-    ImageBvhIntersectRayAMD,
+    ImageBvhIntersectRay,
+    Reserved2,
 #else
+    Reserved2,
     Reserved1,
 #endif
 
     // Input/output
     ReadGenericInput,
     ReadGenericOutput,
     ReadPerVertexInput,
     WriteGenericOutput,
     WriteXfbOutput,
     ReadBaryCoord,
@@ -248,21 +250,21 @@ public:
   // Record shader modes into IR metadata if this is a shader compile (no PipelineState).
   void recordShaderModes(llvm::Module *module) override final;
 
   // -----------------------------------------------------------------------------------------------------------------
   // Base class operations
 
   llvm::Value *CreateDotProduct(llvm::Value *const vector1, llvm::Value *const vector2,
                                 const llvm::Twine &instName = "") override final;
 
   llvm::Value *CreateIntegerDotProduct(llvm::Value *vector1, llvm::Value *vector2, llvm::Value *accumulator,
-                                          unsigned flags, const llvm::Twine &instName = "") override final;
+                                       unsigned flags, const llvm::Twine &instName = "") override final;
 
   // -----------------------------------------------------------------------------------------------------------------
   // Arithmetic operations
 
   // Create calculation of 2D texture coordinates that would be used for accessing the selected cube map face for
   // the given cube map texture coordinates.
   llvm::Value *CreateCubeFaceCoord(llvm::Value *coord, const llvm::Twine &instName = "") override final;
 
   // Create calculation of the index of the cube map face that would be accessed by a texture lookup function for
   // the given cube map texture coordinates.
@@ -439,20 +441,21 @@ public:
   // Create a get of the LOD that would be used for an image sample with the given coordinates
   // and implicit LOD.
   llvm::Value *CreateImageGetLod(unsigned dim, unsigned flags, llvm::Value *imageDesc, llvm::Value *samplerDesc,
                                  llvm::Value *coord, const llvm::Twine &instName = "") override final;
 
 #if VKI_RAY_TRACING
   // Create a ray intersect result with specified node in BVH buffer
   llvm::Value *CreateImageBvhIntersectRay(llvm::Value *nodePtr, llvm::Value *extent, llvm::Value *origin,
                                           llvm::Value *direction, llvm::Value *invDirection, llvm::Value *imageDesc,
                                           const llvm::Twine &instName = "") override final;
+
 #endif
 
   // -----------------------------------------------------------------------------------------------------------------
   // Shader input/output methods
 
   // Create a read of (part of) a user input value.
   llvm::Value *CreateReadGenericInput(llvm::Type *resultTy, unsigned location, llvm::Value *locationOffset,
                                       llvm::Value *elemIdx, unsigned locationCount, InOutInfo inputInfo,
                                       llvm::Value *vertexIndex, const llvm::Twine &instName = "") override final;
 
diff --git a/lgc/include/lgc/patch/FragColorExport.h b/lgc/include/lgc/patch/FragColorExport.h
index b928d682a..c3ba29837 100644
--- a/lgc/include/lgc/patch/FragColorExport.h
+++ b/lgc/include/lgc/patch/FragColorExport.h
@@ -74,20 +74,28 @@ public:
 
 private:
   FragColorExport() = delete;
   FragColorExport(const FragColorExport &) = delete;
   FragColorExport &operator=(const FragColorExport &) = delete;
 
   llvm::Value *convertToHalf(llvm::Value *value, bool signedness, BuilderBase &builder) const;
   llvm::Value *convertToFloat(llvm::Value *value, bool signedness, BuilderBase &builder) const;
   llvm::Value *convertToInt(llvm::Value *value, bool signedness, BuilderBase &builder) const;
 
+#if LLPC_BUILD_GFX11
+  llvm::Value *dualSourceSwizzle(BuilderBase &builder);
+
+  // Colors to be exported for dual-source-blend
+  llvm::SmallVector<llvm::Value *, 4> m_blendSources[2];
+  // Number of color channels for dual-source-blend
+  unsigned m_blendSourceChannels;
+#endif
   llvm::LLVMContext *m_context;   // LLVM context
   PipelineState *m_pipelineState; // The pipeline state
 };
 
 // The information needed for an export to a hardware color target.
 struct ColorExportValueInfo {
   std::vector<llvm::Value *> value; // The value of each component to be exported.
   unsigned location;                // The location that corresponds to the hardware color target.
   bool isSigned;                    // True if the values should be interpreted as signed integers.
 };
diff --git a/lgc/include/lgc/patch/Patch.h b/lgc/include/lgc/patch/Patch.h
index a36cdce5a..2672cf410 100644
--- a/lgc/include/lgc/patch/Patch.h
+++ b/lgc/include/lgc/patch/Patch.h
@@ -59,20 +59,23 @@ void initializeLegacyPatchNullFragShaderPass(PassRegistry &);
 void initializeLegacyPatchPeepholeOptPass(PassRegistry &);
 void initializeLegacyPatchPreparePipelineAbiPass(PassRegistry &);
 void initializeLegacyPatchResourceCollectPass(PassRegistry &);
 void initializeLegacyPatchSetupTargetFeaturesPass(PassRegistry &);
 void initializeLegacyPatchWorkaroundsPass(PassRegistry &);
 void initializeLegacyPatchReadFirstLanePass(PassRegistry &);
 void initializeLegacyPatchWaveSizeAdjustPass(PassRegistry &);
 void initializeLegacyPatchImageDerivativesPass(PassRegistry &);
 void initializeLegacyPatchInitializeWorkgroupMemoryPass(PassRegistry &);
 void initializeLegacyPatchInvariantLoadsPass(PassRegistry &);
+#if LLPC_BUILD_GFX11
+void initializeLegacyPatchImageOpCollectPass(PassRegistry &);
+#endif
 } // namespace llvm
 
 namespace lgc {
 
 class LegacyPatchCheckShaderCache;
 
 // Initialize passes for patching
 //
 // @param passRegistry : Pass registry
 inline void initializePatchPasses(llvm::PassRegistry &passRegistry) {
@@ -90,25 +93,31 @@ inline void initializePatchPasses(llvm::PassRegistry &passRegistry) {
   initializeLegacyPatchPeepholeOptPass(passRegistry);
   initializeLegacyPatchPreparePipelineAbiPass(passRegistry);
   initializeLegacyPatchResourceCollectPass(passRegistry);
   initializeLegacyPatchSetupTargetFeaturesPass(passRegistry);
   initializeLegacyPatchWorkaroundsPass(passRegistry);
   initializeLegacyPatchReadFirstLanePass(passRegistry);
   initializeLegacyPatchWaveSizeAdjustPass(passRegistry);
   initializeLegacyPatchImageDerivativesPass(passRegistry);
   initializeLegacyPatchInitializeWorkgroupMemoryPass(passRegistry);
   initializeLegacyPatchInvariantLoadsPass(passRegistry);
+#if LLPC_BUILD_GFX11
+  initializeLegacyPatchImageOpCollectPass(passRegistry);
+#endif
 }
 
 llvm::ModulePass *createLegacyLowerFragColorExport();
 llvm::ModulePass *createLegacyLowerVertexFetch();
 llvm::FunctionPass *createLegacyPatchBufferOp();
+#if LLPC_BUILD_GFX11
+llvm::ModulePass *createLegacyPatchImageOpCollect();
+#endif
 LegacyPatchCheckShaderCache *createLegacyPatchCheckShaderCache();
 llvm::ModulePass *createLegacyPatchCopyShader();
 llvm::ModulePass *createLegacyPatchEntryPointMutate();
 llvm::ModulePass *createLegacyPatchInOutImportExport();
 llvm::ModulePass *createLegacyPatchLlvmIrInclusion();
 llvm::FunctionPass *createLegacyPatchLoadScalarizer();
 llvm::LoopPass *createLegacyPatchLoopMetadata();
 llvm::ModulePass *createLegacyPatchNullFragShader();
 llvm::FunctionPass *createLegacyPatchPeepholeOpt();
 llvm::ModulePass *createLegacyPatchPreparePipelineAbi();
diff --git a/lgc/include/lgc/patch/PatchBufferOp.h b/lgc/include/lgc/patch/PatchBufferOp.h
index 8e82a0dbf..624247375 100644
--- a/lgc/include/lgc/patch/PatchBufferOp.h
+++ b/lgc/include/lgc/patch/PatchBufferOp.h
@@ -65,41 +65,42 @@ public:
   void visitMemCpyInst(llvm::MemCpyInst &memCpyInst);
   void visitMemMoveInst(llvm::MemMoveInst &memMoveInst);
   void visitMemSetInst(llvm::MemSetInst &memSetInst);
   void visitPHINode(llvm::PHINode &phiNode);
   void visitSelectInst(llvm::SelectInst &selectInst);
   void visitStoreInst(llvm::StoreInst &storeInst);
   void visitICmpInst(llvm::ICmpInst &icmpInst);
   void visitPtrToIntInst(llvm::PtrToIntInst &ptrToIntInst);
 
 private:
-  llvm::Value *getPointerOperandAsInst(llvm::Value *const value);
+  using Replacement = std::pair<llvm::Value *, llvm::Value *>;
+  Replacement getRemappedValueOrNull(llvm::Value *value) const;
+  Replacement getRemappedValue(llvm::Value *value) const;
   llvm::Value *getBaseAddressFromBufferDesc(llvm::Value *const bufferDesc) const;
   void copyMetadata(llvm::Value *const dest, const llvm::Value *const src) const;
   llvm::PointerType *getRemappedType(llvm::Type *const type) const;
   bool removeUsersForInvariantStarts(llvm::Value *const value);
   llvm::Value *replaceLoadStore(llvm::Instruction &loadInst);
   llvm::Value *replaceICmp(llvm::ICmpInst *const iCmpInst);
   llvm::Instruction *makeLoop(llvm::Value *const loopStart, llvm::Value *const loopEnd, llvm::Value *const loopStride,
                               llvm::Instruction *const insertPos);
   void postVisitMemCpyInst(llvm::MemCpyInst &memCpyInst);
   void postVisitMemSetInst(llvm::MemSetInst &memSetInst);
   void fixIncompletePhis();
 
-  using Replacement = std::pair<llvm::Value *, llvm::Value *>;
   using PhiIncoming = std::pair<llvm::PHINode *, llvm::BasicBlock *>;
   llvm::DenseMap<llvm::Value *, Replacement> m_replacementMap; // The replacement map.
   llvm::DenseMap<PhiIncoming, llvm::Value *> m_incompletePhis; // The incomplete phi map.
   llvm::DenseSet<llvm::Value *> m_invariantSet;                // The invariant set.
   llvm::DenseSet<llvm::Value *> m_divergenceSet;               // The divergence set.
   llvm::SmallVector<llvm::Instruction *, 16> m_postVisitInsts; // The post process instruction set.
-  std::unique_ptr<llvm::IRBuilder<>> m_builder;                // The IRBuilder.
+  llvm::IRBuilder<> *m_builder;                                // The IRBuilder.
   llvm::LLVMContext *m_context;                                // The LLVM context.
   PipelineState *m_pipelineState;                              // The pipeline state
 
   std::function<bool(const llvm::Value &)> m_isDivergent;
 
   static constexpr unsigned MinMemOpLoopBytes = 256;
 };
 
 // =====================================================================================================================
 // Represents the pass of LLVM patching operations for buffer operations
diff --git a/lgc/include/lgc/patch/PatchInOutImportExport.h b/lgc/include/lgc/patch/PatchInOutImportExport.h
index e9d77524e..2a48b12f3 100644
--- a/lgc/include/lgc/patch/PatchInOutImportExport.h
+++ b/lgc/include/lgc/patch/PatchInOutImportExport.h
@@ -95,21 +95,20 @@ private:
   void patchVsGenericOutputExport(llvm::Value *output, unsigned location, unsigned compIdx, BuilderBase &builder);
   void patchTcsGenericOutputExport(llvm::Value *output, unsigned location, llvm::Value *locOffset, llvm::Value *compIdx,
                                    llvm::Value *vertexIdx, BuilderBase &builder);
   void patchTesGenericOutputExport(llvm::Value *output, unsigned location, unsigned compIdx, BuilderBase &builder);
   void patchGsGenericOutputExport(llvm::Value *output, unsigned location, unsigned compIdx, unsigned streamId,
                                   BuilderBase &builder);
   void patchMeshGenericOutputExport(llvm::Value *output, unsigned location, llvm::Value *locOffset,
                                     llvm::Value *compIdx, llvm::Value *vertexOrPrimitiveIdx, bool isPerPrimitive,
                                     BuilderBase &builder);
 
-  llvm::Value *patchVsBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, BuilderBase &builder);
   llvm::Value *patchTcsBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, llvm::Value *elemIdx,
                                           llvm::Value *vertexIdx, BuilderBase &builder);
   llvm::Value *patchTesBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, llvm::Value *elemIdx,
                                           llvm::Value *vertexIdx, BuilderBase &builder);
   llvm::Value *patchGsBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, llvm::Value *vertexIdx,
                                          BuilderBase &builder);
   llvm::Value *patchMeshBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, llvm::Value *elemIdx,
                                            BuilderBase &builder);
   llvm::Value *patchFsBuiltInInputImport(llvm::Type *inputTy, unsigned builtInId, llvm::Value *sampleId,
                                          BuilderBase &builder);
@@ -198,39 +197,36 @@ private:
   llvm::Value *reconfigWorkgroup(llvm::Value *localInvocationId, llvm::Instruction *insertPos);
   llvm::Value *swizzleLocalInvocationIdIn8x4(llvm::Value *localInvocationId, llvm::Instruction *insertPos);
   void createSwizzleThreadGroupFunction();
 
   void exportShadingRate(llvm::Value *shadingRate, llvm::Instruction *insertPos);
   llvm::Value *getShadingRate(llvm::Instruction *insertPos);
 
   void recordVertexAttribExport(unsigned location, llvm::ArrayRef<llvm::Value *> attribValues);
   void exportVertexAttribs(llvm::Instruction *insertPos);
 
-  void storeTessFactors();
-  void storeTessFactorToBuffer(llvm::ArrayRef<llvm::Value *> outerTessFactors,
-                               llvm::ArrayRef<llvm::Value *> innerTessFactors, llvm::Instruction *insertPos);
-
   GfxIpVersion m_gfxIp;                     // Graphics IP version info
   PipelineSystemValues m_pipelineSysValues; // Cache of ShaderSystemValues objects, one per shader stage
 
   llvm::Value *m_clipDistance; // Correspond to "out float gl_ClipDistance[]"
   llvm::Value *m_cullDistance; // Correspond to "out float gl_CullDistance[]"
   llvm::Value *m_primitiveId;  // Correspond to "out int gl_PrimitiveID"
   // NOTE: gl_FragDepth, gl_FragStencilRef and gl_SampleMask[] are exported at the same time with one "EXP"
   // instruction. Thus, the export is delayed.
   llvm::Value *m_fragDepth;      // Correspond to "out float gl_FragDepth"
   llvm::Value *m_fragStencilRef; // Correspond to "out int gl_FragStencilRef"
   llvm::Value *m_sampleMask;     // Correspond to "out int gl_SampleMask[]"
   // NOTE: For GFX9, gl_ViewportIndex and gl_Layer are packed with one channel (gl_ViewportIndex is 16-bit high part
   // and gl_Layer is 16-bit low part). Thus, the export is delayed with them merged together.
   llvm::Value *m_viewportIndex; // Correspond to "out int gl_ViewportIndex"
   llvm::Value *m_layer;         // Correspond to "out int gl_Layer"
+  llvm::Value *m_viewIndex;     // Correspond to "in int gl_Layer"
 
   bool m_hasTs; // Whether the pipeline has tessellation shaders
 
   bool m_hasGs; // Whether the pipeline has geometry shader
 
   llvm::GlobalVariable *m_lds; // Global variable to model LDS
   llvm::Value *m_threadId;     // Thread ID
 
   std::vector<llvm::CallInst *> m_importCalls; // List of "call" instructions to import inputs
   std::vector<llvm::CallInst *> m_exportCalls; // List of "call" instructions to export outputs
diff --git a/lgc/include/lgc/patch/PatchPreparePipelineAbi.h b/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
index f023ae869..4c3e2df5b 100644
--- a/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
+++ b/lgc/include/lgc/patch/PatchPreparePipelineAbi.h
@@ -53,27 +53,35 @@ public:
 
   PatchPreparePipelineAbi();
 
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineShadersResult &pipelineShaders, PipelineState *pipelineState,
                FunctionAnalysisHandlers &analysisHandlers);
 
   static llvm::StringRef name() { return "Patch LLVM for preparing pipeline ABI"; }
 
+  static std::pair<llvm::Value *, llvm::Value *> readTessFactors(PipelineState *pipelineState, llvm::Value *relPatchId,
+                                                                 llvm::IRBuilder<> &builder);
+  static void writeTessFactors(PipelineState *pipelineState, llvm::Value *tfBufferDesc, llvm::Value *tfBufferBase,
+                               llvm::Value *relPatchId, llvm::Value *outerTf, llvm::Value *innerTf,
+                               llvm::IRBuilder<> &builder);
+
 private:
   void mergeShader(llvm::Module &module);
 
   void setAbiEntryNames(llvm::Module &module);
 
   void addAbiMetadata(llvm::Module &module);
 
+  void storeTessFactors(llvm::Function *entryPoint);
+
   PipelineState *m_pipelineState;           // Pipeline state
   PipelineShadersResult *m_pipelineShaders; // API shaders in the pipeline
   FunctionAnalysisHandlers
       *m_analysisHandlers; // A collection of handler functions to get the analysis info of the given function
 
   bool m_hasVs;   // Whether the pipeline has vertex shader
   bool m_hasTcs;  // Whether the pipeline has tessellation control shader
   bool m_hasTes;  // Whether the pipeline has tessellation evaluation shader
   bool m_hasGs;   // Whether the pipeline has geometry shader
   bool m_hasTask; // Whether the pipeline has task shader
diff --git a/lgc/include/lgc/patch/PatchResourceCollect.h b/lgc/include/lgc/patch/PatchResourceCollect.h
index 69b29bc56..6ae062175 100644
--- a/lgc/include/lgc/patch/PatchResourceCollect.h
+++ b/lgc/include/lgc/patch/PatchResourceCollect.h
@@ -139,33 +139,32 @@ private:
 
   PatchResourceCollect m_impl;
 };
 
 // Represents the compatibility info of input/output
 union InOutCompatibilityInfo {
   struct {
     uint16_t halfComponentCount : 9; // The number of components measured in times of 16-bits.
                                      // A single 32-bit component will be halfComponentCount=2
     uint16_t is16Bit : 1;            // 16-bit (i8/i16/f16, i8 is treated as 16-bit) or not
-    uint16_t isFlat : 1;             // Flat shading or not
-    uint16_t isCustom : 1;           // Custom interpolation mode or not
   };
   uint16_t u16All;
 };
 
 // =====================================================================================================================
 // Represents the manager of input/output locationInfoMap generation
 class InOutLocationInfoMapManager {
 public:
   InOutLocationInfoMapManager() {}
 
   void createMap(const std::vector<llvm::CallInst *> &calls, ShaderStage shaderStage, bool requireDword);
+  void createMap(const std::vector<InOutLocationInfo> &locInfos, ShaderStage shaderStage);
   void deserializeMap(llvm::ArrayRef<std::pair<unsigned, unsigned>> serializedMap);
   bool findMap(const InOutLocationInfo &origLocInfo, InOutLocationInfoMap::const_iterator &mapIt);
   InOutLocationInfoMap &getMap() { return m_locationInfoMap; }
 
   struct LocationSpan {
     uint16_t getCompatibilityKey() const { return compatibilityInfo.u16All; }
 
     unsigned asIndex() const { return ((getCompatibilityKey() << 16) | firstLocationInfo.getData()); }
 
     bool operator==(const LocationSpan &rhs) const { return this->asIndex() == rhs.asIndex(); }
@@ -176,22 +175,31 @@ public:
     InOutCompatibilityInfo compatibilityInfo;
   };
 
 private:
   InOutLocationInfoMapManager(const InOutLocationInfoMapManager &) = delete;
   InOutLocationInfoMapManager &operator=(const InOutLocationInfoMapManager &) = delete;
 
   void addSpan(llvm::CallInst *call, ShaderStage shaderStage, bool requireDword);
   void buildMap(ShaderStage shaderStage);
 
-  bool isCompatible(const LocationSpan &rSpan, const LocationSpan &lSpan, const bool isGs) const {
+  bool isCompatible(const LocationSpan &rSpan, const LocationSpan &lSpan, ShaderStage shaderStage) const {
     bool isCompatible = rSpan.getCompatibilityKey() == lSpan.getCompatibilityKey();
-    if (isGs)
-      isCompatible &= rSpan.firstLocationInfo.getStreamId() == lSpan.firstLocationInfo.getStreamId();
+    if (isCompatible) {
+      if (shaderStage == ShaderStageGeometry) {
+        // Outputs with the same stream id are packed together
+        isCompatible &= rSpan.firstLocationInfo.getStreamId() == lSpan.firstLocationInfo.getStreamId();
+      } else if (shaderStage == ShaderStageFragment) {
+        // Inputs with the same interpolation mode are packed together
+        const unsigned rInterpMode = rSpan.firstLocationInfo.isCustom() | rSpan.firstLocationInfo.isFlat() << 1;
+        const unsigned lInterpMode = lSpan.firstLocationInfo.isCustom() | lSpan.firstLocationInfo.isFlat() << 1;
+        isCompatible &= rInterpMode == lInterpMode;
+      }
+    }
     return isCompatible;
   }
 
-  std::vector<LocationSpan> m_locationSpans; // Tracks spans of contiguous components in the generic input space
+  std::set<LocationSpan> m_locationSpans;    // Tracks spans of contiguous components in the generic input space
   InOutLocationInfoMap m_locationInfoMap;    // The map between original location and new location
 };
 
 } // namespace lgc
diff --git a/lgc/include/lgc/patch/PatchWaveSizeAdjust.h b/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
index 0eb33c5d0..a1b6fc6a0 100644
--- a/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
+++ b/lgc/include/lgc/patch/PatchWaveSizeAdjust.h
@@ -38,20 +38,24 @@ namespace lgc {
 
 // =====================================================================================================================
 // Pass to adjust wave size per shader stage heuristically.
 class PatchWaveSizeAdjust final : public llvm::PassInfoMixin<PatchWaveSizeAdjust> {
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
 
   bool runImpl(llvm::Module &module, PipelineState *pipelineState);
 
   static llvm::StringRef name() { return "Patch LLVM for per-shader wave size adjustment"; }
+#if LLPC_BUILD_GFX11
+private:
+  bool is16BitArithmeticOp(llvm::Instruction *inst);
+#endif
 };
 
 // =====================================================================================================================
 // Pass to adjust wave size per shader stage heuristically.
 class LegacyPatchWaveSizeAdjust final : public llvm::ModulePass {
 public:
   LegacyPatchWaveSizeAdjust();
 
   void getAnalysisUsage(llvm::AnalysisUsage &analysisUsage) const override {
     analysisUsage.addRequired<LegacyPipelineShaders>();
diff --git a/lgc/include/lgc/patch/SystemValues.h b/lgc/include/lgc/patch/SystemValues.h
index 7955b052e..a38efe4fc 100644
--- a/lgc/include/lgc/patch/SystemValues.h
+++ b/lgc/include/lgc/patch/SystemValues.h
@@ -52,20 +52,25 @@ class ShaderSystemValues {
 public:
   // Initialize this ShaderSystemValues if it was previously uninitialized.
   void initialize(PipelineState *pipelineState, llvm::Function *entryPoint);
 
   // Get ES-GS ring buffer descriptor (for VS/TES output or GS input)
   llvm::Value *getEsGsRingBufDesc();
 
   // Get the descriptor for tessellation factor (TF) buffer (TCS output)
   llvm::Value *getTessFactorBufDesc();
 
+#if LLPC_BUILD_GFX11
+  // Get the descriptor for vertex attribute ring buffer (for VS, TES, and copy shader output)
+  llvm::Value *getAttribRingBufDesc();
+
+#endif
   // Get the descriptor for task payload ring buffer (for task and mesh shader)
   llvm::Value *getTaskPayloadRingBufDesc();
 
   // Get the descriptor for task draw data ring buffer (for task and mesh shader)
   llvm::Value *getTaskDrawDataRingBufDesc();
 
   // Extract value of primitive ID (TCS)
   llvm::Value *getPrimitiveId();
 
   // Get invocation ID (TCS)
@@ -97,64 +102,83 @@ public:
 
   // Load descriptor from driver table
   llvm::Instruction *loadDescFromDriverTable(unsigned tableOffset, BuilderBase &builder);
 
   // Get internal per shader table pointer as pointer to i8.
   llvm::Value *getInternalPerShaderTablePtr();
 
   // Get stream-out buffer descriptor
   llvm::Value *getStreamOutBufDesc(unsigned xfbBuffer);
 
+#if LLPC_BUILD_GFX11
+  // Get stream-out buffer offset
+  llvm::Value *getStreamOutBufOffset(unsigned xfbBuffer);
+#endif
+
   // Test if shadow descriptor table is enabled
   bool isShadowDescTableEnabled() const;
 
 private:
   // Get stream-out buffer table pointer
   std::pair<llvm::Type *, llvm::Instruction *> getStreamOutTablePtr();
 
+#if LLPC_BUILD_GFX11
+  // Get stream-out control buffer pointer
+  llvm::Instruction *getStreamOutControlBufPtr();
+#endif
+
   // Make 64-bit pointer of specified type from 32-bit int, extending with the specified value, or PC if InvalidValue
   llvm::Instruction *makePointer(llvm::Value *lowValue, llvm::Type *ptrTy, unsigned highValue);
 
   // Explicitly set the DATA_FORMAT of ring buffer descriptor.
   llvm::Value *setRingBufferDataFormat(llvm::Value *bufDesc, unsigned dataFormat, BuilderBase &builder) const;
 
   // Find resource node by descriptor set ID
   unsigned findResourceNodeByDescSet(unsigned descSet);
 
   llvm::Function *m_entryPoint = nullptr; // Shader entrypoint
   llvm::LLVMContext *m_context;           // LLVM context
   PipelineState *m_pipelineState;         // Pipeline state
   ShaderStage m_shaderStage;              // Shader stage
 
-  llvm::Value *m_esGsRingBufDesc = nullptr;         // ES -> GS ring buffer descriptor (VS, TES, and GS)
-  llvm::Value *m_tfBufDesc = nullptr;               // Descriptor for tessellation factor (TF) buffer (TCS)
-  llvm::Value *m_offChipLdsDesc = nullptr;          // Descriptor for off-chip LDS buffer (TCS and TES)
+  llvm::Value *m_esGsRingBufDesc = nullptr; // ES -> GS ring buffer descriptor (VS, TES, and GS)
+  llvm::Value *m_tfBufDesc = nullptr;       // Descriptor for tessellation factor (TF) buffer (TCS)
+  llvm::Value *m_offChipLdsDesc = nullptr;  // Descriptor for off-chip LDS buffer (TCS and TES)
+#if LLPC_BUILD_GFX11
+  llvm::Value *m_attribRingBufDesc = nullptr; // Descriptor for vertex attribute ring buffer (VS, TES, and copy shader)
+#endif
   llvm::Value *m_taskPayloadRingBufDesc = nullptr;  // Descriptor for task payload ring buffer (task and mesh shader)
   llvm::Value *m_taskDrawDataRingBufDesc = nullptr; // Descriptor for task draw data ring buffer (task and mesh shader)
   llvm::SmallVector<llvm::Value *, MaxGsStreams>
       m_gsVsRingBufDescs; // GS -> VS ring buffer descriptor (GS out and copy shader in)
   llvm::SmallVector<llvm::Value *, MaxTransformFeedbackBuffers> m_streamOutBufDescs; // Stream-out buffer descriptors
+#if LLPC_BUILD_GFX11
+  llvm::SmallVector<llvm::Value *, MaxTransformFeedbackBuffers> m_streamOutBufOffsets; // Stream-out buffer offsets
+#endif
 
   llvm::Value *m_primitiveId = nullptr;                             // PrimitiveId (TCS)
   llvm::Value *m_invocationId = nullptr;                            // InvocationId (TCS)
   llvm::Value *m_relativeId = nullptr;                              // Relative PatchId (TCS)
   llvm::Value *m_tessCoord = nullptr;                               // Tessellated coordinate (TES)
   llvm::Value *m_esGsOffsets = nullptr;                             // ES -> GS offsets (GS in)
   llvm::SmallVector<llvm::Value *, MaxGsStreams> m_emitCounterPtrs; // Pointers to emit counters (GS)
 
   llvm::SmallVector<llvm::Value *, 8> m_descTablePtrs;       // Descriptor table pointers
   llvm::SmallVector<llvm::Value *, 8> m_shadowDescTablePtrs; // Shadow descriptor table pointers
   llvm::Instruction *m_internalGlobalTablePtr = nullptr;     // Internal global table pointer
   llvm::Value *m_meshPipeStatsBufPtr = nullptr;              // Mesh pipeline statistics buffer pointer
   llvm::Value *m_internalPerShaderTablePtr = nullptr;        // Internal per shader table pointer
   llvm::Instruction *m_streamOutTablePtr = nullptr;          // Stream-out buffer table pointer
-  llvm::Instruction *m_pc = nullptr;                         // Program counter as <2 x i32>
+#if LLPC_BUILD_GFX11
+  llvm::Instruction *m_streamOutControlBufPtr = nullptr; // Stream-out control buffer pointer
+#endif
+  llvm::Instruction *m_pc = nullptr; // Program counter as <2 x i32>
 };
 
 // =====================================================================================================================
 // A class that provides a mapping from a shader entrypoint to its ShaderSystemValues object
 class PipelineSystemValues {
 public:
   // Initialize this PipelineSystemValues.
   void initialize(PipelineState *pipelineState) { m_pipelineState = pipelineState; }
 
   // Get the ShaderSystemValues object for the given shader entrypoint.
diff --git a/lgc/include/lgc/state/AbiMetadata.h b/lgc/include/lgc/state/AbiMetadata.h
index 936ba6ef8..8aa19186b 100644
--- a/lgc/include/lgc/state/AbiMetadata.h
+++ b/lgc/include/lgc/state/AbiMetadata.h
@@ -104,20 +104,23 @@ static constexpr char Shaders[] = ".shaders";
 static constexpr char HardwareStages[] = ".hardware_stages";
 static constexpr char Registers[] = ".registers";
 static constexpr char UserDataLimit[] = ".user_data_limit";
 static constexpr char SpillThreshold[] = ".spill_threshold";
 static constexpr char UsesViewportArrayIndex[] = ".uses_viewport_array_index";
 static constexpr char EsGsLdsSize[] = ".es_gs_lds_size";
 static constexpr char StreamOutTableAddress[] = ".stream_out_table_address";
 static constexpr char IndirectUserDataTableAddresses[] = ".indirect_user_data_table_addresses";
 static constexpr char NggSubgroupSize[] = ".nggSubgroupSize";
 static constexpr char NumInterpolants[] = ".num_interpolants";
+#if LLPC_BUILD_GFX11
+static constexpr char StreamOutVertexStrides[] = ".streamout_vertex_strides";
+#endif
 static constexpr char Api[] = ".api";
 static constexpr char ApiCreateInfo[] = ".api_create_info";
 static constexpr char PsSampleMask[] = ".ps_sample_mask";
 }; // namespace PipelineMetadataKey
 
 namespace HardwareStageMetadataKey {
 static constexpr char EntryPoint[] = ".entry_point";
 static constexpr char ScratchMemorySize[] = ".scratch_memory_size";
 static constexpr char LdsSize[] = ".lds_size";
 static constexpr char PerfDataBufferSize[] = ".perf_data_buffer_size";
@@ -169,20 +172,24 @@ enum class UserDataMapping : unsigned {
                                      //  only appear for one shader stage per pipeline.
   NggCullingData = 0x10000011,       // 64-bit pointer to GPU memory containing the hardware register data needed by
                                      //  some NGG pipelines to perform culling.  This value contains the address of the
                                      //  first of two consecutive registers which provide the full GPU address.
   MeshTaskDispatchDims = 0x10000012, // Offset to three consecutive registers which indicate the number of
                                      //  threadgroups dispatched in the X, Y, and Z dimensions.
   MeshTaskRingIndex = 0x10000013,    // Index offset (32-bit unsigned integer). Indicates the index into the
                                      //  Mesh/Task shader rings for the shader to consume.
   MeshPipeStatsBuf = 0x10000014,     // 32-bit GPU virtual address of a buffer storing the shader-emulated mesh
                                      //  pipeline stats query.
+#if LLPC_BUILD_GFX11
+  StreamOutControlBuf = 0x10000016, // 32-bit GPU virtual address to the streamout control buffer for GPUs that
+                                    // use SW-emulated streamout.
+#endif
 
   // Values used in a user data PAL metadata register to be resolved at link time.
   // This is part of the "unlinked" ABI, so should arguably be in AbiUnlinked.h.
   DescriptorSet0 = 0x80000000,   // 32-bit pointer to the descriptor table for descriptor set 0: add N to this value
                                  //  for descriptor set N
   DescriptorSetMax = 0x800000FF, // Max descriptor set
   PushConst0 = 0x80000100,       // Push constant dword 0: add N to this value for push constant dword N
   PushConstMax = 0x800001FF,     // Max push constant dword
 
   // Value used internally in LGC.
@@ -256,20 +263,23 @@ constexpr unsigned mmSPI_SHADER_Z_FORMAT = 0xA1C4;
 constexpr unsigned mmCB_SHADER_MASK = 0xA08F;
 
 // PS register numbers in PAL metadata
 constexpr unsigned mmSPI_PS_INPUT_CNTL_0 = 0xA191; // NOLINT
 constexpr unsigned mmSPI_PS_INPUT_ENA = 0xA1B3;
 constexpr unsigned mmSPI_PS_INPUT_ADDR = 0xA1B4;
 constexpr unsigned mmSPI_PS_IN_CONTROL = 0xA1B6;
 constexpr unsigned mmPA_SC_SHADER_CONTROL = 0xA310;
 constexpr unsigned mmPA_SC_AA_CONFIG = 0xA2F8;
 
+// GS register numbers in PAL metadata
+constexpr unsigned mmVGT_GS_OUT_PRIM_TYPE = 0xA29B;
+
 // Register bitfield layout.
 
 // General RSRC1 register, enough to get the VGPR and SGPR counts.
 union SPI_SHADER_PGM_RSRC1 {
   struct {
     unsigned int VGPRS : 6;
     unsigned int SGPRS : 4;
     unsigned int : 2;
     unsigned int FLOAT_MODE : 8;
     unsigned int : 12;
diff --git a/lgc/include/lgc/state/Defs.h b/lgc/include/lgc/state/Defs.h
index b33b11f1f..2a9ae4b66 100644
--- a/lgc/include/lgc/state/Defs.h
+++ b/lgc/include/lgc/state/Defs.h
@@ -112,26 +112,34 @@ const static char LateBufferPtrDiff[] = "lgc.late.buffer.ptrdiff";
 const static char ImmutableSamplerGlobal[] = "lgc.immutable.sampler";
 const static char ImmutableConvertingSamplerGlobal[] = "lgc.immutable.converting.sampler";
 
 // Names of entry-points for merged shader
 const static char EsGsEntryPoint[] = "lgc.shader.ESGS.main";
 const static char LsHsEntryPoint[] = "lgc.shader.LSHS.main";
 
 const static char NggEsEntryPoint[] = "lgc.ngg.ES.main";
 const static char NggEsCullDataFetch[] = "lgc.ngg.ES.cull.data.fetch";
 const static char NggEsDeferredVertexExport[] = "lgc.ngg.ES.deferred.vertex.export";
+#if LLPC_BUILD_GFX11
+const static char NggEsXfbOutputFetch[] = "lgc.ngg.ES.xfb.output.fetch";
+const static char NggAttribExport[] = "lgc.ngg.attrib.export";
+const static char NggXfbOutputExport[] = "lgc.ngg.xfb.output.export.";
+#endif
 
 const static char NggGsEntryPoint[] = "lgc.ngg.GS.main";
 const static char NggGsOutputExport[] = "lgc.ngg.GS.output.export.";
 const static char NggGsOutputImport[] = "lgc.ngg.GS.output.import.";
 const static char NggGsEmit[] = "lgc.ngg.GS.emit";
 const static char NggGsCut[] = "lgc.ngg.GS.cut";
+#if LLPC_BUILD_GFX11
+const static char NggGsXfbOutputFetch[] = "lgc.ngg.GS.xfb.output.fetch";
+#endif
 
 const static char NggCopyShaderEntryPoint[] = "lgc.ngg.COPY.main";
 const static char NggPrimShaderEntryPoint[] = "lgc.shader.PRIM.main";
 
 const static char NggCullingFetchReg[] = "lgc.ngg.culling.fetchreg";
 const static char NggCullingBackface[] = "lgc.ngg.culling.backface";
 const static char NggCullingFrustum[] = "lgc.ngg.culling.frustum";
 const static char NggCullingBoxFilter[] = "lgc.ngg.culling.boxfilter";
 const static char NggCullingSphere[] = "lgc.ngg.culling.sphere";
 const static char NggCullingSmallPrimFilter[] = "lgc.ngg.culling.smallprimfilter";
diff --git a/lgc/include/lgc/state/IntrinsDefs.h b/lgc/include/lgc/state/IntrinsDefs.h
index 4fbe7e600..8fa6d7eef 100644
--- a/lgc/include/lgc/state/IntrinsDefs.h
+++ b/lgc/include/lgc/state/IntrinsDefs.h
@@ -72,29 +72,33 @@ enum AddrSpace {
   ADDR_SPACE_LOCAL = 3,              // Local memory
   ADDR_SPACE_CONST = 4,              // Constant memory
   ADDR_SPACE_PRIVATE = 5,            // Private memory
   ADDR_SPACE_CONST_32BIT = 6,        // Constant 32-bit memory
   ADDR_SPACE_BUFFER_FAT_POINTER = 7, // Buffer fat-pointer memory
   ADDR_SPACE_MAX = ADDR_SPACE_BUFFER_FAT_POINTER
 };
 
 // Enumerates the target for "export" instruction.
 enum ExportTarget {
-  EXP_TARGET_MRT_0 = 0,     // MRT 0..7
-  EXP_TARGET_Z = 8,         // Z
-  EXP_TARGET_PS_NULL = 9,   // Null pixel shader export (no data)
-  EXP_TARGET_POS_0 = 12,    // Position 0
-  EXP_TARGET_POS_1 = 13,    // Position 1
-  EXP_TARGET_POS_2 = 14,    // Position 2
-  EXP_TARGET_POS_3 = 15,    // Position 3
-  EXP_TARGET_POS_4 = 16,    // Position 4
-  EXP_TARGET_PRIM = 20,     // NGG primitive data (connectivity data)
+  EXP_TARGET_MRT_0 = 0,   // MRT 0..7
+  EXP_TARGET_Z = 8,       // Z
+  EXP_TARGET_PS_NULL = 9, // Null pixel shader export (no data)
+  EXP_TARGET_POS_0 = 12,  // Position 0
+  EXP_TARGET_POS_1 = 13,  // Position 1
+  EXP_TARGET_POS_2 = 14,  // Position 2
+  EXP_TARGET_POS_3 = 15,  // Position 3
+  EXP_TARGET_POS_4 = 16,  // Position 4
+  EXP_TARGET_PRIM = 20,   // NGG primitive data (connectivity data)
+#if LLPC_BUILD_GFX11
+  EXP_TARGET_DUAL_SRC_0 = 21, // Dual source blend left
+  EXP_TARGET_DUAL_SRC_1 = 22, // Dual source blend right
+#endif
   EXP_TARGET_PARAM_0 = 32,  // Param 0
                             // Param 1..30
   EXP_TARGET_PARAM_31 = 63, // Param 31
 };
 
 // Enumerates shader export format used for "export" instruction.
 enum ExportFormat {
   EXP_FORMAT_ZERO = 0,         // ZERO
   EXP_FORMAT_32_R = 1,         // 32_R
   EXP_FORMAT_32_GR = 2,        // 32_GR
@@ -395,20 +399,56 @@ enum BufFormat {
   BUF_FORMAT_16_16_16_16_UINT_GFX10 = 0x00000045,
   BUF_FORMAT_16_16_16_16_SINT_GFX10 = 0x00000046,
   BUF_FORMAT_16_16_16_16_FLOAT_GFX10 = 0x00000047,
   BUF_FORMAT_32_32_32_UINT_GFX10 = 0x00000048,
   BUF_FORMAT_32_32_32_SINT_GFX10 = 0x00000049,
   BUF_FORMAT_32_32_32_FLOAT_GFX10 = 0x0000004A,
   BUF_FORMAT_32_32_32_32_UINT_GFX10 = 0x0000004B,
   BUF_FORMAT_32_32_32_32_SINT_GFX10 = 0x0000004C,
   BUF_FORMAT_32_32_32_32_FLOAT_GFX10 = 0x0000004D,
 
+#if LLPC_BUILD_GFX11
+  BUF_FORMAT_10_11_11_FLOAT_GFX11 = 0x0000001E,
+  BUF_FORMAT_11_11_10_FLOAT_GFX11 = 0x0000001F,
+  BUF_FORMAT_10_10_10_2_UNORM_GFX11 = 0x00000020,
+  BUF_FORMAT_10_10_10_2_SNORM_GFX11 = 0x00000021,
+  BUF_FORMAT_10_10_10_2_UINT_GFX11 = 0x00000022,
+  BUF_FORMAT_10_10_10_2_SINT_GFX11 = 0x00000023,
+  BUF_FORMAT_2_10_10_10_UNORM_GFX11 = 0x00000024,
+  BUF_FORMAT_2_10_10_10_SNORM_GFX11 = 0x00000025,
+  BUF_FORMAT_2_10_10_10_USCALED_GFX11 = 0x00000026,
+  BUF_FORMAT_2_10_10_10_SSCALED_GFX11 = 0x00000027,
+  BUF_FORMAT_2_10_10_10_UINT_GFX11 = 0x00000028,
+  BUF_FORMAT_2_10_10_10_SINT_GFX11 = 0x00000029,
+  BUF_FORMAT_8_8_8_8_UNORM_GFX11 = 0x0000002A,
+  BUF_FORMAT_8_8_8_8_SNORM_GFX11 = 0x0000002B,
+  BUF_FORMAT_8_8_8_8_USCALED_GFX11 = 0x0000002C,
+  BUF_FORMAT_8_8_8_8_SSCALED_GFX11 = 0x0000002D,
+  BUF_FORMAT_8_8_8_8_UINT_GFX11 = 0x0000002E,
+  BUF_FORMAT_8_8_8_8_SINT_GFX11 = 0x0000002F,
+  BUF_FORMAT_32_32_UINT_GFX11 = 0x00000030,
+  BUF_FORMAT_32_32_SINT_GFX11 = 0x00000031,
+  BUF_FORMAT_32_32_FLOAT_GFX11 = 0x00000032,
+  BUF_FORMAT_16_16_16_16_UNORM_GFX11 = 0x00000033,
+  BUF_FORMAT_16_16_16_16_SNORM_GFX11 = 0x00000034,
+  BUF_FORMAT_16_16_16_16_USCALED_GFX11 = 0x00000035,
+  BUF_FORMAT_16_16_16_16_SSCALED_GFX11 = 0x00000036,
+  BUF_FORMAT_16_16_16_16_UINT_GFX11 = 0x00000037,
+  BUF_FORMAT_16_16_16_16_SINT_GFX11 = 0x00000038,
+  BUF_FORMAT_16_16_16_16_FLOAT_GFX11 = 0x00000039,
+  BUF_FORMAT_32_32_32_UINT_GFX11 = 0x0000003A,
+  BUF_FORMAT_32_32_32_SINT_GFX11 = 0x0000003B,
+  BUF_FORMAT_32_32_32_FLOAT_GFX11 = 0x0000003C,
+  BUF_FORMAT_32_32_32_32_UINT_GFX11 = 0x0000003D,
+  BUF_FORMAT_32_32_32_32_SINT_GFX11 = 0x0000003E,
+  BUF_FORMAT_32_32_32_32_FLOAT_GFX11 = 0x0000003F,
+#endif
 };
 
 // Enumerates destination selection of data in memory buffer.
 enum BufDstSel {
   BUF_DST_SEL_0 = 0, // SEL_0 (0.0)
   BUF_DST_SEL_1 = 1, // SEL_1 (1.0)
   BUF_DST_SEL_X = 4, // SEL_X (X)
   BUF_DST_SEL_Y = 5, // SEL_Y (Y)
   BUF_DST_SEL_Z = 6, // SEL_Z (Z)
   BUF_DST_SEL_W = 7, // SEL_W (W)
@@ -464,20 +504,27 @@ union SqBufRsrcWord0 {
 
 // Represents the second dword of buffer descriptor SQ_BUF_RSRC_WORD1.
 union SqBufRsrcWord1 {
   struct {
     unsigned baseAddressHi : 16;
     unsigned stride : 14;
     unsigned cacheSwizzle : 1;
     unsigned swizzleEnable : 1;
   } bits;
 
+#if LLPC_BUILD_GFX11
+  struct {
+    unsigned : 30;
+    unsigned swizzleEnable : 2;
+  } gfx11;
+#endif
+
   unsigned u32All;
 };
 
 // Represents the third dword of buffer descriptor SQ_BUF_RSRC_WORD2.
 union SqBufRsrcWord2 {
   struct {
     unsigned numRecords : 32;
   } bits;
 
   unsigned u32All;
@@ -513,20 +560,30 @@ union SqBufRsrcWord3 {
   struct {
     unsigned : 12;
     unsigned format : 7;
     unsigned : 5;
     unsigned resourceLevel : 1;
     unsigned : 3;
     unsigned oobSelect : 2;
     unsigned : 2;
   } gfx10;
 
+#if LLPC_BUILD_GFX11
+  struct {
+    unsigned : 12;
+    unsigned format : 6;
+    unsigned : 10;
+    unsigned oobSelect : 2;
+    unsigned : 2;
+  } gfx11;
+#endif
+
   unsigned u32All;
 };
 
 // Represent register fields of PA_SU_SC_MODE_CNTL
 union PaSuScModeCntl {
   struct {
     unsigned cullFront : 1;
     unsigned cullBack : 1;
     unsigned face : 1;
     unsigned polyMode : 2;
diff --git a/lgc/include/lgc/state/PalMetadata.h b/lgc/include/lgc/state/PalMetadata.h
index 50309ea58..5cc057043 100644
--- a/lgc/include/lgc/state/PalMetadata.h
+++ b/lgc/include/lgc/state/PalMetadata.h
@@ -123,22 +123,22 @@ public:
   void setUserDataEntry(ShaderStage stage, unsigned userDataIndex, unsigned userDataValue, unsigned dwordCount = 1);
   void setUserDataEntry(ShaderStage stage, unsigned userDataIndex, UserDataMapping userDataValue,
                         unsigned dwordCount = 1) {
     setUserDataEntry(stage, userDataIndex, static_cast<unsigned>(userDataValue), dwordCount);
   }
 
   // Mark that the user data spill table is used at the given offset. The SpillThreshold PAL metadata entry is
   // set to the minimum of any call to this function in any shader.
   void setUserDataSpillUsage(unsigned dwordOffset);
 
-  // Fix up user data registers. Any user data register that has one of the unlinked UserDataMapping values defined
-  // in AbiUnlinked.h is fixed up by looking at pipeline state.
+  // Fix up registers. Any user data register that has one of the unlinked UserDataMapping values defined in
+  // AbiUnlinked.h is fixed up by looking at pipeline state; And some dynamic states also need to be fixed.
   void fixUpRegisters();
 
   // Get a register value in PAL metadata.
   unsigned getRegister(unsigned regNum);
 
   // Set a register value in PAL metadata. If the register has a value set already, it gets overwritten.
   void setRegister(unsigned regNum, unsigned value);
 
   // Store the vertex fetch in PAL metadata for a fetchless vertex shader with shader compilation.
   void addVertexFetchInfo(llvm::ArrayRef<VertexFetchInfo> fetches);
diff --git a/lgc/include/lgc/state/PipelineState.h b/lgc/include/lgc/state/PipelineState.h
index 82f0d71cc..abfba4bb2 100644
--- a/lgc/include/lgc/state/PipelineState.h
+++ b/lgc/include/lgc/state/PipelineState.h
@@ -111,20 +111,27 @@ struct NggControl {
 
   unsigned primsPerSubgroup; // Preferred number of GS primitives to pack into a primitive shader
                              // sub-group
 
   unsigned vertsPerSubgroup; // Preferred number of vertices consumed by a primitive shader sub-group
 
   bool passthroughMode;                          // Whether NGG passthrough mode is enabled
   Util::Abi::PrimShaderCbLayout primShaderTable; // Primitive shader table (only some registers are used)
 };
 
+// Represents transform feedback state metadata
+struct XfbStateMetadata {
+  bool enableXfb;                                               // Whether transform feedback is active
+  std::array<unsigned, MaxTransformFeedbackBuffers> xfbStrides; // The strides of each XFB buffer.
+  std::array<int, MaxGsStreams> streamXfbBuffers;               // The stream-out XFB buffers bit mask per stream.
+};
+
 // =====================================================================================================================
 // The middle-end implementation of PipelineState, a subclass of Pipeline.
 class PipelineState final : public Pipeline {
 public:
   PipelineState(LgcContext *builderContext, bool emitLgc = false);
 
   ~PipelineState() override final;
 
   // -----------------------------------------------------------------------------------------------------------------
   // Implementations of Pipeline methods exposed to the front-end
@@ -275,45 +282,58 @@ public:
 
   // Set GS on-chip mode
   void setGsOnChip(bool gsOnChip) { m_gsOnChip = gsOnChip; }
 
   // Checks whether GS on-chip mode is enabled
   // NOTE: GS on-chip mode has different meaning for GFX6~8 and GFX9: on GFX6~8, GS on-chip mode means ES -> GS ring
   // and GS -> VS ring are both on-chip; on GFX9, ES -> GS ring is always on-chip, GS on-chip mode means GS -> VS
   // ring is on-chip.
   bool isGsOnChip() const { return m_gsOnChip; }
 
+#if LLPC_BUILD_GFX11
+  // Determine whether can use tessellation factor optimization
+  bool canOptimizeTessFactor();
+#endif
+
   // Gets wave size for the specified shader stage
   unsigned getShaderWaveSize(ShaderStage stage);
   // Gets wave size for the merged shader stage
   unsigned getMergedShaderWaveSize(ShaderStage stage);
   // Gets subgroup size for the specified shader stage
   unsigned getShaderSubgroupSize(ShaderStage stage);
 
   // Set the default wave size for the specified shader stage
   void setShaderDefaultWaveSize(ShaderStage stage);
 
   // Set the wave size for the specified shader stage
   void setShaderWaveSize(ShaderStage stage, unsigned waveSize) {
     assert(waveSize == 32 || waveSize == 64);
     m_waveSize[stage] = waveSize;
   }
 
+  // Whether WGP mode is enabled for the given shader stage
+  bool getShaderWgpMode(ShaderStage stage) const;
+
   // Get NGG control settings
   NggControl *getNggControl() { return &m_nggControl; }
 
   // Checks if SW-emulated mesh pipeline statistics is needed
   bool needSwMeshPipelineStats() const;
 
   // Checks if row export for mesh shader is enabled or not
   bool enableMeshRowExport() const;
 
+#if LLPC_BUILD_GFX11
+  // Checks if SW-emulated stream-out should be enabled
+  bool enableSwXfb() const;
+#endif
+
   // Gets resource usage of the specified shader stage
   ResourceUsage *getShaderResourceUsage(ShaderStage shaderStage);
 
   // Gets interface data of the specified shader stage
   InterfaceData *getShaderInterfaceData(ShaderStage shaderStage);
 
   // Accessor for PAL metadata
   PalMetadata *getPalMetadata();
 
   // Clear PAL metadata object from PipelineState
@@ -348,20 +368,46 @@ public:
 
   // -----------------------------------------------------------------------------------------------------------------
   // Utility methods
 
   // Translate enum "ResourceNodeType" to string
   static const char *getResourceNodeTypeName(ResourceNodeType type);
 
   // Get name of built-in
   static llvm::StringRef getBuiltInName(BuiltInKind builtIn);
 
+  // Set transform feedback state metadata
+  void setXfbStateMetadata(llvm::Module *module);
+
+  // Get XFB state metadata
+  const XfbStateMetadata &getXfbStateMetadata() const { return m_xfbStateMetadata; }
+
+  // Get XFB state metadata
+  XfbStateMetadata &getXfbStateMetadata() { return m_xfbStateMetadata; }
+
+  // Check if transform feedback is active
+  bool enableXfb() const { return m_xfbStateMetadata.enableXfb; }
+
+  // Get transform feedback strides
+  const std::array<unsigned, MaxTransformFeedbackBuffers> &getXfbBufferStrides() const {
+    return m_xfbStateMetadata.xfbStrides;
+  }
+
+  // Get transform feedback strides
+  std::array<unsigned, MaxTransformFeedbackBuffers> &getXfbBufferStrides() { return m_xfbStateMetadata.xfbStrides; }
+
+  // Get transform feedback buffers used for each stream
+  const std::array<int, MaxGsStreams> &getStreamXfbBuffers() const { return m_xfbStateMetadata.streamXfbBuffers; }
+
+  // Get transform feedback buffers used for each stream
+  std::array<int, MaxGsStreams> &getStreamXfbBuffers() { return m_xfbStateMetadata.streamXfbBuffers; }
+
   // -----------------------------------------------------------------------------------------------------------------
   // Utility method templates to read and write IR metadata, used by PipelineState and ShaderModes
 
   // Get a metadata node containing an array of i32 values, which can be read from any type.
   // The array is trimmed to remove trailing zero values. If the whole array would be 0, then this function
   // returns nullptr.
   //
   // @param context : LLVM context
   // @param value : Value to write as array of i32
   // @param atLeastOneValue : True to generate node with one value even if all values are zero
@@ -507,20 +553,21 @@ private:
   InputAssemblyState m_inputAssemblyState = {};                                // Input-assembly state
   RasterizerState m_rasterizerState = {};                                      // Rasterizer state
   DepthStencilState m_depthStencilState = {};                                  // Depth/stencil state
   std::unique_ptr<ResourceUsage> m_resourceUsage[ShaderStageCompute + 1] = {}; // Per-shader ResourceUsage
   std::unique_ptr<InterfaceData> m_interfaceData[ShaderStageCompute + 1] = {}; // Per-shader InterfaceData
   PalMetadata *m_palMetadata = nullptr;                                        // PAL metadata object
   unsigned m_waveSize[ShaderStageCountInternal] = {};                          // Per-shader wave size
   unsigned m_subgroupSize[ShaderStageCountInternal] = {};                      // Per-shader subgroup size
   bool m_inputPackState[ShaderStageGfxCount] = {};  // The input packable state per shader stage
   bool m_outputPackState[ShaderStageGfxCount] = {}; // The output packable state per shader stage
+  XfbStateMetadata m_xfbStateMetadata = {};         // Transform feedback state metadata
 };
 
 // =====================================================================================================================
 // PipelineStateWrapper analysis result
 class PipelineStateWrapperResult {
 public:
   PipelineStateWrapperResult(PipelineState *pipelineState);
   PipelineState *getPipelineState() { return m_pipelineState; }
 
   bool invalidate(llvm::Module &, const llvm::PreservedAnalyses &, llvm::ModuleAnalysisManager::Invalidator &) {
diff --git a/lgc/include/lgc/state/ResourceUsage.h b/lgc/include/lgc/state/ResourceUsage.h
index e85f09bd5..ed3d3ab23 100644
--- a/lgc/include/lgc/state/ResourceUsage.h
+++ b/lgc/include/lgc/state/ResourceUsage.h
@@ -111,32 +111,41 @@ public:
 
   unsigned getComponent() const { return m_data.bits.component; }
   void setComponent(unsigned compIdx) { m_data.bits.component = static_cast<uint16_t>(compIdx); }
 
   unsigned getLocation() const { return m_data.bits.location; }
   void setLocation(unsigned loc) { m_data.bits.location = static_cast<uint16_t>(loc); }
 
   bool isBuiltIn() const { return m_data.bits.isBuiltIn; }
   void setBuiltIn(bool isBuiltIn) { m_data.bits.isBuiltIn = isBuiltIn; }
 
+  bool isFlat() const { return m_data.bits.isFlat; }
+  void setFlat(bool isFlat) { m_data.bits.isFlat = isFlat; }
+
+  bool isCustom() const { return m_data.bits.isCustom; }
+  void setCustom(bool isCustom) { m_data.bits.isCustom = isCustom; }
+
   unsigned getStreamId() const { return m_data.bits.streamId; }
   void setStreamId(unsigned streamId) { m_data.bits.streamId = static_cast<uint16_t>(streamId); }
 
   bool operator<(const InOutLocationInfo &rhs) const { return this->getData() < rhs.getData(); }
+  bool operator!=(const InOutLocationInfo &rhs) const { return this->getData() != rhs.getData(); }
 
 private:
   union {
     struct {
       uint16_t isHighHalf : 1; // High half in case of 16-bit attributes
       uint16_t component : 2;  // The component index
-      uint16_t location : 10;  // The location
+      uint16_t location : 8;   // The location
       uint16_t isBuiltIn : 1;  // Whether location is actually built-in ID
+      uint16_t isFlat : 1;     // Whether is flat shading
+      uint16_t isCustom : 1;   // Whether is custom interpolation
       uint16_t streamId : 2;   // Output vertex stream ID
     } bits;
     uint16_t u16All;
   } m_data;
 };
 
 // Enumerate the workgroup layout options.
 enum class WorkgroupLayout : unsigned {
   Unknown = 0,   // ?x?
   Linear,        // 4x1
@@ -149,20 +158,24 @@ enum class WorkgroupLayout : unsigned {
 // NOTE: All fields must be initialized in InitShaderResourceUsage().
 struct ResourceUsage {
   std::unordered_set<uint64_t> descPairs;  // Pairs of descriptor set/binding
   bool resourceWrite = false;              // Whether shader does resource-write operations (UAV)
   bool resourceRead = false;               // Whether shader does resource-read operations (UAV)
   bool perShaderTable = false;             // Whether per shader stage table is used
   unsigned numSgprsAvailable = UINT32_MAX; // Number of available SGPRs
   unsigned numVgprsAvailable = UINT32_MAX; // Number of available VGPRs
   bool useImages = false;                  // Whether images are used
 
+#if LLPC_BUILD_GFX11
+  bool useImageOp = false; // Whether image instruction is called (for GFX11+, pixel wait sync+)
+#endif
+
 #if VKI_RAY_TRACING
   bool useRayQueryLdsStack = false; // Whether ray query uses LDS stack
 #endif
 
   // Usage of built-ins
   struct {
     // Per-stage built-in usage
     union {
       // Vertex shader
       struct {
@@ -339,28 +352,28 @@ struct ResourceUsage {
     // Map from built-in IDs to specially assigned locations
     std::map<unsigned, unsigned> builtInInputLocMap;
     std::map<unsigned, unsigned> builtInOutputLocMap;
 
     std::map<unsigned, unsigned> perPatchBuiltInInputLocMap;
     std::map<unsigned, unsigned> perPatchBuiltInOutputLocMap;
 
     std::map<unsigned, unsigned> perPrimitiveBuiltInInputLocMap;
     std::map<unsigned, unsigned> perPrimitiveBuiltInOutputLocMap;
 
-    // Transform feedback strides
-    unsigned xfbStrides[MaxTransformFeedbackBuffers] = {};
-
-    // Transform feedback enablement
-    bool enableXfb = false;
+    // Map from output location info to the transform feedback info
+    std::map<InOutLocationInfo, XfbOutInfo> locInfoXfbOutInfoMap;
 
-    // Stream to transform feedback buffers
-    unsigned streamXfbBuffers[MaxGsStreams] = {};
+#if LLPC_BUILD_GFX11
+    // Count of transform feedback output export call (each call is to export <4 x dword> at most), used in SW emulated
+    // stream-out for GFX11+
+    unsigned xfbOutputExpCount = 0;
+#endif
 
     // Count of mapped location for inputs/outputs (including those special locations to which the built-ins
     // are mapped)
     unsigned inputMapLocCount = 0;
     unsigned outputMapLocCount = 0;
     unsigned perPatchInputMapLocCount = 0;
     unsigned perPatchOutputMapLocCount = 0;
     unsigned perPrimitiveInputMapLocCount = 0;
     unsigned perPrimitiveOutputMapLocCount = 0;
 
@@ -375,60 +388,63 @@ struct ResourceUsage {
                                            // "hsCpStride")
         unsigned patchCountPerThreadGroup; // Count of patches per thread group (in dword, correspond to
                                            // "hsNumPatch")
         // On-chip calculation factors
         struct {
           unsigned outPatchStart;   // Offset into LDS where vertices of output patches start
                                     // (in dword, correspond to "hsOutputBase")
           unsigned patchConstStart; // Offset into LDS where patch constants start (in dword,
                                     // correspond to "patchConstBase")
           unsigned tessFactorStart; // Offset into LDS where tess factor start (in dword)
+#if LLPC_BUILD_GFX11
+          unsigned hsPatchCountStart;   // Offset into LDS where count of HS patches start (in dword)
+          unsigned specialTfValueStart; // Offset into LDS where special TF value start (in dword)
+#endif
         } onChip;
 
         // Off-chip calculation factors
         struct {
           unsigned outPatchStart;   // Offset into LDS where vertices of output patches start
                                     // (in dword, correspond to "hsOutputBase")
           unsigned patchConstStart; // Offset into LDS where patch constants start (in dword,
                                     // correspond to "patchConstBase")
         } offChip;
 
         unsigned inPatchSize; // size of an input patch size (in dword)
 
         unsigned outPatchSize; // Size of an output patch output (in dword, correspond to
                                // "patchOutputSize")
 
         unsigned patchConstSize;   // Size of an output patch constants (in dword)
         unsigned tessFactorStride; // Size of tess factor stride (in dword)
-
+#if LLPC_BUILD_GFX11
+        unsigned specialTfValueSize; // Size of special TF value (in dword)
+#endif
         unsigned tessOnChipLdsSize; // On-chip LDS size (exclude off-chip LDS buffer) (in dword)
 #if VKI_RAY_TRACING
         unsigned rayQueryLdsStackSize; // Ray query LDS stack size
 #endif
 
         bool initialized; // Whether calcFactor has been initialized
       } calcFactor;
     } tcs = {};
 
     struct {
       // Map from IDs of built-in outputs to locations of generic outputs (used by copy shader to export built-in
       // outputs to fragment shader, always from vertex stream 0)
       std::map<unsigned, unsigned> builtInOutLocs;
 
       // Map from tightly packed locations to byte sizes of generic outputs (used by copy shader to
       // export generic outputs to fragment shader, always from vertex stream 0):
       //   <location, <component, byteSize>>
       std::unordered_map<unsigned, std::vector<unsigned>> genericOutByteSizes[MaxGsStreams];
 
-      // Map from output location info to the transform feedback info
-      std::map<InOutLocationInfo, XfbOutInfo> locInfoXfbOutInfoMap;
-
       // ID of the vertex stream sent to rasterizer
       unsigned rasterStream = 0;
 
       struct {
         unsigned esGsRingItemSize;   // Size of each vertex written to the ES -> GS Ring, in dwords.
         unsigned gsVsRingItemSize;   // Size of each primitive written to the GS -> VS Ring, in dwords.
         unsigned esVertsPerSubgroup; // Number of vertices ES exports.
         unsigned gsPrimsPerSubgroup; // Number of prims GS exports.
         unsigned esGsLdsSize;        // ES -> GS ring LDS size (GS in)
         unsigned gsOnChipLdsSize;    // Total LDS size for GS on-chip mode.
@@ -472,21 +488,24 @@ struct ResourceUsage {
       unsigned cbShaderMask;                  // CB shader channel mask (correspond to register CB_SHADER_MASK)
       bool isNullFs;                          // Is null FS, so should set final cbShaderMask to 0
     } fs;
   } inOutUsage;
 
   ResourceUsage(ShaderStage shaderStage);
 };
 
 // Represents stream-out data
 struct StreamOutData {
-  unsigned tablePtr;                                   // Table pointer for stream-out
+  unsigned tablePtr; // Table pointer for stream-out
+#if LLPC_BUILD_GFX11
+  unsigned controlBufPtr; // Control buffer pointer for stream-out (GFX11+)
+#endif
   unsigned streamInfo;                                 // Stream-out info (ID, vertex count, enablement)
   unsigned writeIndex;                                 // Write index for stream-out
   unsigned streamOffsets[MaxTransformFeedbackBuffers]; // Stream-out Offset
 };
 
 // Represents interface data used by shader stages
 //
 // NOTE: All fields must be initialized in InitShaderInterfaceData().
 struct InterfaceData {
   static const unsigned MaxDescTableCount = 64; // Must greater than (vk::MaxDynamicDescriptors +
@@ -502,20 +521,23 @@ struct InterfaceData {
   struct {
     unsigned sizeInDwords = 0; // Spill table size in dwords
   } spillTable;
 
   // Usage of user data registers for internal-use variables
   struct {
     // Geometry shader
     struct {
       unsigned copyShaderEsGsLdsSize;    // ES -> GS ring LDS size (for copy shader)
       unsigned copyShaderStreamOutTable; // Stream-out table (for copy shader)
+#if LLPC_BUILD_GFX11
+      unsigned copyShaderStreamOutControlBuf; // Stream-out control buffer (for copy shader)
+#endif
     } gs;
 
     unsigned spillTable; // Spill table user data map
 
   } userDataUsage = {};
 
   // Indices of the arguments in shader entry-point
   struct {
     union {
       // Task shader
@@ -579,21 +601,22 @@ struct InterfaceData {
         unsigned drawIndex;          // Draw index
         unsigned viewIndex;          // View index
         unsigned dispatchDims;       // Dispatch dimensions
         unsigned baseRingEntryIndex; // Base entry index (first workgroup) of mesh/task shader ring for current dispatch
         unsigned pipeStatsBuf;       // Pipeline statistics buffer
         unsigned flatWorkgroupId;    // Flat workgroup ID (emulated by HW vertex ID)
       } mesh;
 
       // Fragment shader
       struct {
-        unsigned primMask; // Primitive mask
+        unsigned viewIndex; // View Index
+        unsigned primMask;  // Primitive mask
 
         // Perspective interpolation (I/J)
         struct {
           unsigned sample;   // Sample
           unsigned center;   // Center
           unsigned centroid; // Centroid
           unsigned pullMode; // Pull-mode
         } perspInterp;
 
         // Linear interpolation (I/J)
diff --git a/lgc/include/lgc/state/TargetInfo.h b/lgc/include/lgc/state/TargetInfo.h
index 974459ec4..48ff9c338 100644
--- a/lgc/include/lgc/state/TargetInfo.h
+++ b/lgc/include/lgc/state/TargetInfo.h
@@ -41,20 +41,23 @@ struct GfxIpVersion {
   unsigned minor;    // Minor version
   unsigned stepping; // Stepping info
 
   // GFX IP checkers
   bool operator==(const GfxIpVersion &rhs) const {
     return std::tie(major, minor, stepping) == std::tie(rhs.major, rhs.minor, rhs.stepping);
   }
   bool operator>=(const GfxIpVersion &rhs) const {
     return std::tie(major, minor, stepping) >= std::tie(rhs.major, rhs.minor, rhs.stepping);
   }
+  bool isGfx(unsigned rhsMajor, unsigned rhsMinor) const {
+    return std::tie(major, minor) == std::tie(rhsMajor, rhsMinor);
+  }
 };
 
 // Represents the properties of GPU device.
 struct GpuProperty {
   unsigned numShaderEngines;                  // Number of shader engines present
   unsigned waveSize;                          // Wavefront size
   unsigned ldsSizePerThreadGroup;             // LDS size per thread group in dwords
   unsigned gsOnChipDefaultPrimsPerSubgroup;   // Default target number of primitives per subgroup for GS on-chip mode.
   unsigned gsOnChipDefaultLdsSizePerSubgroup; // Default value for the maximum LDS size per subgroup for
   unsigned gsOnChipMaxLdsSize;                // Max LDS size used by GS on-chip mode (in dwords)
@@ -138,20 +141,30 @@ struct WorkaroundFlags {
       unsigned waFixBadImageDescriptor : 1;
       unsigned waLimitedMaxOutputVertexCount : 1;
       unsigned waGeNggMaxVertOutWithGsInstancing : 1;
       unsigned waAdjustDepthImportVrs : 1;
       // Clear write compress bit in an image descriptor being used for a read operation.
       unsigned waClearWriteCompressBit : 1;
       unsigned reserved : 11;
     };
     unsigned u32All;
   } gfx10;
+
+#if LLPC_BUILD_GFX11
+  union {
+    struct {
+      unsigned waUserSgprInitBug : 1;
+      unsigned waAtmPrecedesPos : 1;
+    };
+    unsigned u32All;
+  } gfx11;
+#endif
 };
 
 // =====================================================================================================================
 // TargetInfo class, representing features and workarounds for the particular selected target
 class TargetInfo {
 public:
   // Set TargetInfo. Returns false if the GPU name is not found or not supported.
   bool setTargetInfo(llvm::StringRef gpuName);
 
   // Accessors.
diff --git a/lgc/interface/lgc/Builder.h b/lgc/interface/lgc/Builder.h
index 7a050e4b0..551849bf4 100644
--- a/lgc/interface/lgc/Builder.h
+++ b/lgc/interface/lgc/Builder.h
@@ -1105,20 +1105,21 @@ public:
   // @param nodePtr : BVH node pointer
   // @param extent : The valid range on which intersections can occur
   // @param origin : Intersect ray origin
   // @param direction : Intersect ray direction
   // @param invDirection : The inverse of direction
   // @param imageDesc : Image descriptor
   // @param instName : Name to give instruction(s)
   virtual llvm::Value *CreateImageBvhIntersectRay(llvm::Value *nodePtr, llvm::Value *extent, llvm::Value *origin,
                                                   llvm::Value *direction, llvm::Value *invDirection,
                                                   llvm::Value *imageDesc, const llvm::Twine &instName = "");
+
 #endif
 
   // -----------------------------------------------------------------------------------------------------------------
   // Shader input/output methods
 
   // Create a read of (part of) a generic (user) input value, passed from the previous shader stage.
   // The result type is as specified by resultTy, a scalar or vector type with no more than four elements.
   // A "location" can contain up to a 4-vector of 16- or 32-bit components, or up to a 2-vector of
   // 64-bit components. Two consecutive locations together can contain up to a 4-vector of 64-bit components.
   // A non-constant locationOffset is currently only supported for TCS and TES, and for an FS custom-interpolated
diff --git a/lgc/interface/lgc/PassManager.h b/lgc/interface/lgc/PassManager.h
index a4218ca06..c8ae0697a 100644
--- a/lgc/interface/lgc/PassManager.h
+++ b/lgc/interface/lgc/PassManager.h
@@ -25,39 +25,40 @@
 /**
  ***********************************************************************************************************************
  * @file  PassManager.h
  * @brief LLPC header file: contains declaration of class lgc::LegacyPassManager.
  ***********************************************************************************************************************
  */
 #pragma once
 
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/PassManager.h"
-#include "llvm/Target/TargetMachine.h"
 
 namespace lgc {
 
+class LgcContext;
+
 // =====================================================================================================================
 // Public interface of LLPC middle-end's legacy::PassManager override
 class LegacyPassManager : public llvm::legacy::PassManager {
 public:
   static LegacyPassManager *Create();
   virtual ~LegacyPassManager() {}
   virtual void stop() = 0;
   virtual void setPassIndex(unsigned *passIndex) = 0;
 };
 
 // =====================================================================================================================
 // Public interface of LLPC middle-end's PassManager override
 class PassManager : public llvm::ModulePassManager {
 public:
-  static PassManager *Create(llvm::TargetMachine *targetMachine = nullptr);
+  static PassManager *Create(LgcContext *lgcContext);
   virtual ~PassManager() {}
   template <typename PassBuilderT> bool registerFunctionAnalysis(PassBuilderT &&PassBuilder) {
     return m_functionAnalysisManager.registerPass(std::forward<PassBuilderT>(PassBuilder));
   }
   template <typename PassBuilderT> bool registerModuleAnalysis(PassBuilderT &&passBuilder) {
     return m_moduleAnalysisManager.registerPass(std::forward<PassBuilderT>(passBuilder));
   }
   // Register a pass to identify it with a short name in the pass manager
   virtual void registerPass(llvm::StringRef passName, llvm::StringRef className) = 0;
   virtual void run(llvm::Module &module) = 0;
diff --git a/lgc/interface/lgc/Pipeline.h b/lgc/interface/lgc/Pipeline.h
index 44f616e6a..394b8eb10 100644
--- a/lgc/interface/lgc/Pipeline.h
+++ b/lgc/interface/lgc/Pipeline.h
@@ -100,20 +100,22 @@ enum class ThreadGroupSwizzleMode : unsigned {
   Default = 0, // Use the default layout. There is no swizzling conducted.
   _4x4 = 1,    // The tile size is 4x4 in x and y dimension.
   _8x8 = 2,    // The tile size is 8x8 in x and y dimension.
   _16x16 = 3,  // The tile size is 16x16 in x and y dimension.
   Count,
 };
 
 // Value for shadowDescriptorTable pipeline option.
 static const unsigned ShadowDescriptorTableDisable = ~0U;
 
+static const char XfbStateMetadataName[] = "lgc.xfb.state";
+
 // Middle-end per-pipeline options to pass to SetOptions.
 // The front-end should zero-initialize it with "= {}" in case future changes add new fields.
 // Note: new fields must be added to the end of this structure to maintain test compatibility.
 struct Options {
   uint64_t hash[2];                    // Pipeline hash to set in ELF PAL metadata
   unsigned includeDisassembly;         // If set, the disassembly for all compiled shaders will be included
                                        //   in the pipeline ELF.
   unsigned reconfigWorkgroupLayout;    // If set, allows automatic workgroup reconfigure to take place on
                                        //   compute shaders.
   bool forceCsThreadIdSwizzling;       // Force rearranges threadId within group into blocks of 8*8 or 8*4.
@@ -132,23 +134,28 @@ struct Options {
   bool fullSubgroups;                  // Use full subgroup lanes
   unsigned nggVertsPerSubgroup;        // How to determine NGG verts per subgroup
   unsigned nggPrimsPerSubgroup;        // How to determine NGG prims per subgroup
   unsigned shadowDescriptorTable;      // High dword of shadow descriptor table address, or
                                        //   ShadowDescriptorTableDisable to disable shadow descriptor tables
   unsigned allowNullDescriptor;        // Allow and give defined behavior for null descriptor
   unsigned disableImageResourceCheck;  // Don't do image resource type check
   unsigned reserved0f;                 // Reserved for future functionality
   unsigned useResourceBindingRange;    // A resource node binding is the start of a range whose size is
                                        //  sizeInDwords/stride.
-  unsigned reserved1f;                 // Reserved for future functionality
-  unsigned enableInterpModePatch;      // Enable to do per-sample interpolation for nonperspective and smooth input
-  unsigned pageMigrationEnabled;       // Enable page migration
+#if LLPC_BUILD_GFX11
+  unsigned optimizeTessFactor; // If set, we can determine either send HT_TessFactor message or write to TF buffer
+                               // depending the values of tessellation factors.
+#else
+  unsigned reserved1f; // Reserved for future functionality
+#endif
+  unsigned enableInterpModePatch; // Enable to do per-sample interpolation for nonperspective and smooth input
+  unsigned pageMigrationEnabled;  // Enable page migration
   ResourceLayoutScheme resourceLayoutScheme;     // Resource layout scheme
   ThreadGroupSwizzleMode threadGroupSwizzleMode; // Thread group swizzle mode
   unsigned reverseThreadGroupBufferDescSet;      // Descriptor set ID of the internal buffer for reverse thread group
                                                  // optimization
   unsigned reverseThreadGroupBufferBinding; // Binding ID of the internal buffer for reverse thread group optimization
 #if VKI_RAY_TRACING
   bool internalRtShaders; // Enable internal RT shader intrinsics
 #else
   bool reserved15;
 #endif
diff --git a/lgc/patch/ConfigBuilderBase.cpp b/lgc/patch/ConfigBuilderBase.cpp
index 1691a35bb..a9a1883aa 100644
--- a/lgc/patch/ConfigBuilderBase.cpp
+++ b/lgc/patch/ConfigBuilderBase.cpp
@@ -305,20 +305,32 @@ void ConfigBuilderBase::setNggSubgroupSize(unsigned value) {
 // Set thread group dimensions
 //
 // @param values : Values to set
 void ConfigBuilderBase::setThreadgroupDimensions(llvm::ArrayRef<unsigned> values) {
   auto hwShaderNode = getHwShaderNode(Util::Abi::HardwareStage::Cs);
   auto &arrayNode = hwShaderNode[Util::Abi::HardwareStageMetadataKey::ThreadgroupDimensions].getArray(true);
   for (unsigned i = 0; i < values.size(); ++i)
     arrayNode[i] = values[i];
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Set stream-out vertex strides (GFX11+)
+//
+// @param values : Values to set
+void ConfigBuilderBase::setStreamOutVertexStrides(ArrayRef<unsigned> values) {
+  auto &arrayNode = m_pipelineNode[Util::Abi::PipelineMetadataKey::StreamOutVertexStrides].getArray(true);
+  for (unsigned i = 0; i < values.size(); ++i)
+    arrayNode[i] = values[i];
+}
+#endif
+
 // =====================================================================================================================
 /// Append a single entry to the PAL register metadata.
 ///
 /// @param [in] key : The metadata key (usually a register address).
 /// @param [in] value : The metadata value.
 void ConfigBuilderBase::appendConfig(unsigned key, unsigned value) {
   assert(key != InvalidMetadataKey);
 
   PalMetadataNoteEntry entry;
   entry.key = key;
@@ -379,32 +391,30 @@ void ConfigBuilderBase::writePalMetadata() {
 //
 // @param shaderStage : Shader stage
 unsigned ConfigBuilderBase::setupFloatingPointMode(ShaderStage shaderStage) {
   FloatMode floatMode = {};
   floatMode.bits.fp16fp64DenormMode = FP_DENORM_FLUSH_NONE;
   if (shaderStage != ShaderStageCopyShader) {
     const auto &shaderMode = m_pipelineState->getShaderModes()->getCommonShaderMode(shaderStage);
 
     // The HW rounding mode values happen to be one less than the FpRoundMode value, other than
     // FpRoundMode::DontCare, which we map to a default value.
-    floatMode.bits.fp16fp64RoundMode = shaderMode.fp16RoundMode != FpRoundMode::DontCare
-                                           ? static_cast<unsigned>(shaderMode.fp16RoundMode) - 1
-                                           : shaderMode.fp64RoundMode != FpRoundMode::DontCare
-                                                 ? static_cast<unsigned>(shaderMode.fp64RoundMode) - 1
-                                                 : FP_ROUND_TO_NEAREST_EVEN;
+    floatMode.bits.fp16fp64RoundMode =
+        shaderMode.fp16RoundMode != FpRoundMode::DontCare   ? static_cast<unsigned>(shaderMode.fp16RoundMode) - 1
+        : shaderMode.fp64RoundMode != FpRoundMode::DontCare ? static_cast<unsigned>(shaderMode.fp64RoundMode) - 1
+                                                            : FP_ROUND_TO_NEAREST_EVEN;
     floatMode.bits.fp32RoundMode = shaderMode.fp32RoundMode != FpRoundMode::DontCare
                                        ? static_cast<unsigned>(shaderMode.fp32RoundMode) - 1
                                        : FP_ROUND_TO_NEAREST_EVEN;
 
     // The denorm modes happen to be one less than the FpDenormMode value, other than
     // FpDenormMode::DontCare, which we map to a default value.
-    floatMode.bits.fp16fp64DenormMode = shaderMode.fp16DenormMode != FpDenormMode::DontCare
-                                            ? static_cast<unsigned>(shaderMode.fp16DenormMode) - 1
-                                            : shaderMode.fp64DenormMode != FpDenormMode::DontCare
-                                                  ? static_cast<unsigned>(shaderMode.fp64DenormMode) - 1
-                                                  : FP_DENORM_FLUSH_NONE;
+    floatMode.bits.fp16fp64DenormMode =
+        shaderMode.fp16DenormMode != FpDenormMode::DontCare   ? static_cast<unsigned>(shaderMode.fp16DenormMode) - 1
+        : shaderMode.fp64DenormMode != FpDenormMode::DontCare ? static_cast<unsigned>(shaderMode.fp64DenormMode) - 1
+                                                              : FP_DENORM_FLUSH_NONE;
     floatMode.bits.fp32DenormMode = shaderMode.fp32DenormMode != FpDenormMode::DontCare
                                         ? static_cast<unsigned>(shaderMode.fp32DenormMode) - 1
                                         : FP_DENORM_FLUSH_IN_OUT;
   }
   return floatMode.u32All;
 }
diff --git a/lgc/patch/ConfigBuilderBase.h b/lgc/patch/ConfigBuilderBase.h
index 2ad5e055e..290749151 100644
--- a/lgc/patch/ConfigBuilderBase.h
+++ b/lgc/patch/ConfigBuilderBase.h
@@ -76,20 +76,23 @@ protected:
   void setPsWritesDepth(bool value);
   void setPsSampleMask(bool value);
   void setEsGsLdsByteSize(unsigned value);
   void setWaveFrontSize(Util::Abi::HardwareStage hwStage, unsigned value);
   void setApiName(const char *value);
   void setPipelineType(Util::Abi::PipelineType value);
   void setLdsSizeByteSize(Util::Abi::HardwareStage hwStage, unsigned value);
   void setEsGsLdsSize(unsigned value);
   void setNggSubgroupSize(unsigned value);
   void setThreadgroupDimensions(llvm::ArrayRef<unsigned> values);
+#if LLPC_BUILD_GFX11
+  void setStreamOutVertexStrides(llvm::ArrayRef<unsigned> values);
+#endif
   unsigned setupFloatingPointMode(ShaderStage shaderStage);
 
   void appendConfig(llvm::ArrayRef<PalMetadataNoteEntry> config);
   void appendConfig(unsigned key, unsigned value);
 
   bool usesViewportArrayIndex();
 
   template <typename T> void appendConfig(const T &config) {
     static_assert(T::ContainsPalAbiMetadataOnly, "may only be used with structs that are fully metadata notes");
     static_assert(sizeof(T) % sizeof(PalMetadataNoteEntry) == 0,
diff --git a/lgc/patch/FragColorExport.cpp b/lgc/patch/FragColorExport.cpp
index 5f74150e2..bb05de129 100644
--- a/lgc/patch/FragColorExport.cpp
+++ b/lgc/patch/FragColorExport.cpp
@@ -233,23 +233,58 @@ Value *FragColorExport::handleColorExportInstructions(Value *output, unsigned hw
     }
 
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
   }
   }
 
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11 &&
+      m_pipelineState->getColorExportState().dualSourceBlendEnable) {
+    // Save them for later dual-source-swizzle
+    m_blendSourceChannels = exportTy->isHalfTy() ? (compCount + 1) / 2 : compCount;
+    assert(hwColorTarget <= 1);
+    m_blendSources[hwColorTarget].append(comps.begin(), comps.end());
+    return nullptr;
+  }
+#endif
+
   Value *exportCall = nullptr;
 
   if (exportTy->isHalfTy()) {
+#if LLPC_BUILD_GFX11
+    // GFX11 removes compressed export, simply use 32bit-data export.
+    if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11) {
+      // Translate compCount into the number of 32bit data.
+      compCount = (compCount + 1) / 2;
+      for (unsigned i = 0; i < compCount; i++)
+        comps[i] = builder.CreateBitCast(comps[i], builder.getFloatTy());
+      for (unsigned i = compCount; i < 4; i++)
+        comps[i] = undefFloat;
+
+      Value *args[] = {
+          builder.getInt32(EXP_TARGET_MRT_0 + hwColorTarget), // tgt
+          builder.getInt32((1 << compCount) - 1),             // en
+          comps[0],                                           // src0
+          comps[1],                                           // src1
+          comps[2],                                           // src2
+          comps[3],                                           // src3
+          builder.getFalse(),                                 // done
+          builder.getTrue()                                   // vm
+      };
+
+      return builder.CreateNamedCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {});
+    }
+#endif
     // 16-bit export (compressed)
     if (compCount <= 2)
       comps[1] = undefFloat16x2;
     Value *args[] = {
         builder.getInt32(EXP_TARGET_MRT_0 + hwColorTarget), // tgt
         builder.getInt32(compCount > 2 ? 0xF : 0x3),        // en
         comps[0],                                           // src0
         comps[1],                                           // src1
         builder.getFalse(),                                 // done
         builder.getTrue()                                   // vm
@@ -801,20 +836,99 @@ void FragColorExport::setDoneFlag(Value *exportInst, BuilderBase &builder) {
 
   unsigned intrinsicId = callInst->getIntrinsicID();
   if (intrinsicId == Intrinsic::amdgcn_exp)
     callInst->setOperand(6, builder.getTrue());
   else {
     assert(intrinsicId == Intrinsic::amdgcn_exp_compr);
     callInst->setOperand(4, builder.getTrue());
   }
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Swizzle the output to MRT0/MRT1 for dual source blend on GFX11+, and return the last export instruction.
+//
+// @param builder : The builder object that will be used to create new instructions.
+Value *FragColorExport::dualSourceSwizzle(BuilderBase &builder) {
+  Value *result0[4], *result1[4];
+  unsigned waveSize = m_pipelineState->getShaderWaveSize(ShaderStageFragment);
+  auto undefFloat = UndefValue::get(builder.getFloatTy());
+
+  Value *threadId =
+      builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {builder.getInt32(-1), builder.getInt32(0)});
+  if (waveSize == 64)
+    threadId = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {builder.getInt32(-1), threadId});
+  threadId = builder.CreateAnd(threadId, builder.getInt32(1));
+  // mask: 0 1 0 1 0 1 ...
+  Value *mask = builder.CreateICmpNE(threadId, builder.getInt32(0));
+
+  for (unsigned i = 0; i < m_blendSourceChannels; i++) {
+    Value *src0 = m_blendSources[0][i];
+    Value *src1 = m_blendSources[1][i];
+    src0 = builder.CreateBitCast(src0, builder.getInt32Ty());
+    src1 = builder.CreateBitCast(src1, builder.getInt32Ty());
+
+    src0 = builder.CreateSetInactive(src0, builder.getInt32(0));
+    src1 = builder.CreateSetInactive(src1, builder.getInt32(0));
+    // Construct a mask to help the later swizzle work. As we are mainly swapping neighbouring even/odd lanes afterward,
+    // so we need the dpp8-mask(from LSB to MSB, each take 3bits): 1 0 3 2 5 4 7 6
+    Value *dpp8 = builder.getInt32(1 | 0 << 3 | 3 << 6 | 2 << 9 | 5 << 12 | 4 << 15 | 7 << 18 | 6 << 21);
+
+    // Swapping every even/odd lanes of Src1 (S10 means lane-0 of src1).
+    // src1Shuffle: S11 S10 S13 S12 ...
+    Value *src1Shuffle = builder.CreateIntrinsic(Intrinsic::amdgcn_mov_dpp8, builder.getInt32Ty(), {src1, dpp8});
+
+    // blend0: S00 S10 S02 S12 ...
+    Value *blend0 = builder.CreateSelect(mask, src1Shuffle, src0);
+    blend0 = builder.CreateBitCast(blend0, builder.getFloatTy());
+    result0[i] = blend0;
+
+    // blend1: S11 S01 S13 S03 ...
+    Value *blend1 = builder.CreateSelect(mask, src0, src1Shuffle);
+
+    // blend1: S01 S11 S03 S13 ...
+    blend1 = builder.CreateIntrinsic(Intrinsic::amdgcn_mov_dpp8, builder.getInt32Ty(), {blend1, dpp8});
+    blend1 = builder.CreateBitCast(blend1, builder.getFloatTy());
+    result1[i] = blend1;
+  }
+
+  for (unsigned i = m_blendSourceChannels; i < 4; i++) {
+    result0[i] = undefFloat;
+    result1[i] = undefFloat;
+  }
+
+  Value *args0[] = {
+      builder.getInt32(EXP_TARGET_DUAL_SRC_0),            // tgt
+      builder.getInt32((1 << m_blendSourceChannels) - 1), // en
+      result0[0],                                         // src0
+      result0[1],                                         // src1
+      result0[2],                                         // src2
+      result0[3],                                         // src3
+      builder.getFalse(),                                 // done
+      builder.getTrue()                                   // vm
+  };
+  builder.CreateNamedCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args0, {});
+
+  Value *args1[] = {
+      builder.getInt32(EXP_TARGET_DUAL_SRC_1),            // tgt
+      builder.getInt32((1 << m_blendSourceChannels) - 1), // en
+      result1[0],                                         // src0
+      result1[1],                                         // src1
+      result1[2],                                         // src2
+      result1[3],                                         // src3
+      builder.getFalse(),                                 // done
+      builder.getTrue()                                   // vm
+  };
+  return builder.CreateNamedCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args1, {});
+}
+#endif
+
 // =====================================================================================================================
 // Generates the export instructions based on the given color export information.
 //
 // @param info : The color export information for each color export in no particular order.
 // @param values : The values that are to be exported.  Indexed by the hw color target.
 // @param exportFormat : The export format for each color target. Indexed by the hw color target.
 // @param builder : The builder object that will be used to create new instructions.
 void FragColorExport::generateExportInstructions(ArrayRef<lgc::ColorExportInfo> info, ArrayRef<llvm::Value *> values,
                                                  ArrayRef<ExportFormat> exportFormat, bool dummyExport,
                                                  BuilderBase &builder) {
@@ -839,21 +953,27 @@ void FragColorExport::generateExportInstructions(ArrayRef<lgc::ColorExportInfo>
           fragStencilRef,                 // src1
           sampleMask,                     // src2
           undef,                          // src3
           builder.getFalse(),             // done
           builder.getTrue()               // vm
       };
       lastExport = builder.CreateIntrinsic(Intrinsic::amdgcn_exp, builder.getFloatTy(), args);
     }
   }
 
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11 &&
+      m_pipelineState->getColorExportState().dualSourceBlendEnable)
+    lastExport = dualSourceSwizzle(builder);
+#else
   (void(m_pipelineState)); // Unused
+#endif
 
   if (!lastExport && dummyExport) {
     lastExport = FragColorExport::addDummyExport(builder);
   }
 
   if (lastExport)
     FragColorExport::setDoneFlag(lastExport, builder);
 }
 
 // =====================================================================================================================
diff --git a/lgc/patch/Gfx6ConfigBuilder.cpp b/lgc/patch/Gfx6ConfigBuilder.cpp
index b64d3e658..4734eb619 100644
--- a/lgc/patch/Gfx6ConfigBuilder.cpp
+++ b/lgc/patch/Gfx6ConfigBuilder.cpp
@@ -47,25 +47,22 @@ namespace Gfx6 {
 using namespace Pal::Gfx6::Chip;
 
 // =====================================================================================================================
 // Builds PAL metadata for pipeline.
 void ConfigBuilder::buildPalMetadata() {
   if (!m_pipelineState->isGraphics())
     buildPipelineCsRegConfig();
   else {
     const bool hasTs = (m_hasTcs || m_hasTes);
 
-    if (!m_pipelineState->isWholePipeline() && m_pipelineState->hasShaderStage(ShaderStageFragment)) {
-      // FS-only shader compilation (part-pipeline compilation)
-      buildPipelineVsFsRegConfig();
-    } else if (!hasTs && !m_hasGs) {
-      // VS-FS pipeline
+    if (!hasTs && !m_hasGs) {
+      // VS-FS pipeline or FS-only shader compilation (part-pipeline compilation)
       buildPipelineVsFsRegConfig();
     } else if (hasTs && !m_hasGs) {
       // VS-TS-FS pipeline
       buildPipelineVsTsFsRegConfig();
     } else if (!hasTs && m_hasGs) {
       // VS-GS-FS pipeline
       buildPipelineVsGsFsRegConfig();
     } else {
       // VS-TS-GS-FS pipeline
       buildPipelineVsTsGsFsRegConfig();
@@ -336,33 +333,33 @@ template <typename T> void ConfigBuilder::buildVsRegConfig(ShaderStage shaderSta
 
   const auto intfData = m_pipelineState->getShaderInterfaceData(shaderStage);
 
   const auto resUsage = m_pipelineState->getShaderResourceUsage(shaderStage);
   const auto &builtInUsage = resUsage->builtInUsage;
 
   unsigned floatMode = setupFloatingPointMode(shaderStage);
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, FLOAT_MODE, floatMode);
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, DX10_CLAMP, true); // Follow PAL setting
 
-  const auto &xfbStrides = resUsage->inOutUsage.xfbStrides;
-  bool enableXfb = resUsage->inOutUsage.enableXfb;
+  const auto &xfbStrides = m_pipelineState->getXfbBufferStrides();
+  const auto &streamXfbBuffers = m_pipelineState->getStreamXfbBuffers();
+  bool enableXfb = m_pipelineState->enableXfb();
 
   if (shaderStage == ShaderStageCopyShader) {
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, USER_SGPR, lgc::CopyShaderUserSgprCount);
     setNumAvailSgprs(Util::Abi::HardwareStage::Vs, m_pipelineState->getTargetInfo().getGpuProperty().maxSgprsAvailable);
     setNumAvailVgprs(Util::Abi::HardwareStage::Vs, m_pipelineState->getTargetInfo().getGpuProperty().maxVgprsAvailable);
 
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_0_EN,
-                  resUsage->inOutUsage.gs.outLocCount[0] > 0 && enableXfb);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_1_EN, resUsage->inOutUsage.gs.outLocCount[1] > 0);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_2_EN, resUsage->inOutUsage.gs.outLocCount[2] > 0);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_3_EN, resUsage->inOutUsage.gs.outLocCount[3] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_0_EN, streamXfbBuffers[0] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_1_EN, streamXfbBuffers[1] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_2_EN, streamXfbBuffers[2] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_3_EN, streamXfbBuffers[3] > 0);
     SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, RAST_STREAM, resUsage->inOutUsage.gs.rasterStream);
   } else {
     const auto &shaderOptions = m_pipelineState->getShaderOptions(shaderStage);
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, DEBUG_MODE, shaderOptions.debugMode);
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, TRAP_PRESENT, shaderOptions.trapPresent);
 
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, USER_SGPR, intfData->userDataCount);
 
     SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_0_EN, enableXfb);
     SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_1_EN, false);
@@ -379,21 +376,21 @@ template <typename T> void ConfigBuilder::buildVsRegConfig(ShaderStage shaderSta
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, SO_BASE2_EN, (xfbStrides[2] > 0));
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, SO_BASE3_EN, (xfbStrides[3] > 0));
 
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_0, STRIDE, xfbStrides[0] / sizeof(int));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_1, STRIDE, xfbStrides[1] / sizeof(int));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_2, STRIDE, xfbStrides[2] / sizeof(int));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_3, STRIDE, xfbStrides[3] / sizeof(int));
 
   unsigned streamBufferConfig = 0;
   for (auto i = 0; i < MaxGsStreams; ++i)
-    streamBufferConfig |= (resUsage->inOutUsage.streamXfbBuffers[i] << (i * 4));
+    streamBufferConfig |= (streamXfbBuffers[i] << (i * 4));
   SET_REG(&config->vsRegs, VGT_STRMOUT_BUFFER_CONFIG, streamBufferConfig);
 
   bool disableVertexReuse = m_pipelineState->getInputAssemblyState().disableVertexReuse;
 
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_X_SCALE_ENA, true);
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_X_OFFSET_ENA, true);
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_Y_SCALE_ENA, true);
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_Y_OFFSET_ENA, true);
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_Z_SCALE_ENA, true);
   SET_REG_FIELD(&config->vsRegs, PA_CL_VTE_CNTL, VPORT_Z_OFFSET_ENA, true);
diff --git a/lgc/patch/Gfx9Chip.cpp b/lgc/patch/Gfx9Chip.cpp
index 3930ab8f6..717ba8e21 100644
--- a/lgc/patch/Gfx9Chip.cpp
+++ b/lgc/patch/Gfx9Chip.cpp
@@ -127,20 +127,24 @@ PrimShaderRegConfig::PrimShaderRegConfig(GfxIpVersion gfxIp) {
   INIT_REG(SPI_SHADER_PGM_RSRC2_GS);
   INIT_REG(SPI_SHADER_PGM_RSRC4_GS);
   INIT_REG(VGT_GS_MAX_VERT_OUT);
   INIT_REG(VGT_GS_INSTANCE_CNT);
   INIT_REG(VGT_ESGS_RING_ITEMSIZE);
   INIT_REG(VGT_GS_ONCHIP_CNTL);
 
   // Special registers, having different register IDs
   if (gfxIp.major == 9 || gfxIp.major == 10) {
     INIT_REG_GFX9_10(gfxIp.major, VGT_GS_OUT_PRIM_TYPE);
+#if LLPC_BUILD_GFX11
+  } else if (gfxIp.major == 11) {
+    INIT_REG_GFX11(gfxIp.major, VGT_GS_OUT_PRIM_TYPE);
+#endif
   } else {
     llvm_unreachable("Not implemented!");
   }
 
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_PER_VS);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GSVS_RING_ITEMSIZE);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_1);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_2);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_3);
@@ -303,20 +307,24 @@ MeshRegConfig::MeshRegConfig(GfxIpVersion gfxIp) {
   INIT_REG(SPI_SHADER_PGM_RSRC2_GS);
   INIT_REG(SPI_SHADER_PGM_RSRC4_GS);
   INIT_REG(VGT_GS_MAX_VERT_OUT);
   INIT_REG(VGT_GS_INSTANCE_CNT);
   INIT_REG(VGT_ESGS_RING_ITEMSIZE);
   INIT_REG(VGT_GS_ONCHIP_CNTL);
 
   // Special registers, having different register IDs
   if (gfxIp.major == 10) {
     INIT_REG_GFX9_10(gfxIp.major, VGT_GS_OUT_PRIM_TYPE);
+#if LLPC_BUILD_GFX11
+  } else if (gfxIp.major == 11) {
+    INIT_REG_GFX11(gfxIp.major, VGT_GS_OUT_PRIM_TYPE);
+#endif
   } else {
     llvm_unreachable("Not implemented!");
   }
 
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_PER_VS);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GSVS_RING_ITEMSIZE);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_1);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_2);
   INIT_REG_HAS_HW_VS(gfxIp.major, VGT_GS_VERT_ITEMSIZE_3);
@@ -332,20 +340,25 @@ MeshRegConfig::MeshRegConfig(GfxIpVersion gfxIp) {
   INIT_REG(PA_CL_VS_OUT_CNTL);
   INIT_REG(PA_CL_CLIP_CNTL);
   INIT_REG(PA_CL_VTE_CNTL);
   INIT_REG(PA_SU_VTX_CNTL);
   INIT_REG(VGT_PRIMITIVEID_EN);
   INIT_REG(VGT_REUSE_OFF);
   INIT_REG(VGT_DRAW_PAYLOAD_CNTL);
 
   INIT_REG_GFX10_PLUS(gfxIp.major, GE_NGG_SUBGRP_CNTL);
   INIT_REG_GFX10_PLUS(gfxIp.major, SPI_SHADER_IDX_FORMAT);
+
+#if LLPC_BUILD_GFX11
+  INIT_REG_GFX11(gfxIp.major, SPI_SHADER_GS_MESHLET_DIM);
+  INIT_REG_GFX11(gfxIp.major, SPI_SHADER_GS_MESHLET_EXP_ALLOC);
+#endif
 }
 
 // =====================================================================================================================
 // Initializer
 //
 // @param gfxIp : Graphics IP version info
 PipelineMeshFsRegConfig::PipelineMeshFsRegConfig(GfxIpVersion gfxIp) : meshRegs(gfxIp), psRegs(gfxIp) {
 }
 
 // =====================================================================================================================
diff --git a/lgc/patch/Gfx9Chip.h b/lgc/patch/Gfx9Chip.h
index fe4633f4b..8c1be627b 100644
--- a/lgc/patch/Gfx9Chip.h
+++ b/lgc/patch/Gfx9Chip.h
@@ -114,20 +114,33 @@ using namespace Pal::Gfx9::Chip;
 #define INIT_REG_GFX10(_gfx, _reg)                                                                                     \
   {                                                                                                                    \
     if (_gfx == 10) {                                                                                                  \
       _reg##_ID = Pal::Gfx9::Chip::Gfx10::mm##_reg;                                                                    \
       _reg##_VAL.u32All = 0;                                                                                           \
     } else {                                                                                                           \
       INIT_REG_TO_INVALID(_reg);                                                                                       \
     }                                                                                                                  \
   }
 
+#if LLPC_BUILD_GFX11
+// GFX11 only
+#define INIT_REG_GFX11(_gfx, _reg)                                                                                     \
+  {                                                                                                                    \
+    if (_gfx == 11) {                                                                                                  \
+      _reg##_ID = Pal::Gfx9::Chip::Gfx11::mm##_reg;                                                                    \
+      _reg##_VAL.u32All = 0;                                                                                           \
+    } else {                                                                                                           \
+      INIT_REG_TO_INVALID(_reg);                                                                                       \
+    }                                                                                                                  \
+  }
+#endif
+
 // GFX9-GFX10 only
 #define INIT_REG_GFX9_10(_gfx, _reg)                                                                                   \
   {                                                                                                                    \
     if (_gfx == 9 || _gfx == 10) {                                                                                     \
       _reg##_ID = Gfx09_10::mm##_reg;                                                                                  \
       _reg##_VAL.u32All = 0;                                                                                           \
     } else {                                                                                                           \
       INIT_REG_TO_INVALID(_reg);                                                                                       \
     }                                                                                                                  \
   }
@@ -185,20 +198,24 @@ using namespace Pal::Gfx9::Chip;
 // Sets GFX-dependent register field value
 #define SET_REG_GFX9_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx09._field = (_val);
 #define SET_REG_GFX09_1X_PLUS_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx09_1xPlus._field = (_val);
 #define SET_REG_GFX10_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx10._field = (_val);
 #define SET_REG_GFX9_10_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx09_10._field = (_val);
 #define SET_REG_GFX10_PLUS_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx10Plus._field = (_val);
 #define SET_REG_GFX10_1_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx101._field = (_val);
 #define SET_REG_GFX10_3_PLUS_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx103Plus._field = (_val);
 #define SET_REG_GFX10_3_PLUS_EXCLUSIVE_FIELD(_stage, _reg, _field, _val)                                               \
   (_stage)->_reg##_VAL.gfx103PlusExclusive._field = (_val);
+#if LLPC_BUILD_GFX11
+#define SET_REG_GFX10_4_PLUS_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx104Plus._field = (_val);
+#define SET_REG_GFX11_FIELD(_stage, _reg, _field, _val) (_stage)->_reg##_VAL.gfx11._field = (_val);
+#endif
 
 // Preferred number of GS primitives per ES thread.
 constexpr unsigned GsPrimsPerEsThread = 256;
 
 // Preferred number of GS threads per VS thread.
 constexpr unsigned GsThreadsPerVsThread = 2;
 
 // Preferred number of HS threads per subgroup.
 constexpr unsigned MaxHsThreadsPerSubgroup = 256;
 
@@ -551,20 +568,25 @@ struct MeshRegConfig {
   DEF_REG(PA_CL_CLIP_CNTL);
   DEF_REG(PA_CL_VTE_CNTL);
   DEF_REG(PA_SU_VTX_CNTL);
   DEF_REG(VGT_PRIMITIVEID_EN);
   DEF_REG(VGT_REUSE_OFF);
   DEF_REG(VGT_DRAW_PAYLOAD_CNTL);
 
   DEF_REG(GE_NGG_SUBGRP_CNTL);
   DEF_REG(SPI_SHADER_IDX_FORMAT);
 
+#if LLPC_BUILD_GFX11
+  DEF_REG(SPI_SHADER_GS_MESHLET_DIM);
+  DEF_REG(SPI_SHADER_GS_MESHLET_EXP_ALLOC);
+#endif
+
   MeshRegConfig(GfxIpVersion gfxIp);
 };
 
 // =====================================================================================================================
 // Represents configuration of registers relevant to graphics pipeline (Mesh-FS).
 struct PipelineMeshFsRegConfig {
   static constexpr bool ContainsPalAbiMetadataOnly = true;
 
   MeshRegConfig meshRegs; // Mesh -> hardware primitive shader (NGG, ES-GS)
   PsRegConfig psRegs;     // FS   -> hardware PS
diff --git a/lgc/patch/Gfx9ConfigBuilder.cpp b/lgc/patch/Gfx9ConfigBuilder.cpp
index 81ecfe8c1..1053f17e3 100644
--- a/lgc/patch/Gfx9ConfigBuilder.cpp
+++ b/lgc/patch/Gfx9ConfigBuilder.cpp
@@ -48,31 +48,28 @@ using namespace Pal::Gfx9::Chip;
 
 // =====================================================================================================================
 // Builds PAL metadata for pipeline.
 void ConfigBuilder::buildPalMetadata() {
   if (!m_pipelineState->isGraphics()) {
     buildPipelineCsRegConfig();
   } else {
     const bool hasTs = (m_hasTcs || m_hasTes);
     const bool enableNgg = m_pipelineState->getNggControl()->enableNgg;
 
-    if (!m_pipelineState->isWholePipeline() && m_pipelineState->hasShaderStage(ShaderStageFragment)) {
-      // FS-only shader (part-pipeline compilation)
-      buildPipelineVsFsRegConfig();
-    } else if (m_hasTask) {
+    if (m_hasTask) {
       // Task-Mesh-FS pipeline
       buildPipelineTaskMeshFsConfig();
     } else if (m_hasMesh) {
       // Mesh-FS pipeline
       buildPipelineMeshFsConfig();
     } else if (!hasTs && !m_hasGs) {
-      // VS-FS pipeline
+      // VS-FS pipeline or FS-only shader (part-pipeline compilation)
       if (m_gfxIp.major >= 10 && enableNgg)
         buildPipelineNggVsFsRegConfig();
       else
         buildPipelineVsFsRegConfig();
     } else if (hasTs && !m_hasGs) {
       // VS-TS-FS pipeline
       if (m_gfxIp.major >= 10 && enableNgg)
         buildPipelineNggVsTsFsRegConfig();
       else
         buildPipelineVsTsFsRegConfig();
@@ -88,26 +85,24 @@ void ConfigBuilder::buildPalMetadata() {
         buildPipelineNggVsTsGsFsRegConfig();
       else
         buildPipelineVsTsGsFsRegConfig();
     }
   }
 
   writePalMetadata();
 }
 
 // =====================================================================================================================
-// Builds register configuration for graphics pipeline (VS-FS), or FS-only shader compilation
+// Builds register configuration for graphics pipeline (VS-FS) or FS-only shader compilation
 void ConfigBuilder::buildPipelineVsFsRegConfig() {
   GfxIpVersion gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
-  const bool partPipeline = !m_pipelineState->isWholePipeline() && m_pipelineState->hasShaderStage(ShaderStageFragment);
-  assert(gfxIp.major <= 10 || partPipeline); // Must be GFX10 or below, or part-pipeline compilation
-  (void(partPipeline));                      // Unused
+  assert(gfxIp.major <= 10); // Must be GFX10 or below
 
   PipelineVsFsRegConfig config(gfxIp);
 
   addApiHwShaderMapping(ShaderStageFragment, Util::Abi::HwShaderPs);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, MAX_PRIMGRP_IN_WAVE, 2);
 
   if (m_pipelineState->hasShaderStage(ShaderStageVertex)) {
     setPipelineType(Util::Abi::PipelineType::VsPs);
     addApiHwShaderMapping(ShaderStageVertex, Util::Abi::HwShaderVs);
@@ -428,39 +423,46 @@ void ConfigBuilder::buildPipelineVsTsGsFsRegConfig() {
     SET_REG(&config, IA_MULTI_VGT_PARAM, iaMultiVgtParam.u32All);
   }
 
   // Set up VGT_TF_PARAM
   setupVgtTfParam(&config.lsHsRegs);
 
   appendConfig(config);
 }
 
 // =====================================================================================================================
-// Builds register configuration for graphics pipeline (NGG, VS-FS).
+// Builds register configuration for graphics pipeline (NGG, VS-FS) or FS-only shader compilation
 void ConfigBuilder::buildPipelineNggVsFsRegConfig() {
   GfxIpVersion gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
   assert(gfxIp.major >= 10);
 
   const auto nggControl = m_pipelineState->getNggControl();
   assert(nggControl->enableNgg);
 
   PipelineNggVsFsRegConfig config(gfxIp);
 
   addApiHwShaderMapping(ShaderStageVertex, Util::Abi::HwShaderGs);
   addApiHwShaderMapping(ShaderStageFragment, Util::Abi::HwShaderPs);
 
   setPipelineType(Util::Abi::PipelineType::Ngg);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, MAX_PRIMGRP_IN_WAVE, 2);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_EN, true);
   SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_EN, nggControl->passthroughMode);
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    SET_REG_GFX10_4_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_NO_MSG,
+                               nggControl->passthroughMode && !m_pipelineState->enableSwXfb());
+    SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, NGG_WAVE_ID_EN, m_pipelineState->enableSwXfb());
+  }
+#endif
 
   if (m_pipelineState->hasShaderStage(ShaderStageVertex)) {
     buildPrimShaderRegConfig<PipelineNggVsFsRegConfig>(ShaderStageVertex, ShaderStageInvalid, &config);
 
     SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, ES_EN, ES_STAGE_REAL);
     SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, VS_EN, VS_STAGE_REAL);
 
     auto waveFrontSize = m_pipelineState->getShaderWaveSize(ShaderStageVertex);
     if (waveFrontSize == 32) {
       SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, GS_W32_EN, true);
@@ -509,20 +511,27 @@ void ConfigBuilder::buildPipelineNggVsTsFsRegConfig() {
   addApiHwShaderMapping(ShaderStageTessControl, Util::Abi::HwShaderHs);
   addApiHwShaderMapping(ShaderStageTessEval, Util::Abi::HwShaderGs);
   addApiHwShaderMapping(ShaderStageFragment, Util::Abi::HwShaderPs);
 
   setPipelineType(Util::Abi::PipelineType::NggTess);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, MAX_PRIMGRP_IN_WAVE, 2);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_EN, true);
   SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_EN, nggControl->passthroughMode);
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    SET_REG_GFX10_4_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_NO_MSG,
+                               nggControl->passthroughMode && !m_pipelineState->enableSwXfb());
+    SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, NGG_WAVE_ID_EN, m_pipelineState->enableSwXfb());
+  }
+#endif
 
   if (m_pipelineState->hasShaderStage(ShaderStageVertex) || m_pipelineState->hasShaderStage(ShaderStageTessControl)) {
     const bool hasVs = m_pipelineState->hasShaderStage(ShaderStageVertex);
     const bool hasTcs = m_pipelineState->hasShaderStage(ShaderStageTessControl);
 
     buildLsHsRegConfig<PipelineNggVsTsFsRegConfig>(hasVs ? ShaderStageVertex : ShaderStageInvalid,
                                                    hasTcs ? ShaderStageTessControl : ShaderStageInvalid, &config);
 
     unsigned checksum = setShaderHash(ShaderStageVertex);
     checksum = checksum ^ setShaderHash(ShaderStageTessControl);
@@ -592,20 +601,24 @@ void ConfigBuilder::buildPipelineNggVsGsFsRegConfig() {
 
   setPipelineType(Util::Abi::PipelineType::Ngg);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, MAX_PRIMGRP_IN_WAVE, 2);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_EN, true);
   // NOTE: When GS is present, NGG pass-through mode is always turned off regardless of the pass-through flag of
   // NGG control settings. In such case, the pass-through flag means whether there is culling (different from
   // hardware pass-through).
   SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_EN, false);
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11)
+    SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, NGG_WAVE_ID_EN, m_pipelineState->enableSwXfb());
+#endif
 
   if (m_pipelineState->hasShaderStage(ShaderStageVertex) || m_pipelineState->hasShaderStage(ShaderStageGeometry)) {
     const bool hasVs = m_pipelineState->hasShaderStage(ShaderStageVertex);
     const bool hasGs = m_pipelineState->hasShaderStage(ShaderStageGeometry);
 
     buildPrimShaderRegConfig<PipelineNggVsGsFsRegConfig>(hasVs ? ShaderStageVertex : ShaderStageInvalid,
                                                          hasGs ? ShaderStageGeometry : ShaderStageInvalid, &config);
 
     unsigned checksum = setShaderHash(ShaderStageVertex);
     checksum = checksum ^ setShaderHash(ShaderStageGeometry);
@@ -658,20 +671,24 @@ void ConfigBuilder::buildPipelineNggVsTsGsFsRegConfig() {
 
   setPipelineType(Util::Abi::PipelineType::NggTess);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, MAX_PRIMGRP_IN_WAVE, 2);
 
   SET_REG_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_EN, true);
   // NOTE: When GS is present, NGG pass-through mode is always turned off regardless of the pass-through flag of
   // NGG control settings. In such case, the pass-through flag means whether there is culling (different from
   // hardware pass-through).
   SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_EN, false);
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11)
+    SET_REG_GFX10_PLUS_FIELD(&config, VGT_SHADER_STAGES_EN, NGG_WAVE_ID_EN, m_pipelineState->enableSwXfb());
+#endif
 
   if (m_pipelineState->hasShaderStage(ShaderStageVertex) || m_pipelineState->hasShaderStage(ShaderStageTessControl)) {
     const bool hasVs = m_pipelineState->hasShaderStage(ShaderStageVertex);
     const bool hasTcs = m_pipelineState->hasShaderStage(ShaderStageTessControl);
 
     buildLsHsRegConfig<PipelineNggVsTsGsFsRegConfig>(hasVs ? ShaderStageVertex : ShaderStageInvalid,
                                                      hasTcs ? ShaderStageTessControl : ShaderStageInvalid, &config);
 
     unsigned checksum = setShaderHash(ShaderStageVertex);
     checksum = checksum ^ setShaderHash(ShaderStageTessControl);
@@ -828,35 +845,35 @@ template <typename T> void ConfigBuilder::buildVsRegConfig(ShaderStage shaderSta
 
   const auto intfData = m_pipelineState->getShaderInterfaceData(shaderStage);
 
   const auto resUsage = m_pipelineState->getShaderResourceUsage(shaderStage);
   const auto &builtInUsage = resUsage->builtInUsage;
 
   unsigned floatMode = setupFloatingPointMode(shaderStage);
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, FLOAT_MODE, floatMode);
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, DX10_CLAMP, true); // Follow PAL setting
 
-  const auto &xfbStrides = resUsage->inOutUsage.xfbStrides;
-  bool enableXfb = resUsage->inOutUsage.enableXfb;
+  const auto &xfbStrides = m_pipelineState->getXfbBufferStrides();
+  const auto &streamXfbBuffers = m_pipelineState->getStreamXfbBuffers();
+  const bool enableXfb = m_pipelineState->enableXfb();
   if (shaderStage == ShaderStageCopyShader) {
     // NOTE: For copy shader, usually we use fixed number of user data registers.
     // But in some cases, we may change user data registers, we use variable to keep user sgpr count here
     auto copyShaderUserSgprCount = lgc::CopyShaderUserSgprCount;
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, USER_SGPR, copyShaderUserSgprCount);
     setNumAvailSgprs(Util::Abi::HardwareStage::Vs, m_pipelineState->getTargetInfo().getGpuProperty().maxSgprsAvailable);
     setNumAvailVgprs(Util::Abi::HardwareStage::Vs, m_pipelineState->getTargetInfo().getGpuProperty().maxVgprsAvailable);
 
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_0_EN,
-                  resUsage->inOutUsage.gs.outLocCount[0] > 0 && enableXfb);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_1_EN, resUsage->inOutUsage.gs.outLocCount[1] > 0);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_2_EN, resUsage->inOutUsage.gs.outLocCount[2] > 0);
-    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_3_EN, resUsage->inOutUsage.gs.outLocCount[3] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_0_EN, streamXfbBuffers[0] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_1_EN, streamXfbBuffers[1] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_2_EN, streamXfbBuffers[2] > 0);
+    SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, STREAMOUT_3_EN, streamXfbBuffers[3] > 0);
     SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_CONFIG, RAST_STREAM, resUsage->inOutUsage.gs.rasterStream);
   } else {
     const auto &shaderOptions = m_pipelineState->getShaderOptions(shaderStage);
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, DEBUG_MODE, shaderOptions.debugMode);
 
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, TRAP_PRESENT, shaderOptions.trapPresent);
     SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, USER_SGPR, intfData->userDataCount);
     const bool userSgprMsb = (intfData->userDataCount > 31);
 
     if (gfxIp.major == 10) {
@@ -880,21 +897,21 @@ template <typename T> void ConfigBuilder::buildVsRegConfig(ShaderStage shaderSta
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, SO_BASE2_EN, (xfbStrides[2] > 0));
   SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC2_VS, SO_BASE3_EN, (xfbStrides[3] > 0));
 
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_0, STRIDE, xfbStrides[0] / sizeof(unsigned));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_1, STRIDE, xfbStrides[1] / sizeof(unsigned));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_2, STRIDE, xfbStrides[2] / sizeof(unsigned));
   SET_REG_FIELD(&config->vsRegs, VGT_STRMOUT_VTX_STRIDE_3, STRIDE, xfbStrides[3] / sizeof(unsigned));
 
   unsigned streamBufferConfig = 0;
   for (auto i = 0; i < MaxGsStreams; ++i)
-    streamBufferConfig |= (resUsage->inOutUsage.streamXfbBuffers[i] << (i * 4));
+    streamBufferConfig |= (streamXfbBuffers[i] << (i * 4));
   SET_REG(&config->vsRegs, VGT_STRMOUT_BUFFER_CONFIG, streamBufferConfig);
 
   if (gfxIp.major == 10) {
     SET_REG_GFX10_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, MEM_ORDERED, true);
   }
 
   if (shaderStage == ShaderStageVertex) {
     if (builtInUsage.vs.instanceIndex) {
       SET_REG_FIELD(&config->vsRegs, SPI_SHADER_PGM_RSRC1_VS, VGPR_COMP_CNT, 3); // 3: Enable instance ID
     } else if (builtInUsage.vs.primitiveId) {
@@ -944,25 +961,31 @@ void ConfigBuilder::buildLsHsRegConfig(ShaderStage shaderStage1, ShaderStage sha
 
   const auto &vsIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageVertex);
   const auto &tcsIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageTessControl);
   unsigned userDataCount = std::max(vsIntfData->userDataCount, tcsIntfData->userDataCount);
 
   const auto &tcsShaderOptions = m_pipelineState->getShaderOptions(ShaderStageTessControl);
   SET_REG_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC1_HS, DEBUG_MODE, tcsShaderOptions.debugMode);
 
   const bool userSgprMsb = (userDataCount > 31);
   if (gfxIp.major >= 10) {
-    bool wgpMode = (getShaderWgpMode(ShaderStageVertex) || getShaderWgpMode(ShaderStageTessControl));
+    bool wgpMode = (m_pipelineState->getShaderWgpMode(ShaderStageVertex) ||
+                    m_pipelineState->getShaderWgpMode(ShaderStageTessControl));
 
     SET_REG_GFX10_PLUS_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC1_HS, MEM_ORDERED, true);
     SET_REG_GFX10_PLUS_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC1_HS, WGP_MODE, wgpMode);
     SET_REG_GFX10_PLUS_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, USER_SGPR_MSB, userSgprMsb);
+
+#if LLPC_BUILD_NAVI31
+    // The shared scratch offset is reused by HW to provide HS wave ID in group
+    SET_REG_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, SCRATCH_EN, m_pipelineState->canOptimizeTessFactor());
+#endif
   } else {
     SET_REG_GFX9_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, USER_SGPR_MSB, userSgprMsb);
   }
   SET_REG_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, TRAP_PRESENT, tcsShaderOptions.trapPresent);
   SET_REG_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, USER_SGPR, userDataCount);
 
   const auto &calcFactor = tcsResUsage->inOutUsage.tcs.calcFactor;
   assert(m_pipelineState->isTessOffChip()); // Must be off-chip on GFX9+
 
   const unsigned ldsSizeDwordGranularityShift =
@@ -975,20 +998,28 @@ void ConfigBuilder::buildLsHsRegConfig(ShaderStage shaderStage1, ShaderStage sha
 #endif
   ldsSizeInDwords = alignTo(ldsSizeInDwords, ldsSizeDwordGranularity);
 
   const unsigned ldsSize = ldsSizeInDwords >> ldsSizeDwordGranularityShift;
   if (gfxIp.major == 9) {
     SET_REG_GFX9_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, LDS_SIZE, ldsSize);
   } else {
     SET_REG_GFX10_PLUS_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC2_HS, LDS_SIZE, ldsSize);
   }
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // Pixel wait sync+
+    const bool useImageOp = vsResUsage->useImageOp || tcsResUsage->useImageOp;
+    SET_REG_GFX11_FIELD(&config->lsHsRegs, SPI_SHADER_PGM_RSRC4_HS, IMAGE_OP, useImageOp);
+  }
+#endif
+
   setLdsSizeByteSize(Util::Abi::HardwareStage::Hs, ldsSizeInDwords * 4);
 
   // Minimum and maximum tessellation factors supported by the hardware.
   constexpr float minTessFactor = 1.0f;
   constexpr float maxTessFactor = 64.0f;
   SET_REG(&config->lsHsRegs, VGT_HOS_MIN_TESS_LEVEL, FloatToBits(minTessFactor));
   SET_REG(&config->lsHsRegs, VGT_HOS_MAX_TESS_LEVEL, FloatToBits(maxTessFactor));
 
   // Set VGT_LS_HS_CONFIG
   SET_REG_FIELD(&config->lsHsRegs, VGT_LS_HS_CONFIG, NUM_PATCHES, calcFactor.patchCountPerThreadGroup);
@@ -1053,22 +1084,22 @@ void ConfigBuilder::buildEsGsRegConfig(ShaderStage shaderStage1, ShaderStage sha
   const auto tesIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageTessEval);
   const auto gsIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry);
   unsigned userDataCount =
       std::max((hasTs ? tesIntfData->userDataCount : vsIntfData->userDataCount), gsIntfData->userDataCount);
 
   const auto &gsShaderOptions = m_pipelineState->getShaderOptions(ShaderStageGeometry);
   SET_REG_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC1_GS, DEBUG_MODE, gsShaderOptions.debugMode);
 
   const bool userSgprMsb = (userDataCount > 31);
   if (gfxIp.major == 10) {
-    bool wgpMode =
-        (getShaderWgpMode(hasTs ? ShaderStageTessEval : ShaderStageVertex) || getShaderWgpMode(ShaderStageGeometry));
+    bool wgpMode = m_pipelineState->getShaderWgpMode(hasTs ? ShaderStageTessEval : ShaderStageVertex) ||
+                   m_pipelineState->getShaderWgpMode(ShaderStageGeometry);
 
     SET_REG_GFX10_PLUS_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC1_GS, MEM_ORDERED, true);
     SET_REG_GFX10_PLUS_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC1_GS, WGP_MODE, wgpMode);
     SET_REG_GFX10_PLUS_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR_MSB, userSgprMsb);
   } else {
     SET_REG_GFX9_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR_MSB, userSgprMsb);
   }
 
   SET_REG_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC2_GS, TRAP_PRESENT, gsShaderOptions.trapPresent);
   SET_REG_FIELD(&config->esGsRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR, userDataCount);
@@ -1264,23 +1295,23 @@ void ConfigBuilder::buildPrimShaderRegConfig(ShaderStage shaderStage1, ShaderSta
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC1_GS, FLOAT_MODE, floatMode);
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC1_GS, DX10_CLAMP, true); // Follow PAL setting
 
   const auto vsIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageVertex);
   const auto tesIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageTessEval);
   const auto gsIntfData = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry);
   unsigned userDataCount =
       std::max((hasTs ? tesIntfData->userDataCount : vsIntfData->userDataCount), gsIntfData->userDataCount);
 
   const auto &gsShaderOptions = m_pipelineState->getShaderOptions(ShaderStageGeometry);
-  bool wgpMode = getShaderWgpMode(hasTs ? ShaderStageTessEval : ShaderStageVertex);
+  bool wgpMode = m_pipelineState->getShaderWgpMode(hasTs ? ShaderStageTessEval : ShaderStageVertex);
   if (hasGs)
-    wgpMode = (wgpMode || getShaderWgpMode(ShaderStageGeometry));
+    wgpMode = (wgpMode || m_pipelineState->getShaderWgpMode(ShaderStageGeometry));
 
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC1_GS, DEBUG_MODE, gsShaderOptions.debugMode);
   SET_REG_GFX10_PLUS_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC1_GS, MEM_ORDERED, true);
   SET_REG_GFX10_PLUS_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC1_GS, WGP_MODE, wgpMode);
 
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC2_GS, TRAP_PRESENT, gsShaderOptions.trapPresent);
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR, userDataCount);
 
   const bool userSgprMsb = (userDataCount > 31);
 
@@ -1312,20 +1343,32 @@ void ConfigBuilder::buildPrimShaderRegConfig(ShaderStage shaderStage1, ShaderSta
 #if VKI_RAY_TRACING
   ldsSizeInDwords += calcFactor.rayQueryLdsStackSize;
 #endif
   ldsSizeInDwords = alignTo(ldsSizeInDwords, ldsSizeDwordGranularity);
 
   const unsigned ldsSize = ldsSizeInDwords >> ldsSizeDwordGranularityShift;
   SET_REG_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC2_GS, LDS_SIZE, ldsSize);
   setLdsSizeByteSize(Util::Abi::HardwareStage::Gs, ldsSizeInDwords * 4);
   setEsGsLdsSize(calcFactor.esGsLdsSize * 4);
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // Pixel wait sync+
+    bool useImageOp = hasGs ? gsResUsage->useImageOp : false;
+    if (hasTs)
+      useImageOp |= tesResUsage->useImageOp;
+    else
+      useImageOp |= vsResUsage->useImageOp;
+    SET_REG_GFX11_FIELD(&config->primShaderRegs, SPI_SHADER_PGM_RSRC4_GS, IMAGE_OP, useImageOp);
+  }
+#endif
+
   unsigned maxVertOut = std::max(1u, static_cast<unsigned>(geometryMode.outputVertices));
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_MAX_VERT_OUT, MAX_VERT_OUT, maxVertOut);
 
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_MODE, MODE, GS_SCENARIO_G);
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_MODE, ONCHIP, VGT_GS_MODE_ONCHIP_OFF);
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_MODE, ES_WRITE_OPTIMIZE, false);
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_MODE, GS_WRITE_OPTIMIZE, true);
 
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_ONCHIP_CNTL, ES_VERTS_PER_SUBGRP, calcFactor.esVertsPerSubgroup);
   SET_REG_FIELD(&config->primShaderRegs, VGT_GS_ONCHIP_CNTL, GS_PRIMS_PER_SUBGRP, calcFactor.gsPrimsPerSubgroup);
@@ -1438,20 +1481,36 @@ void ConfigBuilder::buildPrimShaderRegConfig(ShaderStage shaderStage1, ShaderSta
   if (nggControl->passthroughMode) {
     INVALIDATE_REG(&config->primShaderRegs, SPI_SHADER_PGM_LO_GS);
   } else {
     // NOTE: For NGG culling mode, the primitive shader table that contains culling data might be accessed by
     // shader. PAL expects 64-bit address of that table and will program it into SPI_SHADER_PGM_LO_GS and
     // SPI_SHADER_PGM_HI_GS if we do not provide one. By setting SPI_SHADER_PGM_LO_GS to NggCullingData, we tell
     // PAL that we will not provide it and it is fine to use SPI_SHADER_PGM_LO_GS and SPI_SHADER_PGM_HI_GS as
     // the address of that table.
     SET_REG(&config->primShaderRegs, SPI_SHADER_PGM_LO_GS, static_cast<unsigned>(UserDataMapping::NggCullingData));
   }
+#if LLPC_BUILD_GFX11
+
+  //
+  // Build SW stream-out configuration (GFX11+)
+  //
+  if (m_pipelineState->enableSwXfb()) {
+    auto resUsage = hasGs ? gsResUsage : (hasTs ? tesResUsage : vsResUsage);
+    std::array<unsigned, MaxTransformFeedbackBuffers> xfbStridesInDwords;
+    for (unsigned i = 0; i < xfbStridesInDwords.size(); ++i) {
+      // Must be multiple of dword (PAL doesn't support 16-bit transform feedback outputs)
+      assert(resUsage->inOutUsage.xfbStrides[i] % sizeof(unsigned) == 0);
+      xfbStridesInDwords[i] = resUsage->inOutUsage.xfbStrides[i] / sizeof(unsigned);
+    }
+    setStreamOutVertexStrides(xfbStridesInDwords); // Set SW stream-out vertex strides
+  }
+#endif
 }
 
 // =====================================================================================================================
 // Builds register configuration for hardware pixel shader.
 //
 // @param shaderStage : Current shader stage (from API side)
 // @param [out] config : Register configuration for pixel-shader-specific pipeline
 template <typename T> void ConfigBuilder::buildPsRegConfig(ShaderStage shaderStage, T *config) {
   assert(shaderStage == ShaderStageFragment);
 
@@ -1473,20 +1532,27 @@ template <typename T> void ConfigBuilder::buildPsRegConfig(ShaderStage shaderSta
   GfxIpVersion gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
 
   if (gfxIp.major >= 10) {
     SET_REG_GFX10_PLUS_FIELD(&config->psRegs, SPI_SHADER_PGM_RSRC1_PS, MEM_ORDERED, true);
     SET_REG_MOST_FIELD(&config->psRegs, PA_STEREO_CNTL, STEREO_MODE, STATE_STEREO_X);
     SET_REG_GFX10_PLUS_FIELD(&config->psRegs, SPI_SHADER_PGM_RSRC2_PS, USER_SGPR_MSB, userSgprMsb);
   } else {
     SET_REG_GFX9_FIELD(&config->psRegs, SPI_SHADER_PGM_RSRC2_PS, USER_SGPR_MSB, userSgprMsb);
   }
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // Pixel wait sync+
+    SET_REG_GFX11_FIELD(&config->psRegs, SPI_SHADER_PGM_RSRC4_PS, IMAGE_OP, resUsage->useImageOp);
+  }
+#endif
+
   SET_REG_FIELD(&config->psRegs, SPI_BARYC_CNTL, FRONT_FACE_ALL_BITS, true);
   if (fragmentMode.pixelCenterInteger) {
     // TRUE - Force floating point position to upper left corner of pixel (X.0, Y.0)
     SET_REG_FIELD(&config->psRegs, SPI_BARYC_CNTL, POS_FLOAT_ULC, true);
   } else if (builtInUsage.runAtSampleRate) {
     // 2 - Calculate per-pixel floating point position at iterated sample number
     SET_REG_FIELD(&config->psRegs, SPI_BARYC_CNTL, POS_FLOAT_LOCATION, 2);
   } else {
     // 0 - Calculate per-pixel floating point position at pixel center
     SET_REG_FIELD(&config->psRegs, SPI_BARYC_CNTL, POS_FLOAT_LOCATION, 0);
@@ -1586,20 +1652,35 @@ template <typename T> void ConfigBuilder::buildPsRegConfig(ShaderStage shaderSta
       continue;
     }
     if ((interpInfoElem.loc == InvalidFsInterpInfo.loc && interpInfoElem.flat == InvalidFsInterpInfo.flat &&
          interpInfoElem.custom == InvalidFsInterpInfo.custom && interpInfoElem.is16bit == InvalidFsInterpInfo.is16bit))
       interpInfoElem.loc = i;
 
     regSPI_PS_INPUT_CNTL_0 spiPsInputCntl = {};
     // NOTE: Flat shading flag is only set for per-vertex parameter.
     spiPsInputCntl.bits.FLAT_SHADE = interpInfoElem.flat && !interpInfoElem.isPerPrimitive;
     spiPsInputCntl.bits.OFFSET = interpInfoElem.loc;
+#if LLPC_BUILD_GFX11
+    if (gfxIp.major >= 11 && interpInfoElem.isPerPrimitive) {
+      const auto preStage = m_pipelineState->getPrevShaderStage(ShaderStageFragment);
+      if (preStage == ShaderStageMesh) {
+        // NOTE: HW allocates and manages attribute ring based on the register fields: VS_EXPORT_COUNT and
+        // PRIM_EXPORT_COUNT. When VS_EXPORT_COUNT = 0, HW assumes there is still a vertex attribute exported even
+        // though this is not what we want. Hence, we should reserve param0 as a dummy vertex attribute and all
+        // primitive attributes are moved after it.
+        bool hasNoVertexAttrib = m_pipelineState->getShaderResourceUsage(ShaderStageMesh)->inOutUsage.expCount == 0;
+        if (hasNoVertexAttrib)
+          ++spiPsInputCntl.bits.OFFSET;
+      }
+      spiPsInputCntl.gfx11.PRIM_ATTR = true;
+    }
+#endif
 
     if (interpInfoElem.custom) {
       // NOTE: Force parameter cache data to be read in passthrough mode.
       static const unsigned PassThroughMode = (1 << 5);
       spiPsInputCntl.bits.FLAT_SHADE = true;
       spiPsInputCntl.bits.OFFSET |= PassThroughMode;
     } else if (!interpInfoElem.flat && interpInfoElem.is16bit) {
       spiPsInputCntl.bits.FP16_INTERP_MODE = true;
       spiPsInputCntl.bits.ATTR0_VALID = interpInfoElem.attr0Valid;
       spiPsInputCntl.bits.ATTR1_VALID = interpInfoElem.attr1Valid;
@@ -1613,22 +1694,29 @@ template <typename T> void ConfigBuilder::buildPsRegConfig(ShaderStage shaderSta
       spiPsInputCntl.bits.OFFSET = UseDefaultVal;
     }
 
     // NOTE: Set SPI_PS_INPUT_CNTL_* here, but the register can still be changed later,
     // when it becomes known that gl_ViewportIndex is not used and fields OFFSET and FLAT_SHADE
     // can be amended.
     appendConfig(mmSPI_PS_INPUT_CNTL_0 + i, spiPsInputCntl.u32All);
   }
 
   unsigned numInterp = resUsage->inOutUsage.fs.interpInfo.size() - numPrimInterp;
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // NOTE: For GFX11+, vertex attributes and primitive attributes are counted together. The field
+    // SPI_PS_INPUT_CNTL.PRIM_ATTR is used to differentiate them.
+    numInterp = resUsage->inOutUsage.fs.interpInfo.size();
+  }
+#endif
   SET_REG_FIELD(&config->psRegs, SPI_PS_IN_CONTROL, NUM_INTERP, numInterp);
-  if (gfxIp == GfxIpVersion{10, 3})
+  if (gfxIp.isGfx(10, 3))
     SET_REG_GFX10_3_PLUS_EXCLUSIVE_FIELD(&config->psRegs, SPI_PS_IN_CONTROL, NUM_PRIM_INTERP, numPrimInterp);
 
   if (pointCoordLoc != InvalidValue) {
     SET_REG_FIELD(&config->psRegs, SPI_INTERP_CONTROL_0, PNT_SPRITE_ENA, true);
     SET_REG_FIELD(&config->psRegs, SPI_INTERP_CONTROL_0, PNT_SPRITE_OVRD_X, SPI_PNT_SPRITE_SEL_S);
     SET_REG_FIELD(&config->psRegs, SPI_INTERP_CONTROL_0, PNT_SPRITE_OVRD_Y, SPI_PNT_SPRITE_SEL_T);
     SET_REG_FIELD(&config->psRegs, SPI_INTERP_CONTROL_0, PNT_SPRITE_OVRD_Z, SPI_PNT_SPRITE_SEL_0);
     SET_REG_FIELD(&config->psRegs, SPI_INTERP_CONTROL_0, PNT_SPRITE_OVRD_W, SPI_PNT_SPRITE_SEL_1);
   }
 
@@ -1679,40 +1767,47 @@ template <typename T> void ConfigBuilder::buildMeshRegConfig(ShaderStage shaderS
 
   SET_REG_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, PRIMGEN_EN, true);
   SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, PRIMGEN_PASSTHRU_EN, false);
 
   const unsigned waveSize = m_pipelineState->getShaderWaveSize(shaderStage);
   if (waveSize == 32)
     SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, GS_W32_EN, true);
 
   SET_REG_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, ES_EN, ES_STAGE_REAL);
   SET_REG_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, GS_EN, GS_STAGE_ON);
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    static constexpr unsigned NEW_FAST_LAUNCH = 0x2;
+    SET_REG_GFX09_1X_PLUS_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, GS_FAST_LAUNCH, NEW_FAST_LAUNCH);
+  } else {
+#else
   {
+#endif
     (void(gfxIp)); // Unused
     static constexpr unsigned LEGACY_FAST_LAUNCH = 0x1;
     SET_REG_GFX09_1X_PLUS_FIELD(&config->meshRegs, VGT_SHADER_STAGES_EN, GS_FAST_LAUNCH, LEGACY_FAST_LAUNCH);
   }
 
   //
   // Build ES-GS specific configuration
   //
   unsigned gsVgprCompCnt = 0;
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, GS_VGPR_COMP_CNT, gsVgprCompCnt);
 
   unsigned floatMode = setupFloatingPointMode(shaderStage);
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, FLOAT_MODE, floatMode);
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, DX10_CLAMP, true); // Follow PAL setting
 
   unsigned userDataCount = intfData->userDataCount;
 
   const auto &shaderOptions = m_pipelineState->getShaderOptions(shaderStage);
-  bool wgpMode = getShaderWgpMode(shaderStage);
+  bool wgpMode = m_pipelineState->getShaderWgpMode(shaderStage);
 
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, DEBUG_MODE, shaderOptions.debugMode);
   SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, MEM_ORDERED, true);
   SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC1_GS, WGP_MODE, wgpMode);
 
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC2_GS, TRAP_PRESENT, shaderOptions.trapPresent);
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR, userDataCount);
 
   const bool userSgprMsb = (userDataCount > 31);
   SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC2_GS, USER_SGPR_MSB, userSgprMsb);
@@ -1724,20 +1819,27 @@ template <typename T> void ConfigBuilder::buildMeshRegConfig(ShaderStage shaderS
       m_pipelineState->getTargetInfo().getGpuProperty().ldsSizeDwordGranularityShift;
   const unsigned ldsSizeDwordGranularity = 1u << ldsSizeDwordGranularityShift;
 
   unsigned ldsSizeInDwords = calcFactor.gsOnChipLdsSize;
   ldsSizeInDwords = alignTo(ldsSizeInDwords, ldsSizeDwordGranularity);
 
   const unsigned ldsSize = ldsSizeInDwords >> ldsSizeDwordGranularityShift;
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC2_GS, LDS_SIZE, ldsSize);
   setLdsSizeByteSize(Util::Abi::HardwareStage::Gs, ldsSizeInDwords * 4);
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // Pixel wait sync+
+    SET_REG_GFX11_FIELD(&config->meshRegs, SPI_SHADER_PGM_RSRC4_GS, IMAGE_OP, resUsage->useImageOp);
+  }
+#endif
+
   unsigned maxVertOut = std::max(1u, static_cast<unsigned>(meshMode.outputVertices));
   SET_REG_FIELD(&config->meshRegs, VGT_GS_MAX_VERT_OUT, MAX_VERT_OUT, maxVertOut);
 
   SET_REG_FIELD(&config->meshRegs, VGT_GS_MODE, MODE, GS_SCENARIO_G);
   SET_REG_FIELD(&config->meshRegs, VGT_GS_MODE, ONCHIP, VGT_GS_MODE_ONCHIP_OFF);
   SET_REG_FIELD(&config->meshRegs, VGT_GS_MODE, ES_WRITE_OPTIMIZE, false);
   SET_REG_FIELD(&config->meshRegs, VGT_GS_MODE, GS_WRITE_OPTIMIZE, true);
 
   assert(calcFactor.esVertsPerSubgroup == 1 && calcFactor.gsPrimsPerSubgroup == 1);
   SET_REG_FIELD(&config->meshRegs, VGT_GS_ONCHIP_CNTL, ES_VERTS_PER_SUBGRP, 1);
@@ -1773,26 +1875,45 @@ template <typename T> void ConfigBuilder::buildMeshRegConfig(ShaderStage shaderS
   setupPaSpecificRegisters(&config->meshRegs);
 
   //
   // Build NGG specific configuration
   //
   assert(calcFactor.primAmpFactor >= 1);
   SET_REG_FIELD(&config->meshRegs, GE_NGG_SUBGRP_CNTL, PRIM_AMP_FACTOR, calcFactor.primAmpFactor);
   SET_REG_FIELD(&config->meshRegs, GE_NGG_SUBGRP_CNTL, THDS_PER_SUBGRP, calcFactor.primAmpFactor);
 
   const bool enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
-  const bool hasPrimitivePayload = builtInUsage.primitiveId || builtInUsage.layer || builtInUsage.viewportIndex ||
-                                   builtInUsage.primitiveShadingRate || enableMultiView;
+  bool hasPrimitivePayload =
+      builtInUsage.layer || builtInUsage.viewportIndex || builtInUsage.primitiveShadingRate || enableMultiView;
+  if (gfxIp.major < 11)
+    hasPrimitivePayload |= builtInUsage.primitiveId;
   SET_REG_FIELD(&config->meshRegs, SPI_SHADER_IDX_FORMAT, IDX0_EXPORT_FORMAT,
                 hasPrimitivePayload ? SPI_SHADER_2COMP : SPI_SHADER_1COMP);
   SET_REG_GFX10_PLUS_FIELD(&config->meshRegs, VGT_DRAW_PAYLOAD_CNTL, EN_PRIM_PAYLOAD, hasPrimitivePayload);
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_DIM, MESHLET_NUM_THREAD_X, meshMode.workgroupSizeX - 1);
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_DIM, MESHLET_NUM_THREAD_Y, meshMode.workgroupSizeY - 1);
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_DIM, MESHLET_NUM_THREAD_Z, meshMode.workgroupSizeZ - 1);
+    // NOTE: If row export for mesh shader is enabled, the thread group size is set according to dimensions of work
+    // group. Otherwise, it is set according to actual primitive amplification factor.
+    const unsigned threadGroupSize = m_pipelineState->enableMeshRowExport()
+                                         ? meshMode.workgroupSizeX * meshMode.workgroupSizeY * meshMode.workgroupSizeZ
+                                         : calcFactor.primAmpFactor;
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_DIM, MESHLET_THREADGROUP_SIZE, threadGroupSize - 1);
+
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_EXP_ALLOC, MAX_EXP_VERTS, meshMode.outputVertices);
+    SET_REG_FIELD(&config->meshRegs, SPI_SHADER_GS_MESHLET_EXP_ALLOC, MAX_EXP_PRIMS, meshMode.outputPrimitives);
+  }
+#endif
+
   setWaveFrontSize(Util::Abi::HardwareStage::Gs, waveSize);
 
   setNumAvailSgprs(Util::Abi::HardwareStage::Gs, resUsage->numSgprsAvailable);
   setNumAvailVgprs(Util::Abi::HardwareStage::Gs, resUsage->numVgprsAvailable);
 
   const unsigned checksum = setShaderHash(ShaderStageMesh);
   if (m_pipelineState->getTargetInfo().getGpuProperty().supportShaderPowerProfiling)
     SET_REG_FIELD(&config->meshRegs, SPI_SHADER_PGM_CHKSUM_GS, CHECKSUM, checksum);
 
   //
@@ -1844,21 +1965,21 @@ void ConfigBuilder::buildCsRegConfig(ShaderStage shaderStage, CsRegConfig *confi
   }
 
   unsigned floatMode = setupFloatingPointMode(shaderStage);
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC1, FLOAT_MODE, floatMode);
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC1, DX10_CLAMP, true); // Follow PAL setting
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC1, DEBUG_MODE, shaderOptions.debugMode);
 
   GfxIpVersion gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
 
   if (gfxIp.major >= 10) {
-    bool wgpMode = getShaderWgpMode(shaderStage);
+    bool wgpMode = m_pipelineState->getShaderWgpMode(shaderStage);
 
     SET_REG_GFX10_PLUS_FIELD(config, COMPUTE_PGM_RSRC1, MEM_ORDERED, true);
     SET_REG_GFX10_PLUS_FIELD(config, COMPUTE_PGM_RSRC1, WGP_MODE, wgpMode);
     unsigned waveSize = m_pipelineState->getShaderWaveSize(shaderStage);
     assert(waveSize == 32 || waveSize == 64);
     setWaveFrontSize(Util::Abi::HardwareStage::Cs, waveSize);
   }
 
   // Set registers based on shader interface data
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC2, TRAP_PRESENT, shaderOptions.trapPresent);
@@ -1869,20 +1990,27 @@ void ConfigBuilder::buildCsRegConfig(ShaderStage shaderStage, CsRegConfig *confi
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC2, TG_SIZE_EN, true);
 
   // 0 = X, 1 = XY, 2 = XYZ
   unsigned tidigCompCnt = 0;
   if (workgroupSizes[2] > 1)
     tidigCompCnt = 2;
   else if (workgroupSizes[1] > 1)
     tidigCompCnt = 1;
   SET_REG_FIELD(config, COMPUTE_PGM_RSRC2, TIDIG_COMP_CNT, tidigCompCnt);
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    // Pixel wait sync+
+    SET_REG_GFX11_FIELD(config, COMPUTE_PGM_RSRC3, IMAGE_OP, resUsage->useImageOp);
+  }
+#endif
+
   SET_REG_FIELD(config, COMPUTE_NUM_THREAD_X, NUM_THREAD_FULL, workgroupSizes[0]);
   SET_REG_FIELD(config, COMPUTE_NUM_THREAD_Y, NUM_THREAD_FULL, workgroupSizes[1]);
   SET_REG_FIELD(config, COMPUTE_NUM_THREAD_Z, NUM_THREAD_FULL, workgroupSizes[2]);
 
   setThreadgroupDimensions(workgroupSizes);
 
   setNumAvailSgprs(Util::Abi::HardwareStage::Cs, resUsage->numSgprsAvailable);
   setNumAvailVgprs(Util::Abi::HardwareStage::Cs, resUsage->numVgprsAvailable);
 
   const unsigned checksum = setShaderHash(shaderStage);
@@ -2101,21 +2229,25 @@ template <typename T> void ConfigBuilder::setupPaSpecificRegisters(T *config) {
   // VTE_VPORT_PROVOKE_DISABLE.
   if (useViewportIndex) {
     // TODO: In the future, we can only disable vertex reuse only if viewport array index is emitted divergently
     // for each vertex.
     disableVertexReuse = true;
     SET_REG_FIELD(config, PA_CL_CLIP_CNTL, VTE_VPORT_PROVOKE_DISABLE, true);
   } else {
     SET_REG_FIELD(config, PA_CL_CLIP_CNTL, VTE_VPORT_PROVOKE_DISABLE, false);
   }
 
+#if LLPC_BUILD_GFX11
+  SET_REG_FIELD(config, VGT_REUSE_OFF, REUSE_OFF, disableVertexReuse || m_pipelineState->enableSwXfb());
+#else
   SET_REG_FIELD(config, VGT_REUSE_OFF, REUSE_OFF, disableVertexReuse);
+#endif
 
   bool miscExport = usePointSize;
   if (!meshPipeline) {
     // NOTE: Those built-ins are exported through primitive payload for mesh pipeline rather than vertex position data.
     miscExport |= useLayer || useViewportIndex || useShadingRate;
   }
 
   if (miscExport) {
     SET_REG_FIELD(config, PA_CL_VS_OUT_CNTL, USE_VTX_POINT_SIZE, usePointSize);
 
@@ -2176,28 +2308,13 @@ template <typename T> void ConfigBuilder::setupPaSpecificRegisters(T *config) {
     SET_REG_FIELD(config, SPI_SHADER_POS_FORMAT, POS1_EXPORT_FORMAT, SPI_SHADER_4COMP);
   }
   if (posCount > 2) {
     SET_REG_FIELD(config, SPI_SHADER_POS_FORMAT, POS2_EXPORT_FORMAT, SPI_SHADER_4COMP);
   }
   if (posCount > 3) {
     SET_REG_FIELD(config, SPI_SHADER_POS_FORMAT, POS3_EXPORT_FORMAT, SPI_SHADER_4COMP);
   }
 }
 
-// =====================================================================================================================
-// Gets WGP mode enablement for the specified shader stage
-//
-// @param shaderStage : Shader stage
-bool ConfigBuilder::getShaderWgpMode(ShaderStage shaderStage) const {
-  if (shaderStage == ShaderStageCopyShader) {
-    // Treat copy shader as part of geometry shader
-    shaderStage = ShaderStageGeometry;
-  }
-
-  assert(shaderStage <= ShaderStageCompute);
-
-  return m_pipelineState->getShaderOptions(shaderStage).wgpMode;
-}
-
 } // namespace Gfx9
 
 } // namespace lgc
diff --git a/lgc/patch/Gfx9ConfigBuilder.h b/lgc/patch/Gfx9ConfigBuilder.h
index 811c354aa..ec7222339 100644
--- a/lgc/patch/Gfx9ConfigBuilder.h
+++ b/lgc/patch/Gfx9ConfigBuilder.h
@@ -68,17 +68,15 @@ private:
   template <typename T> void buildVsRegConfig(ShaderStage shaderStage, T *config);
   template <typename T> void buildLsHsRegConfig(ShaderStage shaderStage1, ShaderStage shaderStage2, T *config);
   template <typename T> void buildEsGsRegConfig(ShaderStage shaderStage1, ShaderStage shaderStage2, T *config);
   template <typename T> void buildPrimShaderRegConfig(ShaderStage shaderStage1, ShaderStage shaderStage2, T *config);
   template <typename T> void buildPsRegConfig(ShaderStage shaderStage, T *config);
   template <typename T> void buildMeshRegConfig(ShaderStage shaderStage, T *config);
   void buildCsRegConfig(ShaderStage shaderStage, CsRegConfig *config);
 
   void setupVgtTfParam(LsHsRegConfig *config);
   template <typename T> void setupPaSpecificRegisters(T *config);
-
-  bool getShaderWgpMode(ShaderStage shaderStage) const;
 };
 
 } // namespace Gfx9
 
 } // namespace lgc
diff --git a/lgc/patch/MeshTaskShader.cpp b/lgc/patch/MeshTaskShader.cpp
index 72b305045..5f404e847 100644
--- a/lgc/patch/MeshTaskShader.cpp
+++ b/lgc/patch/MeshTaskShader.cpp
@@ -311,20 +311,25 @@ GlobalVariable *MeshTaskShader::getOrCreateMeshLds(Module *module, unsigned mesh
   newMeshLds->setAlignment(MaybeAlign(sizeof(unsigned)));
   return newMeshLds;
 }
 
 // =====================================================================================================================
 // Check whether flat workgroup ID will be used directly or indirectly in mesh shader.
 //
 // @param pipelineState : Pipeline state
 // @returns : The flag indicating whether flat workgroup ID is used.
 unsigned MeshTaskShader::useFlatWorkgroupId(PipelineState *pipelineState) {
+#if LLPC_BUILD_GFX11
+  // NOTE: For GFX11+, HW will provide workgroup ID via SGPRs. We don't need flat workgroup ID to do emulation.
+  if (pipelineState->getTargetInfo().getGfxIpVersion().major >= 11)
+    return false;
+#endif
 
   const auto &builtInUsage = pipelineState->getShaderResourceUsage(ShaderStageMesh)->builtInUsage.mesh;
   return builtInUsage.workgroupId || builtInUsage.globalInvocationId;
 }
 
 // =====================================================================================================================
 // Process task shader lowering.
 //
 // @param entryPoint : Entry-point of task shader
 void MeshTaskShader::processTaskShader(Function *entryPoint) {
@@ -616,20 +621,25 @@ void MeshTaskShader::processMeshShader(Function *entryPoint) {
     if (m_pipelineState->enableMeshRowExport()) {
       loopIndexPhi = m_builder->CreatePHI(m_builder->getInt32Ty(), 2);
       loopIndexPhi->addIncoming(m_builder->getInt32(0), entryBlock); // loopIndex = 0
 
       // primitiveIndex = threadIdInSubgroup + loopIndex * waveSize
       m_waveThreadInfo.primOrVertexIndex =
           m_builder->CreateAdd(m_waveThreadInfo.threadIdInSubgroup,
                                m_builder->CreateMul(loopIndexPhi, m_builder->getInt32(waveSize)), "primitiveIndex");
     }
 
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11)
+      prepareAttribRingAccess();
+#endif
+
     auto validPrimitive =
         m_builder->CreateICmpULT(m_waveThreadInfo.primOrVertexIndex, m_builder->getInt32(meshMode.outputPrimitives));
     m_builder->CreateCondBr(validPrimitive, initPrimitiveIndicesBodyBlock, endInitPrimitiveIndicesBlock);
   }
 
   // Construct ".initPrimitiveIndicesBody" block
   {
     m_builder->SetInsertPoint(initPrimitiveIndicesBodyBlock);
 
     if (m_pipelineState->enableMeshRowExport()) {
@@ -844,43 +854,57 @@ void MeshTaskShader::processMeshShader(Function *entryPoint) {
     m_builder->SetInsertPoint(exportPrimitiveHeaderBlock);
 
     if (m_pipelineState->enableMeshRowExport()) {
       loopIndexPhi = m_builder->CreatePHI(m_builder->getInt32Ty(), 2);
       loopIndexPhi->addIncoming(m_builder->getInt32(0), checkExportPrimitiveBlock); // loopIndex = 0
 
       // primitiveIndex = threadIdInSubgroup + loopIndex * waveSize
       m_waveThreadInfo.primOrVertexIndex =
           m_builder->CreateAdd(m_waveThreadInfo.threadIdInSubgroup,
                                m_builder->CreateMul(loopIndexPhi, m_builder->getInt32(waveSize)), "primitiveIndex");
+
+#if LLPC_BUILD_GFX11
+      if (m_gfxIp.major >= 11) {
+        // rowInSubgroup = waveIdInSubgroup + loopIndex
+        m_waveThreadInfo.rowInSubgroup =
+            m_builder->CreateAdd(m_waveThreadInfo.waveIdInSubgroup, loopIndexPhi, "rowInSubgroup");
+      }
+#endif
     }
 
     auto validPrimitive = m_builder->CreateICmpULT(m_waveThreadInfo.primOrVertexIndex, primitiveCount);
     m_builder->CreateCondBr(validPrimitive, exportPrimitiveBodyBlock, endExportPrimitiveBlock);
   }
 
   // Construct ".exportPrimitiveBody" block
   {
     m_builder->SetInsertPoint(exportPrimitiveBodyBlock);
 
     if (m_pipelineState->enableMeshRowExport()) {
       //
       // Row export is something like this:
       //
       //   loopIndex = 0
       //   primitiveIndex = threadIdInSubgroup
+#if LLPC_BUILD_GFX11
+      //   rowInSubgroup = waveIdInSubgroup
+#endif
       //
       //   while (primitiveIndex < primitiveCount) {
       //     Export primitive
       //     Export primitive attributes
       //
       //     loopIndex += numWaves
       //     primitiveIndex += loopIndex * waveSize
+#if LLPC_BUILD_GFX11
+      //     rowInSubgroup += loopIndex
+#endif
       //   }
       //
       auto loopIndex = m_builder->CreateAdd(loopIndexPhi, m_builder->getInt32(numWaves)); // loopIndex += numWaves
       loopIndexPhi->addIncoming(loopIndex, exportPrimitiveBodyBlock);
     }
 
     exportPrimitive();
     m_builder->CreateBr(m_pipelineState->enableMeshRowExport() ? exportPrimitiveHeaderBlock : endExportPrimitiveBlock);
   }
 
@@ -896,43 +920,57 @@ void MeshTaskShader::processMeshShader(Function *entryPoint) {
     m_builder->SetInsertPoint(exportVertexHeaderBlock);
 
     if (m_pipelineState->enableMeshRowExport()) {
       loopIndexPhi = m_builder->CreatePHI(m_builder->getInt32Ty(), 2);
       loopIndexPhi->addIncoming(m_builder->getInt32(0), endExportPrimitiveBlock); // loopIndex = 0
 
       // vertexIndex = threadIdInSubgroup + loopIndex * waveSize
       m_waveThreadInfo.primOrVertexIndex =
           m_builder->CreateAdd(m_waveThreadInfo.threadIdInSubgroup,
                                m_builder->CreateMul(loopIndexPhi, m_builder->getInt32(waveSize)), "vertexIndex");
+
+#if LLPC_BUILD_GFX11
+      if (m_gfxIp.major >= 11) {
+        // rowInSubgroup = waveIdInSubgroup + loopIndex
+        m_waveThreadInfo.rowInSubgroup =
+            m_builder->CreateAdd(m_waveThreadInfo.waveIdInSubgroup, loopIndexPhi, "rowInSubgroup");
+      }
+#endif
     }
 
     auto validVertex = m_builder->CreateICmpULT(m_waveThreadInfo.primOrVertexIndex, vertexCount);
     m_builder->CreateCondBr(validVertex, exportVertexBodyBlock, endExportVertexBlock);
   }
 
   // Construct "exportVertexBody" block
   {
     m_builder->SetInsertPoint(exportVertexBodyBlock);
 
     if (m_pipelineState->enableMeshRowExport()) {
       //
       // Row export is something like this:
       //
       //   loopIndex = 0
       //   vertexIndex = threadIdInSubgroup
+#if LLPC_BUILD_GFX11
+      //   rowInSubgroup = waveIdInSubgroup
+#endif
       //
       //   while (vertexIndex < vertexCount) {
       //     Export vertex position data
       //     Export vertex attributes
       //
       //     loopIndex += numWaves
       //     vertexIndex += loopIndex * waveSize
+#if LLPC_BUILD_GFX11
+      //     rowInSubgroup += loopIndex
+#endif
       //   }
       //
       auto loopIndex = m_builder->CreateAdd(loopIndexPhi, m_builder->getInt32(numWaves)); // loopIndex += numWaves
       loopIndexPhi->addIncoming(loopIndex, exportVertexBodyBlock);
     }
 
     exportVertex();
     m_builder->CreateBr(m_pipelineState->enableMeshRowExport() ? exportVertexHeaderBlock : endExportVertexBlock);
   }
 
@@ -1288,20 +1326,41 @@ void MeshTaskShader::initWaveThreadInfo(Function *entryPoint) {
           Intrinsic::amdgcn_mbcnt_hi, {}, {m_builder->getInt32(-1), m_waveThreadInfo.threadIdInWave});
     }
     m_waveThreadInfo.threadIdInWave->setName("threadIdInWave");
 
     m_waveThreadInfo.threadIdInSubgroup =
         m_builder->CreateAdd(m_builder->CreateMul(m_waveThreadInfo.waveIdInSubgroup, m_builder->getInt32(waveSize)),
                              m_waveThreadInfo.threadIdInWave, "threadIdInSubgroup");
 
     m_waveThreadInfo.primOrVertexIndex =
         m_waveThreadInfo.threadIdInSubgroup; // Primitive or vertex index is initialized to thread ID in subgroup
+
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11) {
+      // The workgroup ID X and Y are reused via the SGPR of off-chip LDS base in NGG new fast launch mode
+      Value *workgroupIdYX =
+          getFunctionArgument(entryPoint, ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::OffChipLdsBase));
+      // workgroupIdY = workgroupIdXY[31:16]
+      m_waveThreadInfo.workgroupIdY =
+          m_builder->CreateAnd(m_builder->CreateLShr(workgroupIdYX, 16), 0xFFFF, "workgroupIdY");
+      // workgroupIdX = workgroupIdXY[15:0]
+      m_waveThreadInfo.workgroupIdX = m_builder->CreateAnd(workgroupIdYX, 0xFFFF, "workgroupIdX");
+      // workgroupIdZ = attribRingBaseAndWorkgroupIdZ[31:16]
+      Value *workgroupIdZAndAttribRingBase =
+          getFunctionArgument(entryPoint, ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::AttribRingBase));
+      m_waveThreadInfo.workgroupIdZ =
+          m_builder->CreateAnd(m_builder->CreateLShr(workgroupIdZAndAttribRingBase, 16), 0xFFFF, "workgroupIdZ");
+
+      m_waveThreadInfo.rowInSubgroup =
+          m_waveThreadInfo.waveIdInSubgroup; // Row number is initialized to wave ID in subgroup
+    }
+#endif
   }
 }
 
 // =====================================================================================================================
 // Get shader ring entry index of current workgroup from the entry-point.
 //
 // @param entryPoint : Shader entry-point
 // @returns : The shader ring entry index of current workgroup
 Value *MeshTaskShader::getShaderRingEntryIndex(Function *entryPoint) {
   if (!m_shaderRingEntryIndex) {
@@ -1527,23 +1586,36 @@ Value *MeshTaskShader::convertToDivergent(Value *value) {
 // @returns : New entry-point of mesh shader after mutation
 Function *MeshTaskShader::mutateMeshShaderEntryPoint(Function *entryPoint) {
   assert(getShaderStage(entryPoint) == ShaderStageMesh); // Must be mesh shader
 
   // GFX10 special SGPR input names
   static const SmallVector<std::string, NumSpecialSgprInputs> SpecialSgprInputNamesGfx10 = {
       "gsUserDataAddrLow", "gsUserDataAddrHigh",  "mergedGroupInfo", "mergedWaveInfo",
       "offChipLdsBase",    "sharedScratchOffset", "gsShaderAddrLow", "gsShaderAddrHigh",
   };
 
+#if LLPC_BUILD_GFX11
+  // GFX10 special SGPR input names
+  static const SmallVector<std::string, NumSpecialSgprInputs> SpecialSgprInputNamesGfx11 = {
+      "gsProgramAddrLow", "gsProgramAddrHigh", "mergedGroupInfo",
+      "mergedWaveInfo",   "workgroupIdYX",     "workgroupIdZAndAttribRingBase",
+      "flatScratchLow",   "flatScratchHigh",
+  };
+#endif
+
   ArrayRef<std::string> specialSgprInputNames;
   if (m_gfxIp.major == 10)
     specialSgprInputNames = makeArrayRef(SpecialSgprInputNamesGfx10);
+#if LLPC_BUILD_GFX11
+  else if (m_gfxIp.major == 11)
+    specialSgprInputNames = makeArrayRef(SpecialSgprInputNamesGfx11);
+#endif
   assert(specialSgprInputNames.size() == NumSpecialSgprInputs);
 
   // Add special SGPR inputs, prior to existing user data SGPRs
   auto int32Ty = m_builder->getInt32Ty();
   auto newEntryPoint =
       addFunctionArgs(entryPoint, nullptr, {int32Ty, int32Ty, int32Ty, int32Ty, int32Ty, int32Ty, int32Ty, int32Ty},
                       specialSgprInputNames, (1u << NumSpecialSgprInputs) - 1);
 
   assert(entryPoint->use_empty());
   entryPoint->eraseFromParent();
@@ -1943,26 +2015,35 @@ void MeshTaskShader::exportPrimitive() {
 
   // The first dword is primitive connectivity data
   auto primitiveIndices = readValueFromLds(m_builder->getInt32Ty(), ldsOffset);
 
   // The second dword is primitive payload, which has the following bit layout specified by HW:
   //
   //   +------------+------------+---------+----------------+----------------+------------------+
   //   | VRS Rate Y | VRS Rate X | Unused  | Viewport Index | RT Slice Index | Pipeline Prim ID |
   //   | [31:30]    | [29:28]    | [27:24] | [23:20]        | [19:17]        | [16:0]           |
   //   +------------+------------+---------+----------------+----------------+------------------+
+#if LLPC_BUILD_GFX11
+  //
+  // On GFX11, the bit layout is changed:
+  //
+  //   +---------------+---------+----------------+---------+----------------+
+  //   | VRS Rate Enum | Unused  | Viewport Index | Unused  | RT Slice Index |
+  //   | [31:28]       | [27:24] | [23:20]        | [19:13] | [12:0]         |
+  //   +---------------+---------+----------------+---------+----------------+
+#endif
   Value *primitivePayload = nullptr;
   Value *primitiveId = nullptr;
   if (builtInUsage.primitiveId) {
+    primitiveId = readMeshBuiltInFromLds(BuiltInPrimitiveId);
     if (m_gfxIp.major < 11) {
       // [16:0] = Pipeline primitive ID
-      primitiveId = readMeshBuiltInFromLds(BuiltInPrimitiveId);
       auto primitiveIdMaskAndShift = m_builder->CreateAnd(primitiveId, 0x1FFFF);
       if (primitivePayload)
         primitivePayload = m_builder->CreateOr(primitivePayload, primitiveIdMaskAndShift);
       else
         primitivePayload = primitiveIdMaskAndShift;
     }
   }
 
   Value *layer = nullptr;
   if (builtInUsage.layer)
@@ -1970,26 +2051,34 @@ void MeshTaskShader::exportPrimitive() {
 
   Value *viewIndex = nullptr;
   const bool enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
   if (enableMultiView) {
     auto entryPoint = m_builder->GetInsertBlock()->getParent();
     const auto entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageMesh)->entryArgIdxs.mesh;
     viewIndex = getFunctionArgument(entryPoint, entryArgIdxs.viewIndex);
   }
 
   if (enableMultiView || builtInUsage.layer) {
+#if LLPC_BUILD_GFX11
+    // [19:17] = RT slice index (on GFX11, [12:0] = RT slice index)
+#else
     // [19:17] = RT slice index
+#endif
     // When multi-view is enabled, the input view index is treated as the output layer.
     Value *layerMaskAndShift = nullptr;
     if (m_gfxIp.major < 11) {
       layerMaskAndShift = m_builder->CreateAnd(enableMultiView ? viewIndex : layer, 0x7);
       layerMaskAndShift = m_builder->CreateShl(layerMaskAndShift, 17);
+#if LLPC_BUILD_GFX11
+    } else {
+      layerMaskAndShift = m_builder->CreateAnd(enableMultiView ? viewIndex : layer, 0x1FFF);
+#endif
     }
     if (primitivePayload)
       primitivePayload = m_builder->CreateOr(primitivePayload, layerMaskAndShift);
     else
       primitivePayload = layerMaskAndShift;
   }
 
   Value *viewportIndex = nullptr;
   if (builtInUsage.viewportIndex) {
     // [23:20] = Viewport index
@@ -2073,29 +2162,20 @@ void MeshTaskShader::exportPrimitive() {
 
   if (exportLayer) {
     if (inOutUsage.mesh.perPrimitiveBuiltInExportLocs.count(BuiltInLayer) > 0) {
       assert(layer);
       const unsigned exportLoc = inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInLayer];
       primAttrExports.push_back({startLoc + exportLoc, layer});
       ++inOutUsage.primExpCount;
     }
   }
 
-  if (enableMultiView) {
-    if (inOutUsage.mesh.perPrimitiveBuiltInExportLocs.count(BuiltInViewIndex) > 0) {
-      assert(viewIndex);
-      const unsigned exportLoc = inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInViewIndex];
-      primAttrExports.push_back({startLoc + exportLoc, viewIndex});
-      ++inOutUsage.primExpCount;
-    }
-  }
-
   bool exportViewportIndex = false;
   if (builtInUsage.viewportIndex) {
     exportViewportIndex = true;
   } else {
     const auto nextStage = m_pipelineState->getNextShaderStage(ShaderStageMesh);
     if (nextStage == ShaderStageFragment) {
       const auto &fsBuiltInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs;
       if (fsBuiltInUsage.viewportIndex) {
         // NOTE: In such case, mesh shader doesn't export viewport index while fragment shader expects to read it. We
         // export 0 to fragment shader, which is required by spec.
@@ -2180,21 +2260,28 @@ void MeshTaskShader::exportVertex() {
     posExports.push_back(
         {pos, {clipCullDistances[0], clipCullDistances[1], clipCullDistances[2], clipCullDistances[3]}});
 
     if (clipCullDistances.size() > 4) {
       // Do the second exporting
       posExports.push_back(
           {pos + 1, {clipCullDistances[4], clipCullDistances[5], clipCullDistances[6], clipCullDistances[7]}});
     }
   }
 
-  doExport(ExportKind::Pos, posExports);
+  bool waAtmPrecedesPos = false;
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11)
+    waAtmPrecedesPos = m_pipelineState->getTargetInfo().getGpuWorkarounds().gfx11.waAtmPrecedesPos;
+#endif
+
+  if (!waAtmPrecedesPos)
+    doExport(ExportKind::Pos, posExports);
 
   SmallVector<ExportInfo, 32> vertAttrExports;
 
   // Export vertex attributes (from generic outputs)
   Value *ldsStart = m_builder->getInt32(getMeshShaderLdsRegionStart(MeshLdsRegion::VertexOutput));
   auto vertexStride = 4 * inOutUsage.outputMapLocCount;
   auto ldsOffsetBase = m_builder->CreateMul(m_waveThreadInfo.primOrVertexIndex, m_builder->getInt32(vertexStride));
   ldsOffsetBase = m_builder->CreateAdd(ldsStart, ldsOffsetBase);
 
   for (unsigned i = 0; i < inOutUsage.mesh.genericOutputMapLocCount; ++i) {
@@ -2264,20 +2351,27 @@ void MeshTaskShader::exportVertex() {
       if (clipCullDistances.size() > 4) {
         // Do the second exporting
         vertAttrExports.push_back(
             {exportLoc + 1, {clipCullDistances[4], clipCullDistances[5], clipCullDistances[6], clipCullDistances[7]}});
         ++inOutUsage.expCount;
       }
     }
   }
 
   doExport(ExportKind::VertAttr, vertAttrExports);
+  if (waAtmPrecedesPos) {
+    // Before the first export call of vertex position data, add s_wait_vscnt 0 to make sure the completion of all
+    // attributes being written to the attribute ring buffer
+    m_builder->CreateFence(AtomicOrdering::Release, SyncScope::System);
+
+    doExport(ExportKind::Pos, posExports);
+  }
 }
 
 // =====================================================================================================================
 // Collect mesh shader statistics and write this info to mesh pipeline statistics buffer.
 //
 // @param entryPoint : Entry-point of mesh shader
 // @param numMeshPrimitives : Actual number of primitives emitted by mesh shader
 void MeshTaskShader::collectMeshStatsInfo(Function *entryPoint, Value *numMeshPrimitives) {
   if (!m_pipelineState->needSwMeshPipelineStats())
     return;
@@ -2371,36 +2465,143 @@ void MeshTaskShader::doExport(ExportKind kind, ArrayRef<ExportInfo> exports) {
       break;
     default:
       llvm_unreachable("Unexpected export target!");
       break;
     }
 
     bool exportDone = false;
     if ((kind == ExportKind::Pos || kind == ExportKind::Prim) && i == exports.size() - 1)
       exportDone = true; // Last export
 
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11) {
+      if (kind == ExportKind::Pos || kind == ExportKind::Prim) {
+        m_builder->CreateIntrinsic(Intrinsic::amdgcn_exp_row, valueTy,
+                                   {
+                                       m_builder->getInt32(target + exports[i].index), // tgt
+                                       m_builder->getInt32(validMask),                 // en
+                                       values[0],                                      // src0
+                                       values[1] ? values[1] : undef,                  // src1
+                                       values[2] ? values[2] : undef,                  // src2
+                                       values[3] ? values[3] : undef,                  // src3
+                                       m_builder->getInt1(exportDone),                 // done
+                                       m_waveThreadInfo.rowInSubgroup,                 // row number
+                                   });
+      } else {
+        assert(kind == ExportKind::VertAttr || kind == ExportKind::PrimAttr);
+
+        Value *valueToStore = UndefValue::get(FixedVectorType::get(valueTy, 4));
+        for (unsigned j = 0; j < 4; ++j) {
+          if (values[j])
+            valueToStore = m_builder->CreateInsertElement(valueToStore, values[j], j);
+        }
+
+        // ringOffset = attribRingBaseOffset + 32 * exportIndex * 16
+        //            = attribRingBaseOffset + exportIndex * 512
+        unsigned exportIndex = exports[i].index;
+        if (kind == ExportKind::PrimAttr && m_hasNoVertexAttrib) {
+          // NOTE: HW allocates and manages attribute ring based on the register fields: VS_EXPORT_COUNT and
+          // PRIM_EXPORT_COUNT. When VS_EXPORT_COUNT = 0, HW assumes there is still a vertex attribute exported even
+          // though this is not what we want. Hence, we should reserve param0 as a dummy vertex attribute and all
+          // primitive attributes are moved after it.
+          ++exportIndex;
+        }
+        auto ringOffset =
+            m_builder->CreateAdd(m_attribRingBaseOffset, m_builder->getInt32(AttribGranularity * exportIndex));
+
+        CoherentFlag coherent = {};
+        coherent.bits.glc = true;
+
+        m_builder->CreateIntrinsic(Intrinsic::amdgcn_struct_buffer_store, valueToStore->getType(),
+                                   {valueToStore, m_attribRingBufDesc, m_waveThreadInfo.threadIdInSubgroup,
+                                    m_builder->getInt32(0), ringOffset, m_builder->getInt32(coherent.u32All)});
+      }
+    } else {
+#else
     {
+#endif
       m_builder->CreateIntrinsic(Intrinsic::amdgcn_exp, valueTy,
                                  {
                                      m_builder->getInt32(target + exports[i].index), // tgt
                                      m_builder->getInt32(validMask),                 // en
                                      values[0],                                      // src0
                                      values[1] ? values[1] : undef,                  // src1
                                      values[2] ? values[2] : undef,                  // src2
                                      values[3] ? values[3] : undef,                  // src3
                                      m_builder->getInt1(exportDone),                 // done
                                      m_builder->getFalse(),                          // vm
                                  });
     }
   }
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Prepare attribute ring access by collecting attribute count, modifying the STRIDE field of attribute ring buffer
+// descriptor, and calculating subgroup's attribute ring base offset.
+void MeshTaskShader::prepareAttribRingAccess() {
+  assert(m_gfxIp.major >= 11); // Must be GFX11+
+
+  // The allocated numbers of vertex/primitive attributes are something as follow:
+  //   1. Generic vertex attributes
+  //   2. Vertex attributes mapped from vertex builtins
+  //   3. Generic primitive attributes
+  //   4. Primitive attributes mapped from primitive builtins
+  const auto &inOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageMesh)->inOutUsage.mesh;
+  unsigned vertAttribCount = inOutUsage.genericOutputMapLocCount;
+  for (auto &builtInExport : inOutUsage.builtInExportLocs) {
+    const unsigned exportLoc = builtInExport.second;
+    vertAttribCount = std::max(vertAttribCount, exportLoc + 1);
+  }
+
+  unsigned primAttribCount = inOutUsage.perPrimitiveGenericOutputMapLocCount;
+  for (auto &perPrimitiveBuiltInExport : inOutUsage.perPrimitiveBuiltInExportLocs) {
+    const unsigned exportLoc = perPrimitiveBuiltInExport.second;
+    primAttribCount = std::max(primAttribCount, exportLoc + 1);
+  }
+
+  unsigned attribCount = vertAttribCount + primAttribCount;
+  if (attribCount == 0)
+    return; // No attribute export
+
+  // NOTE: HW allocates and manages attribute ring based on the register fields: VS_EXPORT_COUNT and PRIM_EXPORT_COUNT.
+  // When VS_EXPORT_COUNT = 0, HW assumes there is still a vertex attribute exported even though this is not what we
+  // want. Hence, we should reserve param0 as a dummy vertex attribute.
+  if (vertAttribCount == 0) {
+    m_hasNoVertexAttrib = true;
+    ++attribCount; // Count in this dummy vertex attribute
+  }
+
+  // attribRingBase[14:0]
+  auto entryPoint = m_builder->GetInsertBlock()->getParent();
+  Value *attribRingBase =
+      getFunctionArgument(entryPoint, ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::AttribRingBase));
+  attribRingBase = m_builder->CreateAnd(attribRingBase, 0x7FFF);
+  m_attribRingBaseOffset =
+      m_builder->CreateMul(attribRingBase, m_builder->getInt32(AttribGranularity), "attribRingBaseOffset");
+
+  m_attribRingBufDesc = m_pipelineSysValues.get(entryPoint)->getAttribRingBufDesc();
+
+  // Modify the field STRIDE of attribute ring buffer descriptor
+  if (attribCount >= 2) {
+    // STRIDE = WORD1[30:16], STRIDE is multiplied by attribute count
+    auto descWord1 = m_builder->CreateExtractElement(m_attribRingBufDesc, 1);
+    auto stride = m_builder->CreateAnd(m_builder->CreateLShr(descWord1, 16), 0x3FFF);
+    stride = m_builder->CreateMul(stride, m_builder->getInt32(attribCount));
+
+    descWord1 = m_builder->CreateAnd(descWord1, ~0x3FFF0000);                     // Clear STRIDE
+    descWord1 = m_builder->CreateOr(descWord1, m_builder->CreateShl(stride, 16)); // Set new STRIDE
+    m_attribRingBufDesc = m_builder->CreateInsertElement(m_attribRingBufDesc, descWord1, 1);
+  }
+}
+#endif
+
 // =====================================================================================================================
 // Get the flat workgroup ID of mesh shader.
 //
 // @returns : Value of flat workgroup ID
 Value *MeshTaskShader::getMeshFlatWorkgroupId() {
   assert(getShaderStage(m_builder->GetInsertBlock()->getParent()) == ShaderStageMesh); // Must be mesh shader
 
   if (!m_meshFlatWorkgroupId) {
     auto ldsOffset = m_builder->getInt32(getMeshShaderLdsRegionStart(MeshLdsRegion::FlatWorkgroupId));
     auto flatWorkgroupId = readValueFromLds(m_builder->getInt32Ty(), ldsOffset);
@@ -2428,21 +2629,33 @@ Value *MeshTaskShader::getMeshNumWorkgroups() {
 
 // =====================================================================================================================
 // Get the built-in WorkgroupId of mesh shader.
 //
 // @returns : Value of the built-in WorkgroupId
 Value *MeshTaskShader::getMeshWorkgroupId() {
   auto entryPoint = m_builder->GetInsertBlock()->getParent();
   assert(getShaderStage(entryPoint) == ShaderStageMesh); // Must be mesh shader
 
   if (!m_meshWorkgroupId) {
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11) {
+      Value *workgroupId = UndefValue::get(FixedVectorType::get(m_builder->getInt32Ty(), 3));
+      workgroupId =
+          m_builder->CreateInsertElement(workgroupId, m_waveThreadInfo.workgroupIdX, static_cast<uint64_t>(0));
+      workgroupId = m_builder->CreateInsertElement(workgroupId, m_waveThreadInfo.workgroupIdY, 1);
+      workgroupId = m_builder->CreateInsertElement(workgroupId, m_waveThreadInfo.workgroupIdZ, 2);
+
+      m_meshWorkgroupId = workgroupId;
+    } else {
+#else
     {
+#endif
       // flatWorkgroupId = workgroupId.z * dispatchDims.x * dispatchDims.y +
       //                   workgroupId.y * dispatchDims.x + workgroupId.x
       //
       // workgroupId.z = flatWorkgroupId / dispatchDims.x * dispatchDims.y
       // workgroupId.y = (flatWorkgroupId - dispatchDims.x * dispatchDims.y * workgroupId.z) / dispatchDims.x
       // workgroupId.x = (flatWorkgroupId - dispatchDims.x * dispatchDims.y * workgroupId.z) -
       //                 dispatchDims.x * workgroupId.y
       auto flatWorkgroupId = getMeshFlatWorkgroupId();
 
       auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageMesh)->entryArgIdxs.mesh;
@@ -2659,22 +2872,76 @@ Value *MeshTaskShader::readMeshBuiltInFromLds(BuiltInKind builtIn) {
 
   return readValueFromLds(readTy, ldsOffset);
 }
 
 // =====================================================================================================================
 // Change primitive shading rate from API to HW-specific shading rate.
 //
 // @param primitiveShadingRate : Primitive shading rate from API
 // @returns : HW-specific shading rate
 Value *MeshTaskShader::convertToHwShadingRate(Value *primitiveShadingRate) {
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // NOTE: In GFX11, the graphics pipeline is to support VRS rates till 4x4 which includes 2x4 and 4x2 along with
+    // the legacy rates. And 1x4 and 4x1 are not supported, hence clamp 1x4 and 4x1 to 1x2 and 2x1 respectively.
+    // The HW shading rate representations are enumerations as following:
+    //
+    //   SHADING_RATE_1x1  0x0
+    //   SHADING_RATE_1x2  0x1
+    //   SHADING_RATE_2x1  0x4
+    //   SHADING_RATE_2x2  0x5
+    //   SHADING_RATE_2x4  0x6
+    //   SHADING_RATE_4x2  0x9
+    //   SHADING_RATE_4x4  0xA
+    //
+    // The shading rate is mapped as follow:
+    //
+    //   HorizontalNone    | VerticalNone    (1x1) = 0b0000 -> 0b0000 = 0x0
+    //   HorizontalNone    | Vertical2Pixels (1x2) = 0b0001 -> 0b0001 = 0x1
+    //   HorizontalNone    | Vertical4Pixels (1x4) = 0b0010 -> 0b0001 = 0x1 (clamped)
+    //   Horizontal2Pixels | VerticalNone    (2x1) = 0b0100 -> 0b0100 = 0x4
+    //   Horizontal2Pixels | Vertical2Pixels (2x2) = 0b0101 -> 0b0101 = 0x5
+    //   Horizontal2Pixels | Vertical4Pixels (2x4) = 0b0110 -> 0b0110 = 0x6
+    //   Horizontal4Pixels | VerticalNone    (4x1) = 0b1000 -> 0b0100 = 0x4 (clamped)
+    //   Horizontal4Pixels | Vertical2Pixels (4x2) = 0b1001 -> 0b1001 = 0x9
+    //   Horizontal4Pixels | Vertical4Pixels (4x4) = 0b1010 -> 0b1010 = 0xA
+    //
+
+    enum : unsigned {
+      HwShadingRate1x1 = 0x0,
+      HwShadingRate1x2 = 0x1,
+      HwShadingRate2x1 = 0x4,
+      HwShadingRate2x2 = 0x5,
+      HwShadingRate2x4 = 0x6,
+      HwShadingRate4x2 = 0x9,
+      HwShadingRate4x4 = 0xA,
+    };
+
+    // hwShadingRate = primitiveShadingRate & (Horizontal2Pixels | Horizontal4Pixels |
+    //                                         Vertical2Pixels | Vertical4Pixels)
+    auto hwShadingRate = m_builder->CreateAnd(
+        primitiveShadingRate, m_builder->getInt32(ShadingRateHorizontal2Pixels | ShadingRateHorizontal4Pixels |
+                                                  ShadingRateVertical2Pixels | ShadingRateVertical4Pixels));
+
+    // hwShadingRate = hwShadingRate == 1x4 ? 1x2 : hwShadingRate
+    Value *isRate1x4 = m_builder->CreateICmpEQ(hwShadingRate, m_builder->getInt32(ShadingRateVertical4Pixels));
+    hwShadingRate = m_builder->CreateSelect(isRate1x4, m_builder->getInt32(HwShadingRate1x2), hwShadingRate);
+
+    // hwShadingRate = hwShadingRate == 4x1 ? 2x1 : hwShadingRate
+    Value *isRate4x1 = m_builder->CreateICmpEQ(hwShadingRate, m_builder->getInt32(ShadingRateHorizontal4Pixels));
+    hwShadingRate = m_builder->CreateSelect(isRate4x1, m_builder->getInt32(HwShadingRate2x1), hwShadingRate);
+
+    return hwShadingRate;
+  }
+#endif
 
-  assert(m_gfxIp == GfxIpVersion({10, 3})); // Must be GFX10.3
+  assert(m_gfxIp.isGfx(10, 3)); // Must be GFX10.3
 
   // NOTE: The shading rates have different meanings in HW and LGC interface. GFX10.3 HW supports 2-pixel mode
   // and 4-pixel mode is not supported. But the spec requires us to accept unsupported rates and clamp them to
   // maxFragmentSize of HW. The mapping is therefore as follow:
   //
   //   VRS rate X: MaskNone -> 0b00, Horizontal2Pixels | Horizontal4Pixels -> 0b01
   //   VRS rate Y: MaskNone -> 0b00, Vertical2Pixels | Vertical4Pixels -> 0b01
   //
   // hwXRate = (primitiveShadingRate & (Horizontal2Pixels | Horizontal4Pixels)) ? 0x1 : 0x0
   Value *xRate2Pixels = m_builder->CreateAnd(
diff --git a/lgc/patch/MeshTaskShader.h b/lgc/patch/MeshTaskShader.h
index 253964469..50a701e1b 100644
--- a/lgc/patch/MeshTaskShader.h
+++ b/lgc/patch/MeshTaskShader.h
@@ -116,20 +116,24 @@ private:
     VertAttr = 2,
     PrimAttr = 3,
   };
   // Export info of a single entry
   struct ExportInfo {
     unsigned index;
     std::array<llvm::Value *, 4> values;
   };
   void doExport(ExportKind kind, llvm::ArrayRef<ExportInfo> exports);
 
+#if LLPC_BUILD_GFX11
+  void prepareAttribRingAccess();
+#endif
+
   llvm::Value *getMeshFlatWorkgroupId();
   llvm::Value *getMeshNumWorkgroups();
   llvm::Value *getMeshWorkgroupId();
   llvm::Value *getMeshLocalInvocationId();
   llvm::Value *getMeshLocalInvocationIndex();
   llvm::Value *getMeshGlobalInvocationId();
   llvm::Value *getGlobalInvocationIndex();
 
   llvm::Value *readMeshBuiltInFromLds(BuiltInKind builtIn);
   llvm::Value *convertToHwShadingRate(llvm::Value *primitiveShadingRate);
@@ -157,25 +161,37 @@ private:
   PipelineSystemValues m_pipelineSysValues; // Cache of ShaderSystemValues objects, one per shader stage
 
   std::unique_ptr<llvm::IRBuilder<>> m_builder; // LLVM IR builder
 
   // The wave/thread info used for control shader branching
   struct {
     llvm::Value *waveIdInSubgroup;
     llvm::Value *threadIdInWave;
     llvm::Value *threadIdInSubgroup;
     llvm::Value *primOrVertexIndex;
+#if LLPC_BUILD_GFX11
+    // Following info is for GFX11+
+    llvm::Value *workgroupIdX;
+    llvm::Value *workgroupIdY;
+    llvm::Value *workgroupIdZ;
+    llvm::Value *rowInSubgroup;
+#endif
   } m_waveThreadInfo = {};
 
   bool m_accessTaskPayload = false;                // Whether task shader has payload access operations
   llvm::Value *m_shaderRingEntryIndex = nullptr;   // Shader ring entry index of current workgroup
   llvm::Value *m_payloadRingEntryOffset = nullptr; // Entry offset (in bytes) of the payload ring
+#if LLPC_BUILD_GFX11
+  bool m_hasNoVertexAttrib = false;              // Whether mesh shader has vertex attribute export or not
+  llvm::Value *m_attribRingBufDesc = nullptr;    // Attribute ring buffer descriptor
+  llvm::Value *m_attribRingBaseOffset = nullptr; // Subgroup's attribute ring base offset (in bytes)
+#endif
 
   llvm::Value *m_meshFlatWorkgroupId = nullptr;       // Flat workgroupId of mesh shader
   llvm::Value *m_meshWorkgroupId = nullptr;           // Built-in WorkgroupId of mesh shader
   llvm::Value *m_meshLocalInvocationId = nullptr;     // Built-in LocalInvocationId of mesh shader
   llvm::Value *m_meshGlobalInvocationId = nullptr;    // Built-in GlobalInvocationId of mesh shader
   llvm::Value *m_meshGlobalInvocationIndex = nullptr; // Global invocation index of mesh shader
 
   llvm::Value *m_barrierToggle = nullptr;            // Toggle used by calculation of barrier completion flag
   bool m_needBarrierFlag = false;                    // Whether barrier completion flag is needed
   llvm::SmallVector<llvm::CallInst *, 8> m_barriers; // Barriers collected from API mesh shader
diff --git a/lgc/patch/NggLdsManager.cpp b/lgc/patch/NggLdsManager.cpp
index a74123b0e..e821a5d70 100644
--- a/lgc/patch/NggLdsManager.cpp
+++ b/lgc/patch/NggLdsManager.cpp
@@ -49,67 +49,101 @@ namespace lgc {
 
 // =====================================================================================================================
 // Initialize static members
 const unsigned NggLdsManager::LdsRegionSizes[LdsRegionCount] = {
     // clang-format off
     //
     // LDS region size for ES-only
     //
     // Distributed primitive ID size is dynamically calculated (don't use it)
     InvalidValue,                                             // LdsRegionDistribPrimId
+#if LLPC_BUILD_GFX11
+    // Transform feedback output size is dynamically calculated (don't use it)
+    InvalidValue,                                             // LdsRegionXfbOutput
+#endif
     // 4 dwords (vec4) per thread
     SizeOfVec4 * Gfx9::NggMaxThreadsPerSubgroup,              // LdsRegionVertPosData
     // Vertex cull info size is dynamically calculated (don't use it)
     InvalidValue,                                             // LdsRegionVertCullInfo
+#if LLPC_BUILD_GFX11
+    // 1 dword per XFB buffer: dword written, 1 dword: primitives to write
+    SizeOfDword * MaxTransformFeedbackBuffers + SizeOfDword,  // LdsRegionXfbStatInfo
+#endif
     // 1 dword per wave (8 potential waves) + 1 dword for the entire sub-group
     SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword, // LdsRegionVertCountInWaves
     // 1 dword (uint32) per thread
     SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup,             // LdsRegionVertThreadIdMap
 
     //
     // LDS region size for ES-GS
     //
     // ES-GS ring size is dynamically calculated (don't use it)
     InvalidValue,                                             // LdsRegionEsGsRing
     // 1 dword (uint32) per thread, 4 GS streams
     (SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup) * MaxGsStreams,
                                                               // LdsRegionOutPrimData
+#if LLPC_BUILD_GFX11
+    // 1 dword per wave (8 potential waves) + 1 dword for the entire sub-group, 4 GS streams
+    (SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword) * MaxGsStreams,
+                                                              // LdsRegionOutPrimCountInWaves
+    // 1 dword (uint32) per thread, 4 GS streams
+    (SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup) * MaxGsStreams,
+                                                              // LdsRegionOutPrimThreadIdMap
+#endif
     // 1 dword per wave (8 potential waves) + 1 dword for the entire sub-group, 4 GS streams
     (SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword) * MaxGsStreams,
                                                               // LdsRegionOutVertCountInWaves
     // 1 dword (uint32) per thread
     SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup,             // LdsRegionOutVertThreadIdMap
+#if LLPC_BUILD_GFX11
+    // 1 dword per XFB buffer: dword written, 1 dword per vertex stream: primitives to write
+    SizeOfDword * MaxTransformFeedbackBuffers + SizeOfDword * MaxGsStreams,
+                                                              // LdsRegionGsXfbStatInfo
+#endif
     // GS-VS ring size is dynamically calculated (don't use it)
     InvalidValue,                                             // LdsRegionGsVsRing
     // clang-format on
 };
 
 // =====================================================================================================================
 // Initialize static members
 const char *NggLdsManager::m_ldsRegionNames[LdsRegionCount] = {
     // clang-format off
     //
     // LDS region name for ES-only
     //
     "Distributed primitive ID",             // LdsRegionDistribPrimId
+#if LLPC_BUILD_GFX11
+    "Transform feedback output",            // LdsRegionXfbOutput
+#endif
     "Vertex position data",                 // LdsRegionVertPosData
     "Vertex cull info",                     // LdsRegionVertCullInfo
+#if LLPC_BUILD_GFX11
+    "Transform feedback statistics",        // LdsRegionXfbStatInfo
+#endif
     "Vertex count in waves",                // LdsRegionVertCountInWaves
     "Vertex thread ID map",                 // LdsRegionVertThreadIdMap
 
     //
     // LDS region name for ES-GS
     //
     "ES-GS ring",                           // LdsRegionEsGsRing
     "GS out primitive data",                // LdsRegionOutPrimData
+#if LLPC_BUILD_GFX11
+    "GS out primitive count in waves",      // LdsRegionOutPrimCountInWaves
+    "GS out primitive thread ID map",       // LdsRegionOutPrimThreadIdMap
+#endif
     "GS out vertex count in waves",         // LdsRegionOutVertCountInWaves
     "GS out vertex thread ID map",          // LdsRegionOutVertThreadIdMap
+#if LLPC_BUILD_GFX11
+    "GS transform feedback statistics",     // LdsRegionGsXfbStatInfo
+#endif
     "GS-VS ring",                           // LdsRegionGsVsRing
     // clang-format on
 };
 
 // =====================================================================================================================
 //
 // @param module : LLVM module
 // @param pipelineState : Pipeline state
 // @param builder : LLVM IR builder
 NggLdsManager::NggLdsManager(Module *module, PipelineState *pipelineState, IRBuilder<> *builder)
@@ -134,38 +168,74 @@ NggLdsManager::NggLdsManager(Module *module, PipelineState *pipelineState, IRBui
   // Calculate start LDS offset for all available LDS region types
   //
 
   LLPC_OUTS("===============================================================================\n");
   LLPC_OUTS("// LLPC NGG LDS region info (in bytes)\n\n");
 
   if (hasGs) {
     //
     // The LDS layout is something like this:
     //
+#if LLPC_BUILD_GFX11
+    // +------------+-----------------------+---------------------------------+--------------------------------+
+    // | ES-GS ring | GS out primitive data | GS out vertex counts (waves)    | GS out vertex thread ID map    | >>>
+    // +------------+-----------------------+---------------------------------+--------------------------------+
+    //                                      | GS out primitive counts (waves) | GS out primitive thread ID map |
+    //                                      +---------------------------------+--------------------------------+
+    //       +-------------------+------------+
+    //   >>> | GS XFB statistics | GS-VS ring |
+    //       +-------------------+------------+
+#else
     // +------------+-----------------------+------------------------------+-----------------------------+------------+
     // | ES-GS ring | GS out primitive data | GS out vertex counts (waves) | GS out vertex thread ID map | GS-VS ring |
     // +------------+-----------------------+------------------------------+-----------------------------+------------+
+#endif
     //
 
     // NOTE: We round ES-GS LDS size to 4-dword alignment. This is for later LDS read/write operations of mutilple
     // dwords (such as DS128).
     const unsigned esGsRingLdsSize = alignTo(calcFactor.esGsLdsSize, 4u) * SizeOfDword;
     const unsigned gsVsRingLdsSize =
         calcFactor.gsOnChipLdsSize * SizeOfDword - esGsRingLdsSize - calcGsExtraLdsSize(m_pipelineState);
 
     unsigned ldsRegionStart = 0;
 
     for (unsigned region = LdsRegionGsBeginRange; region <= LdsRegionGsEndRange; ++region) {
       // NOTE: For vertex compactionless mode, this region is unnecessary
       if (region == LdsRegionOutVertThreadIdMap && nggControl->compactMode == NggCompactDisable)
         continue;
 
+#if LLPC_BUILD_GFX11
+      if (m_pipelineState->enableSwXfb()) {
+        if (region == LdsRegionOutVertCountInWaves || region == LdsRegionOutVertThreadIdMap) {
+          // NOTE: The two regions are overlapped with OutPrimCountInWaves and OutPrimThreadIdMap when SW-emulated
+          // stream-out is enabled.
+          auto overlappedRegion =
+              region == LdsRegionOutVertCountInWaves ? LdsRegionOutPrimCountInWaves : LdsRegionOutPrimThreadIdMap;
+
+          assert(m_ldsRegionStart[overlappedRegion] != InvalidValue); // Must be valid
+          m_ldsRegionStart[region] = m_ldsRegionStart[overlappedRegion];
+          unsigned ldsRegionSize = LdsRegionSizes[overlappedRegion];
+
+          LLPC_OUTS(format("%-40s : offset = 0x%04" PRIX32 ", size = 0x%04" PRIX32, m_ldsRegionNames[region],
+                           m_ldsRegionStart[region], ldsRegionSize)
+                    << "\n");
+          continue;
+        }
+      } else {
+        // NOTE: Such regions are for SW-emulated stream-out. Skip handling them if SW-emulated stream-out is disabled.
+        if (region == LdsRegionOutPrimCountInWaves || region == LdsRegionOutPrimThreadIdMap ||
+            region == LdsRegionGsXfbStatInfo)
+          continue;
+      }
+#endif
+
       unsigned ldsRegionSize = LdsRegionSizes[region];
 
       // NOTE: LDS size of ES-GS ring is calculated (by rounding it up to 16-byte alignment)
       if (region == LdsRegionEsGsRing)
         ldsRegionSize = esGsRingLdsSize;
 
       // NOTE: LDS size of GS-VS ring is calculated
       if (region == LdsRegionGsVsRing)
         ldsRegionSize = gsVsRingLdsSize;
 
@@ -185,49 +255,97 @@ NggLdsManager::NggLdsManager(Module *module, PipelineState *pipelineState, IRBui
               << "\n");
 
     if (!nggControl->passthroughMode) {
       //
       // The LDS layout is something like this:
       //
       // +--------------------------+
       // | Distributed primitive ID |
       // +--------------------------+
       //
+#if LLPC_BUILD_GFX11
+      // +----------------------+-------------------------------+----------------+-------------------------+
+      // | Vertex position data | Vertex cull info (ES-GS ring) | XFB statistics | Vertex count (in waves) | >>>
+      // +----------------------+-------------------------------+----------------+-------------------------+
+      //       +----------------------+
+      //   >>> | Vertex thread ID map |
+      //       +----------------------+
+#else
       // +----------------------+-------------------------------+-------------------------+----------------------+
       // | Vertex position data | Vertex cull info (ES-GS ring) | Vertex count (in waves) | Vertex thread ID map |
       // +----------------------+-------------------------------+-------------------------+----------------------+
+#endif
       //
       unsigned ldsRegionStart = 0;
       for (unsigned region = LdsRegionEsBeginRange; region <= LdsRegionEsEndRange; ++region) {
         // NOTE: For NGG culling mode, distributed primitive ID region is partially overlapped with vertex cull info
         // region.
         if (region == LdsRegionDistribPrimId)
           continue;
 
+#if LLPC_BUILD_GFX11
+        // NOTE: For NGG culling mode, transform feedback output region is stored as part of vertex cull info. There
+        // is no dedicated region.
+        if (region == LdsRegionXfbOutput)
+          continue;
+
+        // NOTE: For transform feedback statistics info region, if SW-emuated stream-out is disabled, it is unused.
+        if (region == LdsRegionXfbStatInfo && !m_pipelineState->enableSwXfb())
+          continue;
+#endif
+
         // NOTE: For vertex compactionless mode, this region is unnecessary
         if (region == LdsRegionVertThreadIdMap && nggControl->compactMode == NggCompactDisable)
           continue;
 
         unsigned ldsRegionSize = LdsRegionSizes[region];
 
         // NOTE: LDS size of vertex cull info (ES-GS ring) is calculated
         if (region == LdsRegionVertCullInfo)
           ldsRegionSize = calcFactor.esGsRingItemSize * calcFactor.esVertsPerSubgroup * SizeOfDword;
 
         m_ldsRegionStart[region] = ldsRegionStart;
         assert(ldsRegionSize != InvalidValue);
         ldsRegionStart += ldsRegionSize;
 
         LLPC_OUTS(format("%-40s : offset = 0x%04" PRIX32 ", size = 0x%04" PRIX32, m_ldsRegionNames[region],
                          m_ldsRegionStart[region], ldsRegionSize)
                   << "\n");
       }
+#if LLPC_BUILD_GFX11
+    } else {
+      //
+      // The LDS layout is something like this:
+      //
+      // +--------------------------+
+      // | Distributed primitive ID |
+      // +--------------------------+
+      //
+      // +--------------------------------+---------------------+
+      // | XFB output ([n x <4 x dword>]) | XFB statistics info |
+      // +--------------------------------+---------------------+
+      //
+      if (m_pipelineState->enableSwXfb()) {
+        // NOTE: For GFX11+, transform feedback outputs are stored as a ES-GS ring item.
+        m_ldsRegionStart[LdsRegionXfbOutput] = 0;
+        const unsigned esGsRingLdsSize = calcFactor.esVertsPerSubgroup * calcFactor.esGsRingItemSize * SizeOfDword;
+        LLPC_OUTS(format("%-40s : offset = 0x%04" PRIX32 ", size = 0x%04" PRIX32, m_ldsRegionNames[LdsRegionXfbOutput],
+                         m_ldsRegionStart[LdsRegionXfbOutput], esGsRingLdsSize)
+                  << "\n");
+
+        m_ldsRegionStart[LdsRegionXfbStatInfo] = esGsRingLdsSize;
+        LLPC_OUTS(format("%-40s : offset = 0x%04" PRIX32 ", size = 0x%04" PRIX32,
+                         m_ldsRegionNames[LdsRegionXfbStatInfo], m_ldsRegionStart[LdsRegionXfbStatInfo],
+                         LdsRegionSizes[LdsRegionXfbStatInfo])
+                  << "\n");
+      }
+#endif
     }
   }
 
   LLPC_OUTS(format("%-40s :                  size = 0x%04" PRIX32, static_cast<const char *>("LDS total"),
                    calcFactor.gsOnChipLdsSize * SizeOfDword)
             << "\n\n");
 }
 
 // =====================================================================================================================
 // Checks if this NGG pipeline needs LDS space.
@@ -250,39 +368,49 @@ bool NggLdsManager::needsLds(PipelineState *pipelineState) {
   // To distribute primitive ID, we need LDS
   const bool hasTs =
       pipelineState->hasShaderStage(ShaderStageTessControl) || pipelineState->hasShaderStage(ShaderStageTessEval);
   if (!hasTs) {
     const bool distribPrimitiveId =
         pipelineState->getShaderResourceUsage(ShaderStageVertex)->builtInUsage.vs.primitiveId;
     if (distribPrimitiveId)
       return true;
   }
 
+#if LLPC_BUILD_GFX11
+  // SW-emulated stream-out needs LDS
+  if (pipelineState->enableSwXfb())
+    return true;
+#endif
+
   return false;
 }
 
 // =====================================================================================================================
 // Calculates ES extra LDS size.
 //
 // @param pipelineState : Pipeline state
 unsigned NggLdsManager::calcEsExtraLdsSize(PipelineState *pipelineState) {
   const auto nggControl = pipelineState->getNggControl();
   if (!nggControl->enableNgg)
     return 0;
 
   const bool hasGs = pipelineState->hasShaderStage(ShaderStageGeometry);
   if (hasGs) {
     // NOTE: Not need ES extra LDS when GS is present.
     return 0;
   }
 
   if (nggControl->passthroughMode) {
+#if LLPC_BUILD_GFX11
+    if (pipelineState->enableSwXfb())
+      return LdsRegionSizes[LdsRegionXfbStatInfo];
+#endif
 
     return 0;
   }
 
   return LdsRegionSizes[LdsRegionVertPosData] + LdsRegionSizes[LdsRegionVertCountInWaves] +
          (nggControl->compactMode == NggCompactDisable ? 0 : LdsRegionSizes[LdsRegionVertThreadIdMap]);
 }
 
 // =====================================================================================================================
 // Calculates GS extra LDS size (used for operations other than ES-GS ring and GS-VS ring read/write).
@@ -292,20 +420,29 @@ unsigned NggLdsManager::calcGsExtraLdsSize(PipelineState *pipelineState) {
   const auto nggControl = pipelineState->getNggControl();
   if (!nggControl->enableNgg)
     return 0;
 
   const bool hasGs = pipelineState->hasShaderStage(ShaderStageGeometry);
   if (!hasGs) {
     // NOTE: Not need GS extra LDS when GS is not present.
     return 0;
   }
 
+#if LLPC_BUILD_GFX11
+  if (pipelineState->enableSwXfb()) {
+    // NOTE: The region OutVertCountInWaves and OutVertThreadIdMap is overlapped with OutPrimCountInWaves and
+    // OutPrimThreadIdMap when SW-emulated stream-out is enabled. Therefore, they are not counted in here.
+    return LdsRegionSizes[LdsRegionOutPrimData] + LdsRegionSizes[LdsRegionOutPrimCountInWaves] +
+           LdsRegionSizes[LdsRegionOutPrimThreadIdMap] + LdsRegionSizes[LdsRegionGsXfbStatInfo];
+  }
+#endif
+
   return LdsRegionSizes[LdsRegionOutPrimData] + LdsRegionSizes[LdsRegionOutVertCountInWaves] +
          (nggControl->compactMode == NggCompactDisable ? 0 : LdsRegionSizes[LdsRegionOutVertThreadIdMap]);
 }
 
 // =====================================================================================================================
 // Reads value from LDS.
 //
 // @param readTy : Type of value read from LDS
 // @param ldsOffset : Start offset to do LDS read operations
 // @param useDs128 : Whether to use 128-bit LDS load, 16-byte alignment is guaranteed by caller
diff --git a/lgc/patch/NggLdsManager.h b/lgc/patch/NggLdsManager.h
index 3816a562d..b7d314b45 100644
--- a/lgc/patch/NggLdsManager.h
+++ b/lgc/patch/NggLdsManager.h
@@ -39,35 +39,48 @@ namespace lgc {
 
 class PipelineState;
 
 // Enumerates the types of LDS regions used in NGG.
 enum NggLdsRegionType {
   // clang-format off
   //
   // LDS region for ES only (no GS)
   //
   LdsRegionDistribPrimId,     // Distributed primitive ID (VS only, for both pass-through and culling modes)
+#if LLPC_BUILD_GFX11
+  LdsRegionXfbOutput,         // Transform feedback output (pass-through mode only)
+#endif
   LdsRegionVertPosData,       // Vertex position data
   LdsRegionVertCullInfo,      // Vertex cull info
+#if LLPC_BUILD_GFX11
+  LdsRegionXfbStatInfo,       // Transform feedback statistics info
+#endif
   LdsRegionVertCountInWaves,  // Vertex count accumulated per wave (8 potential waves) and per sub-group
   LdsRegionVertThreadIdMap,   // Vertex thread ID map (compacted -> uncompacted), for vertex compaction
 
   LdsRegionEsBeginRange = LdsRegionDistribPrimId,
   LdsRegionEsEndRange = LdsRegionVertThreadIdMap,
 
   //
   // LDS region for ES-GS
   //
   LdsRegionEsGsRing,            // ES-GS ring
   LdsRegionOutPrimData,         // GS output primitive data
+#if LLPC_BUILD_GFX11
+  LdsRegionOutPrimCountInWaves, // GS output primitive count accumulated per wave (8 potential waves) and per sub-group
+  LdsRegionOutPrimThreadIdMap,  // GS output primitive thread ID map (compacted -> uncompacted)
+#endif
   LdsRegionOutVertCountInWaves, // GS output vertex count accumulated per wave (8 potential waves) and per sub-group
   LdsRegionOutVertThreadIdMap,  // GS output vertex thread ID map (compacted -> uncompacted), for vertex compaction
+#if LLPC_BUILD_GFX11
+  LdsRegionGsXfbStatInfo,       // GS transform feedback statistics info
+#endif
   LdsRegionGsVsRing,            // GS-VS ring
 
   LdsRegionGsBeginRange = LdsRegionEsGsRing,
   LdsRegionGsEndRange = LdsRegionGsVsRing,
 
   // Total
   LdsRegionCount
   // clang-format on
 };
 
diff --git a/lgc/patch/NggPrimShader.cpp b/lgc/patch/NggPrimShader.cpp
index 9b6c86c1d..38d758fc3 100644
--- a/lgc/patch/NggPrimShader.cpp
+++ b/lgc/patch/NggPrimShader.cpp
@@ -46,20 +46,40 @@ using namespace llvm;
 
 // -ngg-small-subgroup-threshold: threshold of vertex count to determine a small subgroup (NGG)
 static cl::opt<unsigned> NggSmallSubgroupThreshold(
     "ngg-small-subgroup-threshold",
     cl::desc(
         "Threshold of vertex count to determine a small subgroup and such small subgroup won't perform NGG culling"),
     cl::value_desc("threshold"), cl::init(16));
 
 namespace lgc {
 
+#if LLPC_BUILD_GFX11
+// Represents GDS GRBM register for SW-emulated stream-out
+enum {
+  // For 4 stream-out buffers
+  GDS_STRMOUT_DWORDS_WRITTEN_0 = 0,
+  GDS_STRMOUT_DWORDS_WRITTEN_1 = 1,
+  GDS_STRMOUT_DWORDS_WRITTEN_2 = 2,
+  GDS_STRMOUT_DWORDS_WRITTEN_3 = 3,
+  // For 4 stream-out streams
+  GDS_STRMOUT_PRIMS_NEEDED_0 = 8,
+  GDS_STRMOUT_PRIMS_WRITTEN_0 = 9,
+  GDS_STRMOUT_PRIMS_NEEDED_1 = 10,
+  GDS_STRMOUT_PRIMS_WRITTEN_1 = 11,
+  GDS_STRMOUT_PRIMS_NEEDED_2 = 12,
+  GDS_STRMOUT_PRIMS_WRITTEN_2 = 13,
+  GDS_STRMOUT_PRIMS_NEEDED_3 = 14,
+  GDS_STRMOUT_PRIMS_WRITTEN_3 = 15,
+};
+#endif
+
 // =====================================================================================================================
 //
 // @param pipelineState : Pipeline state
 NggPrimShader::NggPrimShader(PipelineState *pipelineState)
     : m_pipelineState(pipelineState), m_context(&pipelineState->getContext()),
       m_gfxIp(pipelineState->getTargetInfo().getGfxIpVersion()), m_nggControl(m_pipelineState->getNggControl()),
       m_ldsManager(nullptr), m_constPositionZ(false), m_builder(new IRBuilder<>(*m_context)) {
   assert(m_nggControl->enableNgg);
 
   // Always allow approximation, to change fdiv(1.0, x) to rcp(x)
@@ -69,20 +89,24 @@ NggPrimShader::NggPrimShader(PipelineState *pipelineState)
 
   assert(m_pipelineState->isGraphics());
 
   memset(&m_nggFactor, 0, sizeof(m_nggFactor));
 
   m_hasVs = m_pipelineState->hasShaderStage(ShaderStageVertex);
   m_hasTcs = m_pipelineState->hasShaderStage(ShaderStageTessControl);
   m_hasTes = m_pipelineState->hasShaderStage(ShaderStageTessEval);
   m_hasGs = m_pipelineState->hasShaderStage(ShaderStageGeometry);
 
+#if LLPC_BUILD_GFX11
+  m_enableSwXfb = m_pipelineState->enableSwXfb();
+#endif
+
   // NOTE: For NGG GS mode, we change data layout of output vertices. They are grouped by vertex streams now.
   // Vertices belonging to different vertex streams are in different regions of GS-VS ring. Here, we calculate
   // the base offset of each vertex streams and record them. See NggPrimShader::exportGsOutput for detail.
   if (m_hasGs) {
     unsigned vertexItemSizes[MaxGsStreams] = {};
     auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
     for (unsigned i = 0; i < MaxGsStreams; ++i)
       vertexItemSizes[i] = 4 * resUsage->inOutUsage.gs.outLocCount[i];
 
     unsigned gsVsRingItemSizes[MaxGsStreams] = {};
@@ -120,20 +144,31 @@ unsigned NggPrimShader::calcEsGsRingItemSize(PipelineState *pipelineState) {
   const bool hasGs = pipelineState->hasShaderStage(ShaderStageGeometry);
   if (hasGs) {
     auto resUsage = pipelineState->getShaderResourceUsage(ShaderStageGeometry);
     // NOTE: Make esGsRingItemSize odd by "| 1", to optimize ES -> GS ring layout for LDS bank conflicts.
     return (4 * std::max(1u, resUsage->inOutUsage.inputMapLocCount)) | 1;
   }
 
   if (pipelineState->getNggControl()->passthroughMode) {
     unsigned esGsRingItemSize = 1;
 
+#if LLPC_BUILD_GFX11
+    if (pipelineState->enableSwXfb()) {
+      const bool hasTs =
+          pipelineState->hasShaderStage(ShaderStageTessControl) || pipelineState->hasShaderStage(ShaderStageTessEval);
+      auto resUsage = pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex);
+
+      // NOTE: For GFX11+, transform feedback outputs (each output is <4 x dword>) are stored as a ES-GS ring item.
+      assert(resUsage->inOutUsage.xfbOutputExpCount > 0);
+      esGsRingItemSize = resUsage->inOutUsage.xfbOutputExpCount * 4;
+    }
+#endif
     // NOTE: Make esGsRingItemSize odd by "| 1", to optimize ES -> GS ring layout for LDS bank conflicts.
     return esGsRingItemSize | 1;
   }
 
   VertexCullInfoOffsets vertCullInfoOffsets = {}; // Dummy offsets (don't care)
   // For non-GS NGG, in the culling mode, the ES-GS ring item is vertex cull info.
   unsigned esGsRingItemSize = calcVertexCullInfoSizeAndOffsets(pipelineState, vertCullInfoOffsets);
 
   // Change it back to dword size
   assert(esGsRingItemSize % SizeOfDword == 0);
@@ -203,20 +238,34 @@ unsigned NggPrimShader::calcVertexCullInfoSizeAndOffsets(PipelineState *pipeline
   vertCullInfoOffsets = {};
 
   // Only for non-GS NGG with culling mode enabled
   const bool hasGs = pipelineState->hasShaderStage(ShaderStageGeometry);
   if (hasGs || nggControl->passthroughMode)
     return 0;
 
   unsigned cullInfoSize = 0;
   unsigned cullInfoOffset = 0;
 
+#if LLPC_BUILD_GFX11
+  if (pipelineState->enableSwXfb()) {
+    const bool hasTs =
+        pipelineState->hasShaderStage(ShaderStageTessControl) || pipelineState->hasShaderStage(ShaderStageTessEval);
+    auto resUsage = pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex);
+
+    // NOTE: Each transform feedback output is <4 x dword>.
+    const unsigned xfbOutputCount = resUsage->inOutUsage.xfbOutputExpCount;
+    cullInfoSize += sizeof(VertexCullInfo::xfbOutputs) * xfbOutputCount;
+    vertCullInfoOffsets.xfbOutputs = cullInfoOffset;
+    cullInfoOffset += sizeof(VertexCullInfo::xfbOutputs) * xfbOutputCount;
+  }
+#endif
+
   if (nggControl->enableCullDistanceCulling) {
     cullInfoSize += sizeof(VertexCullInfo::cullDistanceSignMask);
     vertCullInfoOffsets.cullDistanceSignMask = cullInfoOffset;
     cullInfoOffset += sizeof(VertexCullInfo::cullDistanceSignMask);
   }
 
   cullInfoSize += sizeof(VertexCullInfo::drawFlag);
   vertCullInfoOffsets.drawFlag = cullInfoOffset;
   cullInfoOffset += sizeof(VertexCullInfo::drawFlag);
 
@@ -507,20 +556,28 @@ void NggPrimShader::constructPrimShaderWithoutGs(Module *module) {
   auto entryPoint = module->getFunction(lgcName::NggPrimShaderEntryPoint);
 
   auto arg = entryPoint->arg_begin();
 
   Value *mergedGroupInfo = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::MergedGroupInfo));
   mergedGroupInfo->setName("mergedGroupInfo");
 
   Value *mergedWaveInfo = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::MergedWaveInfo));
   mergedWaveInfo->setName("mergedWaveInfo");
 
+#if LLPC_BUILD_GFX11
+  Value *attribRingBase = nullptr;
+  if (m_gfxIp.major >= 11) {
+    attribRingBase = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::AttribRingBase));
+    attribRingBase->setName("attribRingBase");
+  }
+#endif
+
   // GS shader address is reused as primitive shader table address for NGG culling
   Value *primShaderTableAddrLow = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::GsShaderAddrLow));
   primShaderTableAddrLow->setName("primShaderTableAddrLow");
 
   Value *primShaderTableAddrHigh = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::GsShaderAddrHigh));
   primShaderTableAddrHigh->setName("primShaderTableAddrHigh");
 
   arg += (NumSpecialSgprInputs + 1);
 
   Value *esGsOffsets01 = arg;
@@ -570,63 +627,94 @@ void NggPrimShader::constructPrimShaderWithoutGs(Module *module) {
     //       Get primitive ID
     //   }
     //   Barrier
     //
     //   if (waveId == 0)
     //     GS allocation request (GS_ALLOC_REQ)
     //
     //   if (threadIdInSubgroup < primCountInSubgroup)
     //     Do primitive connectivity data export
     //
+#if LLPC_BUILD_GFX11
+    //   if (enableSwXfb)
+    //     Process XFB output export (Run ES)
+    //   else {
+    //     if (threadIdInSubgroup < vertCountInSubgroup)
+    //       Run ES
+    //   }
+#else
     //   if (threadIdInSubgroup < vertCountInSubgroup)
     //     Run ES
+#endif
     // }
     //
 
     // Define basic blocks
     auto entryBlock = createBlock(entryPoint, ".entry");
 
     // NOTE: Those basic blocks are conditionally created on the basis of actual use of primitive ID.
     BasicBlock *writePrimIdBlock = nullptr;
     BasicBlock *endWritePrimIdBlock = nullptr;
     BasicBlock *readPrimIdBlock = nullptr;
     BasicBlock *endReadPrimIdBlock = nullptr;
 
     if (distributePrimitiveId) {
       writePrimIdBlock = createBlock(entryPoint, ".writePrimId");
       endWritePrimIdBlock = createBlock(entryPoint, ".endWritePrimId");
 
       readPrimIdBlock = createBlock(entryPoint, ".readPrimId");
       endReadPrimIdBlock = createBlock(entryPoint, ".endReadPrimId");
     }
 
+#if LLPC_BUILD_GFX11
+    // NOTE: For GFX11+, we use NO_MSG mode for NGG pass-through mode if SW-emulated stream-out is not requested. The
+    // message GS_ALLOC_REQ is no longer necessary.
+    bool passthroughNoMsg = m_gfxIp.major >= 11 && !m_enableSwXfb;
+#else
     bool passthroughNoMsg = false;
+#endif
 
     BasicBlock *allocReqBlock = nullptr;
     BasicBlock *endAllocReqBlock = nullptr;
     if (!passthroughNoMsg) {
       allocReqBlock = createBlock(entryPoint, ".allocReq");
       endAllocReqBlock = createBlock(entryPoint, ".endAllocReq");
     }
 
     auto expPrimBlock = createBlock(entryPoint, ".expPrim");
     auto endExpPrimBlock = createBlock(entryPoint, ".endExpPrim");
 
+#if LLPC_BUILD_GFX11
+    BasicBlock *expVertBlock = nullptr;
+    BasicBlock *endExpVertBlock = nullptr;
+    if (!m_enableSwXfb) {
+      expVertBlock = createBlock(entryPoint, ".expVert");
+      endExpVertBlock = createBlock(entryPoint, ".endExpVert");
+    }
+#else
     auto expVertBlock = createBlock(entryPoint, ".expVert");
     auto endExpVertBlock = createBlock(entryPoint, ".endExpVert");
+#endif
 
     // Construct ".entry" block
     {
       m_builder->SetInsertPoint(entryBlock);
 
       initWaveThreadInfo(mergedGroupInfo, mergedWaveInfo);
 
+#if LLPC_BUILD_GFX11
+      if (m_gfxIp.major >= 11) {
+        // Record attribute ring base ([14:0])
+        m_nggFactor.attribRingBase = CreateUBfe(attribRingBase, 0, 15);
+      }
+#endif
+
       // Record primitive connectivity data
       m_nggFactor.primData = esGsOffsets01;
 
       if (distributePrimitiveId) {
         auto primValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, m_nggFactor.primCountInWave);
         m_builder->CreateCondBr(primValid, writePrimIdBlock, endWritePrimIdBlock);
       } else {
         m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
 
         if (!passthroughNoMsg) {
@@ -735,61 +823,92 @@ void NggPrimShader::constructPrimShaderWithoutGs(Module *module) {
       m_builder->SetInsertPoint(expPrimBlock);
 
       doPrimitiveExportWithoutGs();
       m_builder->CreateBr(endExpPrimBlock);
     }
 
     // Construct ".endExpPrim" block
     {
       m_builder->SetInsertPoint(endExpPrimBlock);
 
+#if LLPC_BUILD_GFX11
+      // NOTE: For NGG passthrough mode, if SW-emulated stream-out is enabled, running ES is included in processing
+      // transform feedback output exporting. There won't be separated ES running (ES is not split any more). This is
+      // because we could encounter special cases in which there are memory atomics producing output values both for
+      // transform feedback exporting and for vertex exporting like following codes. The atomics shouldn't be separated
+      // and be run multiple times.
+      //
+      //   void ES() {
+      //     ...
+      //     value = atomicXXX()
+      //     xfbExport = value
+      //     vertexExport = value
+      //  }
+      //
+      if (m_enableSwXfb) {
+        processXfbOutputExport(module, entryPoint->arg_begin());
+        m_builder->CreateRetVoid();
+      } else {
+#else
       {
+#endif
         auto vertValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_nggFactor.vertCountInSubgroup);
         m_builder->CreateCondBr(vertValid, expVertBlock, endExpVertBlock);
       }
     }
 
-    // Construct ".expVert" block
-    {
-      m_builder->SetInsertPoint(expVertBlock);
+#if LLPC_BUILD_GFX11
+    if (!m_enableSwXfb) {
+#endif
+      // Construct ".expVert" block
+      {
+        m_builder->SetInsertPoint(expVertBlock);
 
-      runEs(module, entryPoint->arg_begin());
+        runEs(module, entryPoint->arg_begin());
 
-      m_builder->CreateBr(endExpVertBlock);
-    }
+        m_builder->CreateBr(endExpVertBlock);
+      }
 
-    // Construct ".endExpVert" block
-    {
-      m_builder->SetInsertPoint(endExpVertBlock);
+      // Construct ".endExpVert" block
+      {
+        m_builder->SetInsertPoint(endExpVertBlock);
 
-      m_builder->CreateRetVoid();
+        m_builder->CreateRetVoid();
+      }
+#if LLPC_BUILD_GFX11
     }
+#endif
 
     return;
   }
 
   //
   // For culling mode, the processing is something like this:
   //
   // NGG() {
   //   Initialize thread/wave info
   //
   //   if (distribPrimitiveId) {
   //     if (threadIdInWave < primCountInWave)
   //       Distribute primitive ID to provoking vertex (vertex0)
   //     Barrier
   //
   //     if (threadIdInWave < vertCountInWave)
   //       Get primitive ID
   //     Barrier
   //   }
   //
+#if LLPC_BUILD_GFX11
+  //   if (enableSwXfb)
+  //     Process XFB output export
+  //
+#endif
   //   if (threadIdInWave < vertCountInWave)
   //     Run ES-partial to fetch vertex cull data
   //
   //   if (!runtimePassthrough) {
   //     if (threadIdInSubgroup < vertCountInSubgroup)
   //       Initialize vertex draw flag
   //     if (threadIdInSubgroup < waveCount + 1)
   //       Initialize per-wave and per-subgroup count of output vertices
   //
   //     if (threadIdInWave < vertCountInWave)
@@ -927,35 +1046,46 @@ void NggPrimShader::constructPrimShaderWithoutGs(Module *module) {
   auto expVertBlock = createBlock(entryPoint, ".expVert");
   auto endExpVertBlock = createBlock(entryPoint, ".endExpVert");
 
   // Construct ".entry" block
   Value *vertexItemOffset = nullptr;
   {
     m_builder->SetInsertPoint(entryBlock);
 
     initWaveThreadInfo(mergedGroupInfo, mergedWaveInfo);
 
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11) {
+      // Record attribute ring base ([14:0])
+      m_nggFactor.attribRingBase = CreateUBfe(attribRingBase, 0, 15);
+    }
+#endif
+
     m_nggFactor.primShaderTableAddrLow = primShaderTableAddrLow;
     m_nggFactor.primShaderTableAddrHigh = primShaderTableAddrHigh;
 
     // Record ES-GS vertex offsets info
     m_nggFactor.esGsOffset0 = CreateUBfe(esGsOffsets01, 0, 16);
     m_nggFactor.esGsOffset1 = CreateUBfe(esGsOffsets01, 16, 16);
     m_nggFactor.esGsOffset2 = CreateUBfe(esGsOffsets23, 0, 16);
 
     vertexItemOffset =
         m_builder->CreateMul(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(esGsRingItemSize * SizeOfDword));
 
     if (distributePrimitiveId) {
       auto primValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, m_nggFactor.primCountInWave);
       m_builder->CreateCondBr(primValid, writePrimIdBlock, endWritePrimIdBlock);
     } else {
+#if LLPC_BUILD_GFX11
+      if (m_enableSwXfb)
+        processXfbOutputExport(module, entryPoint->arg_begin());
+#endif
 
       auto vertValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, m_nggFactor.vertCountInWave);
       m_builder->CreateCondBr(vertValid, fetchVertCullDataBlock, endFetchVertCullDataBlock);
     }
   }
 
   if (distributePrimitiveId) {
     // Construct ".writePrimId" block
     {
       m_builder->SetInsertPoint(writePrimIdBlock);
@@ -1007,20 +1137,25 @@ void NggPrimShader::constructPrimShaderWithoutGs(Module *module) {
       primitiveIdPhi->addIncoming(m_builder->getInt32(0), endWritePrimIdBlock);
 
       // Record primitive ID
       m_nggFactor.primitiveId = primitiveIdPhi;
 
       SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
       m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
       m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
       m_builder->CreateFence(AtomicOrdering::Acquire, workgroupScope);
 
+#if LLPC_BUILD_GFX11
+      if (m_enableSwXfb)
+        processXfbOutputExport(module, entryPoint->arg_begin());
+#endif
+
       auto vertValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, m_nggFactor.vertCountInWave);
       m_builder->CreateCondBr(vertValid, fetchVertCullDataBlock, endFetchVertCullDataBlock);
     }
   }
 
   // Construct ".fetchVertCullData" block
   Value *cullData = nullptr;
   Value *position = nullptr;
   {
     m_builder->SetInsertPoint(fetchVertCullDataBlock);
@@ -1562,20 +1697,28 @@ void NggPrimShader::constructPrimShaderWithGs(Module *module) {
   auto entryPoint = module->getFunction(lgcName::NggPrimShaderEntryPoint);
 
   auto arg = entryPoint->arg_begin();
 
   Value *mergedGroupInfo = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::MergedGroupInfo));
   mergedGroupInfo->setName("mergedGroupInfo");
 
   Value *mergedWaveInfo = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::MergedWaveInfo));
   mergedWaveInfo->setName("mergedWaveInfo");
 
+#if LLPC_BUILD_GFX11
+  Value *attribRingBase = nullptr;
+  if (m_gfxIp.major >= 11) {
+    attribRingBase = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::AttribRingBase));
+    attribRingBase->setName("attribRingBase");
+  }
+#endif
+
   // GS shader address is reused as primitive shader table address for NGG culling
   Value *primShaderTableAddrLow = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::GsShaderAddrLow));
   primShaderTableAddrLow->setName("primShaderTableAddrLow");
 
   Value *primShaderTableAddrHigh = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::GsShaderAddrHigh));
   primShaderTableAddrHigh->setName("primShaderTableAddrHigh");
 
   arg += (NumSpecialSgprInputs + 1);
 
   Value *esGsOffsets01 = arg;
@@ -1594,20 +1737,25 @@ void NggPrimShader::constructPrimShaderWithGs(Module *module) {
   //   if (threadIdInWave < vertCountInWave)
   //     Run ES
   //
   //   if (threadIdInSubgroup < primCountInSubgroup)
   //     Initialize primitive connectivity data (0x80000000)
   //   Barrier
   //
   //   if (threadIdInWave < primCountInWave)
   //     Run GS
   //
+#if LLPC_BUILD_GFX11
+  //   if (enableSwXfb)
+  //     Process XFB output export
+  //
+#endif
   //  if (threadIdInSubgroup < waveCount + 1)
   //     Initialize per-wave and per-subgroup count of output vertices
   //   Barrier
   //
   //   if (culling && valid primitive & threadIdInSubgroup < primCountInSubgroup) {
   //     Do culling (run culling algorithms)
   //     if (primitive culled)
   //       Nullify primitive connectivity data
   //   }
   //   Barrier
@@ -1696,20 +1844,27 @@ void NggPrimShader::constructPrimShaderWithGs(Module *module) {
 
   auto expVertBlock = createBlock(entryPoint, ".expVert");
   auto endExpVertBlock = createBlock(entryPoint, ".endExpVert");
 
   // Construct ".entry" block
   {
     m_builder->SetInsertPoint(entryBlock);
 
     initWaveThreadInfo(mergedGroupInfo, mergedWaveInfo);
 
+#if LLPC_BUILD_GFX11
+    if (m_gfxIp.major >= 11) {
+      // Record attribute ring base ([14:0])
+      m_nggFactor.attribRingBase = CreateUBfe(attribRingBase, 0, 15);
+    }
+#endif
+
     // Record primitive shader table address info
     m_nggFactor.primShaderTableAddrLow = primShaderTableAddrLow;
     m_nggFactor.primShaderTableAddrHigh = primShaderTableAddrHigh;
 
     // Record ES-GS vertex offsets info
     m_nggFactor.esGsOffset0 = CreateUBfe(esGsOffsets01, 0, 16);
     m_nggFactor.esGsOffset1 = CreateUBfe(esGsOffsets01, 16, 16);
     m_nggFactor.esGsOffset2 = CreateUBfe(esGsOffsets23, 0, 16);
     m_nggFactor.esGsOffset3 = CreateUBfe(esGsOffsets23, 16, 16);
     m_nggFactor.esGsOffset4 = CreateUBfe(esGsOffsets45, 0, 16);
@@ -1733,22 +1888,36 @@ void NggPrimShader::constructPrimShaderWithGs(Module *module) {
     m_builder->SetInsertPoint(endEsBlock);
 
     auto outPrimValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_nggFactor.primCountInSubgroup);
     m_builder->CreateCondBr(outPrimValid, initOutPrimDataBlock, endInitOutPrimDataBlock);
   }
 
   // Construct ".initOutPrimData" block
   {
     m_builder->SetInsertPoint(initOutPrimDataBlock);
 
+#if LLPC_BUILD_GFX11
+    if (m_enableSwXfb) {
+      for (unsigned i = 0; i < MaxGsStreams; ++i) {
+        if (inOutUsage.outLocCount[i] > 0) { // Initialize primitive connectivity data if the stream is active
+          writePerThreadDataToLds(m_builder->getInt32(NullPrim), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimData,
+                                  SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * i);
+        }
+      }
+    } else {
+      writePerThreadDataToLds(m_builder->getInt32(NullPrim), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimData,
+                              SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * rasterStream);
+    }
+#else
     writePerThreadDataToLds(m_builder->getInt32(NullPrim), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimData,
                             SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * rasterStream);
+#endif
 
     m_builder->CreateBr(endInitOutPrimDataBlock);
   }
 
   // Construct ".endInitOutPrimData" block
   {
     m_builder->SetInsertPoint(endInitOutPrimDataBlock);
 
     SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
     m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
@@ -1765,20 +1934,25 @@ void NggPrimShader::constructPrimShaderWithGs(Module *module) {
 
     runGs(module, entryPoint->arg_begin());
 
     m_builder->CreateBr(endGsBlock);
   }
 
   // Construct ".endGs" block
   {
     m_builder->SetInsertPoint(endGsBlock);
 
+#if LLPC_BUILD_GFX11
+    if (m_enableSwXfb)
+      processGsXfbOutputExport(module, entryPoint->arg_begin());
+#endif
+
     auto waveValid =
         m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(waveCountInSubgroup + 1));
     m_builder->CreateCondBr(waveValid, initOutVertCountBlock, endInitOutVertCountBlock);
   }
 
   // Construct ".initOutVertCount" block
   {
     m_builder->SetInsertPoint(initOutVertCountBlock);
 
     writePerThreadDataToLds(m_builder->getInt32(0), m_nggFactor.threadIdInSubgroup, LdsRegionOutVertCountInWaves,
@@ -2126,40 +2300,49 @@ void NggPrimShader::initWaveThreadInfo(Value *mergedGroupInfo, Value *mergedWave
   if (waveSize == 64) {
     threadIdInWave =
         m_builder->CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {m_builder->getInt32(-1), threadIdInWave});
   }
 
   auto primCountInSubgroup = CreateUBfe(mergedGroupInfo, 22, 9);
   auto vertCountInSubgroup = CreateUBfe(mergedGroupInfo, 12, 9);
   auto vertCountInWave = CreateUBfe(mergedWaveInfo, 0, 8);
   auto primCountInWave = CreateUBfe(mergedWaveInfo, 8, 8);
   auto waveIdInSubgroup = CreateUBfe(mergedWaveInfo, 24, 4);
+#if LLPC_BUILD_GFX11
+  auto orderedWaveId = CreateUBfe(mergedGroupInfo, 0, 12);
+#endif
 
   auto threadIdInSubgroup = m_builder->CreateMul(waveIdInSubgroup, m_builder->getInt32(waveSize));
   threadIdInSubgroup = m_builder->CreateAdd(threadIdInSubgroup, threadIdInWave);
 
   primCountInSubgroup->setName("primCountInSubgroup");
   vertCountInSubgroup->setName("vertCountInSubgroup");
   primCountInWave->setName("primCountInWave");
   vertCountInWave->setName("vertCountInWave");
   threadIdInWave->setName("threadIdInWave");
   threadIdInSubgroup->setName("threadIdInSubgroup");
   waveIdInSubgroup->setName("waveIdInSubgroup");
+#if LLPC_BUILD_GFX11
+  orderedWaveId->setName("orderedWaveId");
+#endif
 
   // Record wave/thread info
   m_nggFactor.primCountInSubgroup = primCountInSubgroup;
   m_nggFactor.vertCountInSubgroup = vertCountInSubgroup;
   m_nggFactor.primCountInWave = primCountInWave;
   m_nggFactor.vertCountInWave = vertCountInWave;
   m_nggFactor.threadIdInWave = threadIdInWave;
   m_nggFactor.threadIdInSubgroup = threadIdInSubgroup;
   m_nggFactor.waveIdInSubgroup = waveIdInSubgroup;
+#if LLPC_BUILD_GFX11
+  m_nggFactor.orderedWaveId = orderedWaveId;
+#endif
 }
 
 // =====================================================================================================================
 // Does various culling for NGG primitive shader.
 //
 // @param module : LLVM module
 // @param vertexId0: ID of vertex0 (forming this triangle)
 // @param vertexId1: ID of vertex1 (forming this triangle)
 // @param vertexId2: ID of vertex2 (forming this triangle)
 Value *NggPrimShader::doCulling(Module *module, Value *vertexId0, Value *vertexId1, Value *vertexId2) {
@@ -2514,20 +2697,25 @@ void NggPrimShader::doEarlyExit(unsigned fullyCulledExportCount) {
 void NggPrimShader::runEs(Module *module, Argument *sysValueStart) {
   const bool hasTs = (m_hasTcs || m_hasTes);
   if (!((hasTs && m_hasTes) || (!hasTs && m_hasVs))) {
     // No TES (tessellation is enabled) or VS (tessellation is disabled), don't have to run
     return;
   }
 
   auto esEntry = module->getFunction(lgcName::NggEsEntryPoint);
   assert(esEntry);
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11 && !m_hasGs) // For GS, vertex attribute exports are in copy shader
+    processVertexAttribExport(esEntry);
+#endif
+
   // Call ES entry
   Argument *arg = sysValueStart;
 
   Value *esGsOffset = nullptr;
   if (m_hasGs) {
     auto &calcFactor = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage.gs.calcFactor;
     unsigned waveSize = m_pipelineState->getShaderWaveSize(ShaderStageGeometry);
     unsigned esGsBytesPerWave = waveSize * SizeOfDword * calcFactor.esGsRingItemSize;
     esGsOffset = m_builder->CreateMul(m_nggFactor.waveIdInSubgroup, m_builder->getInt32(esGsBytesPerWave));
   }
@@ -2547,20 +2735,33 @@ void NggPrimShader::runEs(Module *module, Argument *sysValueStart) {
   Value *patchId = (arg + 8);
 
   Value *vertexId = (arg + 5);
   Value *relVertexId = (arg + 6);
   // NOTE: VS primitive ID for NGG is specially obtained, not simply from system VGPR.
   Value *vsPrimitiveId = m_nggFactor.primitiveId ? m_nggFactor.primitiveId : UndefValue::get(m_builder->getInt32Ty());
   Value *instanceId = (arg + 8);
 
   std::vector<Value *> args;
 
+#if LLPC_BUILD_GFX11
+  // Setup attribute ring base and vertex thread ID in sub-group as two additional arguments to export vertex attributes
+  // through memory
+  if (m_gfxIp.major >= 11 && !m_hasGs) { // For GS, vertex attribute exports are in copy shader
+    const auto attribCount =
+        m_pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex)->inOutUsage.expCount;
+    if (attribCount > 0) {
+      args.push_back(m_nggFactor.attribRingBase);
+      args.push_back(m_nggFactor.threadIdInSubgroup);
+    }
+  }
+#endif
+
   auto intfData = m_pipelineState->getShaderInterfaceData(hasTs ? ShaderStageTessEval : ShaderStageVertex);
   const unsigned userDataCount = intfData->userDataCount;
 
   unsigned userDataIdx = 0;
 
   auto esArgBegin = esEntry->arg_begin();
   const unsigned esArgCount = esEntry->arg_size();
   (void(esArgCount)); // Unused
 
   // Set up user data SGPRs
@@ -2809,20 +3010,33 @@ Value *NggPrimShader::runEsPartial(Module *module, Argument *sysValueStart, Valu
           instanceIdPhi->addIncoming(newInstanceId, uncompactVertBlock);
           instanceIdPhi->addIncoming(instanceId, expVertBlock);
           instanceId = instanceIdPhi;
         }
       }
     }
   }
 
   std::vector<Value *> args;
 
+#if LLPC_BUILD_GFX11
+  // Setup attribute ring base and vertex thread ID in sub-group as two additional arguments to export vertex attributes
+  // through memory
+  if (m_gfxIp.major >= 11 && deferredVertexExport) {
+    const auto attribCount =
+        m_pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex)->inOutUsage.expCount;
+    if (attribCount > 0) {
+      args.push_back(m_nggFactor.attribRingBase);
+      args.push_back(m_nggFactor.threadIdInSubgroup);
+    }
+  }
+#endif
+
   if (deferredVertexExport)
     args.push_back(position); // Setup vertex position data as the additional argument
 
   auto intfData = m_pipelineState->getShaderInterfaceData(hasTs ? ShaderStageTessEval : ShaderStageVertex);
   const unsigned userDataCount = intfData->userDataCount;
 
   unsigned userDataIdx = 0;
 
   auto esPartialArgBegin = esPartialEntry->arg_begin();
   const unsigned esPartialArgCount = esPartialEntry->arg_size();
@@ -2897,20 +3111,26 @@ void NggPrimShader::splitEs(Module *module) {
   const auto esEntryPoint = module->getFunction(lgcName::NggEsEntryPoint);
   assert(esEntryPoint);
 
   //
   // Collect all export calls for further analysis
   //
   SmallVector<Function *, 8> expFuncs;
   for (auto &func : module->functions()) {
     if (func.isIntrinsic() && func.getIntrinsicID() == Intrinsic::amdgcn_exp)
       expFuncs.push_back(&func);
+#if LLPC_BUILD_GFX11
+    else if (m_gfxIp.major >= 11) {
+      if (func.getName().startswith(lgcName::NggAttribExport) || func.getName().startswith(lgcName::NggXfbOutputExport))
+        expFuncs.push_back(&func);
+    }
+#endif
   }
 
   //
   // Preparation for fetching cull distances
   //
   unsigned clipCullPos = EXP_TARGET_POS_1;
   unsigned clipDistanceCount = 0;
   unsigned cullDistanceCount = 0;
 
   if (m_nggControl->enableCullDistanceCulling) {
@@ -3062,20 +3282,25 @@ void NggPrimShader::splitEs(Module *module) {
           m_builder->SetInsertPoint(call);
           call->setArgOperand(2, m_builder->CreateExtractElement(position, static_cast<uint64_t>(0)));
           call->setArgOperand(3, m_builder->CreateExtractElement(position, 1));
           call->setArgOperand(4, m_builder->CreateExtractElement(position, 2));
           call->setArgOperand(5, m_builder->CreateExtractElement(position, 3));
         }
       }
     }
   }
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11)
+    processVertexAttribExport(esDeferredVertexExportFunc);
+#endif
+
   // Original ES is no longer needed
   assert(esEntryPoint->use_empty());
   esEntryPoint->eraseFromParent();
 
   // Remove calls
   for (auto call : removeCalls) {
     call->dropAllReferences();
     call->eraseFromParent();
   }
 }
@@ -3332,35 +3557,73 @@ void NggPrimShader::runCopyShader(Module *module, Argument *sysValueStart) {
       vertexIdPhi->addIncoming(vertexId, expVertBlock);
       vertexId = vertexIdPhi;
     }
   }
 
   auto copyShaderEntry = mutateCopyShader(module);
 
   // Run copy shader
   std::vector<Value *> args;
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // Setup attribute ring base and vertex thread ID in sub-group as two additional arguments to export vertex
+    // attributes through memory
+    const auto attribCount = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage.expCount;
+    if (attribCount > 0) {
+      args.push_back(m_nggFactor.attribRingBase);
+      args.push_back(m_nggFactor.threadIdInSubgroup);
+    }
+
+    // Global table
+    auto userData = sysValueStart + NumSpecialSgprInputs;
+    assert(userData->getType()->isVectorTy());
+    auto globalTable = m_builder->CreateExtractElement(userData, static_cast<uint64_t>(0)); // The first user data SGPRs
+    args.push_back(globalTable);
+
+    // Stream-out table and stream-out control buffer
+    if (m_enableSwXfb) {
+      const auto &intfData = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry);
+      // Stream-out table
+      auto streamOutTable = m_builder->CreateExtractElement(userData, intfData->entryArgIdxs.gs.streamOutData.tablePtr);
+      args.push_back(streamOutTable);
+      // Stream-out control buffer
+      auto streamOutControlBuf =
+          m_builder->CreateExtractElement(userData, intfData->entryArgIdxs.gs.streamOutData.controlBufPtr);
+      args.push_back(streamOutControlBuf);
+    } else {
+      args.push_back(UndefValue::get(m_builder->getInt32Ty()));
+      args.push_back(UndefValue::get(m_builder->getInt32Ty()));
+    }
+  }
+#endif
+
   // Vertex ID in sub-group
   args.push_back(vertexId);
 
   CallInst *copyShaderCall = m_builder->CreateCall(copyShaderEntry, args);
   copyShaderCall->setCallingConv(CallingConv::AMDGPU_VS);
 }
 
 // =====================================================================================================================
 // Mutates copy shader to handle the importing GS outputs from GS-VS ring.
 //
 // @param module : LLVM module
 Function *NggPrimShader::mutateCopyShader(Module *module) {
   auto copyShaderEntryPoint = module->getFunction(lgcName::NggCopyShaderEntryPoint);
   assert(copyShaderEntryPoint);
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11)
+    processVertexAttribExport(copyShaderEntryPoint);
+#endif
+
   IRBuilder<>::InsertPointGuard guard(*m_builder);
 
   // Vertex ID is always the last argument
   auto vertexId = getFunctionArgument(copyShaderEntryPoint, copyShaderEntryPoint->arg_size() - 1);
   const unsigned rasterStream =
       m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage.gs.rasterStream;
 
   std::vector<Instruction *> removeCalls;
 
   for (auto &func : module->functions()) {
@@ -3437,23 +3700,29 @@ Function *NggPrimShader::mutateCopyShader(Module *module) {
 //
 // @param output : Output value
 // @param location : Location of the output
 // @param compIdx : Index used for vector element indexing
 // @param streamId : ID of output vertex stream
 // @param threadIdInSubgroup : Thread ID in sub-group
 // @param emitVerts : Counter of GS emitted vertices for this stream
 void NggPrimShader::exportGsOutput(Value *output, unsigned location, unsigned compIdx, unsigned streamId,
                                    Value *threadIdInSubgroup, Value *emitVerts) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
+#if LLPC_BUILD_GFX11
+  if (!m_enableSwXfb && resUsage->inOutUsage.gs.rasterStream != streamId) {
+    // NOTE: If SW-emulated stream-out is not enabled, only import those outputs that belong to the rasterization
+    // stream.
+#else
   if (resUsage->inOutUsage.gs.rasterStream != streamId) {
     // NOTE: Only export those outputs that belong to the rasterization stream.
-    assert(resUsage->inOutUsage.enableXfb == false); // Transform feedback must be disabled
+    assert(m_pipelineState->enableXfb() == false); // Transform feedback must be disabled
+#endif
     return;
   }
 
   // NOTE: We only handle LDS vector/scalar writing, so change [n x Ty] to <n x Ty> for array.
   auto outputTy = output->getType();
   if (outputTy->isArrayTy()) {
     auto outputElemTy = outputTy->getArrayElementType();
     assert(outputElemTy->isSingleValueType());
 
     // [n x Ty] -> <n x Ty>
@@ -3503,23 +3772,29 @@ void NggPrimShader::exportGsOutput(Value *output, unsigned location, unsigned co
 
 // =====================================================================================================================
 // Imports outputs of geometry shader from GS-VS ring.
 //
 // @param outputTy : Type of the output
 // @param location : Location of the output
 // @param streamId : ID of output vertex stream
 // @param vertexOffset : Start offset of vertex item in GS-VS ring (in bytes)
 Value *NggPrimShader::importGsOutput(Type *outputTy, unsigned location, unsigned streamId, Value *vertexOffset) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
+#if LLPC_BUILD_GFX11
+  if (!m_enableSwXfb && resUsage->inOutUsage.gs.rasterStream != streamId) {
+    // NOTE: If SW-emulated stream-out is not enabled, only import those outputs that belong to the rasterization
+    // stream.
+#else
   if (resUsage->inOutUsage.gs.rasterStream != streamId) {
     // NOTE: Only import those outputs that belong to the rasterization stream.
-    assert(resUsage->inOutUsage.enableXfb == false); // Transform feedback must be disabled
+    assert(m_pipelineState->enableXfb() == false); // Transform feedback must be disabled
+#endif
     return UndefValue::get(outputTy);
   }
 
   // NOTE: We only handle LDS vector/scalar reading, so change [n x Ty] to <n x Ty> for array.
   auto origOutputTy = outputTy;
   if (outputTy->isArrayTy()) {
     auto outputElemTy = outputTy->getArrayElementType();
     assert(outputElemTy->isSingleValueType());
 
     // [n x Ty] -> <n x Ty>
@@ -3555,44 +3830,56 @@ Value *NggPrimShader::importGsOutput(Type *outputTy, unsigned location, unsigned
 // Processes the message GS_EMIT.
 //
 // @param module : LLVM module
 // @param streamId : ID of output vertex stream
 // @param threadIdInSubgroup : Thread ID in subgroup
 // @param [in/out] emitVertsPtr : Pointer to the counter of GS emitted vertices for this stream
 // @param [in/out] outVertsPtr : Pointer to the counter of GS output vertices of current primitive for this stream
 void NggPrimShader::processGsEmit(Module *module, unsigned streamId, Value *threadIdInSubgroup, Value *emitVertsPtr,
                                   Value *outVertsPtr) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
+#if LLPC_BUILD_GFX11
+  if (!m_enableSwXfb && resUsage->inOutUsage.gs.rasterStream != streamId) {
+    // NOTE: If SW-emulated stream-out is not enabled, only handle GS_EMIT message that belongs to the rasterization
+    // stream.
+#else
   if (resUsage->inOutUsage.gs.rasterStream != streamId) {
     // Only handle GS_EMIT message that belongs to the rasterization stream.
-    assert(resUsage->inOutUsage.enableXfb == false);
+    assert(m_pipelineState->enableXfb() == false);
+#endif
     return;
   }
 
   auto gsEmitHandler = module->getFunction(lgcName::NggGsEmit);
   if (!gsEmitHandler)
     gsEmitHandler = createGsEmitHandler(module);
 
   m_builder->CreateCall(gsEmitHandler, {threadIdInSubgroup, m_builder->getInt32(streamId), emitVertsPtr, outVertsPtr});
 }
 
 // =====================================================================================================================
 // Processes the message GS_CUT.
 //
 // @param module : LLVM module
 // @param streamId : ID of output vertex stream
 // @param [in/out] outVertsPtr : Pointer to the counter of GS output vertices of current primitive for this stream
 void NggPrimShader::processGsCut(Module *module, unsigned streamId, Value *outVertsPtr) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
+#if LLPC_BUILD_GFX11
+  if (!m_enableSwXfb && resUsage->inOutUsage.gs.rasterStream != streamId) {
+    // NOTE: If SW-emulated stream-out is not enabled, only handle GS_CUT message that belongs to the rasterization
+    // stream.
+#else
   if (resUsage->inOutUsage.gs.rasterStream != streamId) {
     // Only handle GS_CUT message that belongs to the rasterization stream.
-    assert(resUsage->inOutUsage.enableXfb == false);
+    assert(m_pipelineState->enableXfb() == false);
+#endif
     return;
   }
 
   auto gsCutHandler = module->getFunction(lgcName::NggGsCut);
   if (!gsCutHandler)
     gsCutHandler = createGsCutHandler(module);
 
   m_builder->CreateCall(gsCutHandler, outVertsPtr);
 }
 
@@ -4048,21 +4335,21 @@ Function *NggPrimShader::createBackfaceCuller(Module *module) {
                                       FixedVectorType::get(Type::getFloatTy(*m_context), 4), // %vertex2
                                       m_builder->getInt32Ty(),                               // %backfaceExponent
                                       m_builder->getInt32Ty(),                               // %paSuScModeCntl
                                       m_builder->getInt32Ty(),                               // %paClVportXscale
                                       m_builder->getInt32Ty()                                // %paClVportYscale
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingBackface, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *vertex0 = argIt++;
   vertex0->setName("vertex0");
 
   Value *vertex1 = argIt++;
@@ -4210,27 +4497,22 @@ Function *NggPrimShader::createBackfaceCuller(Module *module) {
     //     cullFlag = false
     //
 
     // |w0 * w1 * w2|
     auto absW0W1W2 = m_builder->CreateFMul(w0, w1);
     absW0W1W2 = m_builder->CreateFMul(absW0W1W2, w2);
     absW0W1W2 = m_builder->CreateIntrinsic(Intrinsic::fabs, m_builder->getFloatTy(), absW0W1W2);
 
     // threshold = (10 ^ (-backfaceExponent)) / |w0 * w1 * w2|
     auto threshold = m_builder->CreateNeg(backfaceExponent);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 391319
-    threshold = m_builder->CreateIntrinsic(Intrinsic::powi, m_builder->getFloatTy(),
-                                           {ConstantFP::get(m_builder->getFloatTy(), 10.0), threshold});
-#else
     threshold = m_builder->CreateIntrinsic(Intrinsic::powi, {m_builder->getFloatTy(), threshold->getType()},
                                            {ConstantFP::get(m_builder->getFloatTy(), 10.0), threshold});
-#endif
 
     auto rcpAbsW0W1W2 = m_builder->CreateFDiv(ConstantFP::get(m_builder->getFloatTy(), 1.0), absW0W1W2);
     threshold = m_builder->CreateFMul(threshold, rcpAbsW0W1W2);
 
     // |area|
     auto absArea = m_builder->CreateIntrinsic(Intrinsic::fabs, m_builder->getFloatTy(), area);
 
     // cullFlag = cullFlag && (abs(area) >= threshold)
     cullFlag2 = m_builder->CreateFCmpOGE(absArea, threshold);
     cullFlag2 = m_builder->CreateAnd(cullFlag1, cullFlag2);
@@ -4275,21 +4557,21 @@ Function *NggPrimShader::createFrustumCuller(Module *module) {
                                       FixedVectorType::get(Type::getFloatTy(*m_context), 4), // %vertex1
                                       FixedVectorType::get(Type::getFloatTy(*m_context), 4), // %vertex2
                                       m_builder->getInt32Ty(),                               // %paClClipCntl
                                       m_builder->getInt32Ty(),                               // %paClGbHorzDiscAdj
                                       m_builder->getInt32Ty()                                // %paClGbVertDiscAdj
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingFrustum, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *vertex0 = argIt++;
   vertex0->setName("vertex0");
 
   Value *vertex1 = argIt++;
@@ -4531,21 +4813,21 @@ Function *NggPrimShader::createBoxFilterCuller(Module *module) {
                                       FixedVectorType::get(Type::getFloatTy(*m_context), 4), // %vertex2
                                       m_builder->getInt32Ty(),                               // %paClVteCntl
                                       m_builder->getInt32Ty(),                               // %paClClipCntl
                                       m_builder->getInt32Ty(),                               // %paClGbHorzDiscAdj
                                       m_builder->getInt32Ty()                                // %paClGbVertDiscAdj
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingBoxFilter, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *vertex0 = argIt++;
   vertex0->setName("vertex0");
 
   Value *vertex1 = argIt++;
@@ -4754,21 +5036,21 @@ Function *NggPrimShader::createSphereCuller(Module *module) {
                                       FixedVectorType::get(Type::getFloatTy(*m_context), 4), // %vertex2
                                       m_builder->getInt32Ty(),                               // %paClVteCntl
                                       m_builder->getInt32Ty(),                               // %paClClipCntl
                                       m_builder->getInt32Ty(),                               // %paClGbHorzDiscAdj
                                       m_builder->getInt32Ty()                                // %paClGbVertDiscAdj
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingSphere, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *vertex0 = argIt++;
   vertex0->setName("vertex0");
 
   Value *vertex1 = argIt++;
@@ -5119,21 +5401,21 @@ Function *NggPrimShader::createSmallPrimFilterCuller(Module *module) {
                                       m_builder->getInt32Ty(),                               // %paClVportXscale
                                       m_builder->getInt32Ty(),                               // %paClVportXoffset
                                       m_builder->getInt32Ty(),                               // %paClVportYscale
                                       m_builder->getInt32Ty(),                               // %paClVportYoffset
                                       m_builder->getInt1Ty()                                 // %conservativeRaster
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingSmallPrimFilter, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *vertex0 = argIt++;
   vertex0->setName("vertex0");
 
   Value *vertex1 = argIt++;
@@ -5395,21 +5677,21 @@ Function *NggPrimShader::createCullDistanceCuller(Module *module) {
                                   {
                                       m_builder->getInt1Ty(),  // %cullFlag
                                       m_builder->getInt32Ty(), // %signMask0
                                       m_builder->getInt32Ty(), // %signMask1
                                       m_builder->getInt32Ty()  // %signMask2
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingCullDistance, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *cullFlag = argIt++;
   cullFlag->setName("cullFlag");
 
   Value *signMask0 = argIt++;
   signMask0->setName("signMask0");
 
   Value *signMask1 = argIt++;
@@ -5473,21 +5755,21 @@ Function *NggPrimShader::createFetchCullingRegister(Module *module) {
   auto funcTy = FunctionType::get(m_builder->getInt32Ty(),
                                   {
                                       m_builder->getInt32Ty(), // %primShaderTableAddrLow
                                       m_builder->getInt32Ty(), // %primShaderTableAddrHigh
                                       m_builder->getInt32Ty()  // %regOffset
                                   },
                                   false);
   auto func = Function::Create(funcTy, GlobalValue::InternalLinkage, lgcName::NggCullingFetchReg, module);
 
   func->setCallingConv(CallingConv::C);
-  func->addFnAttr(Attribute::ReadOnly);
+  func->setOnlyReadsMemory();
   func->addFnAttr(Attribute::AlwaysInline);
 
   auto argIt = func->arg_begin();
   Value *primShaderTableAddrLow = argIt++;
   primShaderTableAddrLow->setName("primShaderTableAddrLow");
 
   Value *primShaderTableAddrHigh = argIt++;
   primShaderTableAddrHigh->setName("primShaderTableAddrHigh");
 
   Value *regOffset = argIt++;
@@ -5551,20 +5833,1651 @@ Value *NggPrimShader::doSubgroupBallot(Value *value) {
                                                  m_builder->getInt32Ty()         // Argument type
                                              },
                                              {value, m_builder->getInt32(0), m_builder->getInt32(PredicateNE)});
 
   if (waveSize == 32)
     ballot = m_builder->CreateZExt(ballot, m_builder->getInt64Ty());
 
   return ballot;
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Processes vertex attribute export calls in the target function. We mutate the argument list of the target function
+// by adding two additional arguments (one is attribute ring base and the other is vertex thread ID in sub-group).
+// Also, we expand all export calls by replacing it with real instructions that do vertex attribute exporting through
+// memory.
+//
+// @param [in/out] target : Targeted function that has vertex attribute calls to process
+void NggPrimShader::processVertexAttribExport(Function *&targetFunc) {
+  assert(m_gfxIp.major >= 11); // For GFX11+
+
+  const bool hasTs = m_hasTcs || m_hasTes;
+  const unsigned attribCount =
+      m_pipelineState
+          ->getShaderResourceUsage(m_hasGs ? ShaderStageGeometry : (hasTs ? ShaderStageTessEval : ShaderStageVertex))
+          ->inOutUsage.expCount;
+  if (attribCount == 0)
+    return; // No vertex attribute exports
+
+  IRBuilder<>::InsertPointGuard guard(*m_builder);
+
+  //
+  // Mutate the argument list by adding two additional arguments
+  //
+  auto newTargetFunc = addFunctionArgs(targetFunc, nullptr,
+                                       {
+                                           m_builder->getInt32Ty(), // Attribute ring base (SGPR)
+                                           m_builder->getInt32Ty()  // Vertex thread ID in sub-group (VGPR)
+                                       },
+                                       {"attribRingBase", "vertexIndex"}, 0x1);
+
+  // Original function is no longer needed
+  assert(targetFunc->use_empty());
+  targetFunc->eraseFromParent();
+
+  targetFunc = newTargetFunc;
+
+  //
+  // Expand vertex attribute export calls by replacing them with real instructions
+  //
+  // Modify the field STRIDE of attribute ring buffer descriptor if we have more than one vertex attribute to export
+  bool modifyAttribRingBufDesc = attribCount > 1;
+  Value *attribRingBufDesc = nullptr;
+
+  // Always the first two arguments, added by us
+  auto attribRingBase = targetFunc->getArg(0);
+  auto vertexIndex = targetFunc->getArg(1);
+
+  SmallVector<CallInst *, 8> removeCalls;
+
+  for (auto &func : targetFunc->getParent()->functions()) {
+    if (func.getName().startswith(lgcName::NggAttribExport)) {
+      for (auto user : func.users()) {
+        CallInst *const call = dyn_cast<CallInst>(user);
+        assert(call);
+
+        if (call->getParent()->getParent() != targetFunc)
+          continue; // Export call doesn't belong to targeted function, skip
+
+        // NOTE: We always set the insert point before the terminator of the basic block to which this call belongs.
+        // This is because we might modify attribute ring buffer descriptor and this modified descriptor will be used
+        // by subsequent ring buffer store instructions that do vertex attribute exporting.
+        m_builder->SetInsertPoint(call->getParent()->getTerminator());
+
+        if (!attribRingBufDesc)
+          attribRingBufDesc = call->getArgOperand(0); // Initialize it if necessary
+        const unsigned location = cast<ConstantInt>(call->getArgOperand(1))->getZExtValue();
+        auto attribValue = call->getArgOperand(2);
+
+        // Modify the field STRIDE of attribute ring buffer descriptor
+        if (modifyAttribRingBufDesc) {
+          // STRIDE = WORD1[30:16], STRIDE is multiplied by attribute count
+          auto descWord1 = m_builder->CreateExtractElement(attribRingBufDesc, 1);
+          auto stride = CreateUBfe(descWord1, 16, 14);
+          stride = m_builder->CreateMul(stride, m_builder->getInt32(attribCount));
+
+          descWord1 = m_builder->CreateAnd(descWord1, ~0x3FFF0000);                     // Clear STRIDE
+          descWord1 = m_builder->CreateOr(descWord1, m_builder->CreateShl(stride, 16)); // Set new STRIDE
+          attribRingBufDesc = m_builder->CreateInsertElement(attribRingBufDesc, descWord1, 1);
+
+          modifyAttribRingBufDesc = false; // Clear the flag once finished
+        }
+
+        // Export vertex attributes
+        assert(attribValue->getType() == FixedVectorType::get(m_builder->getFloatTy(), 4)); // Must be <4 xfloat>
+
+        // ringOffset = attribRingBase * 32 * 16 + 32 * location * 16
+        //            = attribRingBase * 512 + location * 512
+        static const unsigned AttribGranularity = 32 * SizeOfVec4; // 32 * 16 bytes
+        auto ringOffset = m_builder->CreateMul(attribRingBase, m_builder->getInt32(AttribGranularity));
+        ringOffset = m_builder->CreateAdd(ringOffset, m_builder->getInt32(AttribGranularity * location));
+
+        CoherentFlag coherent = {};
+        coherent.bits.glc = true;
+        coherent.bits.slc = true;
+
+        m_builder->CreateIntrinsic(Intrinsic::amdgcn_struct_buffer_store, attribValue->getType(),
+                                   {attribValue, attribRingBufDesc, vertexIndex, m_builder->getInt32(0), ringOffset,
+                                    m_builder->getInt32(coherent.u32All)});
+
+        removeCalls.push_back(call);
+      }
+
+      break; // Vertex attribute export calls are handled, could exit the loop
+    }
+  }
+
+  // NOTE: If the workaround of attributes-through-memory preceding vertex position data is required, we have to collect
+  // all vertex position export calls and move them before the return instruction. This actually places them after the
+  // writing operations of attributes-through-memory
+  if (m_pipelineState->getTargetInfo().getGpuWorkarounds().gfx11.waAtmPrecedesPos) {
+    SmallVector<CallInst *, 4> exportCalls;
+
+    // Colllect export calls of vertex position data
+    for (auto &func : targetFunc->getParent()->functions()) {
+      if (func.isIntrinsic() && func.getIntrinsicID() == Intrinsic::amdgcn_exp) {
+        for (auto user : func.users()) {
+          CallInst *const call = dyn_cast<CallInst>(user);
+          assert(call);
+
+          if (call->getParent()->getParent() != targetFunc)
+            continue; // Export call doesn't belong to targeted function, skip
+
+          exportCalls.push_back(call);
+        }
+      }
+    }
+
+    // Move the export calls before the return instructions
+    ReturnInst *retInst = nullptr;
+    for (unsigned i = 0; i < exportCalls.size(); ++i) {
+      auto exportCall = exportCalls[i];
+
+      if (retInst) {
+        // All export calls are expected to be in the same basic block
+        assert(retInst == exportCall->getParent()->getTerminator());
+      } else {
+        retInst = dyn_cast<ReturnInst>(exportCall->getParent()->getTerminator());
+        assert(retInst);
+      }
+
+      exportCall->setOperand(
+          6, m_builder->getInt1(i == exportCalls.size() - 1)); // Make export done flag for the last export call
+      exportCall->moveBefore(retInst);
+    }
+
+    // Before the first export call, add s_wait_vscnt 0 to make sure the completion of all attributes being written
+    // to the attribute ring buffer
+    m_builder->SetInsertPoint(exportCalls[0]);
+    m_builder->CreateFence(AtomicOrdering::Release, SyncScope::System);
+  }
+
+  // Remove calls
+  for (auto call : removeCalls) {
+    call->dropAllReferences();
+    call->eraseFromParent();
+  }
+}
+
+// =====================================================================================================================
+// Processes VS/TES transform feedback output export calls
+//
+// @param module : LLVM module.
+// @param sysValueStart : Start of system value
+void NggPrimShader::processXfbOutputExport(Module *module, Argument *sysValueStart) {
+  assert(m_enableSwXfb);
+  assert(!m_hasGs); // Just for VS/TES
+
+  //
+  // The processing is something like this:
+  //
+  // NGG_XFB() {
+  //   if (threadIdInSubgroup < vertCountInSubgroup) {
+  //     Mutate/clone ES to fetch XFB outputs
+  //     Write XFB outputs to LDS region
+  //   }
+  //
+  //   if (threadIdInSubgroup == 0) {
+  //     Acquire the control of GDS_STRMOUT_DWORDS_WRITTEN_X
+  //     Calculate primsToWrite and dwordsToWrite
+  //     Increment GDS_STRMOUT_DWORDS_WRITTEN_X and release the control
+  //     Store XFB statistics info to LDS
+  //     Increment GDS_STRMOUT_PRIMS_NEEDED_X and GDS_STRMOUT_PRIMS_WRITTEN_X
+  //   }
+  //   Barrier
+  //
+  //   if (threadIdInWave < MaxXfbBuffers + 1)
+  //     Read XFB statistics info from LDS
+  //
+  //   Read primsToWrite and dwordsWritten from XFB statistics info
+  //
+  //   if (threadIdInSubgroup < primsToWrite)
+  //     Export XFB outputs to buffer for each vertice of this primitive
+  // }
+  //
+  BasicBlock *xfbEntryBlock = m_builder->GetInsertBlock();
+
+  BasicBlock *fetchXfbOutputBlock = createBlock(xfbEntryBlock->getParent(), ".fetchXfbOutput");
+  fetchXfbOutputBlock->moveAfter(xfbEntryBlock);
+  BasicBlock *endFetchXfbOutputBlock = createBlock(xfbEntryBlock->getParent(), ".endFetchXfbOutput");
+  endFetchXfbOutputBlock->moveAfter(fetchXfbOutputBlock);
+
+  BasicBlock *prepareXfbExportBlock = createBlock(xfbEntryBlock->getParent(), ".prepareXfbExport");
+  prepareXfbExportBlock->moveAfter(endFetchXfbOutputBlock);
+  BasicBlock *endPrepareXfbExportBlock = createBlock(xfbEntryBlock->getParent(), ".endPrepareXfbExport");
+  endPrepareXfbExportBlock->moveAfter(prepareXfbExportBlock);
+
+  BasicBlock *readXfbStatInfoBlock = createBlock(xfbEntryBlock->getParent(), ".readXfbStatInfo");
+  readXfbStatInfoBlock->moveAfter(endPrepareXfbExportBlock);
+  BasicBlock *endReadXfbStatInfoBlock = createBlock(xfbEntryBlock->getParent(), ".endReadXfbStatInfo");
+  endReadXfbStatInfoBlock->moveAfter(readXfbStatInfoBlock);
+
+  BasicBlock *exportXfbOutputBlock = createBlock(xfbEntryBlock->getParent(), ".exportXfbOutput");
+  exportXfbOutputBlock->moveAfter(endReadXfbStatInfoBlock);
+  BasicBlock *endExportXfbOutputBlock = createBlock(xfbEntryBlock->getParent(), ".endExportXfbOutput");
+  endExportXfbOutputBlock->moveAfter(exportXfbOutputBlock);
+
+  // Insert branching in current block to process transform feedback output export
+  {
+    auto vertValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_nggFactor.vertCountInSubgroup);
+    m_builder->CreateCondBr(vertValid, fetchXfbOutputBlock, endFetchXfbOutputBlock);
+  }
+
+  // Construct ".fetchXfbOutput" block
+  Value *streamOutBufDescs[MaxTransformFeedbackBuffers] = {};
+  Value *streamOutBufOffsets[MaxTransformFeedbackBuffers] = {};
+  SmallVector<XfbOutputExport, 32> xfbOutputExports;
+  {
+    m_builder->SetInsertPoint(fetchXfbOutputBlock);
+
+    auto xfbOutputs = fetchXfbOutput(module, sysValueStart, xfbOutputExports);
+    assert(xfbOutputs->getType()->isArrayTy()); // Must be arrayed
+
+    for (unsigned i = 0; i < cast<ArrayType>(xfbOutputs->getType())->getNumElements(); ++i) {
+      auto xfbOutput = m_builder->CreateExtractValue(xfbOutputs, i);
+      Value *streamOutBufDesc = m_builder->CreateExtractValue(xfbOutput, 0);
+      Value *streamOutBufOffset = m_builder->CreateExtractValue(xfbOutput, 1);
+      Value *outputValue = m_builder->CreateExtractValue(xfbOutput, 2);
+
+      // Record stream-out buffer descriptor if it is missing
+      auto xfbBuffer = xfbOutputExports[i].xfbBuffer;
+      if (!streamOutBufDescs[xfbBuffer])
+        streamOutBufDescs[xfbBuffer] = streamOutBufDesc;
+
+      // Record stream-out buffer offset if it is missing
+      if (!streamOutBufOffsets[xfbBuffer])
+        streamOutBufOffsets[xfbBuffer] = streamOutBufOffset;
+
+      // Write transform feedback outputs to LDS region
+      writeXfbOutputToLds(outputValue, m_nggFactor.threadIdInSubgroup, i);
+    }
+
+    m_builder->CreateBr(endFetchXfbOutputBlock);
+  }
+
+  // Construct ".endFetchXfbOutput" block
+  unsigned firstActiveXfbBuffer = InvalidValue;
+  unsigned lastActiveXfbBuffer = InvalidValue;
+  bool bufferActive[MaxTransformFeedbackBuffers] = {};
+  {
+    m_builder->SetInsertPoint(endFetchXfbOutputBlock);
+
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      bufferActive[i] = streamOutBufDescs[i] != nullptr;
+      // Update stream-out buffer descriptor and buffer offset
+      if (bufferActive[i]) {
+        auto streamOutBufDescPhi = m_builder->CreatePHI(streamOutBufDescs[i]->getType(), 2);
+        streamOutBufDescPhi->addIncoming(streamOutBufDescs[i], fetchXfbOutputBlock);
+        streamOutBufDescPhi->addIncoming(UndefValue::get(streamOutBufDescs[i]->getType()), xfbEntryBlock);
+        streamOutBufDescs[i] = streamOutBufDescPhi;
+
+        auto streamOutBufOffsetPhi = m_builder->CreatePHI(streamOutBufOffsets[i]->getType(), 2);
+        streamOutBufOffsetPhi->addIncoming(streamOutBufOffsets[i], fetchXfbOutputBlock);
+        streamOutBufOffsetPhi->addIncoming(UndefValue::get(streamOutBufOffsets[i]->getType()), xfbEntryBlock);
+        streamOutBufOffsets[i] = streamOutBufOffsetPhi;
+
+        if (firstActiveXfbBuffer == InvalidValue)
+          firstActiveXfbBuffer = i;
+        lastActiveXfbBuffer = i;
+      }
+    }
+
+    auto firstThreadInSubgroup = m_builder->CreateICmpEQ(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(0));
+    m_builder->CreateCondBr(firstThreadInSubgroup, prepareXfbExportBlock, endPrepareXfbExportBlock);
+  }
+
+  // Construct ".prepareXfbExport" block
+  const bool hasTs = m_hasTcs || m_hasTes;
+  const auto &xfbStrides =
+      m_pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex)->inOutUsage.xfbStrides;
+  {
+    m_builder->SetInsertPoint(prepareXfbExportBlock);
+
+    const unsigned vertsPerPrim = m_pipelineState->getVerticesPerPrimitive();
+    Value *numPrimsToWrite = m_nggFactor.primCountInSubgroup;
+
+    Value *dwordsWritten[MaxTransformFeedbackBuffers] = {};
+    Value *dwordsPerPrim[MaxTransformFeedbackBuffers] = {};
+
+    // Calculate numPrimsToWrite
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      if (i == firstActiveXfbBuffer) {
+        // ds_ordered_count
+        dwordsWritten[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_ds_ordered_add, {},
+            {
+                m_builder->CreateIntToPtr(m_nggFactor.orderedWaveId,
+                                          PointerType::get(m_builder->getInt32Ty(), ADDR_SPACE_REGION)), // m0
+                m_builder->getInt32(0),                                                                  // value to add
+                m_builder->getInt32(0),                                                                  // ordering
+                m_builder->getInt32(0),                                                                  // scope
+                m_builder->getFalse(),                                                                   // isVolatile
+                m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) |
+                                    (1 << 24)), // ordered count index, [27:24] is dword count
+                m_builder->getFalse(),          // wave release
+                m_builder->getFalse(),          // wave done
+            });
+      } else {
+        // ds_add_gs_reg
+        dwordsWritten[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, m_builder->getInt32Ty(),
+                                       {m_builder->getInt32(0),                                         // value to add
+                                        m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) << 2)}); // count index
+      }
+
+      // NUM_RECORDS = SQ_BUF_RSRC_WORD2
+      Value *numRecords = m_builder->CreateExtractElement(streamOutBufDescs[i], 2);
+      // bufferSizeInDwords = numRecords >> 2 (NOTE: NUM_RECORDS is set to the byte size of stream-out buffer)
+      Value *bufferSizeInDwords = m_builder->CreateLShr(numRecords, 2);
+      // dwordsRemaining = max(0, bufferSizeInDwords - (bufferOffset + dwordsWritten))
+      Value *dwordsRemaining =
+          m_builder->CreateSub(bufferSizeInDwords, m_builder->CreateAdd(streamOutBufOffsets[i], dwordsWritten[i]));
+      dwordsRemaining = m_builder->CreateIntrinsic(Intrinsic::smax, dwordsRemaining->getType(),
+                                                   {dwordsRemaining, m_builder->getInt32(0)});
+      // numPrimsToWrite = min(dwordsRemaining / dwordsPerPrim, numPrimsToWrite)
+      dwordsPerPrim[i] = m_builder->getInt32(vertsPerPrim * xfbStrides[i] / SizeOfDword);
+      Value *primsCanWrite = m_builder->CreateUDiv(dwordsRemaining, dwordsPerPrim[i]);
+      numPrimsToWrite =
+          m_builder->CreateIntrinsic(Intrinsic::umin, numPrimsToWrite->getType(), {numPrimsToWrite, primsCanWrite});
+    }
+
+    // Increment dwordsWritten
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      Value *dwordsToWrite = m_builder->CreateMul(numPrimsToWrite, dwordsPerPrim[i]);
+
+      if (i == lastActiveXfbBuffer) {
+        // ds_ordered_count, wave done
+        dwordsWritten[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_ds_ordered_add, {},
+            {
+                m_builder->CreateIntToPtr(m_nggFactor.orderedWaveId,
+                                          PointerType::get(m_builder->getInt32Ty(), ADDR_SPACE_REGION)), // m0
+                dwordsToWrite,                                                                           // value to add
+                m_builder->getInt32(0),                                                                  // ordering
+                m_builder->getInt32(0),                                                                  // scope
+                m_builder->getFalse(),                                                                   // isVolatile
+                m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) |
+                                    (1 << 24)), // ordered count index, [27:24] is dword count
+                m_builder->getTrue(),           // wave release
+                m_builder->getTrue(),           // wave done
+            });
+      } else {
+        // ds_add_gs_reg
+        dwordsWritten[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, dwordsToWrite->getType(),
+                                       {dwordsToWrite,                                                  // value to add
+                                        m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) << 2)}); // count index
+      }
+    }
+
+    // Store transform feedback statistics info to LDS and GDS
+    const unsigned regionStart = m_ldsManager->getLdsRegionStart(LdsRegionXfbStatInfo);
+    m_ldsManager->writeValueToLds(numPrimsToWrite,
+                                  m_builder->getInt32(regionStart + MaxTransformFeedbackBuffers * SizeOfDword));
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      m_ldsManager->writeValueToLds(dwordsWritten[i], m_builder->getInt32(regionStart + i * SizeOfDword));
+    }
+
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, m_nggFactor.primCountInSubgroup->getType(),
+                               {m_nggFactor.primCountInSubgroup,                        // value to add
+                                m_builder->getInt32(GDS_STRMOUT_PRIMS_NEEDED_0 << 2)}); // count index
+
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, numPrimsToWrite->getType(),
+                               {numPrimsToWrite,                                         // value to add
+                                m_builder->getInt32(GDS_STRMOUT_PRIMS_WRITTEN_0 << 2)}); // count index
+
+    m_builder->CreateBr(endPrepareXfbExportBlock);
+  }
+
+  // Construct ".endPrepareXfbExport" block
+  {
+    m_builder->SetInsertPoint(endPrepareXfbExportBlock);
+
+    // We are going to read transform feedback statistics info and outputs from LDS and export them to transform
+    // feedback buffers. Make sure the output values have been all written before this.
+    SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
+    m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
+    m_builder->CreateFence(AtomicOrdering::Acquire, workgroupScope);
+
+    auto threadValid =
+        m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, m_builder->getInt32(1 + MaxTransformFeedbackBuffers));
+    m_builder->CreateCondBr(threadValid, readXfbStatInfoBlock, endReadXfbStatInfoBlock);
+  }
+
+  // Construct ".readXfbStatInfo" block
+  Value *xfbStatInfo = nullptr;
+  {
+    m_builder->SetInsertPoint(readXfbStatInfoBlock);
+
+    xfbStatInfo = readPerThreadDataFromLds(m_builder->getInt32Ty(), m_nggFactor.threadIdInWave, LdsRegionXfbStatInfo);
+    m_builder->CreateBr(endReadXfbStatInfoBlock);
+  }
+
+  // Construct ".endReadXfbStatInfo" block
+  Value *streamOutOffsets[MaxTransformFeedbackBuffers] = {}; // Stream-out offset to write transform feedback outputs
+  {
+    m_builder->SetInsertPoint(endReadXfbStatInfoBlock);
+
+    auto xfbStatInfoPhi = m_builder->CreatePHI(m_builder->getInt32Ty(), 2);
+    xfbStatInfoPhi->addIncoming(xfbStatInfo, readXfbStatInfoBlock);
+    xfbStatInfoPhi->addIncoming(UndefValue::get(m_builder->getInt32Ty()), endPrepareXfbExportBlock);
+    xfbStatInfo = xfbStatInfoPhi;
+
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (bufferActive[i]) {
+        streamOutOffsets[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {xfbStatInfo, m_builder->getInt32(i)});
+        streamOutOffsets[i] = m_builder->CreateAdd(streamOutBufOffsets[i], streamOutOffsets[i]);
+        streamOutOffsets[i] = m_builder->CreateShl(streamOutOffsets[i], 2);
+      }
+    }
+    auto numPrimsToWrite = m_builder->CreateIntrinsic(Intrinsic::amdgcn_readlane, {},
+                                                      {xfbStatInfo, m_builder->getInt32(MaxTransformFeedbackBuffers)});
+
+    auto primValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, numPrimsToWrite);
+    m_builder->CreateCondBr(primValid, exportXfbOutputBlock, endExportXfbOutputBlock);
+  }
+
+  // Construct ".exportXfbOutput" block
+  {
+    m_builder->SetInsertPoint(exportXfbOutputBlock);
+
+    Value *vertexIds[3] = {};
+
+    const unsigned vertsPerPrim = m_pipelineState->getVerticesPerPrimitive();
+    if (m_nggControl->passthroughMode) {
+      // [8:0]   = vertexId0
+      vertexIds[0] = CreateUBfe(m_nggFactor.primData, 0, 9);
+      // [18:10] = vertexId1
+      if (vertsPerPrim > 1)
+        vertexIds[1] = CreateUBfe(m_nggFactor.primData, 10, 9);
+      // [28:20] = vertexId2
+      if (vertsPerPrim > 2)
+        vertexIds[2] = CreateUBfe(m_nggFactor.primData, 20, 9);
+
+    } else {
+      // Must be triangle
+      assert(vertsPerPrim == 3);
+      vertexIds[0] = m_nggFactor.esGsOffset0;
+      vertexIds[1] = m_nggFactor.esGsOffset1;
+      vertexIds[2] = m_nggFactor.esGsOffset2;
+    }
+
+    for (unsigned i = 0; i < vertsPerPrim; ++i) {
+      for (unsigned j = 0; j < xfbOutputExports.size(); ++j) {
+        const auto &xfbOutputExport = xfbOutputExports[j];
+        auto outputValue = readXfbOutputFromLds(
+            xfbOutputExport.numElements > 1 ? FixedVectorType::get(m_builder->getFloatTy(), xfbOutputExport.numElements)
+                                            : m_builder->getFloatTy(),
+            vertexIds[i], j);
+
+        if (xfbOutputExport.is16bit) {
+          // NOTE: For 16-bit transform feedbakc outputs, they are stored as 32-bit without tightly packed in LDS.
+          outputValue = m_builder->CreateBitCast(
+              outputValue, FixedVectorType::get(m_builder->getInt32Ty(), xfbOutputExport.numElements));
+          outputValue = m_builder->CreateTrunc(
+              outputValue, FixedVectorType::get(m_builder->getInt16Ty(), xfbOutputExport.numElements));
+          outputValue = m_builder->CreateBitCast(
+              outputValue, FixedVectorType::get(m_builder->getHalfTy(), xfbOutputExport.numElements));
+        }
+
+        unsigned format = 0;
+        switch (xfbOutputExport.numElements) {
+        case 1:
+          format = xfbOutputExport.is16bit ? BUF_FORMAT_16_FLOAT : BUF_FORMAT_32_FLOAT;
+          break;
+        case 2:
+          format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_FLOAT : BUF_FORMAT_32_32_FLOAT_GFX11;
+          break;
+        case 3:
+          format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_FLOAT : BUF_FORMAT_32_32_32_FLOAT_GFX11;
+          break;
+        case 4:
+          format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_16_16_FLOAT_GFX11 : BUF_FORMAT_32_32_32_32_FLOAT_GFX11;
+          break;
+        default:
+          llvm_unreachable("Unexpected element number!");
+          break;
+        }
+
+        CoherentFlag coherent = {};
+        coherent.bits.glc = true;
+        coherent.bits.slc = true;
+
+        // vertexOffset = (threadIdInSubgroup * vertsPerPrim + vertexIndex) * xfbStride
+        Value *vertexOffset = m_builder->CreateAdd(
+            m_builder->CreateMul(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(vertsPerPrim)),
+            m_builder->getInt32(i));
+        vertexOffset = m_builder->CreateMul(vertexOffset, m_builder->getInt32(xfbStrides[xfbOutputExport.xfbBuffer]));
+        // xfbOutputOffset = vertexOffset + xfbOffset
+        Value *xfbOutputOffset = m_builder->CreateAdd(vertexOffset, m_builder->getInt32(xfbOutputExport.xfbOffset));
+
+        if (xfbOutputExport.is16bit && xfbOutputExport.numElements == 3) {
+          // NOTE: For 16vec3, HW doesn't have a corresponding buffer store instruction. We have to split it to 16vec2
+          // and 16scalar.
+          m_builder->CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store,
+                                     FixedVectorType::get(m_builder->getHalfTy(), 2),
+                                     {m_builder->CreateShuffleVector(outputValue, ArrayRef<int>{0, 1}), // vdata
+                                      streamOutBufDescs[xfbOutputExport.xfbBuffer],                     // rsrc
+                                      xfbOutputOffset,                                                  // offset
+                                      streamOutOffsets[xfbOutputExport.xfbBuffer],                      // soffset
+                                      m_builder->getInt32(BUF_FORMAT_16_16_FLOAT),                      // format
+                                      m_builder->getInt32(coherent.u32All)}); // auxiliary data
+
+          m_builder->CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, m_builder->getHalfTy(),
+                                     {m_builder->CreateExtractElement(outputValue, 2), // vdata
+                                      streamOutBufDescs[xfbOutputExport.xfbBuffer],    // rsrc
+                                      m_builder->CreateAdd(xfbOutputOffset,
+                                                           m_builder->getInt32(2 * sizeof(uint16_t))), // offset
+                                      streamOutOffsets[xfbOutputExport.xfbBuffer],                     // soffset
+                                      m_builder->getInt32(BUF_FORMAT_16_FLOAT),                        // format
+                                      m_builder->getInt32(coherent.u32All)});                          // auxiliary data
+        } else {
+          m_builder->CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, outputValue->getType(),
+                                     {outputValue,                                  // vdata
+                                      streamOutBufDescs[xfbOutputExport.xfbBuffer], // rsrc
+                                      xfbOutputOffset,                              // offset
+                                      streamOutOffsets[xfbOutputExport.xfbBuffer],  // soffset
+                                      m_builder->getInt32(format),                  // format
+                                      m_builder->getInt32(coherent.u32All)});       // auxiliary data
+        }
+      }
+    }
+
+    m_builder->CreateBr(endExportXfbOutputBlock);
+  }
+
+  // Construct ".endExportXfbOutput" block
+  { m_builder->SetInsertPoint(endExportXfbOutputBlock); }
+}
+
+// =====================================================================================================================
+// Processes GS transform feedback output export calls
+//
+// @param module : LLVM module.
+// @param sysValueStart : Start of system value
+void NggPrimShader::processGsXfbOutputExport(Module *module, Argument *sysValueStart) {
+  assert(m_enableSwXfb);
+  assert(m_hasGs); // Just for GS
+
+  const unsigned waveSize = m_pipelineState->getShaderWaveSize(ShaderStageGeometry);
+  assert(waveSize == 32 || waveSize == 64);
+  const unsigned waveCountInSubgroup = Gfx9::NggMaxThreadsPerSubgroup / waveSize;
+
+  const auto &inOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage;
+
+  unsigned firstActiveStream = InvalidValue;
+  unsigned lastActiveStream = InvalidValue;
+  bool streamActive[MaxGsStreams] = {};
+  for (unsigned i = 0; i < MaxGsStreams; ++i) {
+    streamActive[i] = inOutUsage.gs.outLocCount[i] > 0;
+    if (streamActive[i]) {
+      if (firstActiveStream == InvalidValue)
+        firstActiveStream = i;
+      lastActiveStream = i;
+    }
+  }
+
+  //
+  // The processing is something like this:
+  //
+  // NGG_GS_XFB() {
+  //   if (threadIdInSubgroup < waveCount + 1)
+  //     Initialize per-wave and per-subgroup count of output primitives
+  //   Barrier
+  //
+  //   if (threadIdInSubgroup < primCountInSubgroup)
+  //     Check the draw flag of output primitives and compute draw mask
+  //
+  //   if (threadIdInWave < waveCount - waveId)
+  //     Accumulate per-wave and per-subgroup count of output primitives
+  //   Barrier
+  //
+  //   for each vertex stream) {
+  //     if (primitive drawn)
+  //       Compact primitive thread ID (map: compacted -> uncompacted)
+  //   }
+  //
+  //   Mutate copy shader to fetch XFB outputs
+  //
+  //   if (threadIdInSubgroup == 0) {
+  //     Acquire the control of GDS_STRMOUT_DWORDS_WRITTEN_X
+  //     Calculate primsToWrite and dwordsToWrite
+  //     Increment GDS_STRMOUT_DWORDS_WRITTEN_X and release the control
+  //     Store GS XFB statistics info to LDS
+  //     Increment GDS_STRMOUT_PRIMS_NEEDED_X and GDS_STRMOUT_PRIMS_WRITTEN_X
+  //   }
+  //   Barrier
+  //
+  //   Read XFB statistics info from LDS
+  //   Read primsToWrite and dwordsWritten from XFB statistics info
+  //
+  //   for each vertex stream {
+  //     if (threadIdInSubgroup < primsToWrite)
+  //       Export XFB outputs to buffer for each vertice of this primitive
+  //   }
+  // }
+  //
+  BasicBlock *xfbEntryBlock = m_builder->GetInsertBlock();
+
+  BasicBlock *initOutPrimCountBlock = createBlock(xfbEntryBlock->getParent(), ".initOutPrimCount");
+  initOutPrimCountBlock->moveAfter(xfbEntryBlock);
+  BasicBlock *endInitOutPrimCountBlock = createBlock(xfbEntryBlock->getParent(), ".endInitOutPrimCount");
+  endInitOutPrimCountBlock->moveAfter(initOutPrimCountBlock);
+
+  BasicBlock *checkOutPrimDrawFlagBlock = createBlock(xfbEntryBlock->getParent(), ".checkOutPrimDrawFlag");
+  checkOutPrimDrawFlagBlock->moveAfter(endInitOutPrimCountBlock);
+  BasicBlock *endCheckOutPrimDrawFlagBlock = createBlock(xfbEntryBlock->getParent(), ".endCheckOutPrimDrawFlag");
+  endCheckOutPrimDrawFlagBlock->moveAfter(checkOutPrimDrawFlagBlock);
+
+  BasicBlock *accumOutPrimCountBlock = createBlock(xfbEntryBlock->getParent(), ".accumOutPrimCount");
+  accumOutPrimCountBlock->moveAfter(endCheckOutPrimDrawFlagBlock);
+  BasicBlock *endAccumOutPrimCountBlock = createBlock(xfbEntryBlock->getParent(), ".endAccumOutPrimCount");
+  endAccumOutPrimCountBlock->moveAfter(accumOutPrimCountBlock);
+
+  BasicBlock *compactOutPrimIdBlock[MaxGsStreams] = {};
+  BasicBlock *endCompactOutPrimIdBlock[MaxGsStreams] = {};
+  BasicBlock *insertPos = endAccumOutPrimCountBlock;
+  for (unsigned i = 0; i < MaxGsStreams; ++i) {
+    if (streamActive[i]) {
+      compactOutPrimIdBlock[i] =
+          createBlock(xfbEntryBlock->getParent(), ".compactOutPrimIdInStream" + std::to_string(i));
+      compactOutPrimIdBlock[i]->moveAfter(insertPos);
+      insertPos = compactOutPrimIdBlock[i];
+
+      endCompactOutPrimIdBlock[i] =
+          createBlock(xfbEntryBlock->getParent(), ".endCompactOutPrimIdInStream" + std::to_string(i));
+      endCompactOutPrimIdBlock[i]->moveAfter(insertPos);
+      insertPos = endCompactOutPrimIdBlock[i];
+    }
+  }
+
+  BasicBlock *prepareXfbExportBlock = createBlock(xfbEntryBlock->getParent(), ".prepareXfbExport");
+  prepareXfbExportBlock->moveAfter(insertPos);
+  BasicBlock *endPrepareXfbExportBlock = createBlock(xfbEntryBlock->getParent(), ".endPrepareXfbExport");
+  endPrepareXfbExportBlock->moveAfter(prepareXfbExportBlock);
+
+  BasicBlock *exportXfbOutputBlock[MaxGsStreams] = {};
+  BasicBlock *endExportXfbOutputBlock[MaxGsStreams] = {};
+  insertPos = endPrepareXfbExportBlock;
+  for (unsigned i = 0; i < MaxGsStreams; ++i) {
+    if (streamActive[i]) {
+      exportXfbOutputBlock[i] = createBlock(xfbEntryBlock->getParent(), ".exportXfbOutputInStream" + std::to_string(i));
+      exportXfbOutputBlock[i]->moveAfter(insertPos);
+      insertPos = exportXfbOutputBlock[i];
+
+      endExportXfbOutputBlock[i] =
+          createBlock(xfbEntryBlock->getParent(), ".endExportXfbOutputInStream" + std::to_string(i));
+      endExportXfbOutputBlock[i]->moveAfter(insertPos);
+      insertPos = endExportXfbOutputBlock[i];
+    }
+  }
+
+  // Insert branching in current block to process transform feedback output export
+  {
+    auto waveValid =
+        m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(waveCountInSubgroup + 1));
+    m_builder->CreateCondBr(waveValid, initOutPrimCountBlock, endInitOutPrimCountBlock);
+  }
+
+  // Construct ".initOutPrimCount" block
+  {
+    m_builder->SetInsertPoint(initOutPrimCountBlock);
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        writePerThreadDataToLds(m_builder->getInt32(0), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimCountInWaves,
+                                (SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword) * i);
+      }
+    }
+
+    m_builder->CreateBr(endInitOutPrimCountBlock);
+  }
+
+  // Construct ".endInitOutPrimCount" block
+  {
+    m_builder->SetInsertPoint(endInitOutPrimCountBlock);
+
+    SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
+    m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
+    m_builder->CreateFence(AtomicOrdering::Acquire, workgroupScope);
+
+    auto outPrimValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, m_nggFactor.primCountInSubgroup);
+    m_builder->CreateCondBr(outPrimValid, checkOutPrimDrawFlagBlock, endCheckOutPrimDrawFlagBlock);
+  }
+
+  // Construct ".checkOutPrimDrawFlag" block
+  Value *drawFlag[MaxGsStreams] = {};
+  {
+    m_builder->SetInsertPoint(checkOutPrimDrawFlagBlock);
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        // drawFlag = primData[N] != NullPrim
+        auto primData =
+            readPerThreadDataFromLds(m_builder->getInt32Ty(), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimData,
+                                     SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * i);
+        drawFlag[i] = m_builder->CreateICmpNE(primData, m_builder->getInt32(NullPrim));
+      }
+    }
+
+    m_builder->CreateBr(endCheckOutPrimDrawFlagBlock);
+  }
+
+  // Construct ".endCheckOutPrimDrawFlag" block
+  Value *drawMask[MaxGsStreams] = {};
+  Value *outPrimCountInWave[MaxGsStreams] = {};
+  {
+    m_builder->SetInsertPoint(endCheckOutPrimDrawFlagBlock);
+
+    // Update draw flags
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        auto drawFlagPhi = m_builder->CreatePHI(m_builder->getInt1Ty(), 2);
+        drawFlagPhi->addIncoming(drawFlag[i], checkOutPrimDrawFlagBlock);
+        drawFlagPhi->addIncoming(m_builder->getFalse(), endInitOutPrimCountBlock);
+        drawFlag[i] = drawFlagPhi;
+      }
+    }
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        drawMask[i] = doSubgroupBallot(drawFlag[i]);
+
+        outPrimCountInWave[i] = m_builder->CreateIntrinsic(Intrinsic::ctpop, m_builder->getInt64Ty(), drawMask[i]);
+        outPrimCountInWave[i] = m_builder->CreateTrunc(outPrimCountInWave[i], m_builder->getInt32Ty());
+      }
+    }
+    auto threadIdUpbound = m_builder->CreateSub(m_builder->getInt32(waveCountInSubgroup), m_nggFactor.waveIdInSubgroup);
+    auto threadValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInWave, threadIdUpbound);
+
+    m_builder->CreateCondBr(threadValid, accumOutPrimCountBlock, endAccumOutPrimCountBlock);
+  }
+
+  // Construct ".accumOutPrimCount" block
+  {
+    m_builder->SetInsertPoint(accumOutPrimCountBlock);
+
+    unsigned regionStart = m_ldsManager->getLdsRegionStart(LdsRegionOutPrimCountInWaves);
+
+    auto ldsOffset = m_builder->CreateAdd(m_nggFactor.waveIdInSubgroup, m_nggFactor.threadIdInWave);
+    ldsOffset = m_builder->CreateAdd(ldsOffset, m_builder->getInt32(1));
+    ldsOffset = m_builder->CreateShl(ldsOffset, 2);
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        m_ldsManager->atomicOpWithLds(
+            AtomicRMWInst::Add, outPrimCountInWave[i],
+            m_builder->CreateAdd(
+                ldsOffset,
+                m_builder->getInt32(regionStart + (SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword) * i)));
+      }
+    }
+
+    m_builder->CreateBr(endAccumOutPrimCountBlock);
+  }
+
+  // Construct ".endAccumOutPrimCount" block
+  Value *primCountInPrevWaves[MaxGsStreams] = {};
+  Value *primCountInSubgroup[MaxGsStreams] = {};
+  {
+    m_builder->SetInsertPoint(endAccumOutPrimCountBlock);
+
+    SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
+    m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
+    m_builder->CreateFence(AtomicOrdering::Acquire, workgroupScope);
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        auto outPrimCountInWaves =
+            readPerThreadDataFromLds(m_builder->getInt32Ty(), m_nggFactor.threadIdInWave, LdsRegionOutPrimCountInWaves,
+                                     (SizeOfDword * Gfx9::NggMaxWavesPerSubgroup + SizeOfDword) * i);
+
+        // The last dword following dwords for all waves (each wave has one dword) stores GS output primitive count of
+        // the entire sub-group
+        primCountInSubgroup[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_readlane, {}, {outPrimCountInWaves, m_builder->getInt32(waveCountInSubgroup)});
+
+        // Get output primitive count for all waves prior to this wave
+        primCountInPrevWaves[i] = m_builder->CreateIntrinsic(Intrinsic::amdgcn_readlane, {},
+                                                             {outPrimCountInWaves, m_nggFactor.waveIdInSubgroup});
+      }
+    }
+
+    m_builder->CreateCondBr(drawFlag[firstActiveStream], compactOutPrimIdBlock[firstActiveStream],
+                            endCompactOutPrimIdBlock[firstActiveStream]);
+  }
+
+  Value *streamOutBufDescs[MaxTransformFeedbackBuffers] = {};
+  Value *streamOutBufOffsets[MaxTransformFeedbackBuffers] = {};
+  SmallVector<XfbOutputExport, 32> xfbOutputExports;
+
+  unsigned firstActiveXfbBuffer = ~0U;
+  unsigned lastActiveXfbBuffer = 0;
+  bool bufferActive[MaxTransformFeedbackBuffers] = {};
+  for (unsigned i = 0; i < MaxGsStreams; ++i) {
+    if (!streamActive[i])
+      continue;
+
+    // Construct ".compactOutPrimIdInStream[N]" block
+    {
+      m_builder->SetInsertPoint(compactOutPrimIdBlock[i]);
+
+      auto drawMaskVec = m_builder->CreateBitCast(drawMask[i], FixedVectorType::get(Type::getInt32Ty(*m_context), 2));
+
+      auto drawMaskLow = m_builder->CreateExtractElement(drawMaskVec, static_cast<uint64_t>(0));
+      Value *compactPrimitiveId =
+          m_builder->CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {drawMaskLow, m_builder->getInt32(0)});
+
+      if (waveSize == 64) {
+        auto drawMaskHigh = m_builder->CreateExtractElement(drawMaskVec, 1);
+        compactPrimitiveId =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {drawMaskHigh, compactPrimitiveId});
+      }
+
+      compactPrimitiveId = m_builder->CreateAdd(primCountInPrevWaves[i], compactPrimitiveId);
+      writePerThreadDataToLds(m_nggFactor.threadIdInSubgroup, compactPrimitiveId, LdsRegionOutPrimThreadIdMap,
+                              SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * i);
+
+      m_builder->CreateBr(endCompactOutPrimIdBlock[i]);
+    }
+
+    // Construct ".endCompactOutPrimIdInStream[N]" block
+    {
+      m_builder->SetInsertPoint(endCompactOutPrimIdBlock[i]);
+
+      if (i == lastActiveStream) {
+        // Start to fetch transform feedback outputs after we finish compacting primitive thread IDs of the last vertex
+        // stream.
+        auto xfbOutputs = fetchXfbOutput(module, sysValueStart, xfbOutputExports);
+        assert(xfbOutputs->getType()->isArrayTy()); // Must be arrayed
+
+        for (unsigned i = 0; i < cast<ArrayType>(xfbOutputs->getType())->getNumElements(); ++i) {
+          auto xfbOutput = m_builder->CreateExtractValue(xfbOutputs, i);
+          Value *streamOutBufDesc = m_builder->CreateExtractValue(xfbOutput, 0);
+          Value *streamOutBufOffset = m_builder->CreateExtractValue(xfbOutput, 1);
+
+          // Record stream-out buffer descriptor if it is missing
+          auto xfbBuffer = xfbOutputExports[i].xfbBuffer;
+          if (!streamOutBufDescs[xfbBuffer])
+            streamOutBufDescs[xfbBuffer] = streamOutBufDesc;
+
+          // Record stream-out buffer offset if it is missing
+          if (!streamOutBufOffsets[xfbBuffer])
+            streamOutBufOffsets[xfbBuffer] = streamOutBufOffset;
+
+          bufferActive[xfbBuffer] = true;
+          firstActiveXfbBuffer = std::min(firstActiveXfbBuffer, xfbBuffer);
+          lastActiveXfbBuffer = std::max(lastActiveXfbBuffer, xfbBuffer);
+        }
+
+        for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+          bufferActive[i] = streamOutBufDescs[i] != nullptr;
+          // Update stream-out buffer descriptor and buffer offset
+          if (bufferActive[i]) {
+            if (firstActiveXfbBuffer == InvalidValue)
+              firstActiveXfbBuffer = i;
+            lastActiveXfbBuffer = i;
+          }
+        }
+
+        auto firstThreadInSubgroup = m_builder->CreateICmpEQ(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(0));
+        m_builder->CreateCondBr(firstThreadInSubgroup, prepareXfbExportBlock, endPrepareXfbExportBlock);
+      } else {
+        unsigned nextActiveStream = i + 1;
+        while (!streamActive[nextActiveStream]) {
+          ++nextActiveStream;
+        }
+
+        assert(nextActiveStream <= lastActiveStream);
+        m_builder->CreateCondBr(drawFlag[nextActiveStream], compactOutPrimIdBlock[nextActiveStream],
+                                endCompactOutPrimIdBlock[nextActiveStream]);
+      }
+    }
+  }
+
+  // Construct ".prepareXfbExport" block
+  const auto &streamXfbBuffers = inOutUsage.streamXfbBuffers;
+  const auto &xfbStrides = inOutUsage.xfbStrides;
+  {
+    m_builder->SetInsertPoint(prepareXfbExportBlock);
+
+    const unsigned outVertsPerPrim = m_pipelineState->getVerticesPerPrimitive();
+
+    Value *numPrimsToWrite[MaxGsStreams] = {};
+    for (unsigned i = 0; i < MaxGsStreams; ++i)
+      numPrimsToWrite[i] = primCountInSubgroup[i];
+
+    Value *dwordsWritten[MaxTransformFeedbackBuffers] = {};
+    Value *dwordsPerPrim[MaxTransformFeedbackBuffers] = {};
+
+    // Determine the associated vertex streams
+    unsigned xfbBufferToStream[MaxTransformFeedbackBuffers] = {};
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      for (unsigned j = 0; j < MaxGsStreams; ++j) {
+        if (!streamActive[j])
+          continue;
+
+        if ((streamXfbBuffers[j] & (1 << i)) != 0) {
+          // NOTE: According to GLSL spec, all outputs assigned to a given transform feedback buffer are required to
+          // come from a single vertex stream.
+          xfbBufferToStream[i] = j;
+          break;
+        }
+      }
+    }
+
+    // Calculate numPrimsToWrite[N]
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      if (i == firstActiveXfbBuffer) {
+        // ds_ordered_count
+        dwordsWritten[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_ds_ordered_add, {},
+            {
+                m_builder->CreateIntToPtr(m_nggFactor.orderedWaveId,
+                                          PointerType::get(m_builder->getInt32Ty(), ADDR_SPACE_REGION)), // m0
+                m_builder->getInt32(0),                                                                  // value to add
+                m_builder->getInt32(0),                                                                  // ordering
+                m_builder->getInt32(0),                                                                  // scope
+                m_builder->getFalse(),                                                                   // isVolatile
+                m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) |
+                                    (1 << 24)), // ordered count index, [27:24] is dword count
+                m_builder->getFalse(),          // wave release
+                m_builder->getFalse(),          // wave done
+            });
+      } else {
+        // ds_add_gs_reg
+        dwordsWritten[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, m_builder->getInt32Ty(),
+                                       {m_builder->getInt32(0),                                         // value to add
+                                        m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) << 2)}); // count index
+      }
+
+      // NUM_RECORDS = SQ_BUF_RSRC_WORD2
+      Value *numRecords = m_builder->CreateExtractElement(streamOutBufDescs[i], 2);
+      // bufferSizeInDwords = numRecords >> 2 (NOTE: NUM_RECORDS is set to the byte size of stream-out buffer)
+      Value *bufferSizeInDwords = m_builder->CreateLShr(numRecords, 2);
+      // dwordsRemaining = max(0, bufferSizeInDwords - (bufferOffset + dwordsWritten))
+      Value *dwordsRemaining =
+          m_builder->CreateSub(bufferSizeInDwords, m_builder->CreateAdd(streamOutBufOffsets[i], dwordsWritten[i]));
+      dwordsRemaining = m_builder->CreateIntrinsic(Intrinsic::smax, dwordsRemaining->getType(),
+                                                   {dwordsRemaining, m_builder->getInt32(0)});
+      // numPrimsToWrite = min(dwordsRemaining / dwordsPerPrim, numPrimsToWrite)
+      dwordsPerPrim[i] = m_builder->getInt32(outVertsPerPrim * xfbStrides[i] / SizeOfDword);
+      Value *primsCanWrite = m_builder->CreateUDiv(dwordsRemaining, dwordsPerPrim[i]);
+      numPrimsToWrite[xfbBufferToStream[i]] =
+          m_builder->CreateIntrinsic(Intrinsic::umin, numPrimsToWrite[xfbBufferToStream[i]]->getType(),
+                                     {numPrimsToWrite[xfbBufferToStream[i]], primsCanWrite});
+    }
+
+    // Increment dwordsWritten
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      Value *dwordsToWrite = m_builder->CreateMul(numPrimsToWrite[xfbBufferToStream[i]], dwordsPerPrim[i]);
+
+      if (i == lastActiveXfbBuffer) {
+        // ds_ordered_count, wave done
+        dwordsWritten[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_ds_ordered_add, {},
+            {
+                m_builder->CreateIntToPtr(m_nggFactor.orderedWaveId,
+                                          PointerType::get(m_builder->getInt32Ty(), ADDR_SPACE_REGION)), // m0
+                dwordsToWrite,                                                                           // value to add
+                m_builder->getInt32(0),                                                                  // ordering
+                m_builder->getInt32(0),                                                                  // scope
+                m_builder->getFalse(),                                                                   // isVolatile
+                m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) |
+                                    (1 << 24)), // ordered count index, [27:24] is dword count
+                m_builder->getTrue(),           // wave release
+                m_builder->getTrue(),           // wave done
+            });
+      } else {
+        // ds_add_gs_reg
+        dwordsWritten[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, dwordsToWrite->getType(),
+                                       {dwordsToWrite,                                                  // value to add
+                                        m_builder->getInt32((GDS_STRMOUT_DWORDS_WRITTEN_0 + i) << 2)}); // count index
+      }
+    }
+
+    // Store transform feedback statistics info to LDS and GDS
+    const unsigned regionStart = m_ldsManager->getLdsRegionStart(LdsRegionGsXfbStatInfo);
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (!bufferActive[i])
+        continue;
+
+      m_ldsManager->writeValueToLds(dwordsWritten[i], m_builder->getInt32(regionStart + i * SizeOfDword));
+    }
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (!streamActive[i])
+        continue;
+
+      m_ldsManager->writeValueToLds(
+          numPrimsToWrite[i],
+          m_builder->getInt32(regionStart + MaxTransformFeedbackBuffers * SizeOfDword + i * SizeOfDword));
+
+      m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, primCountInSubgroup[i]->getType(),
+                                 {primCountInSubgroup[i],                                           // value to add
+                                  m_builder->getInt32((GDS_STRMOUT_PRIMS_NEEDED_0 + 2 * i) << 2)}); // count index
+
+      m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_add_gs_reg_rtn, numPrimsToWrite[i]->getType(),
+                                 {numPrimsToWrite[i],                                                // value to add
+                                  m_builder->getInt32((GDS_STRMOUT_PRIMS_WRITTEN_0 + 2 * i) << 2)}); // count index
+    }
+
+    m_builder->CreateBr(endPrepareXfbExportBlock);
+  }
+
+  // Construct ".endPrepareXfbExport" block
+  Value *streamOutOffsets[MaxTransformFeedbackBuffers] = {}; // Stream-out offset to write transform feedback outputs
+  Value *numPrimsToWrite[MaxGsStreams] = {};
+  {
+    m_builder->SetInsertPoint(endPrepareXfbExportBlock);
+
+    // We are going to read transform feedback statistics info from LDS. Make sure the info has been written before
+    // this.
+    SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
+    m_builder->CreateFence(AtomicOrdering::Release, workgroupScope);
+    m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
+    m_builder->CreateFence(AtomicOrdering::Acquire, workgroupScope);
+
+    auto xfbStatInfo =
+        readPerThreadDataFromLds(m_builder->getInt32Ty(), m_nggFactor.threadIdInWave, LdsRegionGsXfbStatInfo);
+    for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
+      if (bufferActive[i]) {
+        streamOutOffsets[i] =
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_readlane, {}, {xfbStatInfo, m_builder->getInt32(i)});
+        streamOutOffsets[i] = m_builder->CreateAdd(streamOutBufOffsets[i], streamOutOffsets[i]);
+        streamOutOffsets[i] = m_builder->CreateShl(streamOutOffsets[i], 2);
+      }
+    }
+
+    for (unsigned i = 0; i < MaxGsStreams; ++i) {
+      if (streamActive[i]) {
+        numPrimsToWrite[i] = m_builder->CreateIntrinsic(
+            Intrinsic::amdgcn_readlane, {}, {xfbStatInfo, m_builder->getInt32(MaxTransformFeedbackBuffers + i)});
+      }
+    }
+
+    auto primValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, numPrimsToWrite[firstActiveStream]);
+    m_builder->CreateCondBr(primValid, exportXfbOutputBlock[firstActiveStream],
+                            endExportXfbOutputBlock[firstActiveStream]);
+  }
+
+  for (unsigned i = 0; i < MaxGsStreams; ++i) {
+    if (!streamActive[i])
+      continue;
+
+    // Construct ".exportXfbOutputInStream[N]" block
+    {
+      m_builder->SetInsertPoint(exportXfbOutputBlock[i]);
+
+      Value *vertexIds[3] = {};
+
+      Value *uncompactedPrimitiveId =
+          readPerThreadDataFromLds(m_builder->getInt32Ty(), m_nggFactor.threadIdInSubgroup, LdsRegionOutPrimThreadIdMap,
+                                   SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * i);
+      Value *vertexId = uncompactedPrimitiveId;
+
+      const unsigned outVertsPerPrim = m_pipelineState->getVerticesPerPrimitive();
+      vertexIds[0] = vertexId;
+
+      if (outVertsPerPrim > 1)
+        vertexIds[1] = m_builder->CreateAdd(vertexId, m_builder->getInt32(1));
+      if (outVertsPerPrim > 2) {
+        vertexIds[2] = m_builder->CreateAdd(vertexId, m_builder->getInt32(2));
+
+        Value *primData =
+            readPerThreadDataFromLds(m_builder->getInt32Ty(), uncompactedPrimitiveId, LdsRegionOutPrimData,
+                                     SizeOfDword * Gfx9::NggMaxThreadsPerSubgroup * i);
+        Value *winding = m_builder->CreateICmpNE(primData, m_builder->getInt32(0));
+        Value *vertexId1 = m_builder->CreateSelect(winding, vertexIds[2], vertexIds[1]);
+        Value *vertexId2 = m_builder->CreateSelect(winding, vertexIds[1], vertexIds[2]);
+        vertexIds[1] = vertexId1;
+        vertexIds[2] = vertexId2;
+      }
+
+      for (unsigned j = 0; j < outVertsPerPrim; ++j) {
+        for (unsigned k = 0; k < xfbOutputExports.size(); ++k) {
+          const auto &xfbOutputExport = xfbOutputExports[k];
+          if (xfbOutputExport.locInfo.streamId != i)
+            continue; // Output not belong to this stream
+
+          auto outputValue =
+              importGsOutput(xfbOutputExport.numElements > 1
+                                 ? FixedVectorType::get(m_builder->getFloatTy(), xfbOutputExport.numElements)
+                                 : m_builder->getFloatTy(),
+                             xfbOutputExport.locInfo.loc, i, calcVertexItemOffset(i, vertexIds[j]));
+
+          if (xfbOutputExport.is16bit) {
+            // NOTE: For 16-bit transform feedbakc outputs, they are stored as 32-bit without tightly packed in LDS.
+            outputValue = m_builder->CreateBitCast(
+                outputValue, FixedVectorType::get(m_builder->getInt32Ty(), xfbOutputExport.numElements));
+            outputValue = m_builder->CreateTrunc(
+                outputValue, FixedVectorType::get(m_builder->getInt16Ty(), xfbOutputExport.numElements));
+            outputValue = m_builder->CreateBitCast(
+                outputValue, FixedVectorType::get(m_builder->getHalfTy(), xfbOutputExport.numElements));
+          }
+
+          unsigned format = 0;
+          switch (xfbOutputExport.numElements) {
+          case 1:
+            format = xfbOutputExport.is16bit ? BUF_FORMAT_16_FLOAT : BUF_FORMAT_32_FLOAT;
+            break;
+          case 2:
+            format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_FLOAT : BUF_FORMAT_32_32_FLOAT_GFX11;
+            break;
+          case 3:
+            format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_FLOAT : BUF_FORMAT_32_32_32_FLOAT_GFX11;
+            break;
+          case 4:
+            format = xfbOutputExport.is16bit ? BUF_FORMAT_16_16_16_16_FLOAT_GFX11 : BUF_FORMAT_32_32_32_32_FLOAT_GFX11;
+            break;
+          default:
+            llvm_unreachable("Unexpected element number!");
+            break;
+          }
+
+          CoherentFlag coherent = {};
+          coherent.bits.glc = true;
+          coherent.bits.slc = true;
+
+          // vertexOffset = (threadIdInSubgroup * outVertsPerPrim + vertexIndex) * xfbStride
+          Value *vertexOffset = m_builder->CreateAdd(
+              m_builder->CreateMul(m_nggFactor.threadIdInSubgroup, m_builder->getInt32(outVertsPerPrim)),
+              m_builder->getInt32(j));
+          vertexOffset = m_builder->CreateMul(vertexOffset, m_builder->getInt32(xfbStrides[xfbOutputExport.xfbBuffer]));
+          // xfbOutputOffset = vertexOffset + xfbOffset
+          Value *xfbOutputOffset = m_builder->CreateAdd(vertexOffset, m_builder->getInt32(xfbOutputExport.xfbOffset));
+
+          if (xfbOutputExport.is16bit && xfbOutputExport.numElements == 3) {
+            // NOTE: For 16vec3, HW doesn't have a corresponding buffer store instruction. We have to split it to 16vec2
+            // and 16scalar.
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store,
+                                       FixedVectorType::get(m_builder->getHalfTy(), 2),
+                                       {m_builder->CreateShuffleVector(outputValue, ArrayRef<int>{0, 1}), // vdata
+                                        streamOutBufDescs[xfbOutputExport.xfbBuffer],                     // rsrc
+                                        xfbOutputOffset,                                                  // offset
+                                        streamOutOffsets[xfbOutputExport.xfbBuffer],                      // soffset
+                                        m_builder->getInt32(BUF_FORMAT_16_16_FLOAT),                      // format
+                                        m_builder->getInt32(coherent.u32All)}); // auxiliary data
+
+            m_builder->CreateIntrinsic(
+                Intrinsic::amdgcn_raw_tbuffer_store, m_builder->getHalfTy(),
+                {m_builder->CreateExtractElement(outputValue, 2),                                  // vdata
+                 streamOutBufDescs[xfbOutputExport.xfbBuffer],                                     // rsrc
+                 m_builder->CreateAdd(xfbOutputOffset, m_builder->getInt32(2 * sizeof(uint16_t))), // offset
+                 streamOutOffsets[xfbOutputExport.xfbBuffer],                                      // soffset
+                 m_builder->getInt32(BUF_FORMAT_16_FLOAT),                                         // format
+                 m_builder->getInt32(coherent.u32All)});                                           // auxiliary data
+          } else {
+            m_builder->CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, outputValue->getType(),
+                                       {outputValue,                                  // vdata
+                                        streamOutBufDescs[xfbOutputExport.xfbBuffer], // rsrc
+                                        xfbOutputOffset,                              // offset
+                                        streamOutOffsets[xfbOutputExport.xfbBuffer],  // soffset
+                                        m_builder->getInt32(format),                  // format
+                                        m_builder->getInt32(coherent.u32All)});       // auxiliary data
+          }
+        }
+      }
+
+      m_builder->CreateBr(endExportXfbOutputBlock[i]);
+    }
+
+    // Construct ".endExportXfbOutputInStream[N]" block
+    {
+      m_builder->SetInsertPoint(endExportXfbOutputBlock[i]);
+
+      if (i != lastActiveStream) {
+        unsigned nextActiveStream = i + 1;
+        while (!streamActive[nextActiveStream]) {
+          ++nextActiveStream;
+        }
+
+        assert(nextActiveStream <= lastActiveStream);
+        auto primValid = m_builder->CreateICmpULT(m_nggFactor.threadIdInSubgroup, numPrimsToWrite[nextActiveStream]);
+        m_builder->CreateCondBr(primValid, exportXfbOutputBlock[nextActiveStream],
+                                endExportXfbOutputBlock[nextActiveStream]);
+      }
+    }
+  }
+}
+
+// =====================================================================================================================
+// Fetches transform feedback outputs by creating a fetch function cloned from ES/copy shader entry-point or just
+// mutating existing ES and running it after that. Meanwhile, we collect the transform feedback export info.
+//
+// @param module : LLVM module.
+// @param sysValueStart : Start of system value
+// @param [out] xfbOutputExports : Export info of transform feedback outputs
+Value *NggPrimShader::fetchXfbOutput(Module *module, Argument *sysValueStart,
+                                     SmallVector<XfbOutputExport, 32> &xfbOutputExports) {
+  assert(m_enableSwXfb);
+
+  //
+  // Clone ES/copy shader entry-point or just mutate existing ES entry-point to fetch transform feedback outputs
+  //
+  auto entryPoint = module->getFunction(m_hasGs ? lgcName::NggCopyShaderEntryPoint : lgcName::NggEsEntryPoint);
+  assert(entryPoint);
+
+  // We don't clone the entry-point if we are in passthrough mode without GS
+  bool dontClone = !m_hasGs && m_nggControl->passthroughMode;
+
+  // Collect all export calls for further analysis
+  SmallVector<Function *, 8> expFuncs;
+  for (auto &func : module->functions()) {
+    if (dontClone) {
+      if (func.getName().startswith(lgcName::NggXfbOutputExport))
+        expFuncs.push_back(&func);
+    } else {
+      if ((func.isIntrinsic() && func.getIntrinsicID() == Intrinsic::amdgcn_exp) ||
+          func.getName().startswith(lgcName::NggAttribExport) || func.getName().startswith(lgcName::NggXfbOutputExport))
+        expFuncs.push_back(&func);
+    }
+  }
+
+  // Clone or mutate entry-point
+  const bool hasTs = m_hasTcs || m_hasTes;
+  const unsigned xfbOutputCount =
+      m_pipelineState
+          ->getShaderResourceUsage(m_hasGs ? ShaderStageGeometry : (hasTs ? ShaderStageTessEval : ShaderStageVertex))
+          ->inOutUsage.xfbOutputExpCount;
+  assert(xfbOutputCount > 0);
+  xfbOutputExports.resize(xfbOutputCount);
+
+  // Each output is represented as a structure:
+  //   ES: {streamOutBufDesc, streamOutBufOffset, outputValue}
+  //   GS: {streamOutBufDesc, streamOutBufOffset}
+  //
+  // NOTE: For GS transform feedback, the output value must be loaded by GS output import call. Thus, we don't have to
+  // return output value. Instead, we recode the location in transform feedback export info and use it later.
+  auto xfbOutputTy =
+      m_hasGs ? StructType::get(*m_context,
+
+                                {
+                                    FixedVectorType::get(m_builder->getInt32Ty(), 4), // streamOutBufDesc
+                                    m_builder->getInt32Ty(),                          // streamOutBufOffset
+                                })
+              : StructType::get(*m_context, {
+                                                FixedVectorType::get(m_builder->getInt32Ty(), 4), // streamOutBufDesc
+                                                m_builder->getInt32Ty(),                          // streamOutBufOffset
+                                                FixedVectorType::get(m_builder->getInt32Ty(), 4), // outputValue
+                                            });
+
+  auto xfbOutputsTy = ArrayType::get(xfbOutputTy, xfbOutputCount);
+
+  Function *xfbOutputFetchFunc = entryPoint;
+  if (dontClone) {
+    processVertexAttribExport(entryPoint);
+    xfbOutputFetchFunc = addFunctionArgs(entryPoint, xfbOutputsTy, {}, {}, 0);
+
+    // Original function is no longer needed
+    assert(entryPoint->use_empty());
+    entryPoint->eraseFromParent();
+  } else {
+    auto xfbOutputFetchFuncTy = FunctionType::get(xfbOutputsTy, entryPoint->getFunctionType()->params(), false);
+    xfbOutputFetchFunc = Function::Create(xfbOutputFetchFuncTy, entryPoint->getLinkage(), "", module);
+
+    ValueToValueMapTy valueMap;
+
+    Argument *newArg = xfbOutputFetchFunc->arg_begin();
+    for (Argument &arg : entryPoint->args())
+      valueMap[&arg] = newArg++;
+
+    SmallVector<ReturnInst *, 8> retInsts;
+    CloneFunctionInto(xfbOutputFetchFunc, entryPoint, valueMap, CloneFunctionChangeType::LocalChangesOnly, retInsts);
+    xfbOutputFetchFunc->setName(m_hasGs ? lgcName::NggGsXfbOutputFetch : lgcName::NggEsXfbOutputFetch);
+  }
+
+  // Find the return block
+  BasicBlock *retBlock = nullptr;
+  for (BasicBlock &block : *xfbOutputFetchFunc) {
+    auto retInst = dyn_cast<ReturnInst>(block.getTerminator());
+    if (retInst) {
+      retInst->dropAllReferences();
+      retInst->eraseFromParent();
+
+      retBlock = &block;
+      break;
+    }
+  }
+  assert(retBlock);
+
+  auto savedInsertPos = m_builder->saveIP();
+  m_builder->SetInsertPoint(retBlock);
+
+  // Visit all export calls, removing those unnecessary and mutating the return type
+  SmallVector<CallInst *, 8> removeCalls;
+
+  Value *xfbOutputs = UndefValue::get(xfbOutputsTy);
+  unsigned outputIndex = 0;
+
+  for (auto func : expFuncs) {
+    for (auto user : func->users()) {
+      CallInst *const call = dyn_cast<CallInst>(user);
+      assert(call);
+
+      if (!dontClone) {
+        // Remove transform feedback output export calls from original ES/copy shader. No need of doing this if we
+        // don't clone the entry-point.
+        if (call->getFunction() == entryPoint && func->getName().startswith(lgcName::NggXfbOutputExport)) {
+          removeCalls.push_back(call);
+          continue;
+        }
+      }
+
+      if (call->getFunction() != xfbOutputFetchFunc)
+        continue;
+
+      assert(call->getParent() == retBlock); // Must in return block
+
+      if (func->getName().startswith(lgcName::NggXfbOutputExport)) {
+        // Lower transform feedback export calls
+        auto streamOutBufDesc = call->getArgOperand(0);
+        auto streamOutBufOffset = call->getArgOperand(1);
+        auto xfbBuffer = cast<ConstantInt>(call->getArgOperand(2))->getZExtValue();
+        auto xfbOffset = cast<ConstantInt>(call->getArgOperand(3))->getZExtValue();
+        auto outputValue = call->getArgOperand(5);
+
+        const unsigned numElements =
+            outputValue->getType()->isVectorTy() ? cast<FixedVectorType>(outputValue->getType())->getNumElements() : 1;
+        const bool is16bit = outputValue->getType()->getScalarSizeInBits() == 16;
+
+        // Those values are just for GS
+        auto streamId = InvalidValue;
+        unsigned loc = InvalidValue;
+
+        if (m_hasGs) {
+          // NOTE: For GS, the output value must be loaded by GS output import call. This is generated by copy shader.
+          CallInst *importCall = dyn_cast<CallInst>(outputValue);
+          assert(importCall && importCall->getCalledFunction()->getName().startswith(lgcName::NggGsOutputImport));
+          streamId = cast<ConstantInt>(call->getArgOperand(4))->getZExtValue();
+          assert(streamId == cast<ConstantInt>(importCall->getArgOperand(1))->getZExtValue()); // Stream ID must match
+          loc = cast<ConstantInt>(importCall->getArgOperand(0))->getZExtValue();
+        } else {
+          // If the output value is floating point, cast it to integer type
+          if (outputValue->getType()->isFPOrFPVectorTy()) {
+            if (numElements == 1) {
+              outputValue =
+                  m_builder->CreateBitCast(outputValue, is16bit ? m_builder->getInt16Ty() : m_builder->getInt32Ty());
+            } else {
+              outputValue = m_builder->CreateBitCast(
+                  outputValue,
+                  FixedVectorType::get(is16bit ? m_builder->getInt16Ty() : m_builder->getInt32Ty(), numElements));
+            }
+          }
+
+          // If the output value is 16-bit, zero-extend it to 32-bit
+          if (is16bit)
+            outputValue =
+                m_builder->CreateZExt(outputValue, FixedVectorType::get(m_builder->getInt32Ty(), numElements));
+
+          // Always pad the output value to <4 x i32>
+          if (numElements == 1) {
+            outputValue =
+                m_builder->CreateInsertElement(UndefValue::get(FixedVectorType::get(m_builder->getInt32Ty(), 4)),
+                                               outputValue, static_cast<uint64_t>(0));
+          } else if (numElements < 4) {
+            outputValue = m_builder->CreateShuffleVector(outputValue, UndefValue::get(outputValue->getType()),
+                                                         ArrayRef<int>({0U, 1U, 2U, 3U}));
+          }
+        }
+
+        // Construct the return value
+        Value *xfbOutput = UndefValue::get(xfbOutputTy);
+        xfbOutput = m_builder->CreateInsertValue(xfbOutput, streamOutBufDesc, 0);
+        xfbOutput = m_builder->CreateInsertValue(xfbOutput, streamOutBufOffset, 1);
+        if (!m_hasGs)
+          xfbOutput = m_builder->CreateInsertValue(xfbOutput, outputValue, 2); // For VS/TES, return the output value
+        xfbOutputs = m_builder->CreateInsertValue(xfbOutputs, xfbOutput, outputIndex);
+
+        // Collect export info
+        xfbOutputExports[outputIndex].xfbBuffer = xfbBuffer;
+        xfbOutputExports[outputIndex].xfbOffset = xfbOffset;
+        xfbOutputExports[outputIndex].numElements = numElements;
+        xfbOutputExports[outputIndex].is16bit = is16bit;
+        // Those values are just for GS
+        xfbOutputExports[outputIndex].locInfo.streamId = streamId;
+        xfbOutputExports[outputIndex].locInfo.loc = loc;
+
+        ++outputIndex;
+      }
+
+      removeCalls.push_back(call); // Remove export
+    }
+  }
+
+  assert(outputIndex == xfbOutputCount); // Visit all transform feedback output export calls
+  m_builder->CreateRet(xfbOutputs);
+
+  // Remove calls
+  for (auto call : removeCalls) {
+    call->dropAllReferences();
+    call->eraseFromParent();
+  }
+
+  m_builder->restoreIP(savedInsertPos);
+
+  //
+  // Run transform feedback output fetch function
+  //
+  if (m_hasGs) {
+    // Copy shader has fixed argument layout
+    Value *userData = sysValueStart + NumSpecialSgprInputs;
+    assert(userData->getType()->isVectorTy());
+
+    const auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry)->entryArgIdxs.gs;
+    auto globalTable = m_builder->CreateExtractElement(userData, static_cast<uint64_t>(0));
+    auto streamOutTable = m_builder->CreateExtractElement(userData, entryArgIdxs.streamOutData.tablePtr);
+    auto streamOutControlBuf = m_builder->CreateExtractElement(userData, entryArgIdxs.streamOutData.controlBufPtr);
+
+    return m_builder->CreateCall(xfbOutputFetchFunc,
+                                 {globalTable,                      // Global table
+                                  streamOutTable,                   // Stream-out table
+                                  streamOutControlBuf,              // Stream-out control buffer
+                                  m_nggFactor.threadIdInSubgroup}); // Vertex ID in sub-rgoup
+  }
+
+  Argument *arg = sysValueStart;
+
+  Value *offChipLdsBase = (arg + ShaderMerger::getSpecialSgprInputIndex(m_gfxIp, EsGs::OffChipLdsBase));
+  offChipLdsBase->setName("offChipLdsBase");
+
+  Value *isOffChip = UndefValue::get(m_builder->getInt32Ty()); // NOTE: This flag is unused.
+
+  arg += NumSpecialSgprInputs;
+
+  Value *userData = arg++;
+
+  Value *tessCoordX = (arg + 5);
+  Value *tessCoordY = (arg + 6);
+  Value *relPatchId = (arg + 7);
+  Value *patchId = (arg + 8);
+
+  Value *vertexId = (arg + 5);
+  Value *relVertexId = (arg + 6);
+  // NOTE: VS primitive ID for NGG is specially obtained, not simply from system VGPR.
+  Value *vsPrimitiveId = m_nggFactor.primitiveId ? m_nggFactor.primitiveId : UndefValue::get(m_builder->getInt32Ty());
+  Value *instanceId = (arg + 8);
+
+  std::vector<Value *> args;
+
+  // If we don't clone the entry-point, we are going to run the whole ES and handle vertex attribute through memory
+  // here.
+  if (dontClone) {
+    // Setup attribute ring base and vertex thread ID in sub-group as two additional arguments to export vertex
+    // attributes through memory
+    if (m_gfxIp.major >= 11 && !m_hasGs) { // For GS, vertex attribute exports are in copy shader
+      const auto attribCount =
+          m_pipelineState->getShaderResourceUsage(hasTs ? ShaderStageTessEval : ShaderStageVertex)->inOutUsage.expCount;
+      if (attribCount > 0) {
+        args.push_back(m_nggFactor.attribRingBase);
+        args.push_back(m_nggFactor.threadIdInSubgroup);
+      }
+    }
+  }
+
+  auto intfData = m_pipelineState->getShaderInterfaceData(hasTs ? ShaderStageTessEval : ShaderStageVertex);
+  const unsigned userDataCount = intfData->userDataCount;
+
+  unsigned userDataIdx = 0;
+
+  auto argBegin = xfbOutputFetchFunc->arg_begin();
+  const unsigned argCount = xfbOutputFetchFunc->arg_size();
+  (void(argCount)); // Unused
+
+  // Set up user data SGPRs
+  while (userDataIdx < userDataCount) {
+    assert(args.size() < argCount);
+
+    auto arg = (argBegin + args.size());
+    assert(arg->hasAttribute(Attribute::InReg));
+
+    auto argTy = arg->getType();
+    if (argTy->isVectorTy()) {
+      assert(cast<VectorType>(argTy)->getElementType()->isIntegerTy());
+
+      const unsigned userDataSize = cast<FixedVectorType>(argTy)->getNumElements();
+
+      std::vector<int> shuffleMask;
+      for (unsigned i = 0; i < userDataSize; ++i)
+        shuffleMask.push_back(userDataIdx + i);
+
+      args.push_back(m_builder->CreateShuffleVector(userData, userData, shuffleMask));
+      userDataIdx += userDataSize;
+    } else {
+      assert(argTy->isIntegerTy());
+      args.push_back(m_builder->CreateExtractElement(userData, userDataIdx));
+      ++userDataIdx;
+    }
+  }
+
+  if (hasTs) {
+    // Set up system value SGPRs
+    if (m_pipelineState->isTessOffChip()) {
+      args.push_back(isOffChip);
+      args.push_back(offChipLdsBase);
+    }
+
+    // Set up system value VGPRs
+    args.push_back(tessCoordX);
+    args.push_back(tessCoordY);
+    args.push_back(relPatchId);
+    args.push_back(patchId);
+  } else {
+    // Set up system value VGPRs
+    args.push_back(vertexId);
+    args.push_back(relVertexId);
+    args.push_back(vsPrimitiveId);
+    args.push_back(instanceId);
+
+    if (m_nggControl->passthroughMode) {
+      // When tessellation is not enabled, the ES is actually a fetchless VS. Then, we need to add arguments for the
+      // vertex fetches. Also set the name of each vertex fetch primitive shader argument while we're here.
+      unsigned vertexFetchCount = m_pipelineState->getPalMetadata()->getVertexFetchCount();
+      if (vertexFetchCount != 0) {
+        // The last vertexFetchCount arguments of the primitive shader and ES are the vertex fetches
+        Function *primShader = m_builder->GetInsertBlock()->getParent();
+        unsigned primArgCount = primShader->arg_size();
+        for (unsigned i = 0; i != vertexFetchCount; ++i) {
+          Argument *vertexFetch = primShader->getArg(primArgCount - vertexFetchCount + i);
+          vertexFetch->setName(
+              xfbOutputFetchFunc->getArg(argCount - vertexFetchCount + i)->getName()); // Copy argument name
+          args.push_back(vertexFetch);
+        }
+      }
+    }
+  }
+
+  assert(args.size() == argCount); // Must have visit all arguments
+
+  return m_builder->CreateCall(xfbOutputFetchFunc, args);
+}
+
+// =====================================================================================================================
+// Reads transform feedback output from LDS
+//
+// @param readDataTy : Data read from LDS
+// @param vertexId: Vertex thread ID in sub-group
+// @param outputIndex : Index of this transform feedback output
+Value *NggPrimShader::readXfbOutputFromLds(llvm::Type *readDataTy, llvm::Value *vertexId, unsigned outputIndex) {
+  assert(m_enableSwXfb); // SW-emulated stream-out must be enabled
+  assert(!m_hasGs);
+
+  const unsigned esGsRingItemSize =
+      m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage.gs.calcFactor.esGsRingItemSize;
+  auto vertexItemOffset = m_builder->CreateMul(vertexId, m_builder->getInt32(esGsRingItemSize * SizeOfDword));
+
+  if (m_nggControl->passthroughMode) {
+    const auto regionStart = m_ldsManager->getLdsRegionStart(LdsRegionXfbOutput);
+    Value *ldsOffset =
+        m_builder->CreateAdd(vertexItemOffset, m_builder->getInt32(regionStart + SizeOfVec4 * outputIndex));
+    return m_ldsManager->readValueFromLds(readDataTy, ldsOffset);
+  }
+
+  // NOTE: For NGG culling mode, transform feedback outputs are part of vertex cull info.
+  const auto regionStart = m_ldsManager->getLdsRegionStart(LdsRegionVertCullInfo);
+  Value *ldsOffset = m_builder->CreateAdd(
+      vertexItemOffset, m_builder->getInt32(regionStart + m_vertCullInfoOffsets.xfbOutputs + SizeOfVec4 * outputIndex));
+  return m_ldsManager->readValueFromLds(readDataTy, ldsOffset);
+}
+
+// =====================================================================================================================
+// Writes transform feedback output from LDS
+//
+// @param writeData : Data written to LDS
+// @param vertexId: Vertex thread ID in sub-group
+// @param outputIndex : Index of this transform feedback output
+void NggPrimShader::writeXfbOutputToLds(Value *writeData, Value *vertexId, unsigned outputIndex) {
+  assert(m_enableSwXfb); // SW-emulated stream-out must be enabled
+  assert(!m_hasGs);
+
+  const unsigned esGsRingItemSize =
+      m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage.gs.calcFactor.esGsRingItemSize;
+  auto vertexItemOffset = m_builder->CreateMul(vertexId, m_builder->getInt32(esGsRingItemSize * SizeOfDword));
+
+  if (m_nggControl->passthroughMode) {
+    const auto regionStart = m_ldsManager->getLdsRegionStart(LdsRegionXfbOutput);
+    Value *ldsOffset =
+        m_builder->CreateAdd(vertexItemOffset, m_builder->getInt32(regionStart + SizeOfVec4 * outputIndex));
+    m_ldsManager->writeValueToLds(writeData, ldsOffset);
+    return;
+  }
+
+  // NOTE: For NGG culling mode, transform feedback outputs are part of vertex cull info.
+  const auto regionStart = m_ldsManager->getLdsRegionStart(LdsRegionVertCullInfo);
+  Value *ldsOffset = m_builder->CreateAdd(
+      vertexItemOffset, m_builder->getInt32(regionStart + m_vertCullInfoOffsets.xfbOutputs + SizeOfVec4 * outputIndex));
+  m_ldsManager->writeValueToLds(writeData, ldsOffset);
+}
+#endif
+
 // =====================================================================================================================
 // Fetches the position data for the specified vertex ID.
 //
 // @param vertexId : Vertex thread ID in sub-group.
 Value *NggPrimShader::fetchVertexPositionData(Value *vertexId) {
   if (!m_hasGs) {
     // ES-only
     return readPerThreadDataFromLds(FixedVectorType::get(m_builder->getFloatTy(), 4), vertexId, LdsRegionVertPosData, 0,
                                     true);
   }
diff --git a/lgc/patch/NggPrimShader.h b/lgc/patch/NggPrimShader.h
index 6d42b8e5b..8c3d2d4a2 100644
--- a/lgc/patch/NggPrimShader.h
+++ b/lgc/patch/NggPrimShader.h
@@ -81,20 +81,26 @@ struct PrimShaderCbLayoutLookupTable {
   unsigned primitiveRestartEnable;
   unsigned primitiveRestartIndex;
   unsigned matchAllBits;
   unsigned enableConservativeRasterization;
   // Viewport controls
   PrimShaderVportCbLookupTable vportControls[Util::Abi::MaxViewports];
 };
 
 // Represents the layout structure of an item of vertex cull info (this acts as ES-GS ring item from HW's perspective)
 struct VertexCullInfo {
+#if LLPC_BUILD_GFX11
+  //
+  // Vertex transform feedback outputs
+  //
+  unsigned xfbOutputs[4];
+#endif
   //
   // Vertex cull data
   //
   unsigned cullDistanceSignMask;
   //
   // Vertex cull result
   //
   unsigned drawFlag;
   //
   // Vertex compaction info (vertex compaction only, must in the end of this structure)
@@ -110,20 +116,26 @@ struct VertexCullInfo {
       float tessCoordX;
       float tessCoordY;
       unsigned patchId;
       unsigned relPatchId;
     } tes;
   };
 };
 
 // Represents a collection of LDS offsets (in bytes) within an item of vertex cull info.
 struct VertexCullInfoOffsets {
+#if LLPC_BUILD_GFX11
+  //
+  // Vertex transform feedback outputs
+  //
+  unsigned xfbOutputs;
+#endif
   //
   // Vertex cull data
   //
   unsigned cullDistanceSignMask;
   //
   // Vertex cull result
   //
   unsigned drawFlag;
   //
   // Vertex compaction info
@@ -133,20 +145,34 @@ struct VertexCullInfoOffsets {
   unsigned vertexId;
   unsigned instanceId;
   unsigned primitiveId;
   // TES
   unsigned tessCoordX;
   unsigned tessCoordY;
   unsigned patchId;
   unsigned relPatchId;
 };
 
+#if LLPC_BUILD_GFX11
+// Represents export info of a transform feedback output
+struct XfbOutputExport {
+  unsigned xfbBuffer;   // Transform feedback buffer
+  unsigned xfbOffset;   // Transform feedback offset
+  unsigned numElements; // Number of output elements, valid range is [1,4]
+  bool is16bit;         // Whether the output is 16-bit
+  struct {
+    unsigned streamId; // Output stream ID
+    unsigned loc;      // Output location
+  } locInfo;           // Output location info in GS-VS ring (just for GS)
+};
+#endif
+
 // =====================================================================================================================
 // Represents the manager of NGG primitive shader.
 class NggPrimShader {
 public:
   NggPrimShader(PipelineState *pipelineState);
   ~NggPrimShader();
 
   static unsigned calcEsGsRingItemSize(PipelineState *pipelineState);
 
   llvm::Function *generate(llvm::Function *esEntryPoint, llvm::Function *gsEntryPoint,
@@ -239,20 +265,32 @@ private:
   llvm::Function *createCullDistanceCuller(llvm::Module *module);
 
   llvm::Function *createFetchCullingRegister(llvm::Module *module);
 
   llvm::Value *doSubgroupBallot(llvm::Value *value);
 
   llvm::Value *fetchVertexPositionData(llvm::Value *vertexId);
   llvm::Value *fetchCullDistanceSignMask(llvm::Value *vertexId);
   llvm::Value *calcVertexItemOffset(unsigned streamId, llvm::Value *vertexId);
 
+#if LLPC_BUILD_GFX11
+  void processVertexAttribExport(llvm::Function *&targetFunc);
+
+  void processXfbOutputExport(llvm::Module *module, llvm::Argument *sysValueStart);
+  void processGsXfbOutputExport(llvm::Module *module, llvm::Argument *sysValueStart);
+  llvm::Value *fetchXfbOutput(llvm::Module *module, llvm::Argument *sysValueStart,
+                              llvm::SmallVector<XfbOutputExport, 32> &xfbOutputExports);
+
+  llvm::Value *readXfbOutputFromLds(llvm::Type *readDataTy, llvm::Value *vertexId, unsigned outputIndex);
+  void writeXfbOutputToLds(llvm::Value *writeData, llvm::Value *vertexId, unsigned outputIndex);
+#endif
+
   // Checks if NGG culling operations are enabled
   bool enableCulling() const {
     return m_nggControl->enableBackfaceCulling || m_nggControl->enableFrustumCulling ||
            m_nggControl->enableBoxFilterCulling || m_nggControl->enableSphereCulling ||
            m_nggControl->enableSmallPrimFilter || m_nggControl->enableCullDistanceCulling;
   }
 
   llvm::BasicBlock *createBlock(llvm::Function *parent, const llvm::Twine &blockName = "");
 
   llvm::Value *CreateUBfe(llvm::Value *value, unsigned offset, unsigned count);
@@ -271,45 +309,55 @@ private:
   struct {
     llvm::Value *vertCountInSubgroup; // Number of vertices in sub-group
     llvm::Value *primCountInSubgroup; // Number of primitives in sub-group
     llvm::Value *vertCountInWave;     // Number of vertices in wave
     llvm::Value *primCountInWave;     // Number of primitives in wave
 
     llvm::Value *threadIdInWave;     // Thread ID in wave
     llvm::Value *threadIdInSubgroup; // Thread ID in sub-group
 
     llvm::Value *waveIdInSubgroup; // Wave ID in sub-group
+#if LLPC_BUILD_GFX11
+    llvm::Value *orderedWaveId; // Ordered wave ID
+#endif
 
     llvm::Value *primitiveId;   // Primitive ID (for VS)
     llvm::Value *vertCompacted; // Whether vertex compaction is performed (for culling mode)
 
     // System values (SGPRs)
+#if LLPC_BUILD_GFX11
+    llvm::Value *attribRingBase; // Attribute ring base for this sub-group
+#endif
     llvm::Value *primShaderTableAddrLow;  // Primitive shader table address low
     llvm::Value *primShaderTableAddrHigh; // Primitive shader table address high
 
     // System values (VGPRs)
     llvm::Value *primData; // Primitive connectivity data (only for non-GS NGG pass-through mode)
 
     llvm::Value *esGsOffset0; // ES-GS offset of vertex0
     llvm::Value *esGsOffset1; // ES-GS offset of vertex1
     llvm::Value *esGsOffset2; // ES-GS offset of vertex2
     llvm::Value *esGsOffset3; // ES-GS offset of vertex3
     llvm::Value *esGsOffset4; // ES-GS offset of vertex4
     llvm::Value *esGsOffset5; // ES-GS offset of vertex5
 
   } m_nggFactor;
 
   bool m_hasVs;  // Whether the pipeline has vertex shader
   bool m_hasTcs; // Whether the pipeline has tessellation control shader
   bool m_hasTes; // Whether the pipeline has tessellation evaluation shader
   bool m_hasGs;  // Whether the pipeline has geometry shader
 
+#if LLPC_BUILD_GFX11
+  bool m_enableSwXfb; // Whether SW-emulated stream-out is enabled (GFX11+)
+#endif
+
   bool m_constPositionZ; // Whether the Z channel of vertex position data is constant
 
   // Base offsets (in dwords) of GS output vertex streams in GS-VS ring
   unsigned m_gsStreamBases[MaxGsStreams];
 
   PrimShaderCbLayoutLookupTable m_cbLayoutTable; // Layout lookup table of primitive shader constant buffer
   VertexCullInfoOffsets m_vertCullInfoOffsets;   // A collection of offsets within an item of vertex cull info
 
   std::unique_ptr<llvm::IRBuilder<>> m_builder; // LLVM IR builder
 };
diff --git a/lgc/patch/PassRegistry.inc b/lgc/patch/PassRegistry.inc
index 4affe32b4..039c607b4 100644
--- a/lgc/patch/PassRegistry.inc
+++ b/lgc/patch/PassRegistry.inc
@@ -22,51 +22,64 @@
  *  SOFTWARE.
  *
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  PassRegistry.inc
  * @brief LLPC header file: used as the registry of LLPC patching passes
  ***********************************************************************************************************************
  */
 
+#ifndef LLPC_PASS
+#define LLPC_PASS(name, class)
+#endif
 #ifndef LLPC_LOOP_PASS
 #define LLPC_LOOP_PASS LLPC_PASS
 #endif
 #ifndef LLPC_FUNCTION_PASS
 #define LLPC_FUNCTION_PASS LLPC_PASS
 #endif
 #ifndef LLPC_MODULE_PASS
 #define LLPC_MODULE_PASS LLPC_PASS
 #endif
 #ifndef LLPC_MODULE_PASS_WITH_PARSER
 #define LLPC_MODULE_PASS_WITH_PARSER LLPC_MODULE_PASS
 #endif
 
+#ifndef LLPC_MODULE_ANALYSIS
+#define LLPC_MODULE_ANALYSIS(name, class)
+#endif
+
 LLPC_MODULE_PASS_WITH_PARSER("lgc-builder-replayer", BuilderReplayer)
 
+LLPC_MODULE_ANALYSIS("lgc-pipeline-state", PipelineStateWrapper)
+
 LLPC_MODULE_PASS("lgc-patch-resource-collect", PatchResourceCollect)
 LLPC_MODULE_PASS("lgc-patch-initialize-workgroup-memory", PatchInitializeWorkgroupMemory)
 LLPC_MODULE_PASS("lgc-patch-image-derivatives", PatchImageDerivatives)
 LLPC_MODULE_PASS("lgc-patch-in-out-import-export", PatchInOutImportExport)
 LLPC_FUNCTION_PASS("lgc-patch-invariant-loads", PatchInvariantLoads)
 LLPC_MODULE_PASS("lgc-patch-setup-target-features", PatchSetupTargetFeatures)
 LLPC_MODULE_PASS("lgc-patch-copy-shader", PatchCopyShader)
 LLPC_MODULE_PASS("lgc-patch-prepare-pipeline-abi", PatchPreparePipelineAbi)
 LLPC_FUNCTION_PASS("lgc-patch-read-first-lane", PatchReadFirstLane)
 LLPC_MODULE_PASS("lgc-patch-llvm-ir-inclusion", PatchLlvmIrInclusion)
 LLPC_MODULE_PASS("lgc-patch-wave-size-adjust", PatchWaveSizeAdjust)
 LLPC_FUNCTION_PASS("lgc-patch-peephole-opt", PatchPeepholeOpt)
 LLPC_MODULE_PASS("lgc-patch-entry-point-mutate", PatchEntryPointMutate)
 LLPC_MODULE_PASS("lgc-patch-check-shader-cache", PatchCheckShaderCache)
 LLPC_LOOP_PASS("lgc-patch-loop-metadata", PatchLoopMetadata)
 LLPC_FUNCTION_PASS("lgc-patch-buffer-op", PatchBufferOp)
 LLPC_MODULE_PASS("lgc-patch-workarounds", PatchWorkarounds)
 LLPC_FUNCTION_PASS("lgc-patch-load-scalarizer", PatchLoadScalarizer)
 LLPC_MODULE_PASS("lgc-patch-null-frag-shader", PatchNullFragShader)
+#if LLPC_BUILD_GFX11
+LLPC_MODULE_PASS("lgc-patch-image-op-collect", PatchImageOpCollect)
+#endif
 LLPC_MODULE_PASS("lgc-vertex-fetch", LowerVertexFetch)
 
 #undef LLPC_PASS
 #undef LLPC_LOOP_PASS
 #undef LLPC_FUNCTION_PASS
 #undef LLPC_MODULE_PASS
 #undef LLPC_MODULE_PASS_WITH_PARSER
+#undef LLPC_MODULE_ANALYSIS
diff --git a/lgc/patch/Patch.cpp b/lgc/patch/Patch.cpp
index 97fa1132c..961a453c4 100644
--- a/lgc/patch/Patch.cpp
+++ b/lgc/patch/Patch.cpp
@@ -53,20 +53,26 @@
 #include "lgc/patch/PatchSetupTargetFeatures.h"
 #include "lgc/patch/PatchWaveSizeAdjust.h"
 #include "lgc/patch/PatchWorkarounds.h"
 #include "lgc/patch/VertexFetch.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "lgc/util/Debug.h"
 #include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Passes/PassBuilder.h"
 #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #include "llvm/Transforms/IPO/ConstantMerge.h"
 #include "llvm/Transforms/IPO/ForceFunctionAttrs.h"
 #include "llvm/Transforms/IPO/GlobalDCE.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
 #include "llvm/Transforms/IPO/SCCP.h"
 #include "llvm/Transforms/InstCombine/InstCombine.h"
@@ -157,25 +163,37 @@ void Patch::addPasses(PipelineState *pipelineState, lgc::PassManager &passMgr, T
     LgcContext::createAndAddStartStopTimer(passMgr, optTimer, true);
   }
 
   addOptimizationPasses(passMgr, optLevel);
 
   if (patchTimer) {
     LgcContext::createAndAddStartStopTimer(passMgr, optTimer, false);
     LgcContext::createAndAddStartStopTimer(passMgr, patchTimer, true);
   }
 
+#if LLPC_BUILD_GFX11
+  // Collect image operations
+  passMgr.addPass(PatchImageOpCollect());
+#endif
+
   // Second part of lowering to "AMDGCN-style"
   passMgr.addPass(PatchPreparePipelineAbi());
 
+#if LLPC_BUILD_GFX11
+  const bool canUseNgg = pipelineState->isGraphics() &&
+                         ((pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
+                           (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0) ||
+                          pipelineState->getTargetInfo().getGfxIpVersion().major >= 11); // Must enable NGG on GFX11+
+#else
   const bool canUseNgg = pipelineState->isGraphics() && pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
                          (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0;
+#endif
   if (canUseNgg) {
     if (patchTimer) {
       LgcContext::createAndAddStartStopTimer(passMgr, patchTimer, false);
       LgcContext::createAndAddStartStopTimer(passMgr, optTimer, true);
     }
 
     // Extra optimizations after NGG primitive shader creation
     passMgr.addPass(AlwaysInlinerPass());
     passMgr.addPass(GlobalDCEPass());
     FunctionPassManager fpm;
@@ -220,34 +238,45 @@ void Patch::addPasses(PipelineState *pipelineState, lgc::PassManager &passMgr, T
                                     "// LLPC pipeline patching results\n"));
   }
 }
 
 // =====================================================================================================================
 // Register all the patching passes into the given pass manager
 //
 // @param [in/out] passMgr : Pass manager
 void Patch::registerPasses(lgc::PassManager &passMgr) {
 #define LLPC_PASS(NAME, CLASS) passMgr.registerPass(NAME, CLASS::name());
+#define LLPC_MODULE_ANALYSIS(NAME, CLASS) passMgr.registerPass(NAME, CLASS::name());
 #include "PassRegistry.inc"
 }
 
 // =====================================================================================================================
 // Register all the patching passes into the given pass manager
 //
 // @param [in/out] passMgr : Pass manager
 void Patch::registerPasses(PassBuilder &passBuilder) {
 #define HANDLE_PASS(NAME, CLASS)                                                                                       \
   if (innerPipeline.empty() && name == NAME) {                                                                         \
     passMgr.addPass(CLASS());                                                                                          \
     return true;                                                                                                       \
   }
 
+#define HANDLE_ANALYSIS(NAME, CLASS, IRUNIT)                                                                           \
+  if (innerPipeline.empty() && name == "require<" NAME ">") {                                                          \
+    passMgr.addPass(RequireAnalysisPass<CLASS, IRUNIT>());                                                             \
+    return true;                                                                                                       \
+  }                                                                                                                    \
+  if (innerPipeline.empty() && name == "invalidate<" NAME ">") {                                                       \
+    passMgr.addPass(InvalidateAnalysisPass<CLASS>());                                                                  \
+    return true;                                                                                                       \
+  }
+
   auto checkNameWithParams = [](StringRef name, StringRef passName, StringRef &params) -> bool {
     params = name;
     if (!params.consume_front(passName))
       return false;
     if (params.empty())
       return true;
     if (!params.consume_front("<"))
       return false;
     if (!params.consume_back(">"))
       return false;
@@ -257,20 +286,21 @@ void Patch::registerPasses(PassBuilder &passBuilder) {
 #define HANDLE_PASS_WITH_PARSER(NAME, CLASS)                                                                           \
   if (innerPipeline.empty() && checkNameWithParams(name, NAME, params))                                                \
     return CLASS::parsePass(params, passMgr);
 
   passBuilder.registerPipelineParsingCallback(
       [=](StringRef name, ModulePassManager &passMgr, ArrayRef<PassBuilder::PipelineElement> innerPipeline) {
         StringRef params;
 #define LLPC_PASS(NAME, CLASS) /* */
 #define LLPC_MODULE_PASS HANDLE_PASS
 #define LLPC_MODULE_PASS_WITH_PARSER HANDLE_PASS_WITH_PARSER
+#define LLPC_MODULE_ANALYSIS(NAME, CLASS) HANDLE_ANALYSIS(NAME, CLASS, Module)
 #include "PassRegistry.inc"
 
         return false;
       });
 
   passBuilder.registerPipelineParsingCallback(
       [=](StringRef name, FunctionPassManager &passMgr, ArrayRef<PassBuilder::PipelineElement> innerPipeline) {
         StringRef params;
         (void)params;
 #define LLPC_PASS(NAME, CLASS) /* */
@@ -387,25 +417,37 @@ void LegacyPatch::addPasses(PipelineState *pipelineState, legacy::PassManager &p
   // Stop timer for optimization passes and restart timer for patching passes.
   if (patchTimer) {
     passMgr.add(LgcContext::createStartStopTimer(optTimer, false));
     passMgr.add(LgcContext::createStartStopTimer(patchTimer, true));
   }
 
   // Patch buffer operations (must be after optimizations)
   passMgr.add(createLegacyPatchBufferOp());
   passMgr.add(createInstructionCombiningPass(2));
 
+#if LLPC_BUILD_GFX11
+  // Collect image operations
+  passMgr.add(createLegacyPatchImageOpCollect());
+#endif
+
   // Fully prepare the pipeline ABI (must be after optimizations)
   passMgr.add(createLegacyPatchPreparePipelineAbi());
 
+#if LLPC_BUILD_GFX11
+  const bool canUseNgg = pipelineState->isGraphics() &&
+                         ((pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
+                           (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0) ||
+                          pipelineState->getTargetInfo().getGfxIpVersion().major >= 11); // Must enable NGG on GFX11+
+#else
   const bool canUseNgg = pipelineState->isGraphics() && pipelineState->getTargetInfo().getGfxIpVersion().major == 10 &&
                          (pipelineState->getOptions().nggFlags & NggFlagDisable) == 0;
+#endif
   if (canUseNgg) {
     // Stop timer for patching passes and restart timer for optimization passes.
     if (patchTimer) {
       passMgr.add(LgcContext::createStartStopTimer(patchTimer, false));
       passMgr.add(LgcContext::createStartStopTimer(optTimer, true));
     }
 
     // Extra optimizations after NGG primitive shader creation
     passMgr.add(createAlwaysInlinerLegacyPass());
     passMgr.add(createGlobalDCEPass());
@@ -451,37 +493,39 @@ void LegacyPatch::addPasses(PipelineState *pipelineState, legacy::PassManager &p
 // @param [in/out] passMgr : Pass manager to add passes to
 // @param optLevel : The optimization level uses to adjust the aggressiveness of
 //                   passes and which passes to add.
 void Patch::addOptimizationPasses(lgc::PassManager &passMgr, CodeGenOpt::Level optLevel) {
   LLPC_OUTS("PassManager optimization level = " << optLevel << "\n");
 
   passMgr.addPass(ForceFunctionAttrsPass());
   FunctionPassManager fpm;
   fpm.addPass(InstCombinePass(1));
   fpm.addPass(SimplifyCFGPass());
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
+  // Old version of the code
   fpm.addPass(SROAPass());
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  fpm.addPass(SROAPass(SROAOptions::ModifyCFG));
+#endif
   fpm.addPass(EarlyCSEPass(true));
   fpm.addPass(SpeculativeExecutionPass(/* OnlyIfDivergentTarget = */ true));
   fpm.addPass(CorrelatedValuePropagationPass());
   fpm.addPass(SimplifyCFGPass());
   fpm.addPass(AggressiveInstCombinePass());
   fpm.addPass(InstCombinePass(1));
   fpm.addPass(PatchPeepholeOpt());
   fpm.addPass(SimplifyCFGPass());
   fpm.addPass(ReassociatePass());
   LoopPassManager lpm;
   lpm.addPass(LoopRotatePass());
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 418547
-  lpm.addPass(LICMPass());
-#else
   lpm.addPass(LICMPass(LICMOptions()));
-#endif
   fpm.addPass(createFunctionToLoopPassAdaptor(std::move(lpm), true));
   fpm.addPass(SimplifyCFGPass());
   fpm.addPass(InstCombinePass(1));
   LoopPassManager lpm2;
   lpm2.addPass(IndVarSimplifyPass());
   lpm2.addPass(LoopIdiomRecognizePass());
   lpm2.addPass(LoopDeletionPass());
   fpm.addPass(createFunctionToLoopPassAdaptor(std::move(lpm2), true));
   fpm.addPass(LoopUnrollPass(
       LoopUnrollOptions(optLevel).setPeeling(true).setRuntime(false).setUpperBound(false).setPartial(false)));
@@ -517,26 +561,31 @@ void Patch::addOptimizationPasses(lgc::PassManager &passMgr, CodeGenOpt::Level o
 //
 // @param [in/out] passMgr : Pass manager to add passes to
 // @param optLevel : The optimization level uses to adjust the aggressiveness of
 //                   passes and which passes to add.
 void LegacyPatch::addOptimizationPasses(legacy::PassManager &passMgr, CodeGenOpt::Level optLevel) {
   LLPC_OUTS("PassManager optimization level = " << optLevel << "\n");
 
   passMgr.add(createForceFunctionAttrsLegacyPass());
   passMgr.add(createInstructionCombiningPass(1));
   passMgr.add(createCFGSimplificationPass());
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
+  // Old version of the code
   passMgr.add(createSROAPass());
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  passMgr.add(createSROAPass(false));
+#endif
   passMgr.add(createEarlyCSEPass(true));
   passMgr.add(createSpeculativeExecutionIfHasBranchDivergencePass());
   passMgr.add(createCorrelatedValuePropagationPass());
   passMgr.add(createCFGSimplificationPass());
-  passMgr.add(createAggressiveInstCombinerPass());
   passMgr.add(createInstructionCombiningPass(1));
   passMgr.add(createLegacyPatchPeepholeOpt());
   passMgr.add(createCFGSimplificationPass());
   passMgr.add(createReassociatePass());
   passMgr.add(createLoopRotatePass());
   passMgr.add(createLICMPass());
   passMgr.add(createCFGSimplificationPass());
   passMgr.add(createInstructionCombiningPass(1));
   passMgr.add(createIndVarSimplifyPass());
   passMgr.add(createLoopIdiomPass());
diff --git a/lgc/patch/PatchBufferOp.cpp b/lgc/patch/PatchBufferOp.cpp
index 049beed69..8fac26363 100644
--- a/lgc/patch/PatchBufferOp.cpp
+++ b/lgc/patch/PatchBufferOp.cpp
@@ -113,21 +113,23 @@ PreservedAnalyses PatchBufferOp::run(Function &function, FunctionAnalysisManager
 // @param pipelineState : Pipeline state
 // @param isDivergent : Function returning true if the given value is divergent
 // @returns : True if the module was modified by the transformation and false otherwise
 bool PatchBufferOp::runImpl(Function &function, PipelineState *pipelineState,
                             std::function<bool(const llvm::Value &)> isDivergent) {
   LLVM_DEBUG(dbgs() << "Run the pass Patch-Buffer-Op\n");
 
   m_pipelineState = pipelineState;
   m_isDivergent = std::move(isDivergent);
   m_context = &function.getContext();
-  m_builder = std::make_unique<IRBuilder<>>(*m_context);
+
+  IRBuilder<> builder(*m_context);
+  m_builder = &builder;
 
   // Invoke visitation of the target instructions.
 
   // If the function is not a valid shader stage, bail.
   if (lgc::getShaderStage(&function) == ShaderStageInvalid) {
     return false;
   }
 
   // To replace the fat pointer uses correctly we need to walk the basic blocks strictly in domination order to avoid
   // visiting a use of a fat pointer before it was actually defined.
@@ -172,28 +174,28 @@ bool PatchBufferOp::runImpl(Function &function, PipelineState *pipelineState,
 // Visits "cmpxchg" instruction.
 //
 // @param atomicCmpXchgInst : The instruction
 void PatchBufferOp::visitAtomicCmpXchgInst(AtomicCmpXchgInst &atomicCmpXchgInst) {
   // If the type we are doing an atomic operation on is not a fat pointer, bail.
   if (atomicCmpXchgInst.getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&atomicCmpXchgInst);
 
-  Value *const pointer = getPointerOperandAsInst(atomicCmpXchgInst.getPointerOperand());
+  Replacement pointer = getRemappedValue(atomicCmpXchgInst.getPointerOperand());
 
   Type *const storeType = atomicCmpXchgInst.getNewValOperand()->getType();
 
   const bool isSlc = atomicCmpXchgInst.getMetadata(LLVMContext::MD_nontemporal);
 
-  Value *const bufferDesc = m_replacementMap[pointer].first;
-  Value *const baseIndex = m_builder->CreatePtrToInt(m_replacementMap[pointer].second, m_builder->getInt32Ty());
+  Value *const bufferDesc = pointer.first;
+  Value *const baseIndex = m_builder->CreatePtrToInt(pointer.second, m_builder->getInt32Ty());
   copyMetadata(baseIndex, &atomicCmpXchgInst);
 
   // If our buffer descriptor is divergent or is not a 32-bit integer, need to handle it differently.
   if (m_divergenceSet.count(bufferDesc) > 0 || !storeType->isIntegerTy(32)) {
     Value *const baseAddr = getBaseAddressFromBufferDesc(bufferDesc);
 
     // The 2nd element in the buffer descriptor is the byte bound, we do this to support robust buffer access.
     Value *const bound = m_builder->CreateExtractElement(bufferDesc, 2);
     Value *const inBound = m_builder->CreateICmpULT(baseIndex, bound);
     Value *const newBaseIndex = m_builder->CreateSelect(inBound, baseIndex, m_builder->getInt32(0));
@@ -274,28 +276,28 @@ void PatchBufferOp::visitAtomicCmpXchgInst(AtomicCmpXchgInst &atomicCmpXchgInst)
 }
 
 // =====================================================================================================================
 // Visits "atomicrmw" instruction.
 //
 // @param atomicRmwInst : The instruction
 void PatchBufferOp::visitAtomicRMWInst(AtomicRMWInst &atomicRmwInst) {
   if (atomicRmwInst.getPointerAddressSpace() == ADDR_SPACE_BUFFER_FAT_POINTER) {
     m_builder->SetInsertPoint(&atomicRmwInst);
 
-    Value *const pointer = getPointerOperandAsInst(atomicRmwInst.getPointerOperand());
+    Replacement pointer = getRemappedValue(atomicRmwInst.getPointerOperand());
 
     Type *const storeType = atomicRmwInst.getValOperand()->getType();
 
     const bool isSlc = atomicRmwInst.getMetadata(LLVMContext::MD_nontemporal);
 
-    Value *const bufferDesc = m_replacementMap[pointer].first;
-    Value *const baseIndex = m_builder->CreatePtrToInt(m_replacementMap[pointer].second, m_builder->getInt32Ty());
+    Value *const bufferDesc = pointer.first;
+    Value *const baseIndex = m_builder->CreatePtrToInt(pointer.second, m_builder->getInt32Ty());
     copyMetadata(baseIndex, &atomicRmwInst);
 
     // If our buffer descriptor is divergent, need to handle it differently.
     if (m_divergenceSet.count(bufferDesc) > 0) {
       Value *const baseAddr = getBaseAddressFromBufferDesc(bufferDesc);
 
       // The 2nd element in the buffer descriptor is the byte bound, we do this to support robust buffer access.
       Value *const bound = m_builder->CreateExtractElement(bufferDesc, 2);
       Value *const inBound = m_builder->CreateICmpULT(baseIndex, bound);
       Value *const newBaseIndex = m_builder->CreateSelect(inBound, baseIndex, m_builder->getInt32(0));
@@ -395,21 +397,21 @@ void PatchBufferOp::visitAtomicRMWInst(AtomicRMWInst &atomicRmwInst) {
 
       // Record the atomic instruction so we remember to delete it later.
       m_replacementMap[&atomicRmwInst] = std::make_pair(nullptr, nullptr);
 
       atomicRmwInst.replaceAllUsesWith(atomicCall);
     }
   } else if (atomicRmwInst.getPointerAddressSpace() == ADDR_SPACE_GLOBAL) {
     AtomicRMWInst::BinOp op = atomicRmwInst.getOperation();
     Type *const storeType = atomicRmwInst.getValOperand()->getType();
     if (op == AtomicRMWInst::FMin || op == AtomicRMWInst::FMax || op == AtomicRMWInst::FAdd) {
-      Value *const pointer = getPointerOperandAsInst(atomicRmwInst.getPointerOperand());
+      Value *const pointer = atomicRmwInst.getPointerOperand();
       m_builder->SetInsertPoint(&atomicRmwInst);
       Intrinsic::ID intrinsic = Intrinsic::not_intrinsic;
       switch (atomicRmwInst.getOperation()) {
       case AtomicRMWInst::FMin:
         intrinsic = Intrinsic::amdgcn_global_atomic_fmin;
         break;
       case AtomicRMWInst::FMax:
         intrinsic = Intrinsic::amdgcn_global_atomic_fmax;
         break;
       case AtomicRMWInst::FAdd:
@@ -424,21 +426,21 @@ void PatchBufferOp::visitAtomicRMWInst(AtomicRMWInst &atomicRmwInst) {
       copyMetadata(atomicCall, &atomicRmwInst);
       // Record the atomic instruction so we remember to delete it later.
       m_replacementMap[&atomicRmwInst] = std::make_pair(nullptr, nullptr);
 
       atomicRmwInst.replaceAllUsesWith(atomicCall);
     }
   } else if (atomicRmwInst.getPointerAddressSpace() == ADDR_SPACE_LOCAL) {
     AtomicRMWInst::BinOp op = atomicRmwInst.getOperation();
     Type *const storeType = atomicRmwInst.getValOperand()->getType();
     if (op == AtomicRMWInst::FMin || op == AtomicRMWInst::FMax || op == AtomicRMWInst::FAdd) {
-      Value *const pointer = getPointerOperandAsInst(atomicRmwInst.getPointerOperand());
+      Value *const pointer = atomicRmwInst.getPointerOperand();
       m_builder->SetInsertPoint(&atomicRmwInst);
       Intrinsic::ID intrinsic = Intrinsic::not_intrinsic;
       switch (atomicRmwInst.getOperation()) {
       case AtomicRMWInst::FMin:
         intrinsic = Intrinsic::amdgcn_ds_fmin;
         break;
       case AtomicRMWInst::FMax:
         intrinsic = Intrinsic::amdgcn_ds_fmax;
         break;
       case AtomicRMWInst::FAdd:
@@ -472,28 +474,27 @@ void PatchBufferOp::visitBitCastInst(BitCastInst &bitCastInst) {
   // If the type is not a pointer type, bail.
   if (!destType->isPointerTy())
     return;
 
   // If the pointer is not a fat pointer, bail.
   if (destType->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&bitCastInst);
 
-  Value *const pointer = getPointerOperandAsInst(bitCastInst.getOperand(0));
+  Replacement pointer = getRemappedValue(bitCastInst.getOperand(0));
 
-  Value *const newBitCast =
-      m_builder->CreateBitCast(m_replacementMap[pointer].second, getRemappedType(bitCastInst.getDestTy()));
+  Value *const newBitCast = m_builder->CreateBitCast(pointer.second, getRemappedType(bitCastInst.getDestTy()));
 
-  copyMetadata(newBitCast, pointer);
+  copyMetadata(newBitCast, &bitCastInst);
 
-  m_replacementMap[&bitCastInst] = std::make_pair(m_replacementMap[pointer].first, newBitCast);
+  m_replacementMap[&bitCastInst] = std::make_pair(pointer.first, newBitCast);
 }
 
 // =====================================================================================================================
 // Visits "call" instruction.
 //
 // @param callInst : The instruction
 void PatchBufferOp::visitCallInst(CallInst &callInst) {
   Function *const calledFunc = callInst.getCalledFunction();
 
   // If the call does not have a called function, bail.
@@ -513,53 +514,53 @@ void PatchBufferOp::visitCallInst(CallInst &callInst) {
     m_replacementMap[&callInst] = std::make_pair(callInst.getArgOperand(0), nullPointer);
 
     // Check for any invariant starts that use the pointer.
     if (removeUsersForInvariantStarts(&callInst))
       m_invariantSet.insert(callInst.getArgOperand(0));
 
     // If the incoming index to the fat pointer launder was divergent, remember it.
     if (m_isDivergent(*callInst.getArgOperand(0)))
       m_divergenceSet.insert(callInst.getArgOperand(0));
   } else if (callName.startswith(lgcName::LateBufferLength)) {
-    Value *const pointer = getPointerOperandAsInst(callInst.getArgOperand(0));
+    Replacement pointer = getRemappedValue(callInst.getArgOperand(0));
 
     // Extract element 2 which is the NUM_RECORDS field from the buffer descriptor.
-    Value *const bufferDesc = m_replacementMap[pointer].first;
+    Value *const bufferDesc = pointer.first;
     Value *numRecords = m_builder->CreateExtractElement(bufferDesc, 2);
     Value *offset = callInst.getArgOperand(1);
 
     // If null descriptors are allowed, we must guarantee a 0 result for a null buffer descriptor.
     //
     // What we implement here is in fact more robust: ensure that the subtraction of the offset is clamped to 0.
     // The backend should be able to achieve this with a single additional ALU instruction (e.g. s_max_u32).
     if (m_pipelineState->getOptions().allowNullDescriptor) {
       Value *const underflow = m_builder->CreateICmpUGT(offset, numRecords);
       numRecords = m_builder->CreateSelect(underflow, offset, numRecords);
     }
 
     numRecords = m_builder->CreateSub(numRecords, offset);
 
     // Record the call instruction so we remember to delete it later.
     m_replacementMap[&callInst] = std::make_pair(nullptr, nullptr);
 
     callInst.replaceAllUsesWith(numRecords);
   } else if (callName.startswith(lgcName::LateBufferPtrDiff)) {
     Type *const ty = callInst.getArgOperand(0)->getType();
-    Value *const lhs = getPointerOperandAsInst(callInst.getArgOperand(1));
-    Value *const rhs = getPointerOperandAsInst(callInst.getArgOperand(2));
+    Value *const lhs = callInst.getArgOperand(1);
+    Value *const rhs = callInst.getArgOperand(2);
 
     assert(lhs->getType()->isPointerTy() && lhs->getType()->getPointerAddressSpace() == ADDR_SPACE_BUFFER_FAT_POINTER &&
            rhs->getType()->isPointerTy() && rhs->getType()->getPointerAddressSpace() == ADDR_SPACE_BUFFER_FAT_POINTER &&
            "Argument to BufferPtrDiff is not a buffer fat pointer");
 
-    Value *const lhsPtrToInt = m_builder->CreatePtrToInt(m_replacementMap[lhs].second, m_builder->getInt64Ty());
-    Value *const rhsPtrToInt = m_builder->CreatePtrToInt(m_replacementMap[rhs].second, m_builder->getInt64Ty());
+    Value *const lhsPtrToInt = m_builder->CreatePtrToInt(getRemappedValue(lhs).second, m_builder->getInt64Ty());
+    Value *const rhsPtrToInt = m_builder->CreatePtrToInt(getRemappedValue(rhs).second, m_builder->getInt64Ty());
 
     copyMetadata(lhsPtrToInt, lhs);
     copyMetadata(rhsPtrToInt, rhs);
 
     Value *const difference = m_builder->CreateSub(lhsPtrToInt, rhsPtrToInt);
     Constant *const size = ConstantExpr::getSizeOf(ty);
     Value *const elementDifference = m_builder->CreateExactSDiv(difference, size);
 
     // Record the call instruction so we remember to delete it later.
     m_replacementMap[&callInst] = std::make_pair(nullptr, nullptr);
@@ -579,57 +580,57 @@ void PatchBufferOp::visitExtractElementInst(ExtractElementInst &extractElementIn
   // If the extract element is not extracting a pointer, bail.
   if (!pointerType)
     return;
 
   // If the type we are GEPing into is not a fat pointer, bail.
   if (pointerType->getAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&extractElementInst);
 
-  Value *const pointer = getPointerOperandAsInst(extractElementInst.getVectorOperand());
+  Replacement pointer = getRemappedValue(extractElementInst.getVectorOperand());
   Value *const index = extractElementInst.getIndexOperand();
 
-  Value *const pointerElem = m_builder->CreateExtractElement(m_replacementMap[pointer].second, index);
-  copyMetadata(pointerElem, pointer);
+  Value *const pointerElem = m_builder->CreateExtractElement(pointer.second, index);
+  copyMetadata(pointerElem, &extractElementInst);
 
-  m_replacementMap[&extractElementInst] = std::make_pair(m_replacementMap[pointer].first, pointerElem);
+  m_replacementMap[&extractElementInst] = std::make_pair(pointer.first, pointerElem);
 }
 
 // =====================================================================================================================
 // Visits "getelementptr" instruction.
 //
 // @param getElemPtrInst : The instruction
 void PatchBufferOp::visitGetElementPtrInst(GetElementPtrInst &getElemPtrInst) {
   // If the type we are GEPing into is not a fat pointer, bail.
   if (getElemPtrInst.getAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&getElemPtrInst);
 
-  Value *const pointer = getPointerOperandAsInst(getElemPtrInst.getPointerOperand());
+  Replacement pointer = getRemappedValue(getElemPtrInst.getPointerOperand());
 
   SmallVector<Value *, 8> indices(getElemPtrInst.idx_begin(), getElemPtrInst.idx_end());
 
   Value *newGetElemPtr = nullptr;
-  auto getElemPtrPtr = m_replacementMap[pointer].second;
+  auto getElemPtrPtr = pointer.second;
   auto getElemPtrEltTy = getElemPtrInst.getSourceElementType();
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(getElemPtrPtr->getType()->getScalarType(), getElemPtrEltTy));
 
   if (getElemPtrInst.isInBounds())
     newGetElemPtr = m_builder->CreateInBoundsGEP(getElemPtrEltTy, getElemPtrPtr, indices);
   else
     newGetElemPtr = m_builder->CreateGEP(getElemPtrEltTy, getElemPtrPtr, indices);
 
-  copyMetadata(newGetElemPtr, pointer);
+  copyMetadata(newGetElemPtr, &getElemPtrInst);
 
-  m_replacementMap[&getElemPtrInst] = std::make_pair(m_replacementMap[pointer].first, newGetElemPtr);
+  m_replacementMap[&getElemPtrInst] = std::make_pair(pointer.first, newGetElemPtr);
 }
 
 // =====================================================================================================================
 // Visits "insertelement" instruction.
 //
 // @param insertElementInst : The instruction
 void PatchBufferOp::visitInsertElementInst(InsertElementInst &insertElementInst) {
   Type *const type = insertElementInst.getType();
 
   // If the type is not a vector, bail.
@@ -641,35 +642,35 @@ void PatchBufferOp::visitInsertElementInst(InsertElementInst &insertElementInst)
   // If the extract element is not extracting from a vector of pointers, bail.
   if (!pointerType)
     return;
 
   // If the type we are GEPing into is not a fat pointer, bail.
   if (pointerType->getAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&insertElementInst);
 
-  Value *const pointer = getPointerOperandAsInst(insertElementInst.getOperand(1));
-  Value *const index = m_replacementMap[pointer].second;
+  Replacement pointer = getRemappedValue(insertElementInst.getOperand(1));
+  Value *const index = pointer.second;
 
   Value *indexVector = nullptr;
 
   if (isa<UndefValue>(insertElementInst.getOperand(0)))
     indexVector =
         UndefValue::get(FixedVectorType::get(index->getType(), cast<FixedVectorType>(type)->getNumElements()));
   else
-    indexVector = m_replacementMap[getPointerOperandAsInst(insertElementInst.getOperand(0))].second;
+    indexVector = getRemappedValue(insertElementInst.getOperand(0)).second;
 
   indexVector = m_builder->CreateInsertElement(indexVector, index, insertElementInst.getOperand(2));
-  copyMetadata(indexVector, pointer);
+  copyMetadata(indexVector, &insertElementInst);
 
-  m_replacementMap[&insertElementInst] = std::make_pair(m_replacementMap[pointer].first, indexVector);
+  m_replacementMap[&insertElementInst] = std::make_pair(pointer.first, indexVector);
 }
 
 // =====================================================================================================================
 // Visits "load" instruction.
 //
 // @param loadInst : The instruction
 void PatchBufferOp::visitLoadInst(LoadInst &loadInst) {
   const unsigned addrSpace = loadInst.getPointerAddressSpace();
 
   if (addrSpace == ADDR_SPACE_CONST) {
@@ -683,21 +684,21 @@ void PatchBufferOp::visitLoadInst(LoadInst &loadInst) {
 
     // If the address space of the loaded pointer is not a buffer fat pointer, bail.
     if (loadType->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
       return;
 
     assert(loadInst.isVolatile() == false);
     assert(loadInst.getOrdering() == AtomicOrdering::NotAtomic);
 
     Type *const castType = FixedVectorType::get(Type::getInt32Ty(*m_context), 4)->getPointerTo(ADDR_SPACE_CONST);
 
-    Value *const pointer = getPointerOperandAsInst(loadInst.getPointerOperand());
+    Value *const pointer = loadInst.getPointerOperand();
 
     Value *const loadPointer = m_builder->CreateBitCast(pointer, castType);
 
     LoadInst *const newLoad =
         m_builder->CreateAlignedLoad(m_builder->getInt32Ty(), loadPointer, loadInst.getAlign(), loadInst.isVolatile());
     newLoad->setOrdering(loadInst.getOrdering());
     newLoad->setSyncScopeID(loadInst.getSyncScopeID());
     copyMetadata(newLoad, &loadInst);
 
     Constant *const nullPointer = ConstantPointerNull::get(getRemappedType(loadType));
@@ -817,33 +818,29 @@ void PatchBufferOp::visitPHINode(PHINode &phiNode) {
   Type *const type = phiNode.getType();
 
   // If the type is not a pointer type, bail.
   if (!type->isPointerTy())
     return;
 
   // If the pointer is not a fat pointer, bail.
   if (type->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
-  SmallVector<Value *, 8> incomings;
-
-  for (unsigned i = 0, incomingValueCount = phiNode.getNumIncomingValues(); i < incomingValueCount; i++) {
-    // PHIs require us to insert new incomings in the preceding basic blocks.
-    m_builder->SetInsertPoint(phiNode.getIncomingBlock(i)->getTerminator());
+  SmallVector<Replacement> incomings;
 
-    incomings.push_back(getPointerOperandAsInst(phiNode.getIncomingValue(i)));
-  }
+  for (unsigned i = 0, incomingValueCount = phiNode.getNumIncomingValues(); i < incomingValueCount; i++)
+    incomings.push_back(getRemappedValueOrNull(phiNode.getIncomingValue(i)));
 
   Value *bufferDesc = nullptr;
 
-  for (Value *const incoming : incomings) {
-    Value *const incomingBufferDesc = m_replacementMap[incoming].first;
+  for (const Replacement &incoming : incomings) {
+    Value *const incomingBufferDesc = incoming.first;
 
     if (!bufferDesc)
       bufferDesc = incomingBufferDesc;
     else if (bufferDesc != incomingBufferDesc) {
       bufferDesc = nullptr;
       break;
     }
   }
 
   m_builder->SetInsertPoint(&phiNode);
@@ -854,27 +851,27 @@ void PatchBufferOp::visitPHINode(PHINode &phiNode) {
         m_builder->CreatePHI(FixedVectorType::get(Type::getInt32Ty(*m_context), 4), incomings.size());
     copyMetadata(newPhiNode, &phiNode);
 
     bool isInvariant = true;
     bool isDivergent = false;
 
     for (BasicBlock *const block : phiNode.blocks()) {
       const int blockIndex = phiNode.getBasicBlockIndex(block);
       assert(blockIndex >= 0);
 
-      Value *incomingBufferDesc = m_replacementMap[incomings[blockIndex]].first;
+      Value *incomingBufferDesc = incomings[blockIndex].first;
 
       if (!incomingBufferDesc) {
         // If we cannot get an incoming buffer descriptor from the replacement map, it is unvisited yet. Generate an
         // incomplete phi and fix it later.
         incomingBufferDesc = UndefValue::get(newPhiNode->getType());
-        m_incompletePhis[{newPhiNode, block}] = incomings[blockIndex];
+        m_incompletePhis[{newPhiNode, block}] = phiNode.getIncomingValue(blockIndex);
       }
 
       newPhiNode->addIncoming(incomingBufferDesc, block);
 
       // If the incoming buffer descriptor is not invariant, the PHI cannot be marked invariant either.
       if (m_invariantSet.count(incomingBufferDesc) == 0)
         isInvariant = false;
 
       if (m_divergenceSet.count(incomingBufferDesc) > 0 || m_isDivergent(phiNode))
         isDivergent = true;
@@ -891,26 +888,26 @@ void PatchBufferOp::visitPHINode(PHINode &phiNode) {
 
   PHINode *const newPhiNode = m_builder->CreatePHI(getRemappedType(phiNode.getType()), incomings.size());
   copyMetadata(newPhiNode, &phiNode);
 
   m_replacementMap[&phiNode] = std::make_pair(bufferDesc, newPhiNode);
 
   for (BasicBlock *const block : phiNode.blocks()) {
     const int blockIndex = phiNode.getBasicBlockIndex(block);
     assert(blockIndex >= 0);
 
-    Value *incomingIndex = m_replacementMap[incomings[blockIndex]].second;
+    Value *incomingIndex = incomings[blockIndex].second;
 
     if (!incomingIndex) {
       // If we cannot get an incoming index from the replacement map, do the same as buffer descriptor.
       incomingIndex = UndefValue::get(newPhiNode->getType());
-      m_incompletePhis[{newPhiNode, block}] = incomings[blockIndex];
+      m_incompletePhis[{newPhiNode, block}] = phiNode.getIncomingValue(blockIndex);
     }
 
     newPhiNode->addIncoming(incomingIndex, block);
   }
 
   m_replacementMap[&phiNode] = std::make_pair(bufferDesc, newPhiNode);
 }
 
 // =====================================================================================================================
 // Visits "select" instruction.
@@ -922,46 +919,46 @@ void PatchBufferOp::visitSelectInst(SelectInst &selectInst) {
   // If the type is not a pointer type, bail.
   if (!destType->isPointerTy())
     return;
 
   // If the pointer is not a fat pointer, bail.
   if (destType->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&selectInst);
 
-  Value *const value1 = getPointerOperandAsInst(selectInst.getTrueValue());
-  Value *const value2 = getPointerOperandAsInst(selectInst.getFalseValue());
+  Replacement value1 = getRemappedValue(selectInst.getTrueValue());
+  Replacement value2 = getRemappedValue(selectInst.getFalseValue());
 
-  Value *const bufferDesc1 = m_replacementMap[value1].first;
-  Value *const bufferDesc2 = m_replacementMap[value2].first;
+  Value *const bufferDesc1 = value1.first;
+  Value *const bufferDesc2 = value2.first;
 
   Value *bufferDesc = nullptr;
 
   if (bufferDesc1 == bufferDesc2) {
     // If the buffer descriptors are the same, then no select needed.
     bufferDesc = bufferDesc1;
   } else if (!bufferDesc1 || !bufferDesc2) {
     // Select the non-nullptr buffer descriptor
     bufferDesc = bufferDesc1 ? bufferDesc1 : bufferDesc2;
   } else {
     // Otherwise we need to insert a select between the buffer descriptors.
     bufferDesc = m_builder->CreateSelect(selectInst.getCondition(), bufferDesc1, bufferDesc2);
     copyMetadata(bufferDesc, &selectInst);
 
     // If both incomings are invariant, mark the new select as invariant too.
     if (m_invariantSet.count(bufferDesc1) > 0 && m_invariantSet.count(bufferDesc2) > 0)
       m_invariantSet.insert(bufferDesc);
   }
 
-  Value *const index1 = m_replacementMap[value1].second;
-  Value *const index2 = m_replacementMap[value2].second;
+  Value *const index1 = value1.second;
+  Value *const index2 = value2.second;
 
   Value *const newSelect = m_builder->CreateSelect(selectInst.getCondition(), index1, index2);
   copyMetadata(newSelect, &selectInst);
 
   m_replacementMap[&selectInst] = std::make_pair(bufferDesc, newSelect);
 
   // If either of the incoming buffer descriptors are divergent, mark the new buffer descriptor as divergent too.
   if (m_divergenceSet.count(bufferDesc1) > 0 || m_divergenceSet.count(bufferDesc2) > 0)
     m_divergenceSet.insert(bufferDesc);
   else if (m_isDivergent(selectInst) && bufferDesc1 != bufferDesc2) {
@@ -1020,27 +1017,27 @@ void PatchBufferOp::visitPtrToIntInst(PtrToIntInst &ptrToIntInst) {
   // If the type is not a pointer type, bail.
   if (!type->isPointerTy())
     return;
 
   // If the pointer is not a fat pointer, bail.
   if (type->getPointerAddressSpace() != ADDR_SPACE_BUFFER_FAT_POINTER)
     return;
 
   m_builder->SetInsertPoint(&ptrToIntInst);
 
-  Value *const pointer = getPointerOperandAsInst(ptrToIntInst.getOperand(0));
+  Replacement pointer = getRemappedValue(ptrToIntInst.getOperand(0));
 
-  Value *const newPtrToInt = m_builder->CreatePtrToInt(m_replacementMap[pointer].second, ptrToIntInst.getDestTy());
+  Value *const newPtrToInt = m_builder->CreatePtrToInt(pointer.second, ptrToIntInst.getDestTy());
 
-  copyMetadata(newPtrToInt, pointer);
+  copyMetadata(newPtrToInt, &ptrToIntInst);
 
-  m_replacementMap[&ptrToIntInst] = std::make_pair(m_replacementMap[pointer].first, newPtrToInt);
+  m_replacementMap[&ptrToIntInst] = std::make_pair(pointer.first, newPtrToInt);
 
   ptrToIntInst.replaceAllUsesWith(newPtrToInt);
 }
 
 // =====================================================================================================================
 // Post-process visits "memcpy" instruction.
 //
 // @param memCpyInst : The memcpy instruction
 void PatchBufferOp::postVisitMemCpyInst(MemCpyInst &memCpyInst) {
   Value *const dest = memCpyInst.getArgOperand(0);
@@ -1300,46 +1297,45 @@ void PatchBufferOp::postVisitMemSetInst(MemSetInst &memSetInst) {
     StoreInst *const destStore = m_builder->CreateAlignedStore(newValue, castDest, destAlignment);
     copyMetadata(destStore, &memSetInst);
     visitStoreInst(*destStore);
   }
 
   // Record the memset instruction so we remember to delete it later.
   m_replacementMap[&memSetInst] = std::make_pair(nullptr, nullptr);
 }
 
 // =====================================================================================================================
-// Get a pointer operand as an instruction.
+// Get the remapped value for a fat-pointer-typed value, or {nullptr, nullptr} if the value is an instruction that has
+// not been visited yet.
 //
-// @param value : The pointer operand value to get as an instruction.
-Value *PatchBufferOp::getPointerOperandAsInst(Value *const value) {
-  // If the value is already an instruction, return it.
-  if (Instruction *const inst = dyn_cast<Instruction>(value))
-    return inst;
-
-  // If the value is a constant (i.e., null pointer), return it.
-  if (isa<Constant>(value)) {
-    Constant *const nullPointer = ConstantPointerNull::get(getRemappedType(value->getType()));
-    m_replacementMap[value] = std::make_pair(nullptr, nullPointer);
-    return value;
+// @param value : The Value to remap
+PatchBufferOp::Replacement PatchBufferOp::getRemappedValueOrNull(Value *value) const {
+  // If the value is already an instruction, look it up in the replacement map.
+  if (Instruction *inst = dyn_cast<Instruction>(value)) {
+    if (auto iter = m_replacementMap.find(inst); iter != m_replacementMap.end())
+      return iter->second;
+    return {nullptr, nullptr};
   }
 
-  ConstantExpr *const constExpr = cast<ConstantExpr>(value);
-
-  Instruction *const newInst = m_builder->Insert(constExpr->getAsInstruction());
-
-  // Visit the new instruction we made to ensure we remap the value.
-  visit(newInst);
-
-  // Check that the new instruction was definitely in the replacement map.
-  assert(m_replacementMap.count(newInst) > 0);
+  // Otherwise the value is a constant. Assume it is a null pointer and remap its type.
+  Constant *nullPointer = ConstantPointerNull::get(getRemappedType(value->getType()));
+  return std::make_pair(nullptr, nullPointer);
+}
 
-  return newInst;
+// =====================================================================================================================
+// Get the remapped value for a fat-pointer-typed value.
+//
+// @param value : The Value to remap
+PatchBufferOp::Replacement PatchBufferOp::getRemappedValue(Value *value) const {
+  Replacement pointer = getRemappedValueOrNull(value);
+  assert(pointer.second != nullptr);
+  return pointer;
 }
 
 // =====================================================================================================================
 // Extract the 64-bit address from a buffer descriptor.
 //
 // @param bufferDesc : The buffer descriptor to extract the address from
 Value *PatchBufferOp::getBaseAddressFromBufferDesc(Value *const bufferDesc) const {
   Type *const descType = bufferDesc->getType();
 
   assert(descType->isVectorTy());
@@ -1449,38 +1445,37 @@ Value *PatchBufferOp::replaceLoadStore(Instruction &inst) {
   } else {
     type = storeInst->getValueOperand()->getType();
     pointerOperand = storeInst->getPointerOperand();
     ordering = storeInst->getOrdering();
     alignment = storeInst->getAlign();
     syncScopeID = storeInst->getSyncScopeID();
   }
 
   m_builder->SetInsertPoint(&inst);
 
-  Value *const pointer = getPointerOperandAsInst(pointerOperand);
+  Replacement pointer = getRemappedValue(pointerOperand);
 
   const DataLayout &dataLayout = m_builder->GetInsertBlock()->getModule()->getDataLayout();
 
   const unsigned bytesToHandle = static_cast<unsigned>(dataLayout.getTypeStoreSize(type));
 
   bool isInvariant = false;
   if (isLoad) {
-    isInvariant = m_invariantSet.count(m_replacementMap[pointer].first) > 0 ||
-                  loadInst->getMetadata(LLVMContext::MD_invariant_load);
+    isInvariant = m_invariantSet.count(pointer.first) > 0 || loadInst->getMetadata(LLVMContext::MD_invariant_load);
   }
 
   const bool isSlc = inst.getMetadata(LLVMContext::MD_nontemporal);
   const bool isGlc = ordering != AtomicOrdering::NotAtomic;
   const bool isDlc = isGlc; // For buffer load on GFX10+, we set DLC = GLC
 
-  Value *const bufferDesc = m_replacementMap[pointer].first;
-  Value *const baseIndex = m_builder->CreatePtrToInt(m_replacementMap[pointer].second, m_builder->getInt32Ty());
+  Value *const bufferDesc = pointer.first;
+  Value *const baseIndex = m_builder->CreatePtrToInt(pointer.second, m_builder->getInt32Ty());
 
   // If our buffer descriptor is divergent, need to handle that differently.
   if (m_divergenceSet.count(bufferDesc) > 0) {
     Value *const baseAddr = getBaseAddressFromBufferDesc(bufferDesc);
 
     // The 2nd element in the buffer descriptor is the byte bound, we do this to support robust buffer access.
     Value *const bound = m_builder->CreateExtractElement(bufferDesc, 2);
     Value *const inBound = m_builder->CreateICmpULT(baseIndex, bound);
     Value *const newBaseIndex = m_builder->CreateSelect(inBound, baseIndex, m_builder->getInt32(0));
 
@@ -1489,21 +1484,21 @@ Value *PatchBufferOp::replaceLoadStore(Instruction &inst) {
 
     pointer = m_builder->CreateBitCast(pointer, type->getPointerTo(ADDR_SPACE_GLOBAL));
 
     if (isLoad) {
       LoadInst *const newLoad = m_builder->CreateAlignedLoad(type, pointer, alignment, loadInst->isVolatile());
       newLoad->setOrdering(ordering);
       newLoad->setSyncScopeID(syncScopeID);
       copyMetadata(newLoad, loadInst);
 
       if (isInvariant)
-        newLoad->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(*m_context, None));
+        newLoad->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(*m_context, {}));
 
       return newLoad;
     }
     StoreInst *const newStore =
         m_builder->CreateAlignedStore(storeInst->getValueOperand(), pointer, alignment, storeInst->isVolatile());
     newStore->setOrdering(ordering);
     newStore->setSyncScopeID(syncScopeID);
     copyMetadata(newStore, storeInst);
 
     return newStore;
@@ -1609,21 +1604,21 @@ Value *PatchBufferOp::replaceLoadStore(Instruction &inst) {
       coherent.bits.slc = isSlc;
 
     if (isLoad) {
       if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 10) {
         // TODO For stores?
         coherent.bits.dlc = isDlc;
       }
       if (isInvariant && accessSize >= 4) {
         CallInst *call = m_builder->CreateIntrinsic(Intrinsic::amdgcn_s_buffer_load, intAccessType,
                                                     {bufferDesc, offsetVal, m_builder->getInt32(coherent.u32All)});
-        call->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(*m_context, None));
+        call->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(*m_context, {}));
         part = call;
       } else {
         unsigned intrinsicID = Intrinsic::amdgcn_raw_buffer_load;
 #if !defined(LLVM_HAVE_BRANCH_AMD_GFX)
 #warning[!amd-gfx] Atomic load loses memory semantics
 #else
         if (ordering != AtomicOrdering::NotAtomic)
           intrinsicID = Intrinsic::amdgcn_raw_atomic_buffer_load;
 #endif
         part = m_builder->CreateIntrinsic(
@@ -1711,23 +1706,23 @@ Value *PatchBufferOp::replaceLoadStore(Instruction &inst) {
 // =====================================================================================================================
 // Replace fat pointers icmp with the instruction required to do the icmp.
 //
 // @param iCmpInst : The "icmp" instruction to replace.
 Value *PatchBufferOp::replaceICmp(ICmpInst *const iCmpInst) {
   m_builder->SetInsertPoint(iCmpInst);
 
   SmallVector<Value *, 2> bufferDescs;
   SmallVector<Value *, 2> indices;
   for (int i = 0; i < 2; ++i) {
-    Value *const operand = getPointerOperandAsInst(iCmpInst->getOperand(i));
-    bufferDescs.push_back(m_replacementMap[operand].first);
-    indices.push_back(m_builder->CreatePtrToInt(m_replacementMap[operand].second, m_builder->getInt32Ty()));
+    Replacement operand = getRemappedValue(iCmpInst->getOperand(i));
+    bufferDescs.push_back(operand.first);
+    indices.push_back(m_builder->CreatePtrToInt(operand.second, m_builder->getInt32Ty()));
   }
 
   Type *const bufferDescTy = bufferDescs[0]->getType();
 
   assert(bufferDescTy->isVectorTy());
   assert(cast<FixedVectorType>(bufferDescTy)->getNumElements() == 4);
   assert(cast<VectorType>(bufferDescTy)->getElementType()->isIntegerTy(32));
   (void(bufferDescTy)); // unused
   assert(iCmpInst->getPredicate() == ICmpInst::ICMP_EQ || iCmpInst->getPredicate() == ICmpInst::ICMP_NE);
 
diff --git a/lgc/patch/PatchCopyShader.cpp b/lgc/patch/PatchCopyShader.cpp
index 2df65cf83..ddee1c6d4 100644
--- a/lgc/patch/PatchCopyShader.cpp
+++ b/lgc/patch/PatchCopyShader.cpp
@@ -153,24 +153,38 @@ bool PatchCopyShader::runImpl(Module &module, PipelineShadersResult &pipelineSha
                 "vertexOffset"};
   } else {
     // If NGG, the copy shader is not a real HW VS and will be incorporated into NGG primitive shader finally. Thus,
     // the argument definitions are decided by compiler not by HW. We could have such variable layout (not fixed with
     // GPU generation evolvement):
     //
     // GFX10:
     //   void copyShader(
     //     i32 vertexIndex)
     //
+#if LLPC_BUILD_GFX11
+    // GFX11+:
+    //   void copyShader(
+    //     i32 inreg globalTable,
+    //     i32 inreg streamOutTable,
+    //     i32 inreg streamOutControlBuf,
+    //     i32 vertexId)
+#endif
     if (m_pipelineState->getTargetInfo().getGfxIpVersion().major <= 10) {
       argTys = {int32Ty};
       argInReg = {false};
       argNames = {"vertexId"};
+#if LLPC_BUILD_GFX11
+    } else {
+      argTys = {int32Ty, int32Ty, int32Ty, int32Ty};
+      argInReg = {true, true, true, false};
+      argNames = {"globalTable", "streamOutTable", "streamOutControlBuf", "vertexId"};
+#endif
     }
   }
 
   auto entryPointTy = FunctionType::get(builder.getVoidTy(), argTys, false);
 
   // Create function for the copy shader entrypoint, and insert it before the FS (if there is one).
   auto entryPoint = Function::Create(entryPointTy, GlobalValue::ExternalLinkage, lgcName::CopyShaderEntryPoint);
   entryPoint->setDLLStorageClass(GlobalValue::DLLExportStorageClass);
   entryPoint->setCallingConv(CallingConv::AMDGPU_VS);
 
@@ -204,30 +218,34 @@ bool PatchCopyShader::runImpl(Module &module, PipelineShadersResult &pipelineSha
     intfData->userDataUsage.gs.copyShaderStreamOutTable = 2;
   } else {
     if (!m_pipelineState->getNggControl()->enableNgg) {
       // For GFX9+, streamOutTable SGPR index value should be greater than esGsLdsSize
       intfData->userDataUsage.gs.copyShaderEsGsLdsSize = 2;
       intfData->userDataUsage.gs.copyShaderStreamOutTable = 3;
     } else {
       // If NGG, esGsLdsSize is not used
       intfData->userDataUsage.gs.copyShaderEsGsLdsSize = InvalidValue;
       intfData->userDataUsage.gs.copyShaderStreamOutTable = 1;
+#if LLPC_BUILD_GFX11
+      if (m_pipelineState->enableSwXfb())
+        intfData->userDataUsage.gs.copyShaderStreamOutControlBuf = 2;
+#endif
     }
   }
 
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader);
 
   if (!m_pipelineState->getNggControl()->enableNgg) {
     // If no NGG, the copy shader will become a real HW VS. Set the user data entries in the
     // PAL metadata here.
     m_pipelineState->getPalMetadata()->setUserDataEntry(ShaderStageCopyShader, 0, UserDataMapping::GlobalTable);
-    if (resUsage->inOutUsage.enableXfb) {
+    if (m_pipelineState->enableXfb()) {
       m_pipelineState->getPalMetadata()->setUserDataEntry(
           ShaderStageCopyShader, intfData->userDataUsage.gs.copyShaderStreamOutTable, UserDataMapping::StreamOutTable);
     }
     if (cl::InRegEsGsLdsSize && m_pipelineState->isGsOnChip()) {
       m_pipelineState->getPalMetadata()->setUserDataEntry(
           ShaderStageCopyShader, intfData->userDataUsage.gs.copyShaderEsGsLdsSize, UserDataMapping::EsGsLdsSize);
     }
   }
 
   if (m_pipelineState->isGsOnChip())
@@ -238,21 +256,21 @@ bool PatchCopyShader::runImpl(Module &module, PipelineShadersResult &pipelineSha
   unsigned outputStreamCount = 0;
   unsigned outputStreamId = InvalidValue;
   for (int i = 0; i < MaxGsStreams; ++i) {
     if (resUsage->inOutUsage.gs.outLocCount[i] > 0) {
       outputStreamCount++;
       if (outputStreamId == InvalidValue)
         outputStreamId = i;
     }
   }
 
-  if (outputStreamCount > 1 && resUsage->inOutUsage.enableXfb) {
+  if (outputStreamCount > 1 && m_pipelineState->enableXfb()) {
     if (!m_pipelineState->getNggControl()->enableNgg) {
       // StreamId = streamInfo[25:24]
       auto streamInfo = getFunctionArgument(entryPoint, CopyShaderUserSgprIdxStreamInfo);
 
       Value *streamId = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, builder.getInt32Ty(),
                                                 {
                                                     streamInfo,
                                                     builder.getInt32(24),
                                                     builder.getInt32(2),
                                                 });
@@ -301,20 +319,23 @@ bool PatchCopyShader::runImpl(Module &module, PipelineShadersResult &pipelineSha
       //   ...
       //   export outputs of stream 0
       //   ...
       //   export outputs of raster stream
       //   ...
       //   export outputs of stream 3
       //
       //   return
       // }
       //
+#if LLPC_BUILD_GFX11
+      assert(gfxIp.major >= 11); // Must be GFX11+
+#endif
       for (unsigned streamId = 0; streamId < MaxGsStreams; ++streamId) {
         if (resUsage->inOutUsage.gs.outLocCount[streamId] > 0)
           exportOutput(streamId, builder);
       }
       builder.CreateBr(endBlock);
     }
   } else {
     outputStreamId = outputStreamCount == 0 ? 0 : outputStreamId;
     exportOutput(outputStreamId, builder);
     builder.CreateBr(endBlock);
@@ -388,39 +409,39 @@ void PatchCopyShader::collectGsGenericOutputInfo(Function *gsEntryPoint) {
 }
 
 // =====================================================================================================================
 // Exports outputs of geometry shader, inserting buffer-load/output-export calls.
 //
 // @param streamId : Export output of this stream
 // @param builder : BuilderBase to use for instruction constructing
 void PatchCopyShader::exportOutput(unsigned streamId, BuilderBase &builder) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader);
   auto &builtInUsage = resUsage->builtInUsage.gs;
-  auto &locInfoXfbOutInfoMap = resUsage->inOutUsage.gs.locInfoXfbOutInfoMap;
+  auto &locInfoXfbOutInfoMap = resUsage->inOutUsage.locInfoXfbOutInfoMap;
   auto &outputLocInfoMap = resUsage->inOutUsage.outputLocInfoMap;
 
   // Build the map between new location and output value
   DenseMap<unsigned, Value *> newLocValueMap;
   // Collect the output value at each mapped location in the given stream
   const auto &newLocByteSizesMap = m_newLocByteSizesMapArray[streamId];
   for (const auto &locByteSizePair : newLocByteSizesMap) {
     const unsigned newLoc = locByteSizePair.first;
     const unsigned byteSize = locByteSizePair.second;
     assert(byteSize % 4 == 0 && byteSize <= 32);
     const unsigned dwordSize = byteSize / 4;
     Value *outputValue = loadValueFromGsVsRing(dwordSize > 1 ? FixedVectorType::get(builder.getFloatTy(), dwordSize)
                                                              : builder.getFloatTy(),
                                                newLoc, streamId, builder);
     newLocValueMap[newLoc] = outputValue;
   }
 
-  if (resUsage->inOutUsage.enableXfb) {
+  if (m_pipelineState->enableXfb()) {
     // Export XFB output
     if (m_pipelineState->canPackOutput(ShaderStageGeometry)) {
       // With packing locations, we should collect the XFB output value at an original location
       DenseMap<unsigned, SmallVector<Value *, 4>> origLocElemsMap;
       for (const auto &locInfoXfbInfoPair : locInfoXfbOutInfoMap) {
         const InOutLocationInfo &origLocInfo = locInfoXfbInfoPair.first;
         if (origLocInfo.getStreamId() != streamId || origLocInfo.isBuiltIn())
           continue;
         // Get each component from the packed output value
         assert(outputLocInfoMap.count(origLocInfo));
@@ -498,29 +519,29 @@ void PatchCopyShader::exportOutput(unsigned streamId, BuilderBase &builder) {
   }
 
   if (builtInUsage.cullDistance > 0) {
     builtInPairs.push_back(
         std::make_pair(BuiltInCullDistance, ArrayType::get(builder.getFloatTy(), builtInUsage.cullDistance)));
   }
 
   if (builtInUsage.primitiveId)
     builtInPairs.push_back(std::make_pair(BuiltInPrimitiveId, builder.getInt32Ty()));
 
-  const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
-  if (builtInUsage.layer || enableMultiView) {
-    // NOTE: If multi-view is enabled, always export gl_ViewIndex rather than gl_Layer.
-    builtInPairs.push_back(std::make_pair(enableMultiView ? BuiltInViewIndex : BuiltInLayer, builder.getInt32Ty()));
-  }
+  if (builtInUsage.layer)
+    builtInPairs.push_back(std::make_pair(BuiltInLayer, builder.getInt32Ty()));
 
   if (builtInUsage.viewportIndex)
     builtInPairs.push_back(std::make_pair(BuiltInViewportIndex, builder.getInt32Ty()));
 
+  if (m_pipelineState->getInputAssemblyState().enableMultiView)
+    builtInPairs.push_back(std::make_pair(BuiltInViewIndex, builder.getInt32Ty()));
+
   if (builtInUsage.primitiveShadingRate)
     builtInPairs.push_back(std::make_pair(BuiltInPrimitiveShadingRate, builder.getInt32Ty()));
 
   for (auto &builtInPair : builtInPairs) {
     auto builtInId = builtInPair.first;
     Type *builtInTy = builtInPair.second;
 
     assert(resUsage->inOutUsage.builtInOutputLocMap.find(builtInId) != resUsage->inOutUsage.builtInOutputLocMap.end());
 
     unsigned loc = resUsage->inOutUsage.builtInOutputLocMap[builtInId];
@@ -694,48 +715,65 @@ void PatchCopyShader::exportXfbOutput(Value *outputValue, const XfbOutInfo &xfbO
       outputValue = builder.CreateBitCast(outputValue, FixedVectorType::get(builder.getInt32Ty(), compCount));
       outputValue = builder.CreateTrunc(outputValue, FixedVectorType::get(builder.getInt16Ty(), compCount));
       outputValue = builder.CreateBitCast(outputValue, FixedVectorType::get(builder.getHalfTy(), compCount));
     } else {
       outputValue = builder.CreateBitCast(outputValue, builder.getInt32Ty());
       outputValue = new TruncInst(outputValue, builder.getInt16Ty());
       outputValue = new BitCastInst(outputValue, builder.getHalfTy());
     }
   }
 
+#if LLPC_BUILD_GFX11
+  // Collect transform feedback output export calls, used in SW-emulated stream-out.
+  if (m_pipelineState->enableSwXfb()) {
+    auto &inOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader)->inOutUsage;
+    // A transform feedback output export call is expected to be <4 x dword> at most
+    inOutUsage.xfbOutputExpCount += outputValue->getType()->getPrimitiveSizeInBits() > 128 ? 2 : 1;
+  }
+#endif
+
   Value *args[] = {builder.getInt32(xfbOutInfo.xfbBuffer), builder.getInt32(xfbOutInfo.xfbOffset),
                    builder.getInt32(xfbOutInfo.streamId), outputValue};
 
   std::string instName(lgcName::OutputExportXfb);
   addTypeMangling(nullptr, args, instName);
   builder.CreateNamedCall(instName, builder.getVoidTy(), args, {});
 }
 
 // =====================================================================================================================
 // Exports built-in outputs of geometry shader, inserting output-export calls.
 //
 // @param outputValue : Value exported to output
 // @param builtInId : ID of the built-in variable
 // @param streamId : ID of output vertex stream
 // @param builder : BuilderBase to use for instruction constructing
 void PatchCopyShader::exportBuiltInOutput(Value *outputValue, BuiltInKind builtInId, unsigned streamId,
                                           BuilderBase &builder) {
   auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader);
 
-  if (resUsage->inOutUsage.enableXfb) {
+  if (m_pipelineState->enableXfb()) {
     InOutLocationInfo outLocInfo;
     outLocInfo.setLocation(builtInId);
     outLocInfo.setBuiltIn(true);
     outLocInfo.setStreamId(streamId);
 
-    auto &locInfoXfbOutInfoMap = resUsage->inOutUsage.gs.locInfoXfbOutInfoMap;
+    auto &locInfoXfbOutInfoMap = resUsage->inOutUsage.locInfoXfbOutInfoMap;
     const auto &locInfoXfbOutInfoMapIt = locInfoXfbOutInfoMap.find(outLocInfo);
     if (locInfoXfbOutInfoMapIt != locInfoXfbOutInfoMap.end()) {
+#if LLPC_BUILD_GFX11
+      // Collect transform feedback output export calls, used in SW-emulated stream-out.
+      if (m_pipelineState->enableSwXfb()) {
+        auto &inOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader)->inOutUsage;
+        // A transform feedback output export call is expected to be <4 x dword> at most
+        inOutUsage.xfbOutputExpCount += outputValue->getType()->getPrimitiveSizeInBits() > 128 ? 2 : 1;
+      }
+#endif
 
       const auto &xfbOutInfo = locInfoXfbOutInfoMapIt->second;
       std::string instName(lgcName::OutputExportXfb);
       Value *args[] = {builder.getInt32(xfbOutInfo.xfbBuffer), builder.getInt32(xfbOutInfo.xfbOffset),
                        builder.getInt32(0), outputValue};
       addTypeMangling(nullptr, args, instName);
       builder.CreateNamedCall(instName, builder.getVoidTy(), args, {});
     }
   }
 
diff --git a/lgc/patch/PatchEntryPointMutate.cpp b/lgc/patch/PatchEntryPointMutate.cpp
index a57845625..687ae72ac 100644
--- a/lgc/patch/PatchEntryPointMutate.cpp
+++ b/lgc/patch/PatchEntryPointMutate.cpp
@@ -58,20 +58,21 @@
 #include "lgc/patch/ShaderInputs.h"
 #include "lgc/state/AbiUnlinked.h"
 #include "lgc/state/IntrinsDefs.h"
 #include "lgc/state/PalMetadata.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "lgc/util/AddressExtender.h"
 #include "lgc/util/BuilderBase.h"
 #include "llvm/ADT/SmallVector.h"
+#include "llvm/Analysis/AliasAnalysis.h" // for MemoryEffects
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 
 #define DEBUG_TYPE "lgc-patch-entry-point-mutate"
 
 using namespace llvm;
 using namespace lgc;
 
 namespace llvm {
@@ -620,29 +621,23 @@ void PatchEntryPointMutate::fixupUserDataUses(Module &module) {
           call->eraseFromParent();
           inst = nullptr;
         }
       }
     }
 
     // Special user data from lgc.special.user.data calls
     for (unsigned idx = 0; idx != userDataUsage->specialUserData.size(); ++idx) {
       auto &specialUserData = userDataUsage->specialUserData[idx];
       if (!specialUserData.users.empty()) {
-        Value *arg = nullptr;
-        if (specialUserData.entryArgIdx == 0) {
-          // This is the case that no arg was created for this value. That can happen, for example when
-          // ViewIndex is used but is not enabled in pipeline state. So we need to handle it. We just replace
-          // it with UndefValue.
-          arg = UndefValue::get(specialUserData.users[0]->getType());
-        } else {
-          arg = getFunctionArgument(&func, specialUserData.entryArgIdx);
-        }
+        assert(specialUserData.entryArgIdx != 0);
+        Value *arg = getFunctionArgument(&func, specialUserData.entryArgIdx);
+
         for (Instruction *&inst : specialUserData.users) {
           if (inst && inst->getFunction() == &func) {
             Value *replacementVal = arg;
             auto call = dyn_cast<CallInst>(inst);
             if (call->arg_size() >= 2) {
               // There is a second operand, used by ShaderInputs::getSpecialUserDataAsPoint to indicate that we
               // need to extend the loaded 32-bit value to a 64-bit pointer, using either PC or the provided
               // high half.
               builder.SetInsertPoint(call);
               Value *highHalf = call->getArgOperand(1);
@@ -840,27 +835,21 @@ void PatchEntryPointMutate::processCalls(Function &func, SmallVectorImpl<Type *>
       // Replace and erase the old one.
       call->replaceAllUsesWith(newCall);
       call->eraseFromParent();
     }
   }
 }
 
 // =====================================================================================================================
 // Set Attributes on new function
 void PatchEntryPointMutate::setFuncAttrs(Function *entryPoint) {
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 409358
-  // Old version of the code
-  AttrBuilder builder;
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
   AttrBuilder builder(entryPoint->getContext());
-#endif
   if (m_shaderStage == ShaderStageFragment) {
     auto &builtInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs;
     SpiPsInputAddr spiPsInputAddr = {};
 
     spiPsInputAddr.bits.perspSampleEna =
         ((builtInUsage.smooth && builtInUsage.sample) || builtInUsage.baryCoordSmoothSample);
     spiPsInputAddr.bits.perspCenterEna = ((builtInUsage.smooth && builtInUsage.center) || builtInUsage.baryCoordSmooth);
     spiPsInputAddr.bits.perspCentroidEna =
         ((builtInUsage.smooth && builtInUsage.centroid) || builtInUsage.baryCoordSmoothCentroid);
     spiPsInputAddr.bits.perspPullModelEna =
@@ -936,34 +925,33 @@ void PatchEntryPointMutate::setFuncAttrs(Function *entryPoint) {
     builder.addAttribute("disable-code-sinking");
 
   if (shaderOptions->nsaThreshold != 0)
     builder.addAttribute("amdgpu-nsa-threshold", std::to_string(shaderOptions->nsaThreshold));
 
   // Disable backend heuristics which would allow shaders to have lower occupancy. Heed the favorLatencyHiding tuning
   // option instead.
   builder.addAttribute("amdgpu-memory-bound", shaderOptions->favorLatencyHiding ? "true" : "false");
   builder.addAttribute("amdgpu-wave-limiter", "false");
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396807
-  // Old version of the code
-  AttributeList::AttrIndex attribIdx = AttributeList::AttrIndex(AttributeList::FunctionIndex);
-  entryPoint->addAttributes(attribIdx, builder);
-#else
-  // New version of the code (also handles unknown version, which we treat as
-  // latest)
   entryPoint->addFnAttrs(builder);
-#endif
 
   // NOTE: Remove "readnone" attribute for entry-point. If GS is empty, this attribute will allow
   // LLVM optimization to remove sendmsg(GS_DONE). It is unexpected.
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 440919
+  // Old version of the code
   if (entryPoint->hasFnAttribute(Attribute::ReadNone))
     entryPoint->removeFnAttr(Attribute::ReadNone);
+#else
+  // New version of the code (also handles unknown version, which we treat as
+  // latest)
+  entryPoint->setMemoryEffects(MemoryEffects::unknown());
+#endif
 }
 
 // =====================================================================================================================
 // Generates the type for the new entry-point based on already-collected info.
 // This is what decides what SGPRs and VGPRs are passed to the shader at wave dispatch:
 //
 // * (For a GFX9+ merged shader or NGG primitive shader, the 8 system SGPRs at the start are not accounted for here.)
 // * The "user data" SGPRs, up to 32 (GFX9+ non-compute shader) or 16 (compute shader or <=GFX8). Many of the values
 //   here are pointers, but are passed as a single 32-bit register and then expanded to 64-bit in the shader code:
 //   - The "global information table", containing various descriptors such as the inter-shader rings
@@ -1048,20 +1036,41 @@ uint64_t PatchEntryPointMutate::generateEntryPointArgTys(ShaderInputs *shaderInp
         auto &specialUserData = getUserDataUsage(m_shaderStage)->specialUserData;
         if (index < specialUserData.size())
           specialUserData[index].entryArgIdx = argTys.size() + argOffset;
       }
     }
     argTys.push_back(userDataArg.argTy);
     argNames.push_back(userDataArg.name);
     userDataIdx += dwordSize;
   }
 
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->getTargetInfo().getGpuWorkarounds().gfx11.waUserSgprInitBug) {
+    // Add dummy user data to bring the total to 16 SGPRS if hardware workaround
+    // is required
+
+    // Only applies to wave32
+    // TODO: Can we further exclude PS if LDS_GROUP_SIZE == 0
+    if (m_pipelineState->getShaderWaveSize(m_shaderStage) == 32 &&
+        (m_shaderStage == ShaderStageCompute || m_shaderStage == ShaderStageFragment ||
+         m_shaderStage == ShaderStageMesh)) {
+      unsigned userDataLimit = m_shaderStage == ShaderStageMesh ? 8 : 16;
+
+      while (userDataIdx < userDataLimit) {
+        argTys.push_back(builder.getInt32Ty());
+        argNames.push_back(("dummyInit" + Twine(userDataIdx)).str());
+        userDataIdx += 1;
+      }
+    }
+  }
+#endif
+
   intfData->userDataCount = userDataIdx;
   inRegMask = (1ull << argTys.size()) - 1;
 
   // Push the fixed system (not user data) register args.
   inRegMask |= shaderInputs->getShaderArgTys(m_pipelineState, m_shaderStage, argTys, argNames, argOffset);
 
   return inRegMask;
 }
 
 // =====================================================================================================================
@@ -1231,40 +1240,76 @@ void PatchEntryPointMutate::addSpecialUserDataArgs(SmallVectorImpl<UserDataArg>
                                               UserDataMapping::MeshTaskDispatchDims,
                                               &intfData->entryArgIdxs.mesh.dispatchDims));
     specialUserDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "meshTaskRingIndex",
                                               UserDataMapping::MeshTaskRingIndex,
                                               &intfData->entryArgIdxs.mesh.baseRingEntryIndex));
     if (m_pipelineState->needSwMeshPipelineStats()) {
       specialUserDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "meshPipeStatsBuf",
                                                 UserDataMapping::MeshPipeStatsBuf,
                                                 &intfData->entryArgIdxs.mesh.pipeStatsBuf));
     }
+  } else if (m_shaderStage == ShaderStageFragment) {
+    if (m_pipelineState->getInputAssemblyState().enableMultiView &&
+        m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs.viewIndex) {
+      // NOTE: Only add special user data of view index when multi-view is enabled and gl_ViewIndex is used in fragment
+      // shader.
+      specialUserDataArgs.push_back(
+          UserDataArg(builder.getInt32Ty(), "viewId", UserDataMapping::ViewId, &intfData->entryArgIdxs.fs.viewIndex));
+    }
   }
 
   // Allocate register for stream-out buffer table, to go before the user data node args (unlike all the ones
   // above, which go after the user data node args).
   if (userDataUsage->usesStreamOutTable || userDataUsage->isSpecialUserDataUsed(UserDataMapping::StreamOutTable)) {
-    if (enableNgg || !m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader)->inOutUsage.enableXfb) {
+    if (enableNgg || !m_pipelineState->hasShaderStage(ShaderStageCopyShader) && m_pipelineState->enableXfb()) {
       // If no NGG, stream out table will be set to copy shader's user data entry, we should not set it duplicately.
       switch (m_shaderStage) {
       case ShaderStageVertex:
         userDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutTable", UserDataMapping::StreamOutTable,
                                            &intfData->entryArgIdxs.vs.streamOutData.tablePtr));
+#if LLPC_BUILD_GFX11
+        if (m_pipelineState->enableSwXfb()) {
+          // NOTE: For GFX11+, the SW stream-out needs an additional special user data SGPR to store the
+          // stream-out control buffer address.
+          specialUserDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutControlBuf",
+                                                    UserDataMapping::StreamOutControlBuf,
+                                                    &intfData->entryArgIdxs.vs.streamOutData.controlBufPtr));
+        }
+#endif
         break;
       case ShaderStageTessEval:
         userDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutTable", UserDataMapping::StreamOutTable,
                                            &intfData->entryArgIdxs.tes.streamOutData.tablePtr));
+#if LLPC_BUILD_GFX11
+        if (m_pipelineState->enableSwXfb()) {
+          // NOTE: For GFX11+, the SW stream-out needs an additional special user data SGPR to store the
+          // stream-out control buffer address.
+          specialUserDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutControlBuf",
+                                                    UserDataMapping::StreamOutControlBuf,
+                                                    &intfData->entryArgIdxs.tes.streamOutData.controlBufPtr));
+        }
+#endif
         break;
       case ShaderStageGeometry:
         if (m_pipelineState->getTargetInfo().getGfxIpVersion().major <= 10) {
           // Allocate dummy stream-out register for geometry shader
           userDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "dummyStreamOut"));
+#if LLPC_BUILD_GFX11
+        } else if (m_pipelineState->enableSwXfb()) {
+          userDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutTable", UserDataMapping::StreamOutTable,
+                                             &intfData->entryArgIdxs.gs.streamOutData.tablePtr));
+          // NOTE: For GFX11+, the SW stream-out needs an additional special user data SGPR to store the
+          // stream-out control buffer address.
+          specialUserDataArgs.push_back(UserDataArg(builder.getInt32Ty(), "streamOutControlBuf",
+                                                    UserDataMapping::StreamOutControlBuf,
+                                                    &intfData->entryArgIdxs.gs.streamOutData.controlBufPtr));
+#endif
         }
         break;
       default:
         llvm_unreachable("Should never be called!");
         break;
       }
     }
   }
 }
 
diff --git a/lgc/patch/PatchImageOpCollect.cpp b/lgc/patch/PatchImageOpCollect.cpp
new file mode 100644
index 000000000..57c996598
--- /dev/null
+++ b/lgc/patch/PatchImageOpCollect.cpp
@@ -0,0 +1,117 @@
+/*
+ ***********************************************************************************************************************
+ *
+ *  Copyright (c) 2017-2022 Advanced Micro Devices, Inc. All Rights Reserved.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy
+ *  of this software and associated documentation files (the "Software"), to deal
+ *  in the Software without restriction, including without limitation the rights
+ *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ *  copies of the Software, and to permit persons to whom the Software is
+ *  furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included in all
+ *  copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *  SOFTWARE.
+ *
+ **********************************************************************************************************************/
+/**
+ ***********************************************************************************************************************
+ * @file  PatchImageOpCollect.cpp
+ * @brief LLPC source file: contains implementation of class lgc::PatchImageOpCollect.
+ ***********************************************************************************************************************
+ */
+#include "lgc/patch/PatchImageOpCollect.h"
+#include "lgc/patch/Patch.h"
+#include "lgc/state/PipelineState.h"
+#include "llvm/InitializePasses.h"
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "lgc-patch-image-op-collect"
+
+using namespace llvm;
+using namespace lgc;
+
+namespace lgc {
+
+// =====================================================================================================================
+// Initializes static members.
+char LegacyPatchImageOpCollect::ID = 0;
+
+// =====================================================================================================================
+// Pass creator, creates the pass of LLVM patching for image operation collecting
+ModulePass *createLegacyPatchImageOpCollect() {
+  return new LegacyPatchImageOpCollect();
+}
+
+// =====================================================================================================================
+LegacyPatchImageOpCollect::LegacyPatchImageOpCollect() : llvm::ModulePass(ID) {
+}
+
+// =====================================================================================================================
+// Get the analysis usage of this pass.
+//
+// @param [out] analysisUsage : The analysis usage.
+void LegacyPatchImageOpCollect::getAnalysisUsage(AnalysisUsage &analysisUsage) const {
+  analysisUsage.addRequired<LegacyPipelineStateWrapper>();
+}
+
+// =====================================================================================================================
+// Executes this LLVM patching pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on
+// @returns : True if the module was modified by the transformation and false otherwise
+bool LegacyPatchImageOpCollect::runOnModule(Module &module) {
+  PipelineState *pipelineState = getAnalysis<LegacyPipelineStateWrapper>().getPipelineState(&module);
+  return m_impl.runImpl(module, pipelineState);
+}
+
+// =====================================================================================================================
+// Executes this LLVM patching pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on
+// @param [in/out] analysisManager : Analysis manager to use for this transformation
+// @returns : The preserved analyses (The analyses that are still valid after this pass)
+PreservedAnalyses PatchImageOpCollect::run(Module &module, ModuleAnalysisManager &analysisManager) {
+  PipelineState *pipelineState = analysisManager.getResult<PipelineStateWrapper>(module).getPipelineState();
+  if (runImpl(module, pipelineState))
+    return PreservedAnalyses::none();
+  return PreservedAnalyses::all();
+}
+
+// =====================================================================================================================
+// Executes this LLVM patching pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on
+// @param pipelineState : Pipeline state
+// @returns : True if the module was modified by the transformation and false otherwise
+bool PatchImageOpCollect::runImpl(llvm::Module &module, PipelineState *pipelineState) {
+  LLVM_DEBUG(dbgs() << "Run the pass Patch-Image-Op-Collect\n");
+
+  for (Function &func : module) {
+    if (!func.isIntrinsic())
+      continue;
+    if (func.getName().startswith("llvm.amdgcn.image")) {
+      for (User *user : func.users()) {
+        CallInst *call = cast<CallInst>(user);
+        ShaderStage stage = getShaderStage(call->getFunction());
+        ResourceUsage *resUsage = pipelineState->getShaderResourceUsage(stage);
+        resUsage->useImageOp = true;
+      }
+    }
+  }
+  return false;
+}
+
+} // namespace lgc
+
+// =====================================================================================================================
+// Initializes the pass of LLVM patch operations for image operation collecting.
+INITIALIZE_PASS(LegacyPatchImageOpCollect, DEBUG_TYPE, "Patch LLVM for image operation collecting", false, false)
diff --git a/lgc/patch/PatchInOutImportExport.cpp b/lgc/patch/PatchInOutImportExport.cpp
index 0987f63f2..992891b65 100644
--- a/lgc/patch/PatchInOutImportExport.cpp
+++ b/lgc/patch/PatchInOutImportExport.cpp
@@ -1,11 +1,11 @@
-/*
+/*
  ***********************************************************************************************************************
  *
  *  Copyright (c) 2017-2022 Advanced Micro Devices, Inc. All Rights Reserved.
  *
  *  Permission is hereby granted, free of charge, to any person obtaining a copy
  *  of this software and associated documentation files (the "Software"), to deal
  *  in the Software without restriction, including without limitation the rights
  *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  *  copies of the Software, and to permit persons to whom the Software is
  *  furnished to do so, subject to the following conditions:
@@ -78,20 +78,21 @@ LegacyPatchInOutImportExport::~LegacyPatchInOutImportExport() {
 // Initialize per-shader members
 void PatchInOutImportExport::initPerShader() {
   m_clipDistance = nullptr;
   m_cullDistance = nullptr;
   m_primitiveId = nullptr;
   m_fragDepth = nullptr;
   m_fragStencilRef = nullptr;
   m_sampleMask = nullptr;
   m_viewportIndex = nullptr;
   m_layer = nullptr;
+  m_viewIndex = nullptr;
   m_threadId = nullptr;
 
   m_attribExports.clear();
 }
 
 // =====================================================================================================================
 // Executes this LLVM patching pass on the specified LLVM module.
 //
 // @param [in/out] module : LLVM module to be run on
 // @returns : True if the module was modified by the transformation and false otherwise
@@ -165,39 +166,50 @@ bool PatchInOutImportExport::runImpl(Module &module, PipelineShadersResult &pipe
       BUF_NUM_FORMAT_FLOAT << 4 | BUF_DATA_FORMAT_32_32,
       BUF_NUM_FORMAT_FLOAT << 4 | BUF_DATA_FORMAT_32_32_32,
       BUF_NUM_FORMAT_FLOAT << 4 | BUF_DATA_FORMAT_32_32_32_32,
   };
   static const std::array<unsigned char, 4> BufferFormatsGfx10 = {
       BUF_FORMAT_32_FLOAT,
       BUF_FORMAT_32_32_FLOAT_GFX10,
       BUF_FORMAT_32_32_32_FLOAT_GFX10,
       BUF_FORMAT_32_32_32_32_FLOAT_GFX10,
   };
+#if LLPC_BUILD_GFX11
+  static const std::array<unsigned char, 4> BufferFormatsGfx11 = {
+      BUF_FORMAT_32_FLOAT,
+      BUF_FORMAT_32_32_FLOAT_GFX11,
+      BUF_FORMAT_32_32_32_FLOAT_GFX11,
+      BUF_FORMAT_32_32_32_32_FLOAT_GFX11,
+  };
+#endif
 
   switch (m_gfxIp.major) {
   default:
     m_buffFormats = &BufferFormatsGfx9;
     break;
   case 10:
     m_buffFormats = &BufferFormatsGfx10;
     break;
+#if LLPC_BUILD_GFX11
+  case 11:
+    m_buffFormats = &BufferFormatsGfx11;
+    break;
+#endif
   }
 
   // Process each shader in turn, in reverse order (because for example VS uses inOutUsage.tcs.calcFactor
   // set by TCS).
   for (int shaderStage = ShaderStageCountInternal - 1; shaderStage >= 0; --shaderStage) {
     auto entryPoint = pipelineShaders.getEntryPoint(static_cast<ShaderStage>(shaderStage));
     if (entryPoint) {
       processFunction(*entryPoint, static_cast<ShaderStage>(shaderStage), inputCallees, otherCallees,
                       getPostDominatorTree);
-      if (shaderStage == ShaderStageTessControl)
-        storeTessFactors();
     }
   }
 
   // Process non-entry-point shaders
   for (Function &func : module) {
     if (func.isDeclaration())
       continue;
     auto shaderStage = getShaderStage(&func);
     if (shaderStage == ShaderStage::ShaderStageInvalid || &func == pipelineShaders.getEntryPoint(shaderStage))
       continue;
@@ -299,21 +311,21 @@ void PatchInOutImportExport::processShader() {
   } else if (m_shaderStage == ShaderStageTessEval) {
     if (builtInUsage.tes.primitiveId) {
       m_primitiveId = getFunctionArgument(m_entryPoint, entryArgIdxs.tes.patchId);
     }
   }
 
   // Thread ID will be used in on-chip GS offset calculation (ES -> GS ring is always on-chip on GFX9)
   bool useThreadId = (m_hasGs && (m_pipelineState->isGsOnChip() || m_gfxIp.major >= 9));
 
   // Thread ID will also be used for stream-out buffer export
-  const bool enableXfb = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage.enableXfb;
+  const bool enableXfb = m_pipelineState->enableXfb();
   useThreadId = useThreadId || enableXfb;
 
   if (useThreadId) {
     // Calculate and store thread ID
     BuilderBase builder(*m_context);
     builder.SetInsertPointPastAllocas(m_entryPoint);
     m_threadId = getSubgroupLocalInvocationId(builder);
   }
 
   // Initialize calculation factors for tessellation shader
@@ -325,23 +337,29 @@ void PatchInOutImportExport::processShader() {
     if (!calcFactor.initialized) {
       calcFactor.initialized = true;
 
       //
       // NOTE: The LDS for tessellation is as follow:
       //
       //          +-------------+--------------+-------------+-------------+
       // On-chip  | Input Patch | Output Patch | Patch Const | Tess Factor | (LDS)
       //          +-------------+--------------+-------------+-------------+
       //
+#if LLPC_BUILD_GFX11
+      //          +-------------+-------------+----------------+------------------+
+      // Off-chip | Input Patch | Tess Factor | HS Patch Count | Special TF Value | (LDS)
+      //          +-------------+-------------+----------------+------------------+
+#else
       //          +-------------+-------------+
       // Off-chip | Input Patch | Tess Factor | (LDS)
       //          +-------------+-------------+
+#endif
       //          +--------------+-------------+
       //          | Output Patch | Patch Const | (LDS Buffer)
       //          +--------------+-------------+
       //
       // inPatchTotalSize = inVertexCount * inVertexStride * patchCountPerThreadGroup
       // outPatchTotalSize = outVertexCount * outVertexStride * patchCountPerThreadGroup
       // patchConstTotalSize = patchConstCount * 4 * patchCountPerThreadGroup
       // tessFactorTotalSize = 6 * patchCountPerThreadGroup
       //
       const auto &tcsInOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage;
@@ -401,23 +419,46 @@ void PatchInOutImportExport::processShader() {
         calcFactor.offChip.patchConstStart = calcFactor.offChip.outPatchStart + outPatchTotalSize;
 
         calcFactor.onChip.tessFactorStart = inPatchTotalSize;
       } else {
         calcFactor.onChip.outPatchStart = inPatchTotalSize;
         calcFactor.onChip.patchConstStart = calcFactor.onChip.outPatchStart + outPatchTotalSize;
         calcFactor.onChip.tessFactorStart = calcFactor.onChip.patchConstStart + patchConstTotalSize;
       }
 
       calcFactor.tessFactorStride = tessFactorStride;
-
       calcFactor.tessOnChipLdsSize = calcFactor.onChip.tessFactorStart + tessFactorTotalSize;
 
+#if LLPC_BUILD_GFX11
+      if (m_pipelineState->canOptimizeTessFactor()) {
+        //
+        // NOTE: If we are going to optimize TF store, we need additional on-chip LDS size. The required size is
+        // 2 dwords per HS wave (1 dword all-ones flag and 1 dword all-zeros flag) plus an extra dword to count
+        // actual HS patches. The layout is as follow:
+        //
+        // +----------------+--------+--------+-----+--------+--------+
+        // | HS Patch Count | All 1s | All 0s | ... | All 1s | All 0s |
+        // +----------------+--------+--------+-----+--------+--------+
+        //                  |<---- Wave 0 --->|     |<---- Wave N --->|
+        //
+        assert(m_gfxIp.major >= 11);
+        calcFactor.onChip.hsPatchCountStart = calcFactor.tessOnChipLdsSize; // One dword to store actual HS wave count
+        calcFactor.onChip.specialTfValueStart = calcFactor.onChip.hsPatchCountStart + 1;
+
+        const unsigned maxNumHsWaves =
+            Gfx9::MaxHsThreadsPerSubgroup / m_pipelineState->getMergedShaderWaveSize(ShaderStageTessControl);
+        calcFactor.specialTfValueSize = maxNumHsWaves * 2;
+
+        calcFactor.tessOnChipLdsSize += 1 + calcFactor.specialTfValueSize;
+      }
+#endif
+
 #if VKI_RAY_TRACING
       // NOTE: If ray query uses LDS stack, the expected max thread count in the group is 64. And we force wave size
       // to be 64 in order to keep all threads in the same wave. In the future, we could consider to get rid of this
       // restriction by providing the capability of querying thread ID in group rather than in wave.
       const auto vsResUsage = m_pipelineState->getShaderResourceUsage(ShaderStageVertex);
       const auto tcsResUsage = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl);
       if (vsResUsage->useRayQueryLdsStack || tcsResUsage->useRayQueryLdsStack)
         calcFactor.rayQueryLdsStackSize = MaxRayQueryLdsStackEntries * MaxRayQueryThreadsPerGroup;
 #endif
 
@@ -442,20 +483,28 @@ void PatchInOutImportExport::processShader() {
       LLPC_OUTS("Patch constant count: " << patchConstCount << "\n");
       LLPC_OUTS("Patch constant size (in dwords): " << calcFactor.patchConstSize << "\n");
       LLPC_OUTS("Patch constant start: " << (m_pipelineState->isTessOffChip() ? calcFactor.offChip.patchConstStart
                                                                               : calcFactor.onChip.patchConstStart)
                                          << (m_pipelineState->isTessOffChip() ? " (LDS buffer)" : "(LDS)") << "\n");
       LLPC_OUTS("Patch constant total size (in dwords): " << patchConstTotalSize << "\n");
       LLPC_OUTS("\n");
       LLPC_OUTS("Tess factor start: " << calcFactor.onChip.tessFactorStart << " (LDS)\n");
       LLPC_OUTS("Tess factor total size (in dwords): " << tessFactorTotalSize << "\n");
       LLPC_OUTS("\n");
+#if LLPC_BUILD_GFX11
+      LLPC_OUTS("HS patch count start: " << calcFactor.onChip.hsPatchCountStart << " (LDS)\n");
+      LLPC_OUTS("HS wave count size (in dwords): " << 1 << "\n");
+      LLPC_OUTS("\n");
+      LLPC_OUTS("Special TF value start: " << calcFactor.onChip.specialTfValueStart << " (LDS)\n");
+      LLPC_OUTS("Special TF value size (in dwords): " << calcFactor.specialTfValueSize << "\n");
+      LLPC_OUTS("\n");
+#endif
       LLPC_OUTS("Tess factor stride: " << tessFactorStride << " (");
       switch (m_pipelineState->getShaderModes()->getTessellationMode().primitiveMode) {
       case PrimitiveMode::Triangles:
         LLPC_OUTS("triangles");
         break;
       case PrimitiveMode::Quads:
         LLPC_OUTS("quads");
         break;
       case PrimitiveMode::Isolines:
         LLPC_OUTS("isolines");
@@ -592,24 +641,23 @@ void PatchInOutImportExport::visitCallInst(CallInst &callInst) {
     unsigned value = cast<ConstantInt>(callInst.getOperand(0))->getZExtValue();
 
     LLVM_DEBUG(dbgs() << "Find input import call: builtin = " << isBuiltInInputImport << " value = " << value << "\n");
 
     m_importCalls.push_back(&callInst);
 
     if (isBuiltInInputImport) {
       const unsigned builtInId = value;
 
       switch (m_shaderStage) {
-      case ShaderStageVertex: {
-        input = patchVsBuiltInInputImport(inputTy, builtInId, builder);
+      case ShaderStageVertex:
+        // Nothing to do
         break;
-      }
       case ShaderStageTessControl: {
         // Builtin Call has different number of operands
         Value *elemIdx = nullptr;
         Value *vertexIdx = nullptr;
         if (callInst.arg_size() > 1)
           elemIdx = isDontCareValue(callInst.getOperand(1)) ? nullptr : callInst.getOperand(1);
 
         if (callInst.arg_size() > 2)
           vertexIdx = isDontCareValue(callInst.getOperand(2)) ? nullptr : callInst.getOperand(2);
 
@@ -703,30 +751,32 @@ void PatchInOutImportExport::visitCallInst(CallInst &callInst) {
           if (isTcs) {
             hasDynIndex = !isa<ConstantInt>(callInst.getOperand(1)) || !isa<ConstantInt>(callInst.getOperand(2));
             if (!hasDynIndex) {
               // TCS input calls at the same location may have dynamic indexing or not
               // Try the key as combination of location and component at first
               origLocInfo.setComponent(cast<ConstantInt>(callInst.getOperand(elemIdxArgIdx))->getZExtValue());
               locInfoMapIt = resUsage->inOutUsage.inputLocInfoMap.find(origLocInfo);
               if (locInfoMapIt == resUsage->inOutUsage.inputLocInfoMap.end()) {
                 // Try the key as the plain location
                 origLocInfo.setComponent(0);
-                locInfoMapIt = resUsage->inOutUsage.inputLocInfoMap.find(origLocInfo);
                 hasDynIndex = true;
               }
-            } else {
-              locInfoMapIt = resUsage->inOutUsage.inputLocInfoMap.find(origLocInfo);
             }
           } else {
             origLocInfo.setComponent(cast<ConstantInt>(callInst.getOperand(elemIdxArgIdx))->getZExtValue());
-            locInfoMapIt = resUsage->inOutUsage.inputLocInfoMap.find(origLocInfo);
+            if (m_shaderStage == ShaderStageFragment && isInterpolantInputImport) {
+              const unsigned interpMode = cast<ConstantInt>(callInst.getOperand(3))->getZExtValue();
+              origLocInfo.setFlat(interpMode == InOutInfo::InterpModeFlat);
+              origLocInfo.setCustom(interpMode == InOutInfo::InterpModeCustom);
+            }
           }
+          locInfoMapIt = resUsage->inOutUsage.inputLocInfoMap.find(origLocInfo);
           assert(locInfoMapIt != resUsage->inOutUsage.inputLocInfoMap.end());
 
           loc = locInfoMapIt->second.getLocation();
           if (!hasDynIndex)
             elemIdx = builder.getInt32(locInfoMapIt->second.getComponent());
           highHalf = locInfoMapIt->second.isHighHalf();
         } else {
           assert(locInfoMapIt != resUsage->inOutUsage.inputLocInfoMap.end());
           loc = locInfoMapIt->second.getLocation();
         }
@@ -1086,47 +1136,49 @@ void PatchInOutImportExport::visitCallInst(CallInst &callInst) {
         default: {
           llvm_unreachable("Should never be called!");
           break;
         }
         }
       }
     }
   } else {
     // Other calls relevant to input/output import/export
     if (callee->isIntrinsic() && callee->getIntrinsicID() == Intrinsic::amdgcn_s_sendmsg) {
-      // NOTE: Implicitly store the value of gl_ViewIndex to GS-VS ring buffer before emit calls.
-      if (m_pipelineState->getInputAssemblyState().enableMultiView) {
-        assert(m_shaderStage == ShaderStageGeometry); // Must be geometry shader
-
-        auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry)->entryArgIdxs.gs;
-        auto viewIndex = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
-
-        auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
-        const auto &builtInOutLocMap = resUsage->inOutUsage.builtInOutputLocMap;
-
-        assert(builtInOutLocMap.find(BuiltInViewIndex) != builtInOutLocMap.end());
-        unsigned loc = builtInOutLocMap.find(BuiltInViewIndex)->second;
-
-        auto rasterStream = resUsage->inOutUsage.gs.rasterStream;
-        storeValueToGsVsRing(viewIndex, loc, 0, rasterStream, &callInst);
-      }
-
       unsigned emitStream = InvalidValue;
-
       uint64_t message = cast<ConstantInt>(callInst.getArgOperand(0))->getZExtValue();
       if (message == GsEmitStreaM0 || message == GsEmitStreaM1 || message == GsEmitStreaM2 ||
           message == GsEmitStreaM3) {
         // NOTE: MSG[9:8] = STREAM_ID
         emitStream = (message & GsEmitCutStreamIdMask) >> GsEmitCutStreamIdShift;
       }
 
       if (emitStream != InvalidValue) {
+        assert(m_shaderStage == ShaderStageGeometry); // Must be geometry shader
+
+        // NOTE: Implicitly store the value of view index to GS-VS ring buffer for raster stream if multi-view is
+        // enabled. Copy shader will read the value from GS-VS ring and export it to vertex position data.
+        if (m_pipelineState->getInputAssemblyState().enableMultiView) {
+          auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry);
+          auto rasterStream = resUsage->inOutUsage.gs.rasterStream;
+
+          if (emitStream == rasterStream) {
+            auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry)->entryArgIdxs.gs;
+            auto viewIndex = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+
+            const auto &builtInOutLocMap = resUsage->inOutUsage.builtInOutputLocMap;
+            assert(builtInOutLocMap.find(BuiltInViewIndex) != builtInOutLocMap.end());
+            unsigned loc = builtInOutLocMap.find(BuiltInViewIndex)->second;
+
+            storeValueToGsVsRing(viewIndex, loc, 0, rasterStream, &callInst);
+          }
+        }
+
         // Increment emit vertex counter
         auto emitCounterPair = m_pipelineSysValues.get(m_entryPoint)->getEmitCounterPtr();
         auto emitCounterTy = emitCounterPair.first;
         auto emitCounterPtr = emitCounterPair.second[emitStream];
         Value *emitCounter = new LoadInst(emitCounterTy, emitCounterPtr, "", &callInst);
         emitCounter =
             BinaryOperator::CreateAdd(emitCounter, ConstantInt::get(Type::getInt32Ty(*m_context), 1), "", &callInst);
         new StoreInst(emitCounter, emitCounterPtr, &callInst);
       }
     }
@@ -1148,21 +1200,21 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
   const bool useExpInst = ((m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
                             m_shaderStage == ShaderStageCopyShader) &&
                            (nextStage == ShaderStageInvalid || nextStage == ShaderStageFragment));
 
   auto zero = ConstantFP::get(Type::getFloatTy(*m_context), 0.0);
   auto one = ConstantFP::get(Type::getFloatTy(*m_context), 1.0);
   auto undef = UndefValue::get(Type::getFloatTy(*m_context));
 
   Instruction *insertPos = &retInst;
 
-  const bool enableXfb = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage.enableXfb;
+  const bool enableXfb = m_pipelineState->enableXfb();
   if (m_shaderStage == ShaderStageCopyShader && enableXfb) {
     if (!m_pipelineState->getNggControl()->enableNgg) {
       // NOTE: For copy shader, if transform feedback is enabled for multiple streams, the following processing doesn't
       // happen in return block. Rather, they happen in the switch-case branch for the raster stream. See the following:
       //
       //   copyShader() {
       //     ...
       //     switch(streamId) {
       //     case 0:
       //       export outputs of stream 0
@@ -1225,82 +1277,72 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
     bool usePointSize = false;
     bool usePrimitiveId = false;
     bool useLayer = false;
     bool useViewportIndex = false;
     bool useShadingRate = false;
     unsigned clipDistanceCount = 0;
     unsigned cullDistanceCount = 0;
 
     auto &inOutUsage = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage;
 
-    const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
-
     if (m_shaderStage == ShaderStageVertex) {
       auto &builtInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageVertex)->builtInUsage.vs;
-      auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageVertex)->entryArgIdxs.vs;
 
       usePosition = builtInUsage.position;
       usePointSize = builtInUsage.pointSize;
       usePrimitiveId = builtInUsage.primitiveId;
       useLayer = builtInUsage.layer;
       useViewportIndex = builtInUsage.viewportIndex;
       useShadingRate = builtInUsage.primitiveShadingRate;
       clipDistanceCount = builtInUsage.clipDistance;
       cullDistanceCount = builtInUsage.cullDistance;
-
-      if (enableMultiView) {
-        // NOTE: If multi-view is enabled, the exported value of gl_Layer is from gl_ViewIndex.
-        m_layer = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
-      }
     } else if (m_shaderStage == ShaderStageTessEval) {
       auto &builtInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageTessEval)->builtInUsage.tes;
-      auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageTessEval)->entryArgIdxs.tes;
 
       usePosition = builtInUsage.position;
       usePointSize = builtInUsage.pointSize;
       usePrimitiveId = builtInUsage.primitiveId;
       useLayer = builtInUsage.layer;
       useViewportIndex = builtInUsage.viewportIndex;
       clipDistanceCount = builtInUsage.clipDistance;
       cullDistanceCount = builtInUsage.cullDistance;
-
-      if (enableMultiView) {
-        // NOTE: If multi-view is enabled, the exported value of gl_Layer is from gl_ViewIndex.
-        m_layer = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
-      }
     } else {
       assert(m_shaderStage == ShaderStageCopyShader);
       auto &builtInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageCopyShader)->builtInUsage.gs;
 
       usePosition = builtInUsage.position;
       usePointSize = builtInUsage.pointSize;
       usePrimitiveId = builtInUsage.primitiveId;
       useLayer = builtInUsage.layer;
       useViewportIndex = builtInUsage.viewportIndex;
       useShadingRate = builtInUsage.primitiveShadingRate;
       clipDistanceCount = builtInUsage.clipDistance;
       cullDistanceCount = builtInUsage.cullDistance;
     }
 
-    useLayer = enableMultiView || useLayer;
+    const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
+    if (enableMultiView) {
+      if (m_shaderStage == ShaderStageVertex) {
+        auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageVertex)->entryArgIdxs.vs;
+        m_viewIndex = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+      } else if (m_shaderStage == ShaderStageTessEval) {
+        auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageTessEval)->entryArgIdxs.tes;
+        m_viewIndex = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+      } else {
+        assert(m_shaderStage == ShaderStageCopyShader);
+        assert(m_viewIndex); // Must have been explicitly loaded in copy shader
+      }
+    }
 
     const auto &builtInOutLocs =
         m_shaderStage == ShaderStageCopyShader ? inOutUsage.gs.builtInOutLocs : inOutUsage.builtInOutputLocMap;
     const auto &nextBuiltInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs;
-    if (nextStage == ShaderStageFragment) {
-      useLayer |= nextBuiltInUsage.layer || nextBuiltInUsage.viewIndex;
-      if (useLayer && !m_layer) {
-        // Multi-view is disabled and vertex process stages don't use gl_ViewIndex/gl_Layer,
-        // but FS uses them, the value will be zero.
-        m_layer = ConstantInt::get(Type::getInt32Ty(*m_context), 0);
-      }
-    }
 
     // NOTE: If gl_Position is not present in this shader stage, we have to export a dummy one.
     if (!usePosition) {
       Value *args[] = {
           ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_0), // tgt
           ConstantInt::get(Type::getInt32Ty(*m_context), 0xF),              // en
           zero,                                                             // src0
           zero,                                                             // src1
           zero,                                                             // src2
           one,                                                              // src3
@@ -1337,22 +1379,21 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
 
       // Do array padding
       if (clipCullDistance.size() <= 4) {
         while (clipCullDistance.size() < 4) // [4 x float]
           clipCullDistance.push_back(undef);
       } else {
         while (clipCullDistance.size() < 8) // [8 x float]
           clipCullDistance.push_back(undef);
       }
 
-      bool miscExport = usePointSize || useLayer || useViewportIndex;
-      miscExport |= useShadingRate;
+      bool miscExport = usePointSize || useLayer || useViewportIndex || useShadingRate || enableMultiView;
       // NOTE: When misc. export is present, gl_ClipDistance[] or gl_CullDistance[] should start from pos2.
       unsigned pos = miscExport ? EXP_TARGET_POS_2 : EXP_TARGET_POS_1;
       Value *args[] = {
           ConstantInt::get(Type::getInt32Ty(*m_context), pos),  // tgt
           ConstantInt::get(Type::getInt32Ty(*m_context), 0xF),  // en
           clipCullDistance[0],                                  // src0
           clipCullDistance[1],                                  // src1
           clipCullDistance[2],                                  // src2
           clipCullDistance[3],                                  // src3
           ConstantInt::get(Type::getInt1Ty(*m_context), false), // done
@@ -1444,36 +1485,46 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
         assert(builtInOutLocs.find(BuiltInPrimitiveId) != builtInOutLocs.end());
         const unsigned loc = builtInOutLocs.find(BuiltInPrimitiveId)->second;
 
         assert(m_primitiveId);
         Value *primitiveId = new BitCastInst(m_primitiveId, Type::getFloatTy(*m_context), "", insertPos);
 
         recordVertexAttribExport(loc, {primitiveId, undef, undef, undef});
       }
     }
 
-    if (m_gfxIp.major <= 8 && useLayer) {
-      assert(m_layer);
-      addExportInstForBuiltInOutput(m_layer, BuiltInLayer, insertPos);
+    if (m_gfxIp.major <= 8 && (useLayer || enableMultiView)) {
+      if (enableMultiView) {
+        assert(m_viewIndex);
+        addExportInstForBuiltInOutput(m_viewIndex, BuiltInViewIndex, insertPos);
+      }
+
+      if (useLayer) {
+        assert(m_layer);
+        addExportInstForBuiltInOutput(m_layer, BuiltInLayer, insertPos);
+      }
     }
 
     // Export gl_Layer and gl_ViewportIndex before entry-point returns
-    if (m_gfxIp.major >= 9 && (useLayer || useViewportIndex)) {
+    if (m_gfxIp.major >= 9 && (useLayer || useViewportIndex || enableMultiView)) {
       Value *viewportIndexAndLayer = ConstantInt::get(Type::getInt32Ty(*m_context), 0);
 
       if (useViewportIndex) {
         assert(m_viewportIndex);
         viewportIndexAndLayer = BinaryOperator::CreateShl(
             m_viewportIndex, ConstantInt::get(Type::getInt32Ty(*m_context), 16), "", insertPos);
       }
 
-      if (useLayer) {
+      if (enableMultiView) {
+        assert(m_viewIndex);
+        viewportIndexAndLayer = BinaryOperator::CreateOr(viewportIndexAndLayer, m_viewIndex, "", insertPos);
+      } else if (useLayer) {
         assert(m_layer);
         viewportIndexAndLayer = BinaryOperator::CreateOr(viewportIndexAndLayer, m_layer, "", insertPos);
       }
 
       viewportIndexAndLayer = new BitCastInst(viewportIndexAndLayer, Type::getFloatTy(*m_context), "", insertPos);
 
       Value *args[] = {
           ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_1), // tgt
           ConstantInt::get(Type::getInt32Ty(*m_context), 0x4),              // en
           undef,                                                            // src0
@@ -1500,42 +1551,34 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
           const unsigned loc = builtInOutLocs.find(BuiltInViewportIndex)->second;
 
           Value *viewportIndex = new BitCastInst(m_viewportIndex, Type::getFloatTy(*m_context), "", insertPos);
 
           recordVertexAttribExport(loc, {viewportIndex, undef, undef, undef});
         }
       }
 
       // NOTE: We have to export gl_Layer via generic outputs as well.
       if (useLayer) {
+        bool hasLayerExport = true;
         if (nextStage == ShaderStageFragment) {
-          unsigned loc = InvalidValue;
-          Value *layer = nullptr;
-
-          if (nextBuiltInUsage.layer) {
-            assert(builtInOutLocs.find(BuiltInLayer) != builtInOutLocs.end());
-            loc = builtInOutLocs.find(BuiltInLayer)->second;
+          hasLayerExport = nextBuiltInUsage.layer;
+        } else if (nextStage == ShaderStageInvalid) {
+          hasLayerExport = false;
+        }
 
-            layer = new BitCastInst(m_layer, Type::getFloatTy(*m_context), "", insertPos);
-          }
+        if (hasLayerExport) {
+          assert(builtInOutLocs.find(BuiltInLayer) != builtInOutLocs.end());
+          const unsigned loc = builtInOutLocs.find(BuiltInLayer)->second;
 
-          if (nextBuiltInUsage.viewIndex) {
-            assert(builtInOutLocs.find(BuiltInViewIndex) != builtInOutLocs.end());
-            loc = builtInOutLocs.find(BuiltInViewIndex)->second;
+          Value *layer = new BitCastInst(m_layer, Type::getFloatTy(*m_context), "", insertPos);
 
-            if (enableMultiView)
-              layer = new BitCastInst(m_layer, Type::getFloatTy(*m_context), "", insertPos);
-            else
-              layer = ConstantFP::get(Type::getFloatTy(*m_context), 0.0f);
-          }
-          if (layer)
-            recordVertexAttribExport(loc, {layer, undef, undef, undef});
+          recordVertexAttribExport(loc, {layer, undef, undef, undef});
         }
       }
     }
 
     // NOTE: For GFX10+, dummy generic output is no longer needed. Field NO_PC_EXPORT of SPI_VS_OUT_CONFIG
     // will control the behavior.
     if (m_gfxIp.major <= 9) {
       // NOTE: If no generic outputs is present in this shader, we have to export a dummy one
       if (inOutUsage.expCount == 0)
         recordVertexAttribExport(0, {undef, undef, undef, undef});
@@ -1549,20 +1592,27 @@ void PatchInOutImportExport::visitReturnInst(ReturnInst &retInst) {
       // generic outputs that are not written to.  We need to count them in
       // the export count.
       auto resUsage = m_pipelineState->getShaderResourceUsage(m_shaderStage);
       for (const auto &locInfoPair : resUsage->inOutUsage.outputLocInfoMap) {
         const unsigned newLoc = locInfoPair.second.getLocation();
         if (m_expLocs.count(newLoc) != 0)
           continue;
         inOutUsage.expCount = std::max(inOutUsage.expCount, newLoc + 1); // Update export count
       }
     }
+  } else if (m_shaderStage == ShaderStageTessControl) {
+    // NOTE: We will read back tessellation factors from on-chip LDS in later phases and write them to TF buffer.
+    // Add fence and barrier before the return instruction to make sure they have been stored already.
+    SyncScope::ID syncScope = m_context->getOrInsertSyncScopeID("workgroup");
+    new FenceInst(*m_context, AtomicOrdering::Release, syncScope, insertPos);
+    emitCall("llvm.amdgcn.s.barrier", Type::getVoidTy(*m_context), {}, {}, insertPos);
+    new FenceInst(*m_context, AtomicOrdering::Acquire, syncScope, insertPos);
   } else if (m_shaderStage == ShaderStageGeometry) {
     if (m_gfxIp.major >= 10) {
       // NOTE: Per programming guide, we should do a "s_waitcnt 0,0,0 + s_waitcnt_vscnt 0" before issuing a "done", so
       // we use fence release to generate s_waitcnt vmcnt lgkmcnt/s_waitcnt_vscnt before s_sendmsg(MSG_GS_DONE)
       SyncScope::ID scope =
           m_pipelineState->isGsOnChip() ? m_context->getOrInsertSyncScopeID("workgroup") : SyncScope::System;
       new FenceInst(*m_context, AtomicOrdering::Release, scope, insertPos);
     }
 
     auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageGeometry)->entryArgIdxs.gs;
@@ -1654,20 +1704,35 @@ Value *PatchInOutImportExport::patchGsGenericInputImport(Type *inputTy, unsigned
 // @param builder : The IR builder to create and insert IR instruction
 // @param attr : The attribute location to access
 // @param channel: The specific attribute channel to access
 // @param coordI: Value of I coordinate
 // @param coordJ: Value of J coordinate
 // @param primMask: Value to fill into m0 register
 Value *PatchInOutImportExport::performFsFloatInterpolation(BuilderBase &builder, Value *attr, Value *channel,
                                                            Value *coordI, Value *coordJ, Value *primMask) {
   Value *result = nullptr;
   Attribute::AttrKind attribs[] = {Attribute::ReadNone};
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // llvm.amdgcn.lds.param.load(attr_channel, attr, m0)
+    Value *param =
+        builder.CreateNamedCall("llvm.amdgcn.lds.param.load", builder.getFloatTy(), {channel, attr, primMask}, attribs);
+
+    // tmp = llvm.amdgcn.interp.inreg.p10(p10, coordI, p0)
+    result =
+        builder.CreateNamedCall("llvm.amdgcn.interp.inreg.p10", builder.getFloatTy(), {param, coordI, param}, attribs);
+
+    // llvm.amdgcn.interp.inreg.p2(p20, coordJ, tmp)
+    result =
+        builder.CreateNamedCall("llvm.amdgcn.interp.inreg.p2", builder.getFloatTy(), {param, coordJ, result}, attribs);
+  } else
+#endif
   {
     // llvm.amdgcn.interp.p1(coordI, attr_channel, attr, m0)
     result = builder.CreateNamedCall("llvm.amdgcn.interp.p1", builder.getFloatTy(), {coordI, channel, attr, primMask},
                                      attribs);
 
     // llvm.amdgcn.interp.p2(p1, coordJ, attr_channel, attr, m0)
     result = builder.CreateNamedCall("llvm.amdgcn.interp.p2", builder.getFloatTy(),
                                      {result, coordJ, channel, attr, primMask}, attribs);
   }
   return result;
@@ -1681,20 +1746,35 @@ Value *PatchInOutImportExport::performFsFloatInterpolation(BuilderBase &builder,
 // @param channel: The specific attribute channel to access
 // @param coordI: Value of I coordinate
 // @param coordJ: Value of J coordinate
 // @param primMask: Value to fill into m0 register
 // @param highHalf : Whether it is a high half in a 16-bit attribute
 Value *PatchInOutImportExport::performFsHalfInterpolation(BuilderBase &builder, Value *attr, Value *channel,
                                                           Value *coordI, Value *coordJ, Value *primMask,
                                                           Value *highHalf) {
   Value *result = nullptr;
   Attribute::AttrKind attribs[] = {Attribute::ReadNone};
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // llvm.amdgcn.lds.param.load(attr_channel, attr, m0)
+    Value *param =
+        builder.CreateNamedCall("llvm.amdgcn.lds.param.load", builder.getFloatTy(), {channel, attr, primMask}, attribs);
+
+    // tmp = llvm.amdgcn.interp.inreg.p10.f16(p10, coordI, p0, highHalf)
+    result = builder.CreateNamedCall("llvm.amdgcn.interp.inreg.p10.f16", builder.getFloatTy(),
+                                     {param, coordI, param, highHalf}, attribs);
+
+    // llvm.amdgcn.interp.inreg.p2.f16(p20, coordJ, tmp, highHalf)
+    result = builder.CreateNamedCall("llvm.amdgcn.interp.inreg.p2.f16", builder.getHalfTy(),
+                                     {param, coordJ, result, highHalf}, attribs);
+  } else
+#endif
   {
     // llvm.amdgcn.interp.p1.f16(coordI, attr_channel, attr, highhalf, m0)
     result = builder.CreateNamedCall("llvm.amdgcn.interp.p1.f16", builder.getFloatTy(),
                                      {coordI, channel, attr, highHalf, primMask}, attribs);
 
     // llvm.amdgcn.interp.p2.f16(p1, coordJ, attr_channel, attr, highhalf, m0)
     result = builder.CreateNamedCall("llvm.amdgcn.interp.p2.f16", builder.getHalfTy(),
                                      {result, coordJ, channel, attr, highHalf, primMask}, attribs);
   }
   return result;
@@ -1708,20 +1788,43 @@ Value *PatchInOutImportExport::performFsHalfInterpolation(BuilderBase &builder,
 // @param channel : The specific attribute channel to access
 // @param interpParam : The parameter to load
 // @param primMask : Value to fill into m0 register
 // @param bitWidth : The bitwidth of required data type
 // @param highHalf : Whether it is a high half in a 16-bit attribute
 Value *PatchInOutImportExport::performFsParameterLoad(BuilderBase &builder, Value *attr, Value *channel,
                                                       InterpParam interpParam, Value *primMask, unsigned bitWidth,
                                                       bool highHalf) {
   Value *compValue = nullptr;
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // llvm.amdgcn.lds.param.load(attr_channel, attr, m0)
+    compValue = builder.CreateNamedCall("llvm.amdgcn.lds.param.load", builder.getFloatTy(), {channel, attr, primMask},
+                                        {Attribute::ReadNone});
+    DppCtrl dppCtrl;
+    if (interpParam == INTERP_PARAM_P0)
+      dppCtrl = DppCtrl::DppQuadPerm0000;
+    else if (interpParam == INTERP_PARAM_P10)
+      dppCtrl = DppCtrl::DppQuadPerm1111;
+    else
+      dppCtrl = DppCtrl::DppQuadPerm2222;
+
+    compValue = builder.CreateBitCast(compValue, builder.getInt32Ty());
+    compValue = builder.CreateIntrinsic(Intrinsic::amdgcn_mov_dpp, builder.getInt32Ty(),
+                                        {compValue, builder.getInt32(static_cast<unsigned>(dppCtrl)),
+                                         builder.getInt32(15), builder.getInt32(15), builder.getTrue()});
+    // NOTE: Make mov_dpp and its source instructions run in WQM to make sure the mov_dpp could fetch
+    // correct data from possible inactive lanes.
+    compValue = builder.CreateIntrinsic(Intrinsic::amdgcn_wqm, builder.getInt32Ty(), compValue);
+    compValue = builder.CreateBitCast(compValue, builder.getFloatTy());
+  } else
+#endif
   {
     Value *args[] = {
         builder.getInt32(interpParam), // param
         channel,                       // attr_chan
         attr,                          // attr
         primMask                       // m0
     };
     compValue = builder.CreateNamedCall("llvm.amdgcn.interp.mov", builder.getFloatTy(), args, {Attribute::ReadNone});
   }
   // Two int8s are also packed like 16-bit in a 32-bit channel in previous export stage
@@ -2063,44 +2166,20 @@ void PatchInOutImportExport::patchMeshGenericOutputExport(Value *output, unsigne
     compIdx = builder.CreateShl(compIdx, 1);
   }
 
   outputOffset = builder.CreateAdd(outputOffset, compIdx);
 
   std::string callName(isPerPrimitive ? lgcName::MeshTaskWritePrimitiveOutput : lgcName::MeshTaskWriteVertexOutput);
   callName += getTypeName(outputTy);
   builder.CreateNamedCall(callName, builder.getVoidTy(), {outputOffset, vertexOrPrimitiveIdx, output}, {});
 }
 
-// =====================================================================================================================
-// Patches import calls for built-in inputs of vertex shader.
-//
-// @param inputTy : Type of input value
-// @param builtInId : ID of the built-in variable
-// @param builder : The IR builder to create and insert IR instruction
-Value *PatchInOutImportExport::patchVsBuiltInInputImport(Type *inputTy, unsigned builtInId, BuilderBase &builder) {
-  auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageVertex)->entryArgIdxs.vs;
-
-  switch (builtInId) {
-  // BuiltInVertexIndex, BuiltInInstanceIndex, BuiltInBaseVertex, BuiltInBaseInstance, BuiltInDrawIndex
-  // now handled in InOutBuilder.
-  case BuiltInViewIndex: {
-    if (m_pipelineState->getInputAssemblyState().enableMultiView) {
-      return getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
-    }
-    return builder.getInt32(0);
-  }
-  default:
-    llvm_unreachable("Should never be called!");
-    return UndefValue::get(inputTy);
-  }
-}
-
 // =====================================================================================================================
 // Patches import calls for built-in inputs of tessellation control shader.
 //
 // @param inputTy : Type of input value
 // @param builtInId : ID of the built-in variable
 // @param elemIdx : Index used for array/vector element indexing (could be null)
 // @param vertexIdx : Input array outermost index used for vertex indexing (could be null)
 // @param builder : The IR builder to create and insert IR instruction
 Value *PatchInOutImportExport::patchTcsBuiltInInputImport(Type *inputTy, unsigned builtInId, Value *elemIdx,
                                                           Value *vertexIdx, BuilderBase &builder) {
@@ -2160,21 +2239,24 @@ Value *PatchInOutImportExport::patchTcsBuiltInInputImport(Type *inputTy, unsigne
   }
   case BuiltInPrimitiveId: {
     input = m_pipelineSysValues.get(m_entryPoint)->getPrimitiveId();
     break;
   }
   case BuiltInInvocationId: {
     input = m_pipelineSysValues.get(m_entryPoint)->getInvocationId();
     break;
   }
   case BuiltInViewIndex: {
-    input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    else
+      input = builder.getInt32(0);
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
   }
   }
 
   return input;
 }
@@ -2283,21 +2365,24 @@ Value *PatchInOutImportExport::patchTesBuiltInInputImport(Type *inputTy, unsigne
         input = builder.CreateInsertValue(input, elem, {i});
       }
     } else {
       auto ldsOffset = calcLdsOffsetForTesInput(inputTy, loc, nullptr, elemIdx, vertexIdx, builder);
       input = readValueFromLds(m_pipelineState->isTessOffChip(), inputTy, ldsOffset, builder);
     }
 
     break;
   }
   case BuiltInViewIndex: {
-    input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    else
+      input = builder.getInt32(0);
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
   }
   }
 
   return input;
 }
@@ -2329,21 +2414,24 @@ Value *PatchInOutImportExport::patchGsBuiltInInputImport(Type *inputTy, unsigned
   }
   case BuiltInPrimitiveId: {
     input = getFunctionArgument(m_entryPoint, entryArgIdxs.primitiveId);
     break;
   }
   case BuiltInInvocationId: {
     input = getFunctionArgument(m_entryPoint, entryArgIdxs.invocationId);
     break;
   }
   case BuiltInViewIndex: {
-    input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    else
+      input = builder.getInt32(0);
     break;
   }
   // Handle internal-use built-ins
   case BuiltInGsWaveId: {
     input = getFunctionArgument(m_entryPoint, entryArgIdxs.gsWaveId);
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
@@ -2529,40 +2617,45 @@ Value *PatchInOutImportExport::patchFsBuiltInInputImport(Type *inputTy, unsigned
         patchFsBuiltInInputImport(FixedVectorType::get(builder.getFloatTy(), 2), builtInId, nullptr, builder);
     input = patchFsGenericInputImport(inputTy, loc, nullptr, nullptr, false, InOutInfo::InterpModeSmooth, interpValue,
                                       false, builder);
     break;
   }
   case BuiltInHelperInvocation: {
     input = builder.CreateIntrinsic(Intrinsic::amdgcn_ps_live, {}, {});
     input = builder.CreateNot(input);
     break;
   }
+  case BuiltInViewIndex: {
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      input = getFunctionArgument(m_entryPoint, entryArgIdxs.viewIndex);
+    else
+      input = builder.getInt32(0);
+    break;
+  }
   case BuiltInPrimitiveId:
   case BuiltInLayer:
-  case BuiltInViewportIndex:
-  case BuiltInViewIndex: {
+  case BuiltInViewportIndex: {
     unsigned loc = InvalidValue;
     const auto prevStage = m_pipelineState->getPrevShaderStage(ShaderStageFragment);
 
     bool isPerPrimitive = false;
     if (prevStage == ShaderStageMesh) {
       assert(inOutUsage.perPrimitiveBuiltInInputLocMap.count(builtInId) > 0);
       loc = inOutUsage.perPrimitiveBuiltInInputLocMap[builtInId];
       // NOTE: If the previous shader stage is mesh shader, those built-ins are exported via primitive attributes.
       isPerPrimitive = true;
     } else {
       assert(inOutUsage.builtInInputLocMap.count(builtInId) > 0);
       loc = inOutUsage.builtInInputLocMap[builtInId];
     }
 
-    // Emulation for "in int gl_PrimitiveID" or "in int gl_Layer" or "in int gl_ViewportIndex"
-    // or "in int gl_ViewIndex".
+    // Emulation for "in int gl_PrimitiveID" or "in int gl_Layer" or "in int gl_ViewportIndex".
     input = patchFsGenericInputImport(inputTy, loc, nullptr, nullptr, isPerPrimitive, InOutInfo::InterpModeFlat,
                                       nullptr, false, builder);
     break;
   }
   case BuiltInClipDistance:
   case BuiltInCullDistance: {
     assert(inputTy->isArrayTy());
 
     unsigned loc = InvalidValue;
     unsigned locCount = 0;
@@ -2932,29 +3025,34 @@ void PatchInOutImportExport::patchVsBuiltInOutputExport(Value *output, unsigned
         else
           m_cullDistance = output;
       }
     }
 
     break;
   }
   case BuiltInLayer: {
     if (!static_cast<bool>(builtInUsage.layer))
       return;
-    m_layer = output;
+
+    // NOTE: Only last vertex processing shader stage has to export the value of gl_Layer.
+    if (!m_hasTs && !m_hasGs) {
+      // NOTE: The export of gl_Layer is delayed and is done before entry-point returns.
+      m_layer = output;
+    }
 
     break;
   }
   case BuiltInViewportIndex: {
     if (!static_cast<bool>(builtInUsage.viewportIndex))
       return;
 
-    // NOTE: Only last non-fragment shader stage has to export the value of gl_ViewportIndex.
+    // NOTE: Only last vertex processing shader stage has to export the value of gl_ViewportIndex.
     if (!m_hasTs && !m_hasGs) {
       if (m_gfxIp.major <= 8)
         addExportInstForBuiltInOutput(output, builtInId, insertPos);
       else {
         // NOTE: The export of gl_ViewportIndex is delayed and is done before entry-point returns.
         m_viewportIndex = output;
       }
     }
 
     break;
@@ -2989,20 +3087,21 @@ void PatchInOutImportExport::patchVsBuiltInOutputExport(Value *output, unsigned
 // @param insertPos : Where to insert the patch instruction
 void PatchInOutImportExport::patchTcsBuiltInOutputExport(Value *output, unsigned builtInId, Value *elemIdx,
                                                          Value *vertexIdx, Instruction *insertPos) {
   BuilderBase builder(insertPos);
 
   auto outputTy = output->getType();
 
   const auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl);
   const auto &builtInUsage = resUsage->builtInUsage.tcs;
   const auto &builtInOutLocMap = resUsage->inOutUsage.builtInOutputLocMap;
+  const auto &perPatchBuiltInOutLocMap = resUsage->inOutUsage.perPatchBuiltInOutputLocMap;
 
   switch (builtInId) {
   case BuiltInPosition:
   case BuiltInPointSize: {
     if ((builtInId == BuiltInPosition && !builtInUsage.position) ||
         (builtInId == BuiltInPointSize && !builtInUsage.pointSize))
       return;
 
     assert(builtInId != BuiltInPointSize || !elemIdx);
 
@@ -3035,44 +3134,63 @@ void PatchInOutImportExport::patchTcsBuiltInOutputExport(Value *output, unsigned
       }
     } else {
       auto ldsOffset = calcLdsOffsetForTcsOutput(outputTy, loc, nullptr, elemIdx, vertexIdx, builder);
       writeValueToLds(m_pipelineState->isTessOffChip(), output, ldsOffset, builder);
     }
 
     break;
   }
   case BuiltInTessLevelOuter:
   case BuiltInTessLevelInner: {
-    const auto &calcFactor = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor;
     auto relativeId = m_pipelineSysValues.get(m_entryPoint)->getRelativeId();
 
     // tessLevelOuter (float[4]) + tessLevelInner (float[2])
     // ldsOffset = tessFactorStart + relativeId * MaxTessFactorsPerPatch + elemIdx
-    uint32_t tessFactorStart = calcFactor.onChip.tessFactorStart;
+    uint32_t tessFactorStart = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)
+                                   ->inOutUsage.tcs.calcFactor.onChip.tessFactorStart;
     if (builtInId == BuiltInTessLevelInner)
       tessFactorStart += 4;
 
+    // Write tessellation factors to on-chip LDS for later TF buffer store
     Value *baseOffset = builder.CreateMul(relativeId, builder.getInt32(MaxTessFactorsPerPatch));
     if (outputTy->isArrayTy()) {
-      // Export the whole tessLevelOuter array
+      // Handle the whole tessLevelOuter array
       for (unsigned i = 0; i < outputTy->getArrayNumElements(); ++i) {
         Value *ldsOffset = builder.CreateAdd(baseOffset, builder.getInt32(tessFactorStart + i));
         auto elem = builder.CreateExtractValue(output, {i});
         writeValueToLds(false, elem, ldsOffset, builder);
       }
     } else {
-      // Export a single element of tessLevelOuter array
+      // Handle a single element of tessLevelOuter array
       Value *ldsOffset = builder.CreateAdd(baseOffset, builder.getInt32(tessFactorStart));
       ldsOffset = builder.CreateAdd(ldsOffset, elemIdx, "", insertPos);
       writeValueToLds(false, output, ldsOffset, builder);
     }
 
+    // Write tessellation factors for TES to read if needed
+    if (perPatchBuiltInOutLocMap.find(builtInId) != perPatchBuiltInOutLocMap.end()) {
+      unsigned loc = perPatchBuiltInOutLocMap.find(builtInId)->second;
+
+      if (outputTy->isArrayTy()) {
+        // Handle the whole tessLevelOuter array
+        for (unsigned i = 0; i < outputTy->getArrayNumElements(); ++i) {
+          auto ldsOffset = calcLdsOffsetForTcsOutput(outputTy, loc, nullptr, builder.getInt32(i), nullptr, builder);
+          auto elem = builder.CreateExtractValue(output, {i});
+          writeValueToLds(m_pipelineState->isTessOffChip(), elem, ldsOffset, builder);
+        }
+      } else {
+        // Handle a single element of tessLevelOuter array
+        auto ldsOffset = calcLdsOffsetForTcsOutput(outputTy, loc, nullptr, elemIdx, nullptr, builder);
+        writeValueToLds(m_pipelineState->isTessOffChip(), output, ldsOffset, builder);
+      }
+    }
+
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
   }
   }
 }
 
 // =====================================================================================================================
@@ -3141,35 +3259,33 @@ void PatchInOutImportExport::patchTesBuiltInOutputExport(Value *output, unsigned
         llvm_unreachable("unhandled builtInId");
       }
     }
 
     break;
   }
   case BuiltInLayer: {
     if (!static_cast<bool>(builtInUsage.layer))
       return;
 
-    const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
-
-    // NOTE: Only last non-fragment shader stage has to export the value of gl_Layer.
-    if (!m_hasGs && !static_cast<bool>(enableMultiView)) {
+    // NOTE: Only last vertex processing shader stage has to export the value of gl_Layer.
+    if (!m_hasGs) {
       // NOTE: The export of gl_Layer is delayed and is done before entry-point returns.
       m_layer = output;
     }
 
     break;
   }
   case BuiltInViewportIndex: {
     if (!static_cast<bool>(builtInUsage.viewportIndex))
       return;
 
-    // NOTE: Only last non-fragment shader stage has to export the value of gl_ViewportIndex.
+    // NOTE: Only last vertex processing shader stage has to export the value of gl_ViewportIndex.
     if (!m_hasGs) {
       if (m_gfxIp.major <= 8)
         addExportInstForBuiltInOutput(output, builtInId, insertPos);
       else {
         // NOTE: The export of gl_ViewportIndex is delayed and is done before entry-point returns.
         m_viewportIndex = output;
       }
     }
 
     break;
@@ -3406,21 +3522,25 @@ void PatchInOutImportExport::patchCopyShaderBuiltInOutputExport(Value *output, u
     break;
   }
   case BuiltInPrimitiveId: {
     // NOTE: The export of gl_PrimitiveID is delayed and is done before entry-point returns.
     m_primitiveId = output;
     break;
   }
   case BuiltInLayer: {
     // NOTE: The export of gl_Layer is delayed and is done before entry-point returns.
     m_layer = output;
-
+    break;
+  }
+  case BuiltInViewIndex: {
+    // NOTE: The export of gl_ViewIndex is delayed and is done before entry-point returns.
+    m_viewIndex = output;
     break;
   }
   case BuiltInViewportIndex: {
     if (m_gfxIp.major <= 8)
       addExportInstForBuiltInOutput(output, builtInId, insertPos);
     else {
       // NOTE: The export of gl_ViewportIndex is delayed and is done before entry-point returns.
       m_viewportIndex = output;
     }
 
@@ -3448,36 +3568,68 @@ void PatchInOutImportExport::patchCopyShaderBuiltInOutputExport(Value *output, u
 // @param xfbOffset : Transform feedback offset
 // @param streamId : Output stream ID
 // @param insertPos : Where to insert the store instruction
 void PatchInOutImportExport::patchXfbOutputExport(Value *output, unsigned xfbBuffer, unsigned xfbOffset,
                                                   unsigned streamId, Instruction *insertPos) {
   assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
          m_shaderStage == ShaderStageCopyShader);
 
   Value *streamOutBufDesc = m_pipelineSysValues.get(m_entryPoint)->getStreamOutBufDesc(xfbBuffer);
 
-  const auto &xfbStrides = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage.xfbStrides;
+  const auto &xfbStrides = m_pipelineState->getXfbBufferStrides();
   unsigned xfbStride = xfbStrides[xfbBuffer];
 
   auto outputTy = output->getType();
   unsigned compCount = outputTy->isVectorTy() ? cast<FixedVectorType>(outputTy)->getNumElements() : 1;
   unsigned bitWidth = outputTy->getScalarSizeInBits();
 
   if (bitWidth == 64) {
     // Cast 64-bit output to 32-bit
     compCount *= 2;
     bitWidth = 32;
     outputTy = FixedVectorType::get(Type::getFloatTy(*m_context), compCount);
     output = new BitCastInst(output, outputTy, "", insertPos);
   }
   assert(bitWidth == 16 || bitWidth == 32);
 
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->enableSwXfb() && m_shaderStage == ShaderStageCopyShader) {
+    // NOTE: For NGG, importing GS output from GS-VS ring is represented by a call and the call is replaced with
+    // real instructions when when NGG primitive shader is generated.
+    if (compCount > 4) {
+      CallInst *importCall = cast<CallInst>(output);
+      assert(importCall != nullptr);
+      unsigned location = cast<ConstantInt>(importCall->getArgOperand(0))->getZExtValue();
+
+      // vecX -> vec4 + vec(X - 4)
+      assert(compCount <= 8);
+      Type *loadTy = FixedVectorType::get(Type::getFloatTy(*m_context), 4);
+      Value *args[] = {ConstantInt::get(Type::getInt32Ty(*m_context), location),
+                       ConstantInt::get(Type::getInt32Ty(*m_context), streamId)};
+      output = emitCall(lgcName::NggGsOutputImport + getTypeName(loadTy), loadTy, args,
+                        {Attribute::Speculatable, Attribute::ReadOnly, Attribute::WillReturn}, insertPos);
+      storeValueToStreamOutBuffer(output, xfbBuffer, xfbOffset, xfbStride, streamId, streamOutBufDesc, insertPos);
+
+      loadTy = FixedVectorType::get(Type::getFloatTy(*m_context), (compCount - 4));
+      args[0] = ConstantInt::get(Type::getInt32Ty(*m_context), location + 1);
+      output = emitCall(lgcName::NggGsOutputImport + getTypeName(loadTy), loadTy, args,
+                        {Attribute::Speculatable, Attribute::ReadOnly, Attribute::WillReturn}, insertPos);
+      storeValueToStreamOutBuffer(output, xfbBuffer, xfbOffset + 4 * bitWidth / 8, xfbStride, streamId,
+                                  streamOutBufDesc, insertPos);
+    } else {
+      storeValueToStreamOutBuffer(output, xfbBuffer, xfbOffset, xfbStride, streamId, streamOutBufDesc, insertPos);
+    }
+
+    return;
+  }
+#endif
+
   if (compCount == 8) {
     // vec8 -> vec4 + vec4
     assert(bitWidth == 32);
 
     Constant *shuffleMask0123[] = {
         ConstantInt::get(Type::getInt32Ty(*m_context), 0), ConstantInt::get(Type::getInt32Ty(*m_context), 1),
         ConstantInt::get(Type::getInt32Ty(*m_context), 2), ConstantInt::get(Type::getInt32Ty(*m_context), 3)};
     Value *compX4 = new ShuffleVectorInst(output, output, ConstantVector::get(shuffleMask0123), "", insertPos);
 
     storeValueToStreamOutBuffer(compX4, xfbBuffer, xfbOffset, xfbStride, streamId, streamOutBufDesc, insertPos);
@@ -3630,20 +3782,33 @@ void PatchInOutImportExport::createStreamOutBufferStoreFunction(Value *storeValu
   case 10: {
     static unsigned char formatTable[4][2] = {
         {BUF_FORMAT_16_FLOAT, BUF_FORMAT_32_FLOAT},
         {BUF_FORMAT_16_16_FLOAT, BUF_FORMAT_32_32_FLOAT_GFX10},
         {BUF_FORMAT_INVALID, BUF_FORMAT_32_32_32_FLOAT_GFX10},
         {BUF_FORMAT_16_16_16_16_FLOAT_GFX10, BUF_FORMAT_32_32_32_32_FLOAT_GFX10},
     };
     format = formatTable[compCount - 1][bitWidth == 32];
     break;
   }
+#if LLPC_BUILD_GFX11
+  case 11: {
+    static unsigned char formatTable[5][2] = {
+        {},
+        {BUF_FORMAT_16_FLOAT, BUF_FORMAT_32_FLOAT},
+        {BUF_FORMAT_16_16_FLOAT, BUF_FORMAT_32_32_FLOAT_GFX11},
+        {},
+        {BUF_FORMAT_16_16_16_16_FLOAT_GFX11, BUF_FORMAT_32_32_32_32_FLOAT_GFX11},
+    };
+    format = formatTable[compCount][bitWidth == 32];
+    break;
+  }
+#endif
   }
 
   // byteOffset = streamOffsets[xfbBuffer] * 4 +
   //              (writeIndex + threadId) * bufferStride[bufferId] +
   //              xfbOffset
   CoherentFlag coherent = {};
   coherent.bits.glc = true;
   coherent.bits.slc = true;
   Value *args[] = {
       storedValue,                                                    // value
@@ -3782,20 +3947,36 @@ unsigned PatchInOutImportExport::combineBufferLoad(std::vector<Value *> &loadVal
 // @param storeValue : Value to store
 // @param xfbBuffer : Transform feedback buffer
 // @param xfbOffset : Offset of the store value within transform feedback buffer
 // @param xfbStride : Transform feedback stride
 // @param streamId : Output stream ID
 // @param streamOutBufDesc : Transform feedback buffer descriptor
 // @param insertPos : Where to insert the store instruction
 void PatchInOutImportExport::storeValueToStreamOutBuffer(Value *storeValue, unsigned xfbBuffer, unsigned xfbOffset,
                                                          unsigned xfbStride, unsigned streamId, Value *streamOutBufDesc,
                                                          Instruction *insertPos) {
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->enableSwXfb()) {
+    // NOTE: For GFX11+, exporting transform feedback outputs is represented by a call and the call is replaced with
+    // real instructions when when NGG primitive shader is generated.
+    auto xfbBufOffset = m_pipelineSysValues.get(m_entryPoint)->getStreamOutBufOffset(xfbBuffer);
+    Value *args[] = {streamOutBufDesc,
+                     xfbBufOffset,
+                     ConstantInt::get(Type::getInt32Ty(*m_context), xfbBuffer),
+                     ConstantInt::get(Type::getInt32Ty(*m_context), xfbOffset),
+                     ConstantInt::get(Type::getInt32Ty(*m_context), streamId),
+                     storeValue};
+    std::string callName = lgcName::NggXfbOutputExport + getTypeName(storeValue->getType());
+    emitCall(callName, Type::getVoidTy(*m_context), args, {}, insertPos);
+    return;
+  }
+#endif
 
   auto storeTy = storeValue->getType();
 
   unsigned compCount = storeTy->isVectorTy() ? cast<FixedVectorType>(storeTy)->getNumElements() : 1;
   assert(compCount <= 4);
 
   const uint64_t bitWidth = storeTy->getScalarSizeInBits();
   assert(bitWidth == 16 || bitWidth == 32);
 
   if (storeTy->isIntOrIntVectorTy()) {
@@ -3837,25 +4018,25 @@ void PatchInOutImportExport::storeValueToStreamOutBuffer(Value *storeValue, unsi
   } else if (m_shaderStage == ShaderStageTessEval) {
     memcpy(streamOffsets, entryArgIdxs.tes.streamOutData.streamOffsets, sizeof(streamOffsets));
     writeIndex = entryArgIdxs.tes.streamOutData.writeIndex;
     streamInfo = entryArgIdxs.tes.streamOutData.streamInfo;
   } else {
     assert(m_shaderStage == ShaderStageCopyShader);
 
     writeIndex = CopyShaderUserSgprIdxWriteIndex;
     streamInfo = CopyShaderUserSgprIdxStreamInfo;
 
-    const auto &inoutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageGeometry)->inOutUsage;
+    const auto &xfbStrides = m_pipelineState->getXfbBufferStrides();
     unsigned streamOffset = CopyShaderUserSgprIdxStreamOffset;
 
     for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
-      if (inoutUsage.xfbStrides[i] > 0)
+      if (xfbStrides[i] > 0)
         streamOffsets[i] = streamOffset++;
     }
   }
 
   assert(xfbBuffer < MaxTransformFeedbackBuffers);
   assert(streamOffsets[xfbBuffer] != 0);
 
   Value *streamOffset = getFunctionArgument(m_entryPoint, streamOffsets[xfbBuffer]);
 
   streamOffset =
@@ -4351,21 +4532,28 @@ Value *PatchInOutImportExport::readValueFromLds(bool offChip, Type *readTy, Valu
 
     // Convert dword off-chip LDS offset to byte offset
     ldsOffset = builder.CreateMul(ldsOffset, builder.getInt32(4));
 
     CoherentFlag coherent = {};
     if (m_gfxIp.major <= 9)
       coherent.bits.glc = true;
     else if (m_gfxIp.major == 10) {
       coherent.bits.glc = true;
       coherent.bits.dlc = true;
-    } else
+    }
+#if LLPC_BUILD_GFX11
+    else if (m_gfxIp.major == 11) {
+      // NOTE: dlc depends on MALL NOALLOC which isn't used by now.
+      coherent.bits.glc = true;
+    }
+#endif
+    else
       llvm_unreachable("Not implemented!");
 
     for (unsigned i = 0, combineCount = 0; i < numChannels; i += combineCount)
       combineCount = combineBufferLoad(loadValues, i, offChipLdsDesc, ldsOffset, offChipLdsBase, coherent, builder);
   } else {
     // Read from on-chip LDS
     for (unsigned i = 0; i < numChannels; ++i) {
       Value *idxs[] = {builder.getInt32(0), ldsOffset};
       auto ldsType = m_lds->getValueType();
       auto *loadPtr = builder.CreateGEP(ldsType, m_lds, idxs);
@@ -4740,20 +4928,31 @@ unsigned PatchInOutImportExport::calcPatchCountPerThreadGroup(unsigned inVertexC
   const unsigned patchCountLimitedByThread = maxThreadCountPerThreadGroup / maxThreadCountPerPatch;
 
   const unsigned inPatchSize = (inVertexCount * inVertexStride);
   const unsigned outPatchSize = (outVertexCount * outVertexStride);
   const unsigned patchConstSize = patchConstCount * 4;
 
   // Compute the required LDS size per patch, always include the space for input patch and tess factor
   unsigned ldsSizePerPatch = inPatchSize + MaxTessFactorsPerPatch;
 
   unsigned ldsSizePerThreadGroup = m_pipelineState->getTargetInfo().getGpuProperty().ldsSizePerThreadGroup;
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->canOptimizeTessFactor()) {
+    // NOTE: If we are going to optimize TF store, we need additional on-chip LDS size. The required size is
+    // 2 dwords per HS wave (1 dword all-ones flag or 1 dword all-zeros flag) plus an extra dword to
+    // count actual HS patches.
+    assert(m_gfxIp.major >= 11);
+    const unsigned maxNumHsWaves =
+        Gfx9::MaxHsThreadsPerSubgroup / m_pipelineState->getMergedShaderWaveSize(ShaderStageTessControl);
+    ldsSizePerThreadGroup -= 1 + maxNumHsWaves * 2;
+  }
+#endif
 #if VKI_RAY_TRACING
   ldsSizePerThreadGroup -= rayQueryLdsStackSize; // Exclude LDS space used as ray query stack
 #endif
   unsigned patchCountLimitedByLds = ldsSizePerThreadGroup / ldsSizePerPatch;
 
   unsigned patchCountPerThreadGroup = std::min(patchCountLimitedByThread, patchCountLimitedByLds);
 
   // NOTE: Performance analysis shows that 16 patches per thread group is an optimal upper-bound. The value is only
   // an experimental number. For GFX9. 64 is an optimal number instead.
   const unsigned optimalPatchCountPerThreadGroup = m_gfxIp.major >= 9 ? 64 : 16;
@@ -4969,58 +5168,53 @@ void PatchInOutImportExport::addExportInstForBuiltInOutput(Value *output, unsign
         undef,                                                            // src3
         ConstantInt::get(Type::getInt1Ty(*m_context), false),             // done
         ConstantInt::get(Type::getInt1Ty(*m_context), false)              // vm
     };
     emitCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {}, insertPos);
     break;
   }
   case BuiltInLayer: {
     assert(m_gfxIp.major <= 8); // For GFX9, gl_ViewportIndex and gl_Layer are packed
 
-    const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
-
     Value *layer = new BitCastInst(output, Type::getFloatTy(*m_context), "", insertPos);
 
-    Value *args[] = {
-        ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_1), // tgt
-        ConstantInt::get(Type::getInt32Ty(*m_context), 0x4),              // en
-        undef,                                                            // src0
-        undef,                                                            // src1
-        layer,                                                            // src2
-        undef,                                                            // src3
-        ConstantInt::get(Type::getInt1Ty(*m_context), false),             // done
-        ConstantInt::get(Type::getInt1Ty(*m_context), false)              // vm
-    };
-    emitCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {}, insertPos);
+    // NOTE: Only export gl_Layer when multi-view is disabled. Otherwise, we will export gl_ViewIndex to vertex position
+    // data.
+    const auto enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
+    if (!enableMultiView) {
+      Value *args[] = {
+          ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_1), // tgt
+          ConstantInt::get(Type::getInt32Ty(*m_context), 0x4),              // en
+          undef,                                                            // src0
+          undef,                                                            // src1
+          layer,                                                            // src2
+          undef,                                                            // src3
+          ConstantInt::get(Type::getInt1Ty(*m_context), false),             // done
+          ConstantInt::get(Type::getInt1Ty(*m_context), false)              // vm
+      };
+      emitCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {}, insertPos);
+    }
 
     // NOTE: We have to export gl_Layer via generic outputs as well.
+    bool hasLayerExport = true;
     if (nextStage == ShaderStageFragment) {
       const auto &nextBuiltInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs;
-      unsigned loc = InvalidValue;
-      Value *layer = nullptr;
-      if (nextBuiltInUsage.layer) {
-        assert(builtInOutLocs.find(BuiltInLayer) != builtInOutLocs.end());
-        loc = builtInOutLocs.find(BuiltInLayer)->second;
-        layer = new BitCastInst(output, Type::getFloatTy(*m_context), "", insertPos);
-      }
+      hasLayerExport = nextBuiltInUsage.layer;
+    } else if (nextStage == ShaderStageInvalid) {
+      hasLayerExport = false;
+    }
 
-      if (nextBuiltInUsage.viewIndex) {
-        assert(builtInOutLocs.find(BuiltInViewIndex) != builtInOutLocs.end());
-        loc = builtInOutLocs.find(BuiltInViewIndex)->second;
+    if (hasLayerExport) {
+      assert(builtInOutLocs.find(BuiltInLayer) != builtInOutLocs.end());
+      const unsigned loc = builtInOutLocs.find(BuiltInLayer)->second;
 
-        if (enableMultiView)
-          layer = new BitCastInst(output, Type::getFloatTy(*m_context), "", insertPos);
-        else
-          layer = ConstantFP::get(Type::getFloatTy(*m_context), 0.0f);
-      }
-      if (layer)
-        recordVertexAttribExport(loc, {layer, undef, undef, undef});
+      recordVertexAttribExport(loc, {layer, undef, undef, undef});
     }
 
     break;
   }
   case BuiltInViewportIndex: {
     assert(m_gfxIp.major <= 8); // For GFX9, gl_ViewportIndex and gl_Layer are packed
     Value *viewportIndex = new BitCastInst(output, Type::getFloatTy(*m_context), "", insertPos);
 
     Value *args[] = {
         ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_1), // tgt
@@ -5031,35 +5225,53 @@ void PatchInOutImportExport::addExportInstForBuiltInOutput(Value *output, unsign
         viewportIndex,                                                    // src3
         ConstantInt::get(Type::getInt1Ty(*m_context), false),             // done
         ConstantInt::get(Type::getInt1Ty(*m_context), false)              // vm
     };
     emitCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {}, insertPos);
 
     // NOTE: We have to export gl_ViewportIndex via generic outputs as well.
     bool hasViewportIndexExport = true;
     if (nextStage == ShaderStageFragment) {
       const auto &nextBuiltInUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->builtInUsage.fs;
-
       hasViewportIndexExport = nextBuiltInUsage.viewportIndex;
     } else if (nextStage == ShaderStageInvalid) {
       hasViewportIndexExport = false;
     }
 
     if (hasViewportIndexExport) {
       assert(builtInOutLocs.find(BuiltInViewportIndex) != builtInOutLocs.end());
       const unsigned loc = builtInOutLocs.find(BuiltInViewportIndex)->second;
 
       recordVertexAttribExport(loc, {viewportIndex, undef, undef, undef});
     }
 
     break;
   }
+  case BuiltInViewIndex: {
+    assert(m_gfxIp.major <= 8); // For GFX9, gl_ViewportIndex and gl_ViewIndex are packed
+
+    Value *viewIndex = new BitCastInst(output, Type::getFloatTy(*m_context), "", insertPos);
+
+    Value *args[] = {
+        ConstantInt::get(Type::getInt32Ty(*m_context), EXP_TARGET_POS_1), // tgt
+        ConstantInt::get(Type::getInt32Ty(*m_context), 0x4),              // en
+        undef,                                                            // src0
+        undef,                                                            // src1
+        viewIndex,                                                        // src2
+        undef,                                                            // src3
+        ConstantInt::get(Type::getInt1Ty(*m_context), false),             // done
+        ConstantInt::get(Type::getInt1Ty(*m_context), false)              // vm
+    };
+    emitCall("llvm.amdgcn.exp.f32", Type::getVoidTy(*m_context), args, {}, insertPos);
+
+    break;
+  }
   case BuiltInPrimitiveShadingRate: {
     // gl_PrimitiveShadingRate is not supported on pre-GFX10.3
     assert(m_gfxIp >= GfxIpVersion({10, 3}));
 
     exportShadingRate(output, insertPos);
     break;
   }
   default: {
     llvm_unreachable("Should never be called!");
     break;
@@ -5463,21 +5675,21 @@ void PatchInOutImportExport::createSwizzleThreadGroupFunction() {
 
   BuilderBase builder(*m_context);
 
   Type *ivec3Ty = FixedVectorType::get(Type::getInt32Ty(*m_context), 3);
 
   auto func = m_module->getFunction(lgcName::SwizzleWorkgroupId);
 
   func->setCallingConv(CallingConv::C);
   func->addFnAttr(Attribute::NoUnwind);
   func->addFnAttr(Attribute::AlwaysInline);
-  func->addFnAttr(Attribute::ReadNone);
+  func->setDoesNotAccessMemory();
   func->setLinkage(GlobalValue::InternalLinkage);
 
   auto argIt = func->arg_begin();
 
   Value *numWorkgroups = argIt++;
   numWorkgroups->setName("numWorkgroups");
 
   Value *nativeWorkgroupId = argIt++;
   nativeWorkgroupId->setName("nativeWorkgroupId");
 
@@ -5714,20 +5926,53 @@ void PatchInOutImportExport::createSwizzleThreadGroupFunction() {
 // @param shadingRate : LGC shading rate
 // @param insertPos : Where to insert instructions.
 void PatchInOutImportExport::exportShadingRate(Value *shadingRate, Instruction *insertPos) {
   BuilderBase builder(*m_context);
   builder.SetInsertPoint(insertPos);
 
   assert(m_gfxIp >= GfxIpVersion({10, 3})); // Must be GFX10.3+
 
   Value *hwShadingRate = nullptr;
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // NOTE: In GFX11, the graphics pipeline is to support VRS rates till 4x4 which includes 2x4 and 4x2 along with
+    // the legacy rates. And 1x4 and 4x1 are not supported, hence clamp 1x4 and 4x1 to 1x2 and 2x1 respectively.
+    // The HW shading rate representations are as following:
+    //     SHADING_RATE_1x1    0x0
+    //     SHADING_RATE_1x2    0x1
+    //     SHADING_RATE_2x1    0x4
+    //     SHADING_RATE_2x2    0x5
+    //     SHADING_RATE_2x4    0x6
+    //     SHADING_RATE_4x2    0x9
+    //     SHADING_RATE_4x4    0xA
+    //
+    // [5:2] = HW rate enum
+    // hwShadingRate = shadingRate & (ShadingRateHorizontal2Pixels | ShadingRateHorizontal4Pixels |
+    //                                 ShadingRateVertical2Pixels | ShadingRateVertical4Pixels)
+    hwShadingRate =
+        builder.CreateAnd(shadingRate, builder.getInt32(ShadingRateHorizontal2Pixels | ShadingRateHorizontal4Pixels |
+                                                        ShadingRateVertical2Pixels | ShadingRateVertical4Pixels));
+
+    // hwShadingRate = hwShadingRate == 1x4 ? 1x2 : hwShadingRate
+    Value *shadingRate1x4 = builder.CreateICmpEQ(hwShadingRate, builder.getInt32(2));
+    hwShadingRate = builder.CreateSelect(shadingRate1x4, builder.getInt32(1), hwShadingRate);
+
+    // hwShadingRate = hwShadingRate == 4x1 ? 2x1 : hwShadingRate
+    Value *shadingRate4x1 = builder.CreateICmpEQ(hwShadingRate, builder.getInt32(8));
+    hwShadingRate = builder.CreateSelect(shadingRate4x1, builder.getInt32(4), hwShadingRate);
+
+    // hwShadingRate = hwShadingRate << 2
+    hwShadingRate = builder.CreateShl(hwShadingRate, 2);
+    hwShadingRate = builder.CreateBitCast(hwShadingRate, builder.getFloatTy());
+  } else
+#endif
   {
     // NOTE: The shading rates have different meanings in HW and LGC interface. Current HW only supports 2-pixel mode
     // and 4-pixel mode is not supported. But the spec requires us to accept unsupported rates and clamp them to
     // maxFragmentSize of HW. The mapping is therefore as follow:
     //
     //   VRS X rate: MaskNone -> 0b00, Horizontal2Pixels | Horizontal4Pixels -> 0b01
     //   VRS Y rate: MaskNone -> 0b00, Vertical2Pixels | Vertical4Pixels -> 0b01
     //
     // xRate = (shadingRate & (Horizontal2Pixels | Horizontal4Pixels) ? 0x1 : 0x0
     Value *xRate2Pixels =
@@ -5775,20 +6020,40 @@ Value *PatchInOutImportExport::getShadingRate(Instruction *insertPos) {
   assert(m_shaderStage == ShaderStageFragment);
   auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageFragment)->entryArgIdxs.fs;
   auto ancillary = getFunctionArgument(m_entryPoint, entryArgIdxs.ancillary);
 
   // Y rate = Ancillary[5:4], X rate = Ancillary[3:2]
   Value *xRate = builder.CreateAnd(ancillary, 0xC);
   xRate = builder.CreateLShr(xRate, 2);
   Value *yRate = builder.CreateAnd(ancillary, 0x30);
   yRate = builder.CreateLShr(yRate, 4);
 
+#if LLPC_BUILD_GFX11
+  if (m_gfxIp.major >= 11) {
+    // NOTE: In GFX11, the graphics pipeline is to support VRS rates till 4x4 which includes 2x4 and 4x2
+    // along with the legacy rates.
+    //
+    // xRate = xRate == 0x1 ? Horizontal2Pixels : (xRate == 0x2 ? Horizontal4Pixels : None)
+    auto xRate2Pixels = builder.CreateICmpEQ(xRate, builder.getInt32(1));
+    auto xRate4Pixels = builder.CreateICmpEQ(xRate, builder.getInt32(2));
+    xRate = builder.CreateSelect(xRate2Pixels, builder.getInt32(ShadingRateHorizontal2Pixels),
+                                 builder.CreateSelect(xRate4Pixels, builder.getInt32(ShadingRateHorizontal4Pixels),
+                                                      builder.getInt32(ShadingRateNone)));
+
+    // yRate = yRate == 0x1 ? Vertical2Pixels : (yRate == 0x2 ? Vertical2Pixels : None)
+    auto yRate2Pixels = builder.CreateICmpEQ(yRate, builder.getInt32(1));
+    auto yRate4Pixels = builder.CreateICmpEQ(yRate, builder.getInt32(2));
+    yRate = builder.CreateSelect(yRate2Pixels, builder.getInt32(ShadingRateVertical2Pixels),
+                                 builder.CreateSelect(yRate4Pixels, builder.getInt32(ShadingRateVertical4Pixels),
+                                                      builder.getInt32(ShadingRateNone)));
+  } else
+#endif
   {
     // NOTE: The shading rates have different meanings in HW and LGC interface. Current HW only supports 2-pixel mode
     // and 4-pixel mode is not supported. The mapping is as follow:
     //
     //   VRS X rate: 0b00 -> MaskNone, 0b01 -> Horizontal2Pixels
     //   VRS Y rate: 0b00 -> MaskNone, 0b01 -> Vertical2Pixels
     //
     // xRate = xRate == 0x1 ? Horizontal2Pixels : None
     auto xRate2Pixels = builder.CreateICmpEQ(xRate, builder.getInt32(1));
     xRate = builder.CreateSelect(xRate2Pixels, builder.getInt32(ShadingRateHorizontal2Pixels),
@@ -5870,246 +6135,34 @@ void PatchInOutImportExport::exportVertexAttribs(Instruction *insertPos) {
       builder.CreateIntrinsic(Intrinsic::amdgcn_exp, builder.getFloatTy(),
                               {builder.getInt32(EXP_TARGET_PARAM_0 + attribExport.first), // tgt
                                builder.getInt32(channelMask),                             // en
                                attribExport.second[0],                                    // src0
                                attribExport.second[1],                                    // src1
                                attribExport.second[2],                                    // src2
                                attribExport.second[3],                                    // src3
                                builder.getFalse(),                                        // done
                                builder.getFalse()});                                      // src0
     } else {
+#if LLPC_BUILD_GFX11
+      Value *attribValue = UndefValue::get(FixedVectorType::get(builder.getFloatTy(), 4)); // Always be <4 x float>
+      for (unsigned i = 0; i < 4; ++i)
+        attribValue = builder.CreateInsertElement(attribValue, attribExport.second[i], i);
+      // NOTE: For GFX11+, vertex attributes are exported through memory. This call will be expanded when NGG primitive
+      // shader is generated. The arguments are: buffer descriptor of attribute ring, attribute location, and attribute
+      // export value.
+      emitCall(lgcName::NggAttribExport, builder.getVoidTy(),
+               {m_pipelineSysValues.get(m_entryPoint)->getAttribRingBufDesc(), builder.getInt32(attribExport.first),
+                attribValue},
+               {}, insertPos);
+#else
       llvm_unreachable("Not implemented!");
+#endif
     }
   }
 }
 
-// =====================================================================================================================
-// Handle the store of tessellation factors.
-//   1. Collect outer and inner tessellation factors;
-//   2. Write tessellation factors to LDS if they are read as inputs by TES;
-//   3. Write tessellation factors to TF buffer.
-void PatchInOutImportExport::storeTessFactors() {
-  assert(m_shaderStage == ShaderStageTessControl); // Must be tessellation control shader
-
-  //
-  // Find the ret instruction as the insert position
-  //
-  Instruction *insertPos = nullptr;
-  for (auto &block : *m_entryPoint) {
-    auto retInst = dyn_cast<ReturnInst>(block.getTerminator());
-    if (retInst) {
-      assert(retInst->getType()->isVoidTy());
-      insertPos = retInst;
-    }
-  }
-  assert(insertPos); // Must have ret instruction
-
-  BuilderBase builder(*m_context);
-  builder.SetInsertPoint(insertPos);
-
-  //
-  // Collect tessellation factors from on-chip LDS
-  //
-  unsigned outerTessFactorCount = 0;
-  unsigned innerTessFactorCount = 0;
-
-  const auto primitiveMode = m_pipelineState->getShaderModes()->getTessellationMode().primitiveMode;
-  switch (primitiveMode) {
-  case PrimitiveMode::Triangles:
-    outerTessFactorCount = 3;
-    innerTessFactorCount = 1;
-    break;
-  case PrimitiveMode::Quads:
-    outerTessFactorCount = 4;
-    innerTessFactorCount = 2;
-    break;
-  case PrimitiveMode::Isolines:
-    outerTessFactorCount = 2;
-    innerTessFactorCount = 0;
-    break;
-  default:
-    llvm_unreachable("Unknown primitive mode!");
-    break;
-  }
-
-  const auto &calcFactor = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor;
-  auto relativeId = m_pipelineSysValues.get(m_entryPoint)->getRelativeId();
-
-  // NOTE: We are going to read back tess factors from on-chip LDS. Make sure they have been stored already.
-  SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
-  builder.CreateFence(AtomicOrdering::Release, workgroupScope);
-  builder.CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
-  builder.CreateFence(AtomicOrdering::Acquire, workgroupScope);
-
-  SmallVector<Value *> outerTessFactors, innerTessFactors;
-
-  assert(outerTessFactorCount >= 2 && outerTessFactorCount <= 4);
-  // ldsOffset = tessFactorStart + relativeId * MaxTessFactorsPerPatch
-  Value *ldsOffset = builder.CreateMul(relativeId, builder.getInt32(MaxTessFactorsPerPatch));
-  ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(calcFactor.onChip.tessFactorStart));
-  auto outerTessFactorVec =
-      readValueFromLds(false, FixedVectorType::get(builder.getFloatTy(), outerTessFactorCount), ldsOffset, builder);
-  for (unsigned i = 0; i < outerTessFactorCount; ++i)
-    outerTessFactors.push_back(builder.CreateExtractElement(outerTessFactorVec, i));
-
-  assert(innerTessFactorCount <= 2);
-  if (innerTessFactorCount > 0) {
-    // ldsOffset = tessFactorStart + relativeId * MaxTessFactorsPerPatch + 4
-    Value *ldsOffset = builder.CreateMul(relativeId, builder.getInt32(MaxTessFactorsPerPatch));
-    ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(calcFactor.onChip.tessFactorStart + 4));
-    auto innerTessFactorVec =
-        readValueFromLds(false, FixedVectorType::get(builder.getFloatTy(), innerTessFactorCount), ldsOffset, builder);
-    for (unsigned i = 0; i < innerTessFactorCount; ++i)
-      innerTessFactors.push_back(builder.CreateExtractElement(innerTessFactorVec, i));
-  }
-
-  {
-    //
-    // Write tessellation factors to LDS if they are read as inputs by TES
-    //
-    const auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl);
-    const auto &perPatchBuiltInOutLocMap = resUsage->inOutUsage.perPatchBuiltInOutputLocMap;
-
-    auto tessLevelOuterLocIt = perPatchBuiltInOutLocMap.find(BuiltInTessLevelOuter);
-    if (tessLevelOuterLocIt != perPatchBuiltInOutLocMap.end()) {
-      const unsigned loc = tessLevelOuterLocIt->second;
-
-      for (unsigned i = 0; i < outerTessFactorCount; ++i) {
-        auto ldsOffset =
-            calcLdsOffsetForTcsOutput(builder.getFloatTy(), loc, nullptr, builder.getInt32(i), nullptr, builder);
-        writeValueToLds(m_pipelineState->isTessOffChip(), outerTessFactors[i], ldsOffset, builder);
-      }
-    }
-
-    auto tessLevelInnerLocIt = perPatchBuiltInOutLocMap.find(BuiltInTessLevelInner);
-    if (tessLevelInnerLocIt != perPatchBuiltInOutLocMap.end()) {
-      const unsigned loc = tessLevelInnerLocIt->second;
-
-      for (unsigned i = 0; i < innerTessFactorCount; ++i) {
-        auto ldsOffset =
-            calcLdsOffsetForTcsOutput(builder.getFloatTy(), loc, nullptr, builder.getInt32(i), nullptr, builder);
-        writeValueToLds(m_pipelineState->isTessOffChip(), innerTessFactors[i], ldsOffset, builder);
-      }
-    }
-
-    // NOTE: For isoline, the outer tessellation factors have to be exchanged, which is required by HW.
-    if (primitiveMode == PrimitiveMode::Isolines)
-      std::swap(outerTessFactors[0], outerTessFactors[1]);
-
-    storeTessFactorToBuffer(outerTessFactors, innerTessFactors, insertPos);
-  }
-}
-
-// =====================================================================================================================
-// Write the collected tessellation factors to TF buffer.
-//
-// @param outerTessFactors : The collected outer tessellation factors
-// @param innerTessFactors : The collected inner tessellation factors
-// @param insertPos : Where to insert instructions
-void PatchInOutImportExport::storeTessFactorToBuffer(ArrayRef<Value *> outerTessFactors,
-                                                     ArrayRef<Value *> innerTessFactors, Instruction *insertPos) {
-  assert(m_shaderStage == ShaderStageTessControl);
-
-  // NOTE: Tessellation factors are from tessellation level array and we have:
-  //   (1) Isoline
-  //      tessFactor[0] = gl_TessLevelOuter[1]
-  //      tessFactor[1] = gl_TessLevelOuter[0]
-  //   (2) Triangle
-  //      tessFactor[0] = gl_TessLevelOuter[0]
-  //      tessFactor[1] = gl_TessLevelOuter[1]
-  //      tessFactor[2] = gl_TessLevelOuter[2]
-  //      tessFactor[3] = gl_TessLevelInner[0]
-  //   (3) Quad
-  //      tessFactor[0] = gl_TessLevelOuter[0]
-  //      tessFactor[1] = gl_TessLevelOuter[1]
-  //      tessFactor[2] = gl_TessLevelOuter[2]
-  //      tessFactor[3] = gl_TessLevelOuter[3]
-  //      tessFactor[4] = gl_TessLevelInner[0]
-  //      tessFactor[5] = gl_TessLevelInner[1]
-
-  BuilderBase builder(*m_context);
-  builder.SetInsertPoint(insertPos);
-
-  Value *tfBufferDesc = m_pipelineSysValues.get(m_entryPoint)->getTessFactorBufDesc();
-
-  auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageTessControl)->entryArgIdxs.tcs;
-  Value *tfBufferBase = getFunctionArgument(m_entryPoint, entryArgIdxs.tfBufferBase);
-  if (m_pipelineState->isTessOffChip()) {
-    if (m_gfxIp.major <= 8) {
-      // NOTE: Additional 4-byte offset is required for tessellation off-chip mode (pre-GFX9).
-      tfBufferBase =
-          BinaryOperator::CreateAdd(tfBufferBase, ConstantInt::get(Type::getInt32Ty(*m_context), 4), "", insertPos);
-    }
-  }
-
-  const auto &calcFactor = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor;
-  auto relPatchId = m_pipelineSysValues.get(m_entryPoint)->getRelativeId();
-  Value *tfBufferOffset = builder.CreateMul(relPatchId, builder.getInt32(calcFactor.tessFactorStride * sizeof(float)));
-
-  CoherentFlag coherent = {};
-  coherent.bits.glc = true;
-
-  auto primitiveMode = m_pipelineState->getShaderModes()->getTessellationMode().primitiveMode;
-  if (primitiveMode == PrimitiveMode::Isolines || primitiveMode == PrimitiveMode::Triangles) {
-    // For isoline and triangle, we can combine outer tessellation factors with inner ones
-    FixedVectorType *tfValueTy =
-        FixedVectorType::get(builder.getFloatTy(), outerTessFactors.size() + innerTessFactors.size());
-    Value *tfValue = UndefValue::get(tfValueTy);
-
-    assert(outerTessFactors.size() == 2 || outerTessFactors.size() == 3);
-    for (unsigned i = 0; i < outerTessFactors.size(); ++i)
-      tfValue = builder.CreateInsertElement(tfValue, outerTessFactors[i], i);
-
-    assert(innerTessFactors.size() == 0 || innerTessFactors.size() == 1);
-    for (unsigned i = 0; i < innerTessFactors.size(); ++i)
-      tfValue = builder.CreateInsertElement(tfValue, innerTessFactors[i], outerTessFactors.size() + i);
-
-    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, tfValueTy,
-                            {tfValue,                                                             // vdata
-                             tfBufferDesc,                                                        // rsrc
-                             tfBufferOffset,                                                      // voffset
-                             tfBufferBase,                                                        // soffset
-                             builder.getInt32((*m_buffFormats)[tfValueTy->getNumElements() - 1]), // format
-                             builder.getInt32(coherent.u32All)});                                 // glc
-  } else {
-    assert(primitiveMode == PrimitiveMode::Quads);
-
-    FixedVectorType *outerTfValueTy = FixedVectorType::get(builder.getFloatTy(), outerTessFactors.size());
-    Value *outerTfValue = UndefValue::get(outerTfValueTy);
-
-    assert(outerTessFactors.size() == 4);
-    for (unsigned i = 0; i < outerTessFactors.size(); ++i)
-      outerTfValue = builder.CreateInsertElement(outerTfValue, outerTessFactors[i], i);
-
-    FixedVectorType *innerTfValueTy = FixedVectorType::get(builder.getFloatTy(), innerTessFactors.size());
-    Value *innerTfValue = UndefValue::get(innerTfValueTy);
-
-    assert(innerTessFactors.size() == 2);
-    for (unsigned i = 0; i < innerTessFactors.size(); ++i)
-      innerTfValue = builder.CreateInsertElement(innerTfValue, innerTessFactors[i], i);
-
-    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, outerTfValueTy,
-                            {outerTfValue,                                                             // vdata
-                             tfBufferDesc,                                                             // rsrc
-                             tfBufferOffset,                                                           // voffset
-                             tfBufferBase,                                                             // soffset
-                             builder.getInt32((*m_buffFormats)[outerTfValueTy->getNumElements() - 1]), // format
-                             builder.getInt32(coherent.u32All)});                                      // glc
-
-    tfBufferOffset =
-        builder.CreateAdd(tfBufferOffset, builder.getInt32(outerTfValueTy->getNumElements() * sizeof(float)));
-    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, innerTfValueTy,
-                            {innerTfValue,                                                             // vdata
-                             tfBufferDesc,                                                             // rsrc
-                             tfBufferOffset,                                                           // voffset
-                             tfBufferBase,                                                             // soffset
-                             builder.getInt32((*m_buffFormats)[innerTfValueTy->getNumElements() - 1]), // format
-                             builder.getInt32(coherent.u32All)});                                      // glc
-  }
-}
-
 } // namespace lgc
 
 // =====================================================================================================================
 // Initializes the pass of LLVM patching operations for input import and output export.
 INITIALIZE_PASS(LegacyPatchInOutImportExport, DEBUG_TYPE, "Patch LLVM for input import and output export operations",
                 false, false)
diff --git a/lgc/patch/PatchInitializeWorkgroupMemory.cpp b/lgc/patch/PatchInitializeWorkgroupMemory.cpp
index dea2a4b35..9b4752945 100644
--- a/lgc/patch/PatchInitializeWorkgroupMemory.cpp
+++ b/lgc/patch/PatchInitializeWorkgroupMemory.cpp
@@ -169,20 +169,47 @@ void PatchInitializeWorkgroupMemory::initializeWithZero(GlobalVariable *lds, Bui
   auto bodyBlock = BasicBlock::Create(*m_context, ".body", originBlock->getParent(), initBlock);
   auto forHeaderBlock = BasicBlock::Create(*m_context, ".for.header", originBlock->getParent(), bodyBlock);
 
   builder.SetInsertPoint(originBlock->getTerminator());
   // Get thread info
   auto &shaderMode = m_pipelineState->getShaderModes()->getComputeShaderMode();
   const auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(m_shaderStage)->entryArgIdxs;
   Value *localInvocationId = getFunctionArgument(m_entryPoint, entryArgIdxs.cs.localInvocationId);
   const unsigned actualNumThreads = shaderMode.workgroupSizeX * shaderMode.workgroupSizeY * shaderMode.workgroupSizeZ;
 
+#if LLPC_BUILD_GFX11
+  // On GFX11, it is a single VGPR and we need to extract the three components.
+  if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11) {
+    assert(localInvocationId->getType() == builder.getInt32Ty());
+
+    static constexpr unsigned LocalInvocationIdPackMask = 0x3FF;
+    Value *unpackedLocalInvocationId = UndefValue::get(FixedVectorType::get(builder.getInt32Ty(), 3));
+
+    // X = PackedId[9:0]
+    unpackedLocalInvocationId = builder.CreateInsertElement(
+        unpackedLocalInvocationId, builder.CreateAnd(localInvocationId, builder.getInt32(LocalInvocationIdPackMask)),
+        uint64_t(0));
+
+    // Y = PackedId[19:10]
+    localInvocationId = builder.CreateLShr(localInvocationId, builder.getInt32(10));
+    unpackedLocalInvocationId = builder.CreateInsertElement(
+        unpackedLocalInvocationId, builder.CreateAnd(localInvocationId, builder.getInt32(LocalInvocationIdPackMask)),
+        1);
+
+    // Z = PackedId[29:20], PackedId[31:30] set to 0 by hardware
+    localInvocationId = builder.CreateLShr(localInvocationId, builder.getInt32(10));
+    unpackedLocalInvocationId = builder.CreateInsertElement(unpackedLocalInvocationId, localInvocationId, 2);
+
+    localInvocationId = unpackedLocalInvocationId;
+  }
+#endif
+
   Value *threadId = builder.CreateExtractElement(localInvocationId, uint64_t(0));
   if (shaderMode.workgroupSizeY > 1) {
     Value *stride = builder.CreateMul(builder.getInt32(shaderMode.workgroupSizeX),
                                       builder.CreateExtractElement(localInvocationId, 1));
     threadId = builder.CreateAdd(threadId, stride);
   }
   if (shaderMode.workgroupSizeZ > 1) {
     Value *stride = builder.CreateMul(builder.getInt32(shaderMode.workgroupSizeX * shaderMode.workgroupSizeY),
                                       builder.CreateExtractElement(localInvocationId, 2));
     threadId = builder.CreateAdd(threadId, stride);
diff --git a/lgc/patch/PatchInvariantLoads.cpp b/lgc/patch/PatchInvariantLoads.cpp
index 378de3a31..27962ddd4 100644
--- a/lgc/patch/PatchInvariantLoads.cpp
+++ b/lgc/patch/PatchInvariantLoads.cpp
@@ -246,21 +246,21 @@ bool PatchInvariantLoads::runImpl(Function &function, PipelineState *pipelineSta
 
   auto &context = function.getContext();
   bool changed = false;
   for (Instruction *inst : loads) {
     if (inst->hasMetadata(LLVMContext::MD_invariant_load))
       continue;
     if (writtenAddrSpaces && (writtenAddrSpaces & (1 << findAddressSpaceAccess(inst))))
       continue;
 
     LLVM_DEBUG(dbgs() << "Marking load invariant: " << *inst << "\n");
-    inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(context, None));
+    inst->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(context, {}));
     changed = true;
   }
 
   return changed;
 }
 
 } // namespace lgc
 
 // =====================================================================================================================
 // Initializes the pass of LLVM patch image derivative operations dependent on discards.
diff --git a/lgc/patch/PatchLoopMetadata.cpp b/lgc/patch/PatchLoopMetadata.cpp
index 05fee6018..338e26eeb 100644
--- a/lgc/patch/PatchLoopMetadata.cpp
+++ b/lgc/patch/PatchLoopMetadata.cpp
@@ -56,21 +56,21 @@ char LegacyPatchLoopMetadata::ID = 0;
 //
 // @param loopId : loop
 // @param prefixesToRemove : metadata prefixes to be removed
 // @param newMetadata : the new metadata to be added
 // @param conditional : true if the new metadata is only to be added if one or more prefixes was removed
 MDNode *PatchLoopMetadata::updateMetadata(MDNode *loopId, ArrayRef<StringRef> prefixesToRemove, Metadata *newMetadata,
                                           bool conditional) {
   bool found = false;
   SmallVector<Metadata *, 4> mds;
   // Reserve first location for self reference to the loopId metadata node.
-  TempMDTuple tempNode = MDNode::getTemporary(*m_context, None);
+  TempMDTuple tempNode = MDNode::getTemporary(*m_context, {});
   mds.push_back(tempNode.get());
   for (unsigned i = 1, operandCount = loopId->getNumOperands(); i < operandCount; ++i) {
     Metadata *op = loopId->getOperand(i);
     if (MDNode *mdNode = dyn_cast<MDNode>(op)) {
       if (const MDString *mdString = dyn_cast<MDString>(mdNode->getOperand(0))) {
         if (any_of(prefixesToRemove,
                    [mdString](StringRef prefix) -> bool { return mdString->getString().startswith(prefix); }))
           found = true;
         else
           mds.push_back(op);
diff --git a/lgc/patch/PatchPreparePipelineAbi.cpp b/lgc/patch/PatchPreparePipelineAbi.cpp
index e896f7e20..1a7c7d150 100644
--- a/lgc/patch/PatchPreparePipelineAbi.cpp
+++ b/lgc/patch/PatchPreparePipelineAbi.cpp
@@ -27,20 +27,21 @@
 * @file  PatchPreparePipelineAbi.cpp
 * @brief LLPC source file: contains implementation of class lgc::PatchPreparePipelineAbi.
 ***********************************************************************************************************************
 */
 #include "lgc/patch/PatchPreparePipelineAbi.h"
 #include "Gfx6ConfigBuilder.h"
 #include "Gfx9ConfigBuilder.h"
 #include "MeshTaskShader.h"
 #include "ShaderMerger.h"
 #include "lgc/state/PalMetadata.h"
+#include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-prepare-pipeline-abi"
 
 using namespace llvm;
 using namespace lgc;
 
 char LegacyPatchPreparePipelineAbi::ID = 0;
 
@@ -130,32 +131,215 @@ bool PatchPreparePipelineAbi::runImpl(Module &module, PipelineShadersResult &pip
 
   m_hasVs = m_pipelineState->hasShaderStage(ShaderStageVertex);
   m_hasTcs = m_pipelineState->hasShaderStage(ShaderStageTessControl);
   m_hasTes = m_pipelineState->hasShaderStage(ShaderStageTessEval);
   m_hasGs = m_pipelineState->hasShaderStage(ShaderStageGeometry);
   m_hasTask = m_pipelineState->hasShaderStage(ShaderStageTask);
   m_hasMesh = m_pipelineState->hasShaderStage(ShaderStageMesh);
 
   m_gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
 
+  if (auto hsEntryPoint = m_pipelineShaders->getEntryPoint(ShaderStageTessControl))
+    storeTessFactors(hsEntryPoint);
+
   if (m_gfxIp.major >= 9)
     mergeShader(module);
 
   setAbiEntryNames(module);
 
   addAbiMetadata(module);
 
   m_pipelineState->getPalMetadata()->finalizePipeline(m_pipelineState->isWholePipeline());
 
   return true; // Modified the module.
 }
 
+// =====================================================================================================================
+// Read tessellation factors from on-chip LDS.
+//
+// @param pipelineState : Pipeline state
+// @param relPatchId : Relative patch ID
+// @param builder : IR builder to insert instructions
+std::pair<Value *, Value *> PatchPreparePipelineAbi::readTessFactors(PipelineState *pipelineState, Value *relPatchId,
+                                                                     IRBuilder<> &builder) {
+  auto module = builder.GetInsertBlock()->getModule();
+  auto lds = Patch::getLdsVariable(pipelineState, module);
+
+  // Helper to read value from LDS
+  auto readValueFromLds = [&](Type *readTy, Value *ldsOffset) {
+    assert(readTy->getScalarSizeInBits() == 32); // Only accept 32-bit data
+
+    Value *readPtr = builder.CreateGEP(lds->getValueType(), lds, {builder.getInt32(0), ldsOffset});
+    readPtr = builder.CreateBitCast(readPtr, PointerType::get(readTy, readPtr->getType()->getPointerAddressSpace()));
+    return builder.CreateAlignedLoad(readTy, readPtr, Align(4));
+  };
+
+  unsigned numOuterTfs = 0;
+  unsigned numInnerTfs = 0;
+
+  const auto primitiveMode = pipelineState->getShaderModes()->getTessellationMode().primitiveMode;
+  switch (primitiveMode) {
+  case PrimitiveMode::Triangles:
+    numOuterTfs = 3;
+    numInnerTfs = 1;
+    break;
+  case PrimitiveMode::Quads:
+    numOuterTfs = 4;
+    numInnerTfs = 2;
+    break;
+  case PrimitiveMode::Isolines:
+    numOuterTfs = 2;
+    numInnerTfs = 0;
+    break;
+  default:
+    llvm_unreachable("Unknown primitive mode!");
+    break;
+  }
+
+  const auto tessFactorStart =
+      pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor.onChip.tessFactorStart;
+
+  assert(numOuterTfs >= 2 && numOuterTfs <= 4);
+  // ldsOffset = tessFactorStart + relativeId * MaxTessFactorsPerPatch
+  Value *ldsOffset = builder.CreateMul(relPatchId, builder.getInt32(MaxTessFactorsPerPatch));
+  ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(tessFactorStart));
+  Value *outerTf = readValueFromLds(FixedVectorType::get(builder.getFloatTy(), numOuterTfs), ldsOffset);
+
+  // NOTE: For isoline, the outer tessellation factors have to be exchanged, which is required by HW.
+  if (primitiveMode == PrimitiveMode::Isolines) {
+    assert(numOuterTfs == 2);
+    outerTf = builder.CreateShuffleVector(outerTf, ArrayRef<int>{1, 0});
+  }
+
+  assert(numInnerTfs <= 2);
+  Value *innerTf = nullptr;
+  if (numInnerTfs > 0) {
+    // ldsOffset = tessFactorStart + relativeId * MaxTessFactorsPerPatch + 4
+    Value *ldsOffset = builder.CreateMul(relPatchId, builder.getInt32(MaxTessFactorsPerPatch));
+    ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(tessFactorStart + 4));
+    innerTf = readValueFromLds(FixedVectorType::get(builder.getFloatTy(), numInnerTfs), ldsOffset);
+  }
+
+  return std::make_pair(outerTf, innerTf);
+}
+
+// =====================================================================================================================
+// Write tessellation factors to TF buffer.
+//
+// @param pipelineState : Pipeline state
+// @param tfBufferDesc : TF buffer descriptor
+// @param tfBufferBase : TF buffer base offset
+// @param relPatchId : Relative patch ID
+// @param outerTf : Outer tessellation factors to write to TF buffer
+// @param innerTf : Inner tessellation factors to write to TF buffer
+// @param builder : IR builder to insert instructions
+void PatchPreparePipelineAbi::writeTessFactors(PipelineState *pipelineState, Value *tfBufferDesc, Value *tfBufferBase,
+                                               Value *relPatchId, Value *outerTf, Value *innerTf,
+                                               IRBuilder<> &builder) {
+  // NOTE: Tessellation factors are from tessellation level array and we have:
+  //   Isoline:
+  //     TF[0] = outerTF[0]
+  //     TF[1] = outerTF[1]
+  //   Triangle:
+  //     TF[0] = outerTF[0]
+  //     TF[1] = outerTF[1]
+  //     TF[2] = outerTF[2]
+  //     TF[3] = innerTF[0]
+  //   Quad:
+  //     TF[0] = outerTF[0]
+  //     TF[1] = outerTF[1]
+  //     TF[2] = outerTF[2]
+  //     TF[3] = outerTF[3]
+  //     TF[4] = innerTF[0]
+  //     TF[5] = innerTF[1]
+  if (pipelineState->isTessOffChip()) {
+    if (pipelineState->getTargetInfo().getGfxIpVersion().major <= 8) {
+      // NOTE: Additional 4-byte offset is required for tessellation off-chip mode (pre-GFX9).
+      tfBufferBase = builder.CreateAdd(tfBufferBase, builder.getInt32(4));
+    }
+  }
+
+  const auto &calcFactor = pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor;
+  Value *tfBufferOffset = builder.CreateMul(relPatchId, builder.getInt32(calcFactor.tessFactorStride * sizeof(float)));
+
+  CoherentFlag coherent = {};
+  coherent.bits.glc = true;
+
+  const auto numOuterTfs = cast<FixedVectorType>(outerTf->getType())->getNumElements();
+  const auto numInnerTfs = innerTf ? cast<FixedVectorType>(innerTf->getType())->getNumElements()
+                                   : 0; // Isoline doesn't have inner tessellation factors
+
+  (void(numOuterTfs)); // Unused
+  (void(numInnerTfs));
+
+  auto bufferFormatX2 = BUF_NUM_FORMAT_FLOAT << 4 | BUF_DATA_FORMAT_32_32;
+  auto bufferFormatX4 = BUF_NUM_FORMAT_FLOAT << 4 | BUF_DATA_FORMAT_32_32_32_32;
+  if (pipelineState->getTargetInfo().getGfxIpVersion().major == 10) {
+    bufferFormatX2 = BUF_FORMAT_32_32_FLOAT_GFX10;
+    bufferFormatX4 = BUF_FORMAT_32_32_32_32_FLOAT_GFX10;
+#if LLPC_BUILD_GFX11
+  } else if (pipelineState->getTargetInfo().getGfxIpVersion().major == 11) {
+    bufferFormatX2 = BUF_FORMAT_32_32_FLOAT_GFX11;
+    bufferFormatX4 = BUF_FORMAT_32_32_32_32_FLOAT_GFX11;
+#endif
+  }
+
+  auto primitiveMode = pipelineState->getShaderModes()->getTessellationMode().primitiveMode;
+  if (primitiveMode == PrimitiveMode::Isolines) {
+    assert(numOuterTfs == 2 && numInnerTfs == 0);
+
+    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, outerTf->getType(),
+                            {outerTf,                             // vdata
+                             tfBufferDesc,                        // rsrc
+                             tfBufferOffset,                      // voffset
+                             tfBufferBase,                        // soffset
+                             builder.getInt32(bufferFormatX2),    // format
+                             builder.getInt32(coherent.u32All)}); // glc
+
+  } else if (primitiveMode == PrimitiveMode::Triangles) {
+    assert(numOuterTfs == 3 && numInnerTfs == 1);
+
+    // For triangle, we can combine outer tessellation factors with inner ones
+    Value *tessFactor = builder.CreateShuffleVector(outerTf, ArrayRef<int>{0, 1, 2, 3});
+    tessFactor =
+        builder.CreateInsertElement(tessFactor, builder.CreateExtractElement(innerTf, static_cast<uint64_t>(0)), 3);
+
+    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, tessFactor->getType(),
+                            {tessFactor,                          // vdata
+                             tfBufferDesc,                        // rsrc
+                             tfBufferOffset,                      // voffset
+                             tfBufferBase,                        // soffset
+                             builder.getInt32(bufferFormatX4),    // format
+                             builder.getInt32(coherent.u32All)}); // glc
+  } else {
+    assert(primitiveMode == PrimitiveMode::Quads);
+    assert(numOuterTfs == 4 && numInnerTfs == 2);
+
+    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, outerTf->getType(),
+                            {outerTf,                             // vdata
+                             tfBufferDesc,                        // rsrc
+                             tfBufferOffset,                      // voffset
+                             tfBufferBase,                        // soffset
+                             builder.getInt32(bufferFormatX4),    // format
+                             builder.getInt32(coherent.u32All)}); // glc
+
+    tfBufferOffset = builder.CreateAdd(tfBufferOffset, builder.getInt32(4 * sizeof(float)));
+    builder.CreateIntrinsic(Intrinsic::amdgcn_raw_tbuffer_store, innerTf->getType(),
+                            {innerTf,                             // vdata
+                             tfBufferDesc,                        // rsrc
+                             tfBufferOffset,                      // voffset
+                             tfBufferBase,                        // soffset
+                             builder.getInt32(bufferFormatX2),    // format
+                             builder.getInt32(coherent.u32All)}); // glc
+  }
+}
+
 // =====================================================================================================================
 // Merge shaders and set calling convention for the entry-point of each shader (GFX9+)
 //
 // @param module : LLVM module
 void PatchPreparePipelineAbi::mergeShader(Module &module) {
   assert(m_gfxIp.major >= 9);
 
   const bool hasTs = (m_hasTcs || m_hasTes);
 
   if (m_pipelineState->isGraphics()) {
@@ -324,13 +508,55 @@ void PatchPreparePipelineAbi::setAbiEntryNames(Module &module) {
 void PatchPreparePipelineAbi::addAbiMetadata(Module &module) {
   if (m_gfxIp.major <= 8) {
     Gfx6::ConfigBuilder configBuilder(&module, m_pipelineState);
     configBuilder.buildPalMetadata();
   } else {
     Gfx9::ConfigBuilder configBuilder(&module, m_pipelineState);
     configBuilder.buildPalMetadata();
   }
 }
 
+// =====================================================================================================================
+// Handle the store of tessellation factors.
+//
+// @param entryPoint : Entry-point of tessellation control shader
+void PatchPreparePipelineAbi::storeTessFactors(Function *entryPoint) {
+  assert(getShaderStage(entryPoint) == ShaderStageTessControl); // Must be tessellation control shader
+
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->canOptimizeTessFactor())
+    return; // If TF store is to be optimized, skip further processing
+#endif
+
+  // Find the return instruction
+  Instruction *retInst = nullptr;
+  for (auto &block : *entryPoint) {
+    retInst = dyn_cast<ReturnInst>(block.getTerminator());
+    if (retInst) {
+      assert(retInst->getType()->isVoidTy());
+      break;
+    }
+  }
+  assert(retInst); // Must have return instruction
+
+  IRBuilder<> builder(*m_context);
+  builder.SetInsertPoint(retInst);
+
+  PipelineSystemValues pipelineSysValues;
+  pipelineSysValues.initialize(m_pipelineState);
+
+  const auto tfBufferDesc = pipelineSysValues.get(entryPoint)->getTessFactorBufDesc();
+  const auto &entryArgIdxs = m_pipelineState->getShaderInterfaceData(ShaderStageTessControl)->entryArgIdxs.tcs;
+  const auto tfBufferBase = getFunctionArgument(entryPoint, entryArgIdxs.tfBufferBase);
+  const auto relPatchId = pipelineSysValues.get(entryPoint)->getRelativeId();
+
+  // Read back tessellation factors and write them to TF buffer
+  auto tessFactors = readTessFactors(m_pipelineState, relPatchId, builder);
+  writeTessFactors(m_pipelineState, tfBufferDesc, tfBufferBase, relPatchId, tessFactors.first, tessFactors.second,
+                   builder);
+
+  pipelineSysValues.clear();
+}
+
 // =====================================================================================================================
 // Initializes the pass
 INITIALIZE_PASS(LegacyPatchPreparePipelineAbi, DEBUG_TYPE, "Patch LLVM for preparing pipeline ABI", false, false)
diff --git a/lgc/patch/PatchResourceCollect.cpp b/lgc/patch/PatchResourceCollect.cpp
index 2749cf557..845f9ea95 100644
--- a/lgc/patch/PatchResourceCollect.cpp
+++ b/lgc/patch/PatchResourceCollect.cpp
@@ -214,20 +214,24 @@ void PatchResourceCollect::setNggControl(Module *module) {
   } else {
     const auto resUsage = m_pipelineState->getShaderResourceUsage(ShaderStageVertex);
     useCullDistance = resUsage->builtInUsage.vs.cullDistance > 0;
   }
 
   const auto &options = m_pipelineState->getOptions();
   NggControl &nggControl = *m_pipelineState->getNggControl();
 
   nggControl.enableNgg = canUseNgg(module);
   nggControl.enableGsUse = (options.nggFlags & NggFlagEnableGsUse);
+#if LLPC_BUILD_GFX11
+  nggControl.enableGsUse |=
+      m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11; // Always enable NGG on GS for GFX11+
+#endif
   nggControl.compactMode = (options.nggFlags & NggFlagCompactDisable) ? NggCompactDisable : NggCompactVertices;
 
   nggControl.enableVertexReuse = (options.nggFlags & NggFlagEnableVertexReuse);
   nggControl.enableBackfaceCulling = (options.nggFlags & NggFlagEnableBackfaceCulling);
   nggControl.enableFrustumCulling = (options.nggFlags & NggFlagEnableFrustumCulling);
   nggControl.enableBoxFilterCulling = (options.nggFlags & NggFlagEnableBoxFilterCulling);
   nggControl.enableSphereCulling = (options.nggFlags & NggFlagEnableSphereCulling);
   nggControl.enableSmallPrimFilter = (options.nggFlags & NggFlagEnableSmallPrimFilter);
   nggControl.enableCullDistanceCulling = ((options.nggFlags & NggFlagEnableCullDistanceCulling) && useCullDistance);
 
@@ -307,37 +311,41 @@ void PatchResourceCollect::setNggControl(Module *module) {
 }
 
 // =====================================================================================================================
 // Checks whether NGG could be enabled.
 //
 // @param [in/out] module : Module
 bool PatchResourceCollect::canUseNgg(Module *module) {
   assert(m_pipelineState->isGraphics());
   assert(m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 10);
 
+#if LLPC_BUILD_GFX11
+  // Always enable NGG for GFX11+
+  if (m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11)
+    return true;
+#endif
+
   const bool hasTs =
       m_pipelineState->hasShaderStage(ShaderStageTessControl) || m_pipelineState->hasShaderStage(ShaderStageTessEval);
   const bool hasGs = m_pipelineState->hasShaderStage(ShaderStageGeometry);
 
   // If the workaround flag requests us to disable NGG, respect it. Hardware must have some limitations.
   if (m_pipelineState->getTargetInfo().getGpuWorkarounds().gfx10.waNggDisabled)
     return false;
 
   // NGG used on GS is disabled by default.
   const auto &options = m_pipelineState->getOptions();
   if (hasGs && (options.nggFlags & NggFlagEnableGsUse) == 0)
     return false;
 
   // TODO: If transform feedback is enabled, currently disable NGG.
-  const auto resUsage = m_pipelineState->getShaderResourceUsage(
-      hasGs ? ShaderStageGeometry : (hasTs ? ShaderStageTessEval : ShaderStageVertex));
-  if (resUsage->inOutUsage.enableXfb)
+  if (m_pipelineState->enableXfb())
     return false;
 
   if (hasTs && hasGs) {
     auto &geometryMode = m_pipelineState->getShaderModes()->getGeometryShaderMode();
 
     // NOTE: On GFX10, when tessllation and geometry shader are both enabled, the lowest number of GS primitives per
     // NGG subgroup is implicitly 3 (specified by HW). Thus, the maximum primitive amplification factor is therefore
     // 256/3 = 85.
     if (m_pipelineState->getTargetInfo().getGpuWorkarounds().gfx10.waLimitedMaxOutputVertexCount) {
       static const unsigned MaxOutputVertices = Gfx9::NggMaxThreadsPerSubgroup / 3;
@@ -687,21 +695,21 @@ bool PatchResourceCollect::checkGsOnChipValidity() {
         break;
       case NggSubgroupSizing::OptimizeForPrims:
         esVertsPerSubgroup = Gfx9::NggMaxThreadsPerSubgroup;
         gsPrimsPerSubgroup = 128;
         break;
       case NggSubgroupSizing::Explicit:
         esVertsPerSubgroup = nggControl->vertsPerSubgroup;
         gsPrimsPerSubgroup = nggControl->primsPerSubgroup;
         break;
       case NggSubgroupSizing::Auto:
-        if (m_pipelineState->getTargetInfo().getGfxIpVersion() == GfxIpVersion{10, 1}) {
+        if (m_pipelineState->getTargetInfo().getGfxIpVersion().isGfx(10, 1)) {
           esVertsPerSubgroup = Gfx9::NggMaxThreadsPerSubgroup / 2 - 2;
           gsPrimsPerSubgroup = Gfx9::NggMaxThreadsPerSubgroup / 2;
         } else {
           // Newer hardware performs the decrement on esVertsPerSubgroup for us already.
           esVertsPerSubgroup = Gfx9::NggMaxThreadsPerSubgroup / 2;
           gsPrimsPerSubgroup = Gfx9::NggMaxThreadsPerSubgroup / 2;
         }
         break;
       case NggSubgroupSizing::MaximumSize:
       default:
@@ -734,23 +742,23 @@ bool PatchResourceCollect::checkGsOnChipValidity() {
           gsInstanceCount = 1;
           gsPrimsPerSubgroup = 1;
         }
 
         esVertsPerSubgroup = std::min(gsPrimsPerSubgroup * inVertsPerPrim, Gfx9::NggMaxThreadsPerSubgroup);
 
         if (hasTs)
           esVertsPerSubgroup = std::min(esVertsPerSubgroup, OptimalVerticesPerPrimitiveForTess * gsPrimsPerSubgroup);
 
         // Low values of esVertsPerSubgroup are illegal. These numbers below come from HW restrictions.
-        if (gfxIp == GfxIpVersion{10, 3})
+        if (gfxIp.isGfx(10, 3))
           esVertsPerSubgroup = std::max(29u, esVertsPerSubgroup);
-        else if (gfxIp == GfxIpVersion{10, 1})
+        else if (gfxIp.isGfx(10, 1))
           esVertsPerSubgroup = std::max(24u, esVertsPerSubgroup);
       } else {
         // If GS is not present, instance count must be 1
         assert(gsInstanceCount == 1);
       }
 
 #if VKI_RAY_TRACING
       // NOTE: If ray query uses LDS stack, the expected max thread count in the group is 64. And we force wave size
       // to be 64 in order to keep all threads in the same wave. In the future, we could consider to get rid of this
       // restriction by providing the capability of querying thread ID in the group rather than in wave.
@@ -815,23 +823,23 @@ bool PatchResourceCollect::checkGsOnChipValidity() {
 
         // Make sure that we have at least one primitive.
         gsPrimsPerSubgroup = std::max(1u, gsPrimsPerSubgroup);
 
         // inVertsPerPrim is the minimum number of vertices we must have per subgroup.
         esVertsPerSubgroup =
             std::max(inVertsPerPrim, std::min(static_cast<unsigned>(gsPrimsPerSubgroup * esVertToGsPrimRatio),
                                               Gfx9::NggMaxThreadsPerSubgroup));
 
         // Low values of esVertsPerSubgroup are illegal. These numbers below come from HW restrictions.
-        if (gfxIp == GfxIpVersion{10, 3})
+        if (gfxIp.isGfx(10, 3))
           esVertsPerSubgroup = std::max(29u, esVertsPerSubgroup);
-        else if (gfxIp == GfxIpVersion{10, 1})
+        else if (gfxIp.isGfx(10, 1))
           esVertsPerSubgroup = std::max(24u, esVertsPerSubgroup);
 
 #if VKI_RAY_TRACING
         // NOTE: If ray query uses LDS stack, the expected max thread count in the group is 64. And we force wave size
         // to be 64 in order to keep all threads in the same wave. In the future, we could consider to get rid of this
         // restriction by providing the capability of querying thread ID in the group rather than in wave.
         if (gsResUsage->useRayQueryLdsStack)
           gsPrimsPerSubgroup = std::min(MaxRayQueryThreadsPerGroup, gsPrimsPerSubgroup);
         if (esResUsage->useRayQueryLdsStack)
           esVertsPerSubgroup = std::min(MaxRayQueryThreadsPerGroup, esVertsPerSubgroup);
@@ -1097,24 +1105,25 @@ bool PatchResourceCollect::checkGsOnChipValidity() {
   LLPC_OUTS("ES-GS ring item size (in dwords): " << gsResUsage->inOutUsage.gs.calcFactor.esGsRingItemSize << "\n");
   LLPC_OUTS("GS-VS ring item size (in dwords): " << gsResUsage->inOutUsage.gs.calcFactor.gsVsRingItemSize << "\n");
   LLPC_OUTS("\n");
 
   if (hasGs) {
     LLPC_OUTS("GS stream item size:\n");
     for (unsigned i = 0; i < MaxGsStreams; ++i) {
       unsigned streamItemSize = gsResUsage->inOutUsage.gs.outLocCount[i] * geometryMode.outputVertices * 4;
       LLPC_OUTS("    stream " << i << " = " << streamItemSize);
 
-      if (gsResUsage->inOutUsage.enableXfb) {
+      if (m_pipelineState->enableXfb()) {
         LLPC_OUTS(", XFB buffer = ");
+        const auto &streamXfbBuffers = m_pipelineState->getStreamXfbBuffers();
         for (unsigned j = 0; j < MaxTransformFeedbackBuffers; ++j) {
-          if ((gsResUsage->inOutUsage.streamXfbBuffers[i] & (1 << j)) != 0) {
+          if ((streamXfbBuffers[i] & (1 << j)) != 0) {
             LLPC_OUTS(j);
             if (j != MaxTransformFeedbackBuffers - 1)
               LLPC_OUTS(", ");
           }
         }
       }
 
       LLPC_OUTS("\n");
     }
     LLPC_OUTS("\n");
@@ -1230,23 +1239,20 @@ void PatchResourceCollect::processMissingFs() {
   // pre-rasterization stage.
   for (std::pair<unsigned, unsigned> oneLocInfo : fsInputMappings.builtInLocationInfo) {
     m_resUsage->inOutUsage.builtInInputLocMap[oneLocInfo.first] = oneLocInfo.second;
     switch (oneLocInfo.first) {
     case BuiltInPrimitiveId:
       m_resUsage->builtInUsage.fs.primitiveId = true;
       break;
     case BuiltInLayer:
       m_resUsage->builtInUsage.fs.layer = true;
       break;
-    case BuiltInViewIndex:
-      m_resUsage->builtInUsage.fs.viewIndex = true;
-      break;
     case BuiltInViewportIndex:
       m_resUsage->builtInUsage.fs.viewportIndex = true;
       break;
     default:
       break;
     }
   }
   m_resUsage->builtInUsage.fs.clipDistance = fsInputMappings.clipDistanceCount;
   m_resUsage->builtInUsage.fs.cullDistance = fsInputMappings.cullDistanceCount;
 }
@@ -1348,21 +1354,21 @@ void PatchResourceCollect::visitCallInst(CallInst &callInst) {
         outLocInfo.setLocation(cast<ConstantInt>(callInst.getArgOperand(0))->getZExtValue());
         outLocInfo.setComponent(cast<ConstantInt>(callInst.getArgOperand(1))->getZExtValue());
         if (m_shaderStage == ShaderStageGeometry)
           outLocInfo.setStreamId(cast<ConstantInt>(callInst.getArgOperand(2))->getZExtValue());
         // Also, we remove the output location info from the map if it exists
         auto &outLocInfoMap = m_resUsage->inOutUsage.outputLocInfoMap;
         if (outLocInfoMap.count(outLocInfo) > 0)
           outLocInfoMap.erase(outLocInfo);
         // For GS, we remove transform feedback location info as well if it exists
         if (m_shaderStage == ShaderStageGeometry) {
-          auto &locInfoXfbOutInfoMap = m_resUsage->inOutUsage.gs.locInfoXfbOutInfoMap;
+          auto &locInfoXfbOutInfoMap = m_resUsage->inOutUsage.locInfoXfbOutInfoMap;
           if (locInfoXfbOutInfoMap.count(outLocInfo) > 0)
             locInfoXfbOutInfoMap.erase(outLocInfo);
         }
       }
     } else {
       m_outputCalls.push_back(&callInst);
     }
   } else if (mangledName.startswith(lgcName::OutputExportBuiltIn)) {
     // NOTE: If an output value is undefined, we can safely drop it and remove the output export call.
     // Currently, do this for geometry shader.
@@ -1374,20 +1380,30 @@ void PatchResourceCollect::visitCallInst(CallInst &callInst) {
         unsigned builtInId = cast<ConstantInt>(callInst.getOperand(0))->getZExtValue();
         m_activeOutputBuiltIns.insert(builtInId);
       }
     }
   } else if (mangledName.startswith(lgcName::OutputExportXfb)) {
     auto outputValue = callInst.getArgOperand(callInst.arg_size() - 1);
     if (isa<UndefValue>(outputValue)) {
       // NOTE: If an output value is undefined, we can safely drop it and remove the transform feedback output export
       // call.
       m_deadCalls.push_back(&callInst);
+#if LLPC_BUILD_GFX11
+    } else if (m_pipelineState->enableSwXfb()) {
+      // Collect transform feedback output export calls, used in SW-emulated stream-out. For GS, the collecting will
+      // be done when we generate copy shader since GS is primitive-based.
+      if (m_shaderStage != ShaderStageGeometry) {
+        auto &inOutUsage = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage;
+        // A transform feedback output export call is expected to be <4 x dword> at most
+        inOutUsage.xfbOutputExpCount += outputValue->getType()->getPrimitiveSizeInBits() > 128 ? 2 : 1;
+      }
+#endif
     }
   }
 }
 
 // =====================================================================================================================
 // Clears inactive (those actually unused) inputs.
 void PatchResourceCollect::clearInactiveBuiltInInput() {
   // Clear those inactive built-in inputs (some are not checked, whose usage flags do not rely on their
   // actual uses)
   auto &builtInUsage = m_resUsage->builtInUsage;
@@ -1648,25 +1664,26 @@ void PatchResourceCollect::matchGenericInOut() {
   if (packInput)
     updateInputLocInfoMapWithPack();
   else
     updateInputLocInfoMapWithUnpack();
 
   // Do output matching and location remapping
   bool packOutput = m_pipelineState->canPackOutput(m_shaderStage);
   if (m_shaderStage == ShaderStageVertex && m_tcsInputHasDynamicIndexing)
     packOutput = false;
   if (packOutput) {
+    // OutputLocInfoMap is used for computing the shader hash and looking remapped location
+    updateOutputLocInfoMapWithPack();
     // Re-create output export calls to pack exp instruction for the last vertex processing stage
     if (m_shaderStage == m_pipelineState->getLastVertexProcessingStage() && m_shaderStage != ShaderStageGeometry)
       reassembleOutputExportCalls();
-    // OutputLocInfoMap is used for computing the shader hash and looking remapped location
-    updateOutputLocInfoMapWithPack();
+    m_outputCalls.clear();
   } else {
     updateOutputLocInfoMapWithUnpack();
   }
 
   // Update location count of input/output
   LLPC_OUTS("===============================================================================\n");
   LLPC_OUTS("// LLPC location input/output mapping results (" << getShaderStageAbbreviation(m_shaderStage)
                                                               << " shader)\n\n");
   auto &inOutUsage = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage;
   auto &inLocInfoMap = inOutUsage.inputLocInfoMap;
@@ -1848,26 +1865,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInPrimitiveId];
         inOutUsage.builtInOutputLocMap[BuiltInPrimitiveId] = mapLoc;
       }
 
       if (nextBuiltInUsage.layer) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInLayer) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInLayer];
         inOutUsage.builtInOutputLocMap[BuiltInLayer] = mapLoc;
       }
 
-      if (nextBuiltInUsage.viewIndex) {
-        assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewIndex) != nextInOutUsage.builtInInputLocMap.end());
-        const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewIndex];
-        inOutUsage.builtInOutputLocMap[BuiltInViewIndex] = mapLoc;
-      }
-
       if (nextBuiltInUsage.viewportIndex) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewportIndex) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewportIndex];
         inOutUsage.builtInOutputLocMap[BuiltInViewportIndex] = mapLoc;
       }
     } else if (nextStage == ShaderStageTessControl) {
       // VS  ==>  TCS
       const auto &nextBuiltInUsage = nextResUsage->builtInUsage.tcs;
       auto &nextInOutUsage = nextResUsage->inOutUsage;
 
@@ -1963,23 +1974,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
             ++mapLoc;
           inOutUsage.builtInOutputLocMap[BuiltInCullDistance] = mapLoc;
         }
       }
 
       if (builtInUsage.vs.viewportIndex)
         inOutUsage.builtInOutputLocMap[BuiltInViewportIndex] = availOutMapLoc++;
 
       if (builtInUsage.vs.layer)
         inOutUsage.builtInOutputLocMap[BuiltInLayer] = availOutMapLoc++;
-
-      if (builtInUsage.vs.viewIndex)
-        inOutUsage.builtInOutputLocMap[BuiltInViewIndex] = availOutMapLoc++;
     }
 
     inOutUsage.outputMapLocCount = std::max(inOutUsage.outputMapLocCount, availOutMapLoc);
   } else if (m_shaderStage == ShaderStageTessControl) {
     // TCS  ==>  XXX
     unsigned availInMapLoc = inOutUsage.inputMapLocCount;
     unsigned availOutMapLoc = inOutUsage.outputMapLocCount;
 
     unsigned availPerPatchOutMapLoc = inOutUsage.perPatchOutputMapLocCount;
 
@@ -1995,23 +2003,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
       if (builtInUsage.tcs.clipDistanceIn > 4)
         ++availInMapLoc;
     }
 
     if (builtInUsage.tcs.cullDistanceIn > 0) {
       inOutUsage.builtInInputLocMap[BuiltInCullDistance] = availInMapLoc++;
       if (builtInUsage.tcs.cullDistanceIn > 4)
         ++availInMapLoc;
     }
 
-    if (builtInUsage.tcs.viewIndex)
-      inOutUsage.builtInInputLocMap[BuiltInViewIndex] = availInMapLoc++;
-
     // Map built-in outputs to generic ones
     if (nextStage == ShaderStageTessEval) {
       const auto &nextBuiltInUsage = nextResUsage->builtInUsage.tes;
       auto &nextInOutUsage = nextResUsage->inOutUsage;
 
       // NOTE: For tessellation control shader, those built-in outputs that involve in output import have to
       // be mapped to generic ones even if they do not have corresponding built-in inputs used in next shader
       // stage.
       if (nextBuiltInUsage.positionIn) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInPosition) != nextInOutUsage.builtInInputLocMap.end());
@@ -2054,20 +2059,22 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInCullDistance];
         inOutUsage.builtInOutputLocMap[BuiltInCullDistance] = mapLoc;
         availOutMapLoc = std::max(availOutMapLoc, mapLoc + (nextBuiltInUsage.cullDistanceIn > 4 ? 2u : 1u));
       } else {
         if (m_importedOutputBuiltIns.find(BuiltInCullDistance) != m_importedOutputBuiltIns.end())
           inOutUsage.builtInOutputLocMap[BuiltInCullDistance] = InvalidValue;
         else
           builtInUsage.tcs.cullDistance = 0;
       }
 
+      // NOTE: We shouldn't clear the usage of tessellation levels if the next stage doesn't read them back because they
+      // are always required to be written to TF buffer.
       if (nextBuiltInUsage.tessLevelOuter) {
         assert(nextInOutUsage.perPatchBuiltInInputLocMap.find(BuiltInTessLevelOuter) !=
                nextInOutUsage.perPatchBuiltInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.perPatchBuiltInInputLocMap[BuiltInTessLevelOuter];
         inOutUsage.perPatchBuiltInOutputLocMap[BuiltInTessLevelOuter] = mapLoc;
         availPerPatchOutMapLoc = std::max(availPerPatchOutMapLoc, mapLoc + 1);
       }
 
       if (nextBuiltInUsage.tessLevelInner) {
         assert(nextInOutUsage.perPatchBuiltInInputLocMap.find(BuiltInTessLevelInner) !=
@@ -2199,32 +2206,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInPrimitiveId) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInPrimitiveId];
         inOutUsage.builtInOutputLocMap[BuiltInPrimitiveId] = mapLoc;
       }
 
       if (nextBuiltInUsage.layer) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInLayer) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInLayer];
         inOutUsage.builtInOutputLocMap[BuiltInLayer] = mapLoc;
       }
-
-      if (nextBuiltInUsage.viewIndex) {
-        assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewIndex) != nextInOutUsage.builtInInputLocMap.end());
-        const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewIndex];
-        inOutUsage.builtInOutputLocMap[BuiltInViewIndex] = mapLoc;
-      }
-
-      if (nextBuiltInUsage.viewportIndex) {
-        assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewportIndex) != nextInOutUsage.builtInInputLocMap.end());
-        const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewportIndex];
-        inOutUsage.builtInOutputLocMap[BuiltInViewportIndex] = mapLoc;
-      }
     } else if (nextStage == ShaderStageGeometry) {
       // TES  ==>  GS
       const auto &nextBuiltInUsage = nextResUsage->builtInUsage.gs;
       auto &nextInOutUsage = nextResUsage->inOutUsage;
 
       if (nextBuiltInUsage.positionIn) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInPosition) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInPosition];
         inOutUsage.builtInOutputLocMap[BuiltInPosition] = mapLoc;
         availOutMapLoc = std::max(availOutMapLoc, mapLoc + 1);
@@ -2274,23 +2269,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
             ++mapLoc;
           inOutUsage.builtInOutputLocMap[BuiltInCullDistance] = mapLoc;
         }
       }
 
       if (builtInUsage.tes.viewportIndex)
         inOutUsage.builtInOutputLocMap[BuiltInViewportIndex] = availOutMapLoc++;
 
       if (builtInUsage.tes.layer)
         inOutUsage.builtInOutputLocMap[BuiltInLayer] = availOutMapLoc++;
-
-      if (builtInUsage.tes.viewIndex)
-        inOutUsage.builtInOutputLocMap[BuiltInViewIndex] = availOutMapLoc++;
     }
 
     inOutUsage.inputMapLocCount = std::max(inOutUsage.inputMapLocCount, availInMapLoc);
     inOutUsage.outputMapLocCount = std::max(inOutUsage.outputMapLocCount, availOutMapLoc);
 
     inOutUsage.perPatchInputMapLocCount = std::max(inOutUsage.perPatchInputMapLocCount, availPerPatchInMapLoc);
   } else if (m_shaderStage == ShaderStageGeometry) {
     // GS  ==>  XXX
     unsigned availInMapLoc = inOutUsage.inputMapLocCount;
 
@@ -2325,26 +2317,26 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
 
     if (builtInUsage.gs.cullDistance > 0)
       mapGsBuiltInOutput(BuiltInCullDistance, builtInUsage.gs.cullDistance);
 
     if (builtInUsage.gs.primitiveId)
       mapGsBuiltInOutput(BuiltInPrimitiveId, 1);
 
     if (builtInUsage.gs.layer)
       mapGsBuiltInOutput(BuiltInLayer, 1);
 
-    if (builtInUsage.gs.viewIndex)
-      mapGsBuiltInOutput(BuiltInViewIndex, 1);
-
     if (builtInUsage.gs.viewportIndex)
       mapGsBuiltInOutput(BuiltInViewportIndex, 1);
 
+    if (m_pipelineState->getInputAssemblyState().enableMultiView)
+      mapGsBuiltInOutput(BuiltInViewIndex, 1);
+
     if (builtInUsage.gs.primitiveShadingRate)
       mapGsBuiltInOutput(BuiltInPrimitiveShadingRate, 1);
 
     // Map built-in outputs to generic ones (for copy shader)
     auto &builtInOutLocs = inOutUsage.gs.builtInOutLocs;
 
     if (nextStage == ShaderStageFragment) {
       // GS  ==>  FS
       const auto &nextBuiltInUsage = nextResUsage->builtInUsage.fs;
       auto &nextInOutUsage = nextResUsage->inOutUsage;
@@ -2366,26 +2358,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInPrimitiveId];
         builtInOutLocs[BuiltInPrimitiveId] = mapLoc;
       }
 
       if (nextBuiltInUsage.layer) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInLayer) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInLayer];
         builtInOutLocs[BuiltInLayer] = mapLoc;
       }
 
-      if (nextBuiltInUsage.viewIndex) {
-        assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewIndex) != nextInOutUsage.builtInInputLocMap.end());
-        const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewIndex];
-        builtInOutLocs[BuiltInViewIndex] = mapLoc;
-      }
-
       if (nextBuiltInUsage.viewportIndex) {
         assert(nextInOutUsage.builtInInputLocMap.find(BuiltInViewportIndex) != nextInOutUsage.builtInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.builtInInputLocMap[BuiltInViewportIndex];
         builtInOutLocs[BuiltInViewportIndex] = mapLoc;
       }
     } else if (nextStage == ShaderStageInvalid) {
       // GS only
       unsigned availOutMapLoc = inOutUsage.outputLocInfoMap.size(); // Reset available location
 
       if (builtInUsage.gs.clipDistance > 0 || builtInUsage.gs.cullDistance > 0) {
@@ -2406,29 +2392,25 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
       }
 
       if (builtInUsage.gs.primitiveId)
         builtInOutLocs[BuiltInPrimitiveId] = availOutMapLoc++;
 
       if (builtInUsage.gs.viewportIndex)
         builtInOutLocs[BuiltInViewportIndex] = availOutMapLoc++;
 
       if (builtInUsage.gs.layer)
         builtInOutLocs[BuiltInLayer] = availOutMapLoc++;
-
-      if (builtInUsage.gs.viewIndex)
-        builtInOutLocs[BuiltInViewIndex] = availOutMapLoc++;
     }
 
     inOutUsage.inputMapLocCount = std::max(inOutUsage.inputMapLocCount, availInMapLoc);
   } else if (m_shaderStage == ShaderStageMesh) {
     // Mesh shader -> XXX
-    const bool enableMultiView = m_pipelineState->getInputAssemblyState().enableMultiView;
     unsigned availOutMapLoc = inOutUsage.outputMapLocCount;
     unsigned availPerPrimitiveOutMapLoc = inOutUsage.perPrimitiveOutputMapLocCount;
 
     // Map per-vertex built-in outputs to generic ones
     if (builtInUsage.mesh.position)
       inOutUsage.builtInOutputLocMap[BuiltInPosition] = availOutMapLoc++;
 
     if (builtInUsage.mesh.pointSize)
       inOutUsage.builtInOutputLocMap[BuiltInPointSize] = availOutMapLoc++;
 
@@ -2515,27 +2497,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         const unsigned mapLoc = nextInOutUsage.perPrimitiveBuiltInInputLocMap[BuiltInLayer];
         inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInLayer] = mapLoc;
       }
 
       if (nextBuiltInUsage.viewportIndex) {
         assert(nextInOutUsage.perPrimitiveBuiltInInputLocMap.find(BuiltInViewportIndex) !=
                nextInOutUsage.perPrimitiveBuiltInInputLocMap.end());
         const unsigned mapLoc = nextInOutUsage.perPrimitiveBuiltInInputLocMap[BuiltInViewportIndex];
         inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInViewportIndex] = mapLoc;
       }
-
-      if (enableMultiView && nextBuiltInUsage.viewIndex) {
-        assert(nextInOutUsage.perPrimitiveBuiltInInputLocMap.find(BuiltInViewIndex) !=
-               nextInOutUsage.perPrimitiveBuiltInInputLocMap.end());
-        const unsigned mapLoc = nextInOutUsage.perPrimitiveBuiltInInputLocMap[BuiltInViewIndex];
-        inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInViewIndex] = mapLoc;
-      }
     } else if (nextStage == ShaderStageInvalid) {
       // Mesh shader only
       unsigned availPerPrimitiveExportLoc = inOutUsage.perPrimitiveOutputMapLocCount;
 
       if (builtInUsage.mesh.primitiveId)
         inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInPrimitiveId] = availPerPrimitiveExportLoc++;
 
       if (builtInUsage.mesh.layer)
         inOutUsage.mesh.perPrimitiveBuiltInExportLocs[BuiltInLayer] = availPerPrimitiveExportLoc++;
 
@@ -2572,27 +2547,20 @@ void PatchResourceCollect::mapBuiltInToGenericInOut() {
         inOutUsage.builtInInputLocMap[BuiltInLayer] = availInMapLoc++;
     }
 
     if (builtInUsage.fs.viewportIndex) {
       if (prevStage == ShaderStageMesh)
         inOutUsage.perPrimitiveBuiltInInputLocMap[BuiltInViewportIndex] = availPerPrimitiveInMapLoc++;
       else
         inOutUsage.builtInInputLocMap[BuiltInViewportIndex] = availInMapLoc++;
     }
 
-    if (builtInUsage.fs.viewIndex) {
-      if (prevStage == ShaderStageMesh)
-        inOutUsage.perPrimitiveBuiltInInputLocMap[BuiltInViewIndex] = availPerPrimitiveInMapLoc++;
-      else
-        inOutUsage.builtInInputLocMap[BuiltInViewIndex] = availInMapLoc++;
-    }
-
     if (builtInUsage.fs.clipDistance > 0 || builtInUsage.fs.cullDistance > 0) {
       unsigned mapLoc = availInMapLoc++;
       if (builtInUsage.fs.clipDistance + builtInUsage.fs.cullDistance > 4) {
         assert(builtInUsage.fs.clipDistance + builtInUsage.fs.cullDistance <= MaxClipCullDistanceCount);
         ++availInMapLoc; // Occupy two locations
       }
 
       if (builtInUsage.fs.clipDistance > 0)
         inOutUsage.builtInInputLocMap[BuiltInClipDistance] = mapLoc;
 
@@ -2837,21 +2805,21 @@ void PatchResourceCollect::clearUnusedOutput() {
       if (m_shaderStage == ShaderStageFragment) {
         // Collect locations with invalid data format
         const bool generatingColorExportShader =
             m_pipelineState->isUnlinked() && !m_pipelineState->hasColorExportFormats();
         if (!generatingColorExportShader && m_pipelineState->getColorExportFormat(origLoc).dfmt == BufDataFormatInvalid)
           unusedLocInfos.push_back(locInfoPair.first);
       } else {
         // Collect locations of those outputs that are not used
         bool isOutputXfb = false;
         if (m_shaderStage == ShaderStageGeometry)
-          isOutputXfb = inOutUsage.gs.locInfoXfbOutInfoMap.count(locInfoPair.first) > 0;
+          isOutputXfb = inOutUsage.locInfoXfbOutInfoMap.count(locInfoPair.first) > 0;
 
         if (!isOutputXfb && nextInLocInfoMap.find(locInfoPair.first) == nextInLocInfoMap.end()) {
           bool isActiveLoc = false;
           if (m_shaderStage == ShaderStageTessControl) {
             // NOTE: If either dynamic indexing of generic outputs exists or the generic output involve in
             // output import, we have to mark it as active.
             isActiveLoc = dynIndexedOrImportOutputLocs.find(origLoc) != dynIndexedOrImportOutputLocs.end();
           }
           if (isActiveLoc) {
             // The assigned location must not overlap with those used by inputs of next shader stage.
@@ -3014,136 +2982,168 @@ void PatchResourceCollect::updateInputLocInfoMapWithPack() {
   const bool isTcs = m_shaderStage == ShaderStageTessControl;
   const bool isFs = m_shaderStage == ShaderStageFragment;
   const bool isGs = m_shaderStage == ShaderStageGeometry;
   assert(isTcs || isFs || isGs);
 
   // TCS: @lgc.input.import.generic.%Type%(i32 location, i32 locOffset, i32 elemIdx, i32 vertexIdx)
   // GS: @lgc.input.import.generic.%Type%(i32 location, i32 elemIdx, i32 vertexIdx)
   // FS: @lgc.input.import.generic.%Type%(i32 location, i32 elemIdx, i1 perPrimitive, i32 interpMode, i32 interpLoc)
   //     @lgc.input.import.interpolant.%Type%(i32 location, i32 locOffset, i32 elemIdx,
   //                                          i32 interpMode, <2 x float> | i32 auxInterpValue)
-
-  // The locations of TCS with dynamic indexing (locOffset/elemIdx) cannot be unpacked
-  // NOTE: Dynamic indexing in FS is processed to be constant in the lower pass.
-  std::vector<CallInst *> packableCalls;
-  packableCalls = std::move(m_inputCalls);
+  // NOTE: Dynamic indexing in FS is processed to be constant in the lower pass and TCS has dynamic indexing will go
+  // through unpacked path
 
   // LDS load/store copes with dword. For 8-bit/16-bit data type, we will extend them to 32-bit
   bool partPipelineHasGs = m_pipelineState->isPartPipeline() && m_pipelineState->getPreRasterHasGs();
   bool isFsAndHasGs = (isFs && (m_pipelineState->hasShaderStage(ShaderStageGeometry) || partPipelineHasGs));
   bool requireDword = isTcs || isGs || isFsAndHasGs;
-  // Create locationMap according to the packable calls
-  m_locationInfoMapManager->createMap(packableCalls, m_shaderStage, requireDword);
+  // Create locationMap
+  m_locationInfoMapManager->createMap(m_inputCalls, m_shaderStage, requireDword);
 
   // Fill inputLocInfoMap of {TCS, GS, FS} for the packable calls
   unsigned newLocIdx = 0;
-  for (auto call : packableCalls) {
+  for (auto call : m_inputCalls) {
     const bool isInterpolant = call->getCalledFunction()->getName().startswith(lgcName::InputImportInterpolant);
     unsigned locOffset = 0;
     unsigned compIdxArgIdx = 1;
     if (isInterpolant || isTcs) {
       assert(isa<ConstantInt>(call->getOperand(1)));
       locOffset = cast<ConstantInt>(call->getOperand(1))->getZExtValue();
       compIdxArgIdx = 2;
     }
     assert(isa<ConstantInt>(call->getOperand(compIdxArgIdx)));
 
     // Get the packed InOutLocationInfo from locationInfoMap
     InOutLocationInfo origLocInfo;
     origLocInfo.setLocation(cast<ConstantInt>(call->getOperand(0))->getZExtValue() + locOffset);
     origLocInfo.setComponent(cast<ConstantInt>(call->getOperand(compIdxArgIdx))->getZExtValue());
+    if (isFs && isInterpolant) {
+      const unsigned interpMode = cast<ConstantInt>(call->getOperand(3))->getZExtValue();
+      origLocInfo.setFlat(interpMode == InOutInfo::InterpModeFlat);
+      origLocInfo.setCustom(interpMode == InOutInfo::InterpModeCustom);
+    }
     InOutLocationInfoMap::const_iterator mapIter;
     assert(m_locationInfoMapManager->findMap(origLocInfo, mapIter));
     m_locationInfoMapManager->findMap(origLocInfo, mapIter);
     inputLocInfoMap[origLocInfo] = mapIter->second;
     newLocIdx = std::max(newLocIdx, mapIter->second.getLocation() + 1);
   }
-  if (isTcs) {
-    // Fill inputLocInfoMap for the unpackable calls of TCS
-    for (auto &locInfo : inputLocInfoMap) {
-      if (locInfo.second.isInvalid()) {
-        locInfo.second.setData(0);
-        locInfo.second.setLocation(newLocIdx++);
-      }
-    }
-  }
+  m_inputCalls.clear();
 }
 
 // =====================================================================================================================
 // Update outputLocInfoMap based on inputLocInfoMap of next stage or GS output export calls for copy shader
 void PatchResourceCollect::updateOutputLocInfoMapWithPack() {
   auto &inOutUsage = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage;
   auto &outputLocInfoMap = inOutUsage.outputLocInfoMap;
   outputLocInfoMap.clear();
 
   if (m_outputCalls.empty())
     return;
 
-  if (m_shaderStage != ShaderStageGeometry) {
-    assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval);
-    auto nextStage = m_pipelineState->getNextShaderStage(m_shaderStage);
-    assert(nextStage != ShaderStageInvalid);
-    // In reassembleOutputExportCalls, the unused calls in next stage have been added into dead call set.
-    bool isMarkedDeadCall = (m_shaderStage == m_pipelineState->getLastVertexProcessingStage());
-    auto &nextStageInputLocInfoMap = m_pipelineState->getShaderResourceUsage(nextStage)->inOutUsage.inputLocInfoMap;
+  assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
+         m_shaderStage == ShaderStageGeometry);
+  auto nextStage = m_pipelineState->getNextShaderStage(m_shaderStage);
+  assert(nextStage != ShaderStageInvalid);
+  auto &nextStageInputLocInfoMap = m_pipelineState->getShaderResourceUsage(nextStage)->inOutUsage.inputLocInfoMap;
+
+  // Remove unused outputs and update the output map
+  if (m_shaderStage != m_pipelineState->getLastVertexProcessingStage()) {
+    // For VS-{TCS, GS}, the dead output has no matching input of the next stage
     for (auto call : m_outputCalls) {
       InOutLocationInfo origLocInfo;
       origLocInfo.setLocation(cast<ConstantInt>(call->getOperand(0))->getZExtValue());
       origLocInfo.setComponent(cast<ConstantInt>(call->getOperand(1))->getZExtValue());
-
-      auto locInfoMapIt = nextStageInputLocInfoMap.find(origLocInfo);
-      if (locInfoMapIt != nextStageInputLocInfoMap.end())
-        outputLocInfoMap[origLocInfo] = locInfoMapIt->second;
-      else if (!isMarkedDeadCall)
-        m_deadCalls.push_back(call); // unused call in next stage
+      if (nextStageInputLocInfoMap.find(origLocInfo) == nextStageInputLocInfoMap.end())
+        m_deadCalls.push_back(call);
+    }
+    // The output map should be equal to the input map of the next stage
+    outputLocInfoMap = nextStageInputLocInfoMap;
+  } else {
+    // For {VS, TES, GS}-FS, the dead output is neither a XFB output or a corresponding FS' input.
+    // Collect XFB locations
+    auto &xfbOutLocInfoMap = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage.locInfoXfbOutInfoMap;
+    std::set<unsigned> xfbOutputLocs[MaxGsStreams];
+    for (const auto &locInfoPair : xfbOutLocInfoMap) {
+      const auto &locInfo = locInfoPair.first;
+      xfbOutputLocs[locInfo.getStreamId()].insert(locInfo.getLocation());
+    }
+
+    // Collect flat-shading locations and custom interpolation locations
+    std::set<unsigned> flatInputLocs;
+    std::set<unsigned> customInputLocs;
+    for (const auto &locInfoPair : nextStageInputLocInfoMap) {
+      const auto &locInfo = locInfoPair.first;
+      if (locInfo.isFlat())
+        flatInputLocs.insert(locInfo.getLocation());
+      else if (locInfo.isCustom())
+        customInputLocs.insert(locInfo.getLocation());
+    }
+
+    // Add dead calls
+    for (auto call : m_outputCalls) {
+      InOutLocationInfo origLocInfo;
+      origLocInfo.setLocation(cast<ConstantInt>(call->getOperand(0))->getZExtValue());
+      origLocInfo.setComponent(cast<ConstantInt>(call->getOperand(1))->getZExtValue());
+      unsigned streamId = 0;
+      if (m_shaderStage == ShaderStageGeometry) {
+        streamId = cast<ConstantInt>(call->getOperand(2))->getZExtValue();
+        origLocInfo.setStreamId(streamId);
+      }
+      const unsigned origLocation = origLocInfo.getLocation();
+      bool isUsed = xfbOutputLocs[streamId].count(origLocation) > 0 || flatInputLocs.count(origLocation) > 0 ||
+                    customInputLocs.count(origLocation) > 0 || nextStageInputLocInfoMap.count(origLocInfo) > 0;
+      if (!isUsed)
+        m_deadCalls.push_back(call);
+    }
+
+    auto *locInfoMap = &nextStageInputLocInfoMap;
+
+    // If the outputs are allowed to have no matching inputs, such as XFB output and non-raster streams outputs, we
+    // should build the output map based on output info, otherwise, update the output map via the input map of the next
+    // stage.
+    if (xfbOutLocInfoMap.size() > 0 || xfbOutputLocs[1].size() > 0 || xfbOutputLocs[2].size() > 0 ||
+        xfbOutputLocs[3].size() > 0) {
+      std::vector<InOutLocationInfo> outLocInfos;
+      for (auto call : m_outputCalls) {
+        InOutLocationInfo origLocInfo;
+        origLocInfo.setLocation(cast<ConstantInt>(call->getOperand(0))->getZExtValue());
+        origLocInfo.setComponent(cast<ConstantInt>(call->getOperand(1))->getZExtValue());
+        if (m_shaderStage == ShaderStageGeometry)
+          origLocInfo.setStreamId(cast<ConstantInt>(call->getOperand(2))->getZExtValue());
+        if (flatInputLocs.count(origLocInfo.getLocation()))
+          origLocInfo.setFlat(true);
+        else if (customInputLocs.count(origLocInfo.getLocation()))
+          origLocInfo.setCustom(true);
+        outLocInfos.push_back(origLocInfo);
+      }
+      m_locationInfoMapManager->createMap(outLocInfos, m_shaderStage);
+      locInfoMap = &m_locationInfoMapManager->getMap();
     }
-    m_outputCalls.clear();
-    return;
-  }
 
-  // For GS, the outputLocInfoMap is created according to the output calls in each stream
-  // LDS load/store copes with dword
-  m_locationInfoMapManager->createMap(m_outputCalls, m_shaderStage, true);
-  m_outputCalls.clear();
+    // Update the output map
+    for (auto &locInfoPair : *locInfoMap) {
+      InOutLocationInfo origLocInfo;
+      origLocInfo.setStreamId(locInfoPair.first.getStreamId());
+      origLocInfo.setLocation(locInfoPair.first.getLocation());
+      origLocInfo.setComponent(locInfoPair.first.getComponent());
+      outputLocInfoMap.insert({origLocInfo, locInfoPair.second});
+    }
 
-  auto &fsInOutUsage = m_pipelineState->getShaderResourceUsage(ShaderStageFragment)->inOutUsage;
-  auto &fsInputLocInfoMap = fsInOutUsage.inputLocInfoMap;
-  auto &locationInfoMap = m_locationInfoMapManager->getMap();
-
-  const bool hasNullFs = fsInOutUsage.fs.isNullFs || fsInputLocInfoMap.empty();
-  if (!hasNullFs) {
-    // Update mapped location infos (excluding XFB output) in raster stream according to inputLocInfoMap fo FS
-    for (auto locInfoMapIt = locationInfoMap.begin(); locInfoMapIt != locationInfoMap.end();) {
-      const auto &origLocInfo = locInfoMapIt->first;
-      const bool isOutputXfb = inOutUsage.gs.locInfoXfbOutInfoMap.count(locInfoMapIt->first) > 0;
-      if (origLocInfo.getStreamId() == inOutUsage.gs.rasterStream && !isOutputXfb) {
-        if (fsInputLocInfoMap.count(origLocInfo) > 0) {
-          // Get remmapped InOutLocationInfo from the inputLocMap of FS
-          locInfoMapIt->second = fsInputLocInfoMap[origLocInfo];
-          ++locInfoMapIt;
-        } else {
-          // Erase the output that is not used by FS
-          locInfoMapIt = locationInfoMap.erase(locInfoMapIt);
-        }
-      } else {
-        ++locInfoMapIt;
+    // update output count per stream for GS
+    if (m_shaderStage == ShaderStageGeometry) {
+      for (auto &locInfoPair : outputLocInfoMap) {
+        auto &outLocCount = inOutUsage.gs.outLocCount[locInfoPair.first.getStreamId()];
+        outLocCount = std::max(outLocCount, locInfoPair.second.getLocation() + 1);
       }
     }
   }
-
-  outputLocInfoMap = std::move(locationInfoMap);
-  // Update inOutUsage.gs.outLocCount
-  for (auto &locInfoPair : outputLocInfoMap) {
-    const auto &newLocInfo = locInfoPair.second;
-    auto &outLocCount = inOutUsage.gs.outLocCount[newLocInfo.getStreamId()];
-    outLocCount = std::max(outLocCount, newLocInfo.getLocation() + 1);
-  }
 }
 
 // =====================================================================================================================
 // Re-assemble output export functions based on the locationInfoMap
 void PatchResourceCollect::reassembleOutputExportCalls() {
   if (m_outputCalls.empty())
     return;
   assert(m_pipelineState->canPackOutput(m_shaderStage));
 
   BuilderBase builder(*m_context);
@@ -3162,32 +3162,34 @@ void PatchResourceCollect::reassembleOutputExportCalls() {
                   "The code assumes that 'elements' and 'outCalls' have the same number of elements");
     // Element number of 32-bit
     unsigned elemCountOf32bit = 0;
     // Element number of 16-bit
     unsigned elemCountOf16bit = 0;
     // First component index in the mapped vector.
     unsigned baseMappedComponentIdx = InvalidValue;
   };
 
   // Collect ElementsInfo in each packed location
-  const unsigned locCount = m_locationInfoMapManager->getMap().size();
-  std::vector<ElementsInfo> elementsInfoArray(locCount);
+  auto &outputLocInfoMap = m_pipelineState->getShaderResourceUsage(m_shaderStage)->inOutUsage.outputLocInfoMap;
+  std::vector<ElementsInfo> elementsInfoArray(outputLocInfoMap.size());
 
   for (auto call : m_outputCalls) {
     InOutLocationInfo origLocInfo;
     origLocInfo.setLocation(cast<ConstantInt>(call->getOperand(0))->getZExtValue());
     origLocInfo.setComponent(cast<ConstantInt>(call->getOperand(1))->getZExtValue());
 
-    m_deadCalls.push_back(call);
-    InOutLocationInfoMap::const_iterator mapIter;
-    if (!m_locationInfoMapManager->findMap(origLocInfo, mapIter))
+    auto mapIter = outputLocInfoMap.find(origLocInfo);
+    // Unused scalarized calls have been added into dead call set
+    if (mapIter == outputLocInfoMap.end())
       continue;
+    // Add used scalarized calls to dead call set
+    m_deadCalls.push_back(call);
 
     const unsigned newLoc = mapIter->second.getLocation();
     auto &elementsInfo = elementsInfoArray[newLoc];
 
     const unsigned origComponentIdx = mapIter->second.getComponent();
     // Update the first components used
     elementsInfo.baseMappedComponentIdx = std::min(elementsInfo.baseMappedComponentIdx, origComponentIdx);
 
     const unsigned elemIdx = origComponentIdx * 2 + (mapIter->second.isHighHalf() ? 1 : 0);
     elementsInfo.outCalls[elemIdx] = call;
@@ -3515,36 +3517,49 @@ void PatchResourceCollect::scalarizeGenericOutput(CallInst *call) {
 // @param shaderStage : Shader stage
 // @param requireDword : Whether need extend 8-bit/16-bit data to dword
 void InOutLocationInfoMapManager::createMap(const std::vector<CallInst *> &calls, ShaderStage shaderStage,
                                             bool requireDword) {
   for (auto call : calls)
     addSpan(call, shaderStage, requireDword);
   // Build locationInfoMap according to the collected LocationSpans
   buildMap(shaderStage);
 }
 
+// =====================================================================================================================
+// Create a locationInfo map for the given shader stage
+//
+// @param locInfos : location infos to process
+// @param shaderStage : Shader stage
+void InOutLocationInfoMapManager::createMap(const std::vector<InOutLocationInfo> &locInfos, ShaderStage shaderStage) {
+  for (const auto &locInfo : locInfos) {
+    LocationSpan span{};
+    span.firstLocationInfo = locInfo;
+    m_locationSpans.insert(span);
+  }
+  buildMap(shaderStage);
+}
+
 // =====================================================================================================================
 // Create a locationInfo map by deserializing the serialized map. Used when compiling the vertex-processing
 // part-pipeline given the packed input map from the separate FS compilation.
 void InOutLocationInfoMapManager::deserializeMap(ArrayRef<std::pair<unsigned, unsigned>> serializedMap) {
   m_locationInfoMap.clear();
   for (std::pair<unsigned, unsigned> entry : serializedMap)
     m_locationInfoMap[entry.first] = entry.second;
 }
 
 // =====================================================================================================================
 // Fill the locationSpan container by constructing a LocationSpan from each input import call or GS output export call
 //
 // @param call : Call to process
 // @param shaderStage : Shader stage
 // @param requireDword : Whether need extend to dword
-// @param resUsage : The resource usage reference
 void InOutLocationInfoMapManager::addSpan(CallInst *call, ShaderStage shaderStage, bool requireDword) {
   const bool isFs = shaderStage == ShaderStageFragment;
   const bool isInterpolant = call->getCalledFunction()->getName().startswith(lgcName::InputImportInterpolant);
   unsigned locOffset = 0;
   unsigned compIdxArgIdx = 1;
   if (isInterpolant || shaderStage == ShaderStageTessControl) {
     assert(isa<ConstantInt>(call->getOperand(1)));
     locOffset = cast<ConstantInt>(call->getOperand(1))->getZExtValue();
     compIdxArgIdx = 2;
   }
@@ -3563,90 +3578,81 @@ void InOutLocationInfoMapManager::addSpan(CallInst *call, ShaderStage shaderStag
   if (requireDword && bitWidth < 32)
     bitWidth = 32;
   else if (bitWidth == 8)
     bitWidth = 16;
   span.compatibilityInfo.halfComponentCount = bitWidth / 16;
   // For VS/TES-FS, 32-bit and 16-bit are packed separately; For VS-TCS, VS/TES-GS and GS-FS, they are packed together
   span.compatibilityInfo.is16Bit = bitWidth == 16;
 
   if (isFs && isInterpolant) {
     const unsigned interpMode = cast<ConstantInt>(call->getOperand(3))->getZExtValue();
-    span.compatibilityInfo.isFlat = interpMode == InOutInfo::InterpModeFlat;
-    span.compatibilityInfo.isCustom = interpMode == InOutInfo::InterpModeCustom;
-
-    assert(isInterpolant || (!isInterpolant && !is_contained(m_locationSpans, span)));
-  }
-  if (!is_contained(m_locationSpans, span)) {
-    m_locationSpans.push_back(span);
+    span.firstLocationInfo.setFlat(interpMode == InOutInfo::InterpModeFlat);
+    span.firstLocationInfo.setCustom(interpMode == InOutInfo::InterpModeCustom);
   }
+  m_locationSpans.insert(span);
 }
 
 // =====================================================================================================================
 // Build the map between original InOutLocationInfo and packed InOutLocationInfo based on sorted location spans
 //
 // @param shaderStage : The shader stage to determine whether to check compatibility
 void InOutLocationInfoMapManager::buildMap(ShaderStage shaderStage) {
+  m_locationInfoMap.clear();
   if (m_locationSpans.empty())
     return;
-  // Sort m_locationSpans based on LocationSpan::GetCompatibilityKey() and InOutLocationInfo::AsIndex()
-  std::sort(m_locationSpans.begin(), m_locationSpans.end());
-
-  m_locationInfoMap.clear();
 
   // Map original InOutLocationInfo to new InOutLocationInfo
   unsigned consecutiveLocation = 0;
   unsigned compIdx = 0;
   bool isHighHalf = false;
   const bool isGs = shaderStage == ShaderStageGeometry;
-  // For GS, the locationSpans in the same stream is compatible.
-  // No need to check compatibility means all locationSpans are compatible.
-  const bool checkCompatibility = shaderStage == ShaderStageFragment || isGs;
+
   for (auto spanIt = m_locationSpans.begin(); spanIt != m_locationSpans.end(); ++spanIt) {
     if (spanIt != m_locationSpans.begin()) {
       // Check the current span with previous span to determine whether it is put in the same location or the next
       // location.
       const auto &prevSpan = *(--spanIt);
       ++spanIt;
 
-      bool compatible = true;
-      if (checkCompatibility)
-        compatible = isCompatible(prevSpan, *spanIt, isGs);
+      bool compatible = isCompatible(prevSpan, *spanIt, shaderStage);
 
       // If the current locationSpan is compatible with previous one, increase component index with location unchanged
       // until the component index is up to 4 and increase location index and reset component index to 0. Otherwise,
       // reset the location index for GS or increase location index, and reset component index to 0.
       if (compatible) {
         if (compIdx > 3) {
           ++consecutiveLocation;
           compIdx = 0;
           isHighHalf = false;
         } else {
           isHighHalf = spanIt->compatibilityInfo.is16Bit ? !isHighHalf : false;
         }
       } else {
+        ++consecutiveLocation;
         // NOTE: For GS, the indexing of remapped location is zero-based in each stream
-        consecutiveLocation = isGs ? 0 : consecutiveLocation + 1;
+        if (isGs && spanIt->firstLocationInfo.getStreamId() != prevSpan.firstLocationInfo.getStreamId())
+          consecutiveLocation = 0;
         compIdx = 0;
         isHighHalf = false;
       }
     }
 
     // Add a location map item
     InOutLocationInfo newLocInfo;
     newLocInfo.setLocation(consecutiveLocation);
     newLocInfo.setComponent(compIdx);
     newLocInfo.setHighHalf(isHighHalf);
     newLocInfo.setStreamId(spanIt->firstLocationInfo.getStreamId());
     m_locationInfoMap.insert({spanIt->firstLocationInfo, newLocInfo});
 
     // Update component index
-    if ((spanIt->compatibilityInfo.is16Bit && isHighHalf) || !spanIt->compatibilityInfo.is16Bit)
+    if (isHighHalf || !spanIt->compatibilityInfo.is16Bit)
       ++compIdx;
     assert(compIdx <= 4);
   }
 
   // Exists temporarily for computing m_locationInfoMap
   m_locationSpans.clear();
 }
 
 // =====================================================================================================================
 // Output a mapped InOutLocationInfo from a given InOutLocationInfo if the mapping exists
diff --git a/lgc/patch/PatchSetupTargetFeatures.cpp b/lgc/patch/PatchSetupTargetFeatures.cpp
index 09f26ab6c..4c5bb74c9 100644
--- a/lgc/patch/PatchSetupTargetFeatures.cpp
+++ b/lgc/patch/PatchSetupTargetFeatures.cpp
@@ -119,27 +119,21 @@ void PatchSetupTargetFeatures::setupTargetFeatures(Module *module) {
   std::string globalFeatures = "";
 
   if (m_pipelineState->getOptions().includeDisassembly)
     globalFeatures += ",+DumpCode";
 
   for (auto func = module->begin(), end = module->end(); func != end; ++func) {
     if (func->isDeclaration())
       continue;
 
     std::string targetFeatures(globalFeatures);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 409358
-    // Old version of the code
-    AttrBuilder builder;
-#else
-    // New version of the code (also handles unknown version, which we treat as latest)
     AttrBuilder builder(module->getContext());
-#endif
 
     ShaderStage shaderStage = lgc::getShaderStage(&*func);
 
     if (shaderStage == ShaderStage::ShaderStageInvalid) {
       errs() << "Invalid shader stage for function " << func->getName() << "\n";
       report_fatal_error("Got invalid shader stage when setting up features for function");
     }
 
     if (isShaderEntryPoint(&*func)) {
       bool useSiScheduler = m_pipelineState->getShaderOptions(shaderStage).useSiScheduler;
@@ -183,33 +177,29 @@ void PatchSetupTargetFeatures::setupTargetFeatures(Module *module) {
     }
 
     auto gfxIp = m_pipelineState->getTargetInfo().getGfxIpVersion();
 
     if (gfxIp.major >= 10) {
       // Setup wavefront size per shader stage
       unsigned waveSize = m_pipelineState->getShaderWaveSize(shaderStage);
 
       targetFeatures += ",+wavefrontsize" + std::to_string(waveSize);
 
-      // Allow driver setting for WGP by forcing backend to set 0
-      // which is then OR'ed with the driver set value
-      targetFeatures += ",+cumode";
+      if (m_pipelineState->getShaderWgpMode(shaderStage))
+        targetFeatures += ",-cumode";
+      else
+        targetFeatures += ",+cumode";
     }
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 414671
-    // Old version of the code
-#else
-    // New version of the code (also handles unknown version, which we treat as latest)
     // Enable flat scratch for gfx10.3+
     if (gfxIp.major == 10 && gfxIp.minor >= 3)
       targetFeatures += ",+enable-flat-scratch";
-#endif
 
     if (m_pipelineState->getTargetInfo().getGpuProperty().supportsXnack) {
       // Enable or disable xnack depending on whether page migration is enabled.
       if (m_pipelineState->getOptions().pageMigrationEnabled)
         targetFeatures += ",+xnack";
       else
         targetFeatures += ",-xnack";
     }
 
     // Set up denormal mode attributes.
@@ -231,25 +221,17 @@ void PatchSetupTargetFeatures::setupTargetFeatures(Module *module) {
       if (shaderMode.fp32DenormMode == FpDenormMode::FlushNone || shaderMode.fp32DenormMode == FpDenormMode::FlushIn) {
         builder.addAttribute("denormal-fp-math-f32", "ieee");
       } else if (shaderMode.fp32DenormMode == FpDenormMode::FlushOut ||
                  shaderMode.fp32DenormMode == FpDenormMode::FlushInOut) {
         builder.addAttribute("denormal-fp-math-f32", "preserve-sign");
       }
     }
 
     builder.addAttribute("target-features", targetFeatures);
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396807
-    // Old version of the code
-    AttributeList::AttrIndex attribIdx = AttributeList::AttrIndex(AttributeList::FunctionIndex);
-    func->addAttributes(attribIdx, builder);
-#else
-    // New version of the code (also handles unknown version, which we treat as
-    // latest)
     func->addFnAttrs(builder);
-#endif
   }
 }
 
 // =====================================================================================================================
 // Initializes the pass
 INITIALIZE_PASS(LegacyPatchSetupTargetFeatures, DEBUG_TYPE, "Patch LLVM to set up target features", false, false)
diff --git a/lgc/patch/PatchWaveSizeAdjust.cpp b/lgc/patch/PatchWaveSizeAdjust.cpp
index 825cf8325..1d6a94f16 100644
--- a/lgc/patch/PatchWaveSizeAdjust.cpp
+++ b/lgc/patch/PatchWaveSizeAdjust.cpp
@@ -25,20 +25,23 @@
 /**
  ***********************************************************************************************************************
  * @file  PatchWaveSizeAdjust.cpp
  * @brief LLPC source file: PatchWaveSizeAdjust pass
  ***********************************************************************************************************************
  */
 #include "lgc/patch/PatchWaveSizeAdjust.h"
 #include "lgc/patch/Patch.h"
 #include "lgc/state/TargetInfo.h"
 #include "llvm/IR/InstIterator.h"
+#if LLPC_BUILD_GFX11
+#include "llvm/IR/IntrinsicInst.h"
+#endif
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/Support/Debug.h"
 
 #define DEBUG_TYPE "lgc-patch-wave-size-adjust"
 
 using namespace lgc;
 using namespace llvm;
 
 char LegacyPatchWaveSizeAdjust::ID = 0;
 
@@ -90,16 +93,87 @@ bool PatchWaveSizeAdjust::runImpl(Module &module, PipelineState *pipelineState)
 
   for (int stageIdx = 0; stageIdx < ShaderStageCount; ++stageIdx) {
     ShaderStage shaderStage = static_cast<ShaderStage>(stageIdx);
     if (pipelineState->hasShaderStage(shaderStage)) {
       pipelineState->setShaderDefaultWaveSize(shaderStage);
       if (shaderStage == ShaderStageGeometry)
         pipelineState->setShaderDefaultWaveSize(ShaderStageCopyShader);
     }
   }
 
+#if LLPC_BUILD_GFX11
+  if (pipelineState->getTargetInfo().getGfxIpVersion().major >= 11) {
+    // Prefer Wave64 when 16-bit arithmetic is used by the shader.
+    // Except when API subgroup size requirements require Wave32 or tuning option specifies wave32.
+    // Check if there are any 16-bit arithmetic operations per-stage.
+    bool stageChecked[ShaderStageCount] = {};
+    for (auto &func : module) {
+      auto shaderStage = lgc::getShaderStage(&func);
+      if (shaderStage == ShaderStageInvalid || stageChecked[shaderStage])
+        continue;
+      if (pipelineState->getShaderWaveSize(shaderStage) == 32) {
+        const auto &shaderOptions = pipelineState->getShaderOptions(shaderStage);
+        if ((pipelineState->getShaderModes()->getAnyUseSubgroupSize() && shaderOptions.subgroupSize != 0) ||
+            shaderOptions.waveSize != 0)
+          continue;
+        bool hasAny16BitArith = false;
+        for (inst_iterator instIter = inst_begin(&func); instIter != inst_end(&func); ++instIter) {
+          if (is16BitArithmeticOp(&*instIter)) {
+            hasAny16BitArith = true;
+            stageChecked[shaderStage] = true;
+            break;
+          }
+        }
+        if (hasAny16BitArith)
+          pipelineState->setShaderWaveSize(shaderStage, 64);
+      }
+    }
+  }
+#endif
+  return false;
+}
+
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Check if the given instruction is a 16-bit arithmetic operation
+//
+// @param inst : The instruction
+bool PatchWaveSizeAdjust::is16BitArithmeticOp(Instruction *inst) {
+  if (dyn_cast<BinaryOperator>(inst) || dyn_cast<UnaryOperator>(inst))
+    return true;
+  if (auto intrinsicInst = dyn_cast<IntrinsicInst>(inst)) {
+    Intrinsic::ID intrinsicId = intrinsicInst->getIntrinsicID();
+    switch (intrinsicId) {
+    case Intrinsic::rint:
+    case Intrinsic::trunc:
+    case Intrinsic::fabs:
+    case Intrinsic::floor:
+    case Intrinsic::ceil:
+    case Intrinsic::sin:
+    case Intrinsic::cos:
+    case Intrinsic::exp2:
+    case Intrinsic::log2:
+    case Intrinsic::sqrt:
+    case Intrinsic::minnum:
+    case Intrinsic::maxnum:
+    case Intrinsic::umin:
+    case Intrinsic::smin:
+    case Intrinsic::umax:
+    case Intrinsic::smax:
+    case Intrinsic::fma:
+    case Intrinsic::amdgcn_fract:
+    case Intrinsic::amdgcn_frexp_mant:
+    case Intrinsic::amdgcn_frexp_exp:
+    case Intrinsic::amdgcn_fmed3:
+    case Intrinsic::amdgcn_ldexp:
+      return true;
+    default:
+      return false;
+    }
+  }
   return false;
 }
+#endif
 
 // =====================================================================================================================
 // Initializes the pass
 INITIALIZE_PASS(LegacyPatchWaveSizeAdjust, DEBUG_TYPE, "Patch LLVM for per-shader wave size adjustment", false, false)
diff --git a/lgc/patch/ShaderInputs.cpp b/lgc/patch/ShaderInputs.cpp
index b478c6ac9..91f6486df 100644
--- a/lgc/patch/ShaderInputs.cpp
+++ b/lgc/patch/ShaderInputs.cpp
@@ -68,20 +68,24 @@ const char *ShaderInputs::getSpecialUserDataName(UserDataMapping kind) {
   case UserDataMapping::VertexBufferTable:
     return "VertexBufferTable";
   case UserDataMapping::NggCullingData:
     return "NggCullingData";
   case UserDataMapping::MeshTaskDispatchDims:
     return "MeshTaskDispatchDims";
   case UserDataMapping::MeshTaskRingIndex:
     return "MeshTaskRingIndex";
   case UserDataMapping::MeshPipeStatsBuf:
     return "MeshPipeStatsBuf";
+#if LLPC_BUILD_GFX11
+  case UserDataMapping::StreamOutControlBuf:
+    return "StreamOutControlBuf";
+#endif
   default:
     return "";
   }
 }
 
 // =====================================================================================================================
 // Get a special user data value by inserting a call to lgc.special.user.data
 //
 // @param kind : The kind of special user data, a UserDataMapping enum value
 // @param builder : Builder to insert the call with
@@ -152,20 +156,24 @@ Value *ShaderInputs::getInput(ShaderInput kind, BuilderBase &builder, const LgcC
 // Get IR type of a particular shader input
 //
 // @param kind : The kind of shader input, a ShaderInput enum value
 // @param context : LLVM context for getting types
 Type *ShaderInputs::getInputType(ShaderInput inputKind, const LgcContext &lgcContext) {
   LLVMContext &context = lgcContext.getContext();
   switch (inputKind) {
   case ShaderInput::WorkgroupId:
     return FixedVectorType::get(Type::getInt32Ty(context), 3);
   case ShaderInput::LocalInvocationId:
+#if LLPC_BUILD_GFX11
+    if (lgcContext.getTargetInfo().getGfxIpVersion().major >= 11)
+      return Type::getInt32Ty(context);
+#endif
     return FixedVectorType::get(Type::getInt32Ty(context), 3);
 
   case ShaderInput::TessCoordX:
   case ShaderInput::TessCoordY:
   case ShaderInput::FragCoordX:
   case ShaderInput::FragCoordY:
   case ShaderInput::FragCoordZ:
   case ShaderInput::FragCoordW:
   case ShaderInput::LineStipple:
     return Type::getFloatTy(context);
@@ -520,24 +528,27 @@ static const ShaderInputDesc CsVgprInputs[] = {
 // @returns : Bitmap with bits set for SGPR arguments so caller can set "inreg" attribute on the args
 uint64_t ShaderInputs::getShaderArgTys(PipelineState *pipelineState, ShaderStage shaderStage,
                                        SmallVectorImpl<Type *> &argTys, SmallVectorImpl<std::string> &argNames,
                                        unsigned argOffset) {
 
   bool hasTs = pipelineState->hasShaderStage(ShaderStageTessControl);
   bool hasGs = pipelineState->hasShaderStage(ShaderStageGeometry);
 
   uint64_t inRegMask = 0;
   auto intfData = pipelineState->getShaderInterfaceData(shaderStage);
-  auto resUsage = pipelineState->getShaderResourceUsage(shaderStage);
-  const auto &xfbStrides = resUsage->inOutUsage.xfbStrides;
+  const auto &xfbStrides = pipelineState->getXfbBufferStrides();
+#if LLPC_BUILD_GFX11
+  // NOTE: For GFX11+, stream-out is actually SW-emulated in NGG primitive shader and we doesn't have relevant shader
+  // inputs for HW stream-out.
+#endif
   const unsigned gfxIp = pipelineState->getTargetInfo().getGfxIpVersion().major;
-  const bool enableHwXfb = resUsage->inOutUsage.enableXfb && gfxIp <= 10;
+  const bool enableHwXfb = pipelineState->enableXfb() && gfxIp <= 10;
 
   // Enable optional shader inputs as required.
   switch (shaderStage) {
   case ShaderStageVertex:
     if (enableHwXfb && (!hasGs && !hasTs)) {
       // HW stream-out in VS as hardware VS
       getShaderInputUsage(shaderStage, ShaderInput::StreamOutInfo)->enable();
       getShaderInputUsage(shaderStage, ShaderInput::StreamOutWriteIndex)->enable();
       for (unsigned i = 0; i < MaxTransformFeedbackBuffers; ++i) {
         if (xfbStrides[i] > 0)
diff --git a/lgc/patch/ShaderMerger.cpp b/lgc/patch/ShaderMerger.cpp
index 7608b1ac3..d0bc5daf1 100644
--- a/lgc/patch/ShaderMerger.cpp
+++ b/lgc/patch/ShaderMerger.cpp
@@ -24,25 +24,28 @@
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  ShaderMerger.cpp
  * @brief LLPC source file: contains implementation of class lgc::ShaderMerger.
  ***********************************************************************************************************************
  */
 #include "ShaderMerger.h"
 #include "NggPrimShader.h"
 #include "lgc/patch/Patch.h"
+#include "lgc/patch/PatchPreparePipelineAbi.h"
+#include "lgc/patch/SystemValues.h"
 #include "lgc/state/PalMetadata.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/util/BuilderBase.h"
 #include "llvm/IR/Constants.h"
+#include "llvm/IR/InlineAsm.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/IntrinsicsAMDGPU.h"
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
 
 #define DEBUG_TYPE "lgc-shader-merger"
 
 using namespace llvm;
 using namespace lgc;
@@ -75,22 +78,40 @@ unsigned ShaderMerger::getSpecialSgprInputIndex(GfxIpVersion gfxIp, LsHs::Specia
       {LsHs::UserDataAddrLow, 0},     // s0
       {LsHs::UserDataAddrHigh, 1},    // s1
       {LsHs::OffChipLdsBase, 2},      // s2
       {LsHs::MergedWaveInfo, 3},      // s3
       {LsHs::TfBufferBase, 4},        // s4
       {LsHs::SharedScratchOffset, 5}, // s5
       {LsHs::HsShaderAddrLow, 6},     // s6
       {LsHs::HsShaderAddrHigh, 7},    // s7
   };
 
+#if LLPC_BUILD_GFX11
+  static const std::unordered_map<LsHs::SpecialSgprInput, unsigned> LsHsSpecialSgprInputMapGfx11 = {
+      {LsHs::HsShaderAddrLow, 0},  // s0
+      {LsHs::HsShaderAddrHigh, 1}, // s1
+      {LsHs::OffChipLdsBase, 2},   // s2
+      {LsHs::MergedWaveInfo, 3},   // s3
+      {LsHs::TfBufferBase, 4},     // s4
+      {LsHs::waveIdInGroup, 5},    // s5
+  };
+#endif
+
   assert(gfxIp.major >= 9); // Must be GFX9+
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    assert(LsHsSpecialSgprInputMapGfx11.count(sgprInput) > 0);
+    return LsHsSpecialSgprInputMapGfx11.at(sgprInput);
+  }
+#endif
+
   assert(LsHsSpecialSgprInputMapGfx9.count(sgprInput) > 0);
   return LsHsSpecialSgprInputMapGfx9.at(sgprInput);
 }
 
 // =====================================================================================================================
 // Get the index of the specified special SGPR input according to graphics IP version (ES-GS merged shader).
 //
 // @param gfxIp : Graphics IP version
 // @param sgprInput : Special SGPR input
 // @returns : Index of the specified special SGPR input
@@ -111,22 +132,42 @@ unsigned ShaderMerger::getSpecialSgprInputIndex(GfxIpVersion gfxIp, EsGs::Specia
       {EsGs::UserDataAddrLow, 0},     // s0
       {EsGs::UserDataAddrHigh, 1},    // s1
       {EsGs::MergedGroupInfo, 2},     // s2
       {EsGs::MergedWaveInfo, 3},      // s3
       {EsGs::OffChipLdsBase, 4},      // s4
       {EsGs::SharedScratchOffset, 5}, // s5
       {EsGs::GsShaderAddrLow, 6},     // s6
       {EsGs::GsShaderAddrHigh, 7},    // s7
   };
 
+#if LLPC_BUILD_GFX11
+  static const std::unordered_map<EsGs::SpecialSgprInput, unsigned> EsGsSpecialSgprInputMapGfx11 = {
+      {EsGs::GsShaderAddrLow, 0},  // s0
+      {EsGs::GsShaderAddrHigh, 1}, // s1
+      {EsGs::MergedGroupInfo, 2},  // s2
+      {EsGs::MergedWaveInfo, 3},   // s3
+      {EsGs::OffChipLdsBase, 4},   // s4
+      {EsGs::AttribRingBase, 5},   // s5
+      {EsGs::FlatScratchLow, 6},   // s6
+      {EsGs::FlatScratchHigh, 7},  // s7
+  };
+#endif
+
   assert(gfxIp.major >= 9); // Must be GFX9+
 
+#if LLPC_BUILD_GFX11
+  if (gfxIp.major >= 11) {
+    assert(EsGsSpecialSgprInputMapGfx11.count(sgprInput) > 0);
+    return EsGsSpecialSgprInputMapGfx11.at(sgprInput);
+  }
+#endif
+
   if (gfxIp.major >= 10) {
     if (useNgg) {
       assert(EsGsSpecialSgprInputMapGfx10.count(sgprInput) > 0);
       return EsGsSpecialSgprInputMapGfx10.at(sgprInput);
     }
   }
 
   assert(EsGsSpecialSgprInputMapGfx9.count(sgprInput) > 0);
   return EsGsSpecialSgprInputMapGfx9.at(sgprInput);
 }
@@ -322,67 +363,79 @@ Function *ShaderMerger::generateLsHsEntryPoint(Function *lsEntryPoint, Function
   mergeWaveInfo->setName("mergeWaveInfo");
 
   Value *tfBufferBase = (arg + getSpecialSgprInputIndex(m_gfxIp, LsHs::TfBufferBase));
   tfBufferBase->setName("tfBufferBase");
 
   arg += NumSpecialSgprInputs;
 
   Value *userData = arg++;
 
   // Define basic blocks
+  auto entryBlock = BasicBlock::Create(*m_context, ".entry", entryPoint);
+  auto beginLsBlock = BasicBlock::Create(*m_context, ".beginLs", entryPoint);
+  auto endLsBlock = BasicBlock::Create(*m_context, ".endLs", entryPoint);
+#if LLPC_BUILD_GFX11
+  BasicBlock *distribHsPatchCountBlock = nullptr;
+  BasicBlock *endDistribHsPatchCountBlock = nullptr;
+  if (m_pipelineState->canOptimizeTessFactor()) {
+    distribHsPatchCountBlock = BasicBlock::Create(*m_context, ".distribHsPatchCount", entryPoint);
+    endDistribHsPatchCountBlock = BasicBlock::Create(*m_context, ".endDistribHsPatchCount", entryPoint);
+  }
+#endif
+  auto beginHsBlock = BasicBlock::Create(*m_context, ".beginHs", entryPoint);
   auto endHsBlock = BasicBlock::Create(*m_context, ".endHs", entryPoint);
-  auto beginHsBlock = BasicBlock::Create(*m_context, ".beginHs", entryPoint, endHsBlock);
-  auto endLsBlock = BasicBlock::Create(*m_context, ".endLs", entryPoint, beginHsBlock);
-  auto beginLsBlock = BasicBlock::Create(*m_context, ".beginLs", entryPoint, endLsBlock);
-  auto entryBlock = BasicBlock::Create(*m_context, ".entry", entryPoint, beginLsBlock);
 
   // Construct ".entry" block
   BuilderBase builder(entryBlock);
 
   builder.CreateIntrinsic(Intrinsic::amdgcn_init_exec, {}, {builder.getInt64(-1)});
 
-  auto threadId = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {builder.getInt32(-1), builder.getInt32(0)});
+  auto threadIdInWave =
+      builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {builder.getInt32(-1), builder.getInt32(0)});
 
   unsigned waveSize = m_pipelineState->getShaderWaveSize(ShaderStageTessControl);
   if (waveSize == 64) {
-    threadId = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {builder.getInt32(-1), threadId});
+    threadIdInWave = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {builder.getInt32(-1), threadIdInWave});
   }
+  threadIdInWave->setName("threadIdInWave");
 
   auto lsVertCount = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                              {mergeWaveInfo, builder.getInt32(0), builder.getInt32(8)});
+  lsVertCount->setName("lsVertCount");
 
   Value *patchId = arg;
   Value *relPatchId = (arg + 1);
   Value *vertexId = (arg + 2);
   Value *relVertexId = (arg + 3);
   Value *stepRate = (arg + 4);
   Value *instanceId = (arg + 5);
   auto vertexFetchesStart = (arg + 6);
   auto vertexFetchesEnd = entryPoint->arg_end();
 
   auto hsVertCount = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                              {mergeWaveInfo, builder.getInt32(8), builder.getInt32(8)});
+  hsVertCount->setName("hsVertCount");
 
   // NOTE: For GFX9, hardware has an issue of initializing LS VGPRs. When HS is null, v0~v3 are initialized as LS
   // VGPRs rather than expected v2~v4.
   auto gpuWorkarounds = &m_pipelineState->getTargetInfo().getGpuWorkarounds();
   if (gpuWorkarounds->gfx9.fixLsVgprInput) {
     auto nullHs = builder.CreateICmpEQ(hsVertCount, builder.getInt32(0));
 
     vertexId = builder.CreateSelect(nullHs, arg, (arg + 2));
     relVertexId = builder.CreateSelect(nullHs, (arg + 1), (arg + 3));
     stepRate = builder.CreateSelect(nullHs, (arg + 2), (arg + 4));
     instanceId = builder.CreateSelect(nullHs, (arg + 3), (arg + 5));
   }
 
-  auto lsEnable = builder.CreateICmpULT(threadId, lsVertCount);
-  builder.CreateCondBr(lsEnable, beginLsBlock, endLsBlock);
+  auto validLsVert = builder.CreateICmpULT(threadIdInWave, lsVertCount, "validLsVert");
+  builder.CreateCondBr(validLsVert, beginLsBlock, endLsBlock);
 
   // Construct ".beginLs" block
   builder.SetInsertPoint(beginLsBlock);
 
   if (m_hasVs) {
     // Call LS main function
     SmallVector<Value *> args;
     auto intfData = m_pipelineState->getShaderInterfaceData(ShaderStageVertex);
 
     unsigned lsArgIdx = 0;
@@ -416,27 +469,54 @@ Function *ShaderMerger::generateLsHsEntryPoint(Function *lsEntryPoint, Function
 
     CallInst *call = builder.CreateCall(lsEntryPoint, args);
     call->setCallingConv(CallingConv::AMDGPU_LS);
   }
 
   builder.CreateBr(endLsBlock);
 
   // Construct ".endLs" block
   builder.SetInsertPoint(endLsBlock);
 
-  SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
-  builder.CreateFence(AtomicOrdering::Release, workgroupScope);
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->canOptimizeTessFactor()) {
+    assert(distribHsPatchCountBlock);
+    assert(endDistribHsPatchCountBlock);
+
+    // firstWave = mergedWaveInfo[31]
+    Value *firstWaveInGroup = builder.CreateAnd(mergeWaveInfo, 0x80000000);
+    firstWaveInGroup = builder.CreateICmpNE(firstWaveInGroup, builder.getInt32(0), "firstWaveInGroup");
+    builder.CreateCondBr(firstWaveInGroup, distribHsPatchCountBlock, endDistribHsPatchCountBlock);
+
+    // Construct ".distribHsPatchCount" block
+    builder.SetInsertPoint(distribHsPatchCountBlock);
+
+    // NOTE: The hsPatchCount is only valid for the first wave in the group. We have to store it to LDS to distribute
+    // it through the group.
+    Value *hasPatchCount = builder.CreateLShr(mergeWaveInfo, 16); // hsWaveCount = mergedWaveInfo[24:16]
+    hasPatchCount = builder.CreateAnd(hasPatchCount, 0xFF);
+    const auto hsPatchCountStart = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)
+                                       ->inOutUsage.tcs.calcFactor.onChip.hsPatchCountStart;
+    writeValueToLds(hasPatchCount, builder.getInt32(hsPatchCountStart), builder);
+    builder.CreateBr(endDistribHsPatchCountBlock);
+
+    // Construct ".endDistribHsPatchCount" block
+    builder.SetInsertPoint(endDistribHsPatchCountBlock);
+  }
+#endif
+
+  SyncScope::ID syncScope = m_context->getOrInsertSyncScopeID("workgroup");
+  builder.CreateFence(AtomicOrdering::Release, syncScope);
   builder.CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
-  builder.CreateFence(AtomicOrdering::Acquire, workgroupScope);
+  builder.CreateFence(AtomicOrdering::Acquire, syncScope);
 
-  auto hsEnable = builder.CreateICmpULT(threadId, hsVertCount);
-  builder.CreateCondBr(hsEnable, beginHsBlock, endHsBlock);
+  auto validHsVert = builder.CreateICmpULT(threadIdInWave, hsVertCount, "validHsVert");
+  builder.CreateCondBr(validHsVert, beginHsBlock, endHsBlock);
 
   // Construct ".beginHs" block
   builder.SetInsertPoint(beginHsBlock);
 
   if (m_hasTcs) {
     // Call HS main function
     SmallVector<Value *> args;
 
     auto intfData = m_pipelineState->getShaderInterfaceData(ShaderStageTessControl);
 
@@ -468,20 +548,25 @@ Function *ShaderMerger::generateLsHsEntryPoint(Function *lsEntryPoint, Function
 
     assert(hsArgIdx == hsEntryPoint->arg_size()); // Must have visit all arguments of HS entry point
 
     CallInst *call = builder.CreateCall(hsEntryPoint, args);
     call->setCallingConv(CallingConv::AMDGPU_HS);
   }
   builder.CreateBr(endHsBlock);
 
   // Construct ".endHs" block
   builder.SetInsertPoint(endHsBlock);
+
+#if LLPC_BUILD_GFX11
+  if (m_pipelineState->canOptimizeTessFactor())
+    storeTessFactorsWithOpt(threadIdInWave, builder);
+#endif
   builder.CreateRetVoid();
 
   return entryPoint;
 }
 
 // =====================================================================================================================
 // Generates the type for the new entry-point of ES-GS merged shader.
 //
 // @param [out] inRegMask : "Inreg" bit mask for the arguments
 FunctionType *ShaderMerger::generateEsGsEntryPointType(uint64_t *inRegMask) const {
@@ -633,51 +718,57 @@ Function *ShaderMerger::generateEsGsEntryPoint(Function *esEntryPoint, Function
   mergedWaveInfo->setName("mergedWaveInfo");
 
   Value *offChipLdsBase = (arg + getSpecialSgprInputIndex(m_gfxIp, EsGs::OffChipLdsBase, false));
   offChipLdsBase->setName("offChipLdsBase");
 
   arg += NumSpecialSgprInputs;
 
   Value *userData = arg++;
 
   // Define basic blocks
+  auto entryBlock = BasicBlock::Create(*m_context, ".entry", entryPoint);
+  auto beginEsBlock = BasicBlock::Create(*m_context, ".beginEs", entryPoint);
+  auto endEsBlock = BasicBlock::Create(*m_context, ".endEs", entryPoint);
+  auto beginGsBlock = BasicBlock::Create(*m_context, ".beginGs", entryPoint);
   auto endGsBlock = BasicBlock::Create(*m_context, ".endGs", entryPoint);
-  auto beginGsBlock = BasicBlock::Create(*m_context, ".beginGs", entryPoint, endGsBlock);
-  auto endEsBlock = BasicBlock::Create(*m_context, ".endEs", entryPoint, beginGsBlock);
-  auto beginEsBlock = BasicBlock::Create(*m_context, ".beginEs", entryPoint, endEsBlock);
-  auto entryBlock = BasicBlock::Create(*m_context, ".entry", entryPoint, beginEsBlock);
 
   // Construct ".entry" block
   BuilderBase builder(entryBlock);
   builder.CreateIntrinsic(Intrinsic::amdgcn_init_exec, {}, {builder.getInt64(-1)});
 
-  auto threadId = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {builder.getInt32(-1), builder.getInt32(0)});
+  auto threadIdInWave =
+      builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_lo, {}, {builder.getInt32(-1), builder.getInt32(0)});
 
   unsigned waveSize = m_pipelineState->getShaderWaveSize(ShaderStageGeometry);
   if (waveSize == 64) {
-    threadId = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {builder.getInt32(-1), threadId});
+    threadIdInWave = builder.CreateIntrinsic(Intrinsic::amdgcn_mbcnt_hi, {}, {builder.getInt32(-1), threadIdInWave});
   }
+  threadIdInWave->setName("threadIdInWave");
 
   auto esVertCount = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                              {mergedWaveInfo, builder.getInt32(0), builder.getInt32(8)});
+  esVertCount->setName("esVertCount");
   auto gsPrimCount = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                              {mergedWaveInfo, builder.getInt32(8), builder.getInt32(8)});
+  gsPrimCount->setName("gsPrimCount");
   auto gsWaveId = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                           {mergedWaveInfo, builder.getInt32(16), builder.getInt32(8)});
+  gsWaveId->setName("gsWaveId");
   auto waveInSubgroup = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                                 {mergedWaveInfo, builder.getInt32(24), builder.getInt32(4)});
+  waveInSubgroup->setName("waveInSubgroup");
 
   unsigned esGsBytesPerWave = waveSize * 4 * calcFactor.esGsRingItemSize;
   auto esGsOffset = builder.CreateMul(waveInSubgroup, builder.getInt32(esGsBytesPerWave));
 
-  auto esEnable = builder.CreateICmpULT(threadId, esVertCount);
-  builder.CreateCondBr(esEnable, beginEsBlock, endEsBlock);
+  auto validEsVert = builder.CreateICmpULT(threadIdInWave, esVertCount, "validEsVert");
+  builder.CreateCondBr(validEsVert, beginEsBlock, endEsBlock);
 
   Value *esGsOffsets01 = arg;
 
   Value *esGsOffsets23 = PoisonValue::get(Type::getInt32Ty(*m_context));
   if (calcFactor.inputVertices > 2) {
     // NOTE: ES to GS offset (vertex 2 and 3) is valid once the primitive type has more than 2 vertices.
     esGsOffsets23 = (arg + 1);
   }
 
   Value *gsPrimitiveId = (arg + 2);
@@ -772,27 +863,27 @@ Function *ShaderMerger::generateEsGsEntryPoint(Function *esEntryPoint, Function
     }
 
     CallInst *call = builder.CreateCall(esEntryPoint, args);
     call->setCallingConv(CallingConv::AMDGPU_ES);
   }
   builder.CreateBr(endEsBlock);
 
   // Construct ".endEs" block
   builder.SetInsertPoint(endEsBlock);
 
-  SyncScope::ID workgroupScope = m_context->getOrInsertSyncScopeID("workgroup");
-  builder.CreateFence(AtomicOrdering::Release, workgroupScope);
+  SyncScope::ID syncScope = m_context->getOrInsertSyncScopeID("workgroup");
+  builder.CreateFence(AtomicOrdering::Release, syncScope);
   builder.CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
-  builder.CreateFence(AtomicOrdering::Acquire, workgroupScope);
+  builder.CreateFence(AtomicOrdering::Acquire, syncScope);
 
-  auto gsEnable = builder.CreateICmpULT(threadId, gsPrimCount);
-  builder.CreateCondBr(gsEnable, beginGsBlock, endGsBlock);
+  auto validGsPrim = builder.CreateICmpULT(threadIdInWave, gsPrimCount, "validGsPrim");
+  builder.CreateCondBr(validGsPrim, beginGsBlock, endGsBlock);
 
   // Construct ".beginGs" block
   builder.SetInsertPoint(beginGsBlock);
   {
     auto esGsOffset0 = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                                {esGsOffsets01, builder.getInt32(0), builder.getInt32(16)});
     auto esGsOffset1 = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                                {esGsOffsets01, builder.getInt32(16), builder.getInt32(16)});
     auto esGsOffset2 = builder.CreateIntrinsic(Intrinsic::amdgcn_ubfe, {builder.getInt32Ty()},
                                                {esGsOffsets23, builder.getInt32(0), builder.getInt32(16)});
@@ -1004,10 +1095,396 @@ void ShaderMerger::processRayQueryLdsStack(Function *entryPoint1, Function *entr
       for (auto inst : ldsStackInsts) {
         inst->replaceUsesOfWith(ldsStack, newLdsStack);
       }
     }
 
     if (ldsStack->user_empty())
       ldsStack->eraseFromParent();
   }
 }
 #endif
+
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Handle the store of tessellation factors with optimization (TF0/TF1 messaging)
+//
+// @param threadIdInWave : Thread ID in wave
+// @param builder : IR builder to insert instructions
+void ShaderMerger::storeTessFactorsWithOpt(Value *threadIdInWave, IRBuilder<> &builder) {
+  assert(m_pipelineState->canOptimizeTessFactor());
+
+  //
+  // The processing is something like this:
+  //
+  // OPTIMIZED_TF_STORE() {
+  //   Read hsPatchCount from LDS
+  //
+  //   if (threadIdInGroup < hsPatchCount) {
+  //     Read TFs from LDS (with a barrier to make sure TFs are written)
+  //     Compute per-thread specielTf
+  //     Compute per-wave specielTf
+  //   }
+  //
+  //   hsPatchWaveCount = alignTo(hsPatchCount, waveSize) / waveSize
+  //   if (hsPatchWaveCount > 1) {
+  //     Write per-wave specielTf to LDS
+  //     Barrier
+  //
+  //     if (threadIdInWave < hsPatchWaveCount) {
+  //       Read per-wave specielTf from LDS
+  //       Compute per-group specielTf
+  //     }
+  //   }
+  //
+  //   if (threadIdInWave < hsPatchCount) {
+  //     if (specialTf)
+  //       if (waveIdInGroup == 0)
+  //         Send HsTessFactor message
+  //     } else {
+  //       Write TFs to buffer
+  //     }
+  //   }
+  // }
+  //
+
+  auto insertBlock = builder.GetInsertBlock();
+  auto entryPoint = insertBlock->getParent();
+  assert(entryPoint->getName() == lgcName::LsHsEntryPoint); // Must be LS-HS merged shader
+
+  const auto &calcFactor = m_pipelineState->getShaderResourceUsage(ShaderStageTessControl)->inOutUsage.tcs.calcFactor;
+  const unsigned waveSize = m_pipelineState->getMergedShaderWaveSize(ShaderStageTessControl);
+  assert(waveSize == 32 || waveSize == 64);
+
+  // Helper to create a basic block
+  auto createBlock = [&](const Twine &name) { return BasicBlock::Create(*m_context, name, entryPoint); };
+
+  // Helper to create a PHI node with two incomings
+  auto createPhi = [&](std::pair<Value *, BasicBlock *> incoming1, std::pair<Value *, BasicBlock *> incoming2) {
+    assert(incoming1.first->getType() == incoming2.first->getType());
+    auto phi = builder.CreatePHI(incoming1.first->getType(), 2);
+    phi->addIncoming(incoming1.first, incoming1.second);
+    phi->addIncoming(incoming2.first, incoming2.second);
+    return phi;
+  };
+
+  // Helper to do a group ballot
+  auto ballot = [&](Value *value) {
+    assert(value->getType()->isIntegerTy(1)); // Should be i1
+
+    value = builder.CreateSelect(value, builder.getInt32(1), builder.getInt32(0));
+    auto inlineAsmTy = FunctionType::get(builder.getInt32Ty(), builder.getInt32Ty(), false);
+    auto inlineAsm = InlineAsm::get(inlineAsmTy, "; %1", "=v,0", true);
+    value = builder.CreateCall(inlineAsm, value);
+
+    static const unsigned PredicateNE = 33; // 33 = predicate NE
+    Value *ballot = builder.CreateIntrinsic(Intrinsic::amdgcn_icmp,
+                                            {
+                                                builder.getIntNTy(waveSize), // Return type
+                                                builder.getInt32Ty()         // Argument type
+                                            },
+                                            {value, builder.getInt32(0), builder.getInt32(PredicateNE)});
+    if (waveSize == 32)
+      ballot = builder.CreateZExt(ballot, builder.getInt64Ty());
+    return ballot;
+  };
+
+  // Define basic blocks
+  auto checkSpecilTfInWaveBlock = createBlock(".checkSpecialTfInWave");
+  auto endCheckSpecialTfInWaveBlock = createBlock(".endCheckSpecialTfInWave");
+
+  auto handleMultiWaveBlock = createBlock(".handleMultiWave");
+  auto checkSpecilTfInGroupBlock = createBlock(".checkSpecialTfInGroup");
+  auto endCheckSpecialTfInGroupBlock = createBlock(".endCheckSpecialTfInGroup");
+  auto endHandleMultiWaveBlock = createBlock(".endHandleMultiWave");
+
+  auto tryStoreTfBlock = createBlock(".tryStoreTf");
+  auto checkSendTfMessageBlock = createBlock(".checkSendTfMessage");
+  auto sendTfMessageBlock = createBlock(".sendTfMessage");
+  auto storeTfBlock = createBlock(".storeTf");
+  auto endTryStoreTfBlock = createBlock(".endTryStoreTf");
+
+  // Construct current insert block
+  Value *waveIdInGroup = nullptr;
+  Value *threadIdInGroup = nullptr;
+  Value *hsPatchCount = nullptr;
+  Value *validHsPatch = nullptr;
+  {
+    waveIdInGroup = getFunctionArgument(entryPoint, getSpecialSgprInputIndex(m_gfxIp, LsHs::waveIdInGroup));
+    waveIdInGroup = builder.CreateAnd(waveIdInGroup, 0x1F, "waveIdInGroup"); // waveIdInGroup = [4:0]
+
+    threadIdInGroup = builder.CreateMul(builder.getInt32(waveSize), waveIdInGroup);
+    threadIdInGroup = builder.CreateAdd(threadIdInGroup, threadIdInWave, "threadIdInGroup");
+
+    const auto hsPatchCountStart = calcFactor.onChip.hsPatchCountStart;
+    hsPatchCount = readValueFromLds(builder.getInt32Ty(), builder.getInt32(hsPatchCountStart), builder);
+    hsPatchCount = builder.CreateIntrinsic(Intrinsic::amdgcn_readfirstlane, {}, hsPatchCount);
+    hsPatchCount->setName("hsPatchCount");
+
+    validHsPatch = builder.CreateICmpULT(threadIdInGroup, hsPatchCount, "validHsPatch");
+    builder.CreateCondBr(validHsPatch, checkSpecilTfInWaveBlock, endCheckSpecialTfInWaveBlock);
+  }
+
+  // Construct ".checkSpecialTfInWave" block
+  Value *outerTf = nullptr;
+  Value *innerTf = nullptr;
+  std::pair<Value *, Value *> specialTfInWave = {}; // Special TF in this wave
+  {
+    builder.SetInsertPoint(checkSpecilTfInWaveBlock);
+
+    // Read back TFs from LDS
+    auto tessFactors = PatchPreparePipelineAbi::readTessFactors(m_pipelineState, threadIdInGroup, builder);
+    outerTf = tessFactors.first;
+    innerTf = tessFactors.second;
+
+    // Check special TFs
+    Value *one = ConstantFP::get(builder.getFloatTy(), 1.0);
+    Value *zero = ConstantFP::get(builder.getFloatTy(), 0.0);
+
+    Value *isAllOnesTf = builder.getTrue();
+    Value *isAllZerosTf = builder.getTrue();
+
+    // Check if the thread has all-ones/all-zeros TFs
+    for (unsigned i = 0; i < cast<FixedVectorType>(outerTf->getType())->getNumElements(); ++i) {
+      auto elem = builder.CreateExtractElement(outerTf, i);
+      Value *isOne = builder.CreateFCmpOEQ(elem, one);
+      Value *isZero = builder.CreateFCmpOEQ(elem, zero);
+
+      isAllOnesTf = builder.CreateAnd(isAllOnesTf, isOne);
+      isAllZerosTf = builder.CreateAnd(isAllZerosTf, isZero);
+    }
+
+    // Check inner tessellation factors
+    if (innerTf) {
+      // Isoline doesn't have inner tessellation factors
+      for (unsigned i = 0; i < cast<FixedVectorType>(innerTf->getType())->getNumElements(); ++i) {
+        auto elem = builder.CreateExtractElement(innerTf, i);
+        Value *isOne = builder.CreateFCmpOEQ(elem, one);
+        Value *isZero = builder.CreateFCmpOEQ(elem, zero);
+
+        isAllOnesTf = builder.CreateAnd(isAllOnesTf, isOne);
+        isAllZerosTf = builder.CreateAnd(isAllZerosTf, isZero);
+      }
+    }
+
+    auto validhMask = ballot(builder.getTrue());
+
+    // Check if the wave has all-ones TFs uniformly
+    Value *allOnesTfMask = ballot(isAllOnesTf);
+    auto isAllOnesTfInWave = builder.CreateICmpEQ(allOnesTfMask, validhMask);
+
+    // Check if the wave has all-zeros TFs uniformly
+    Value *allZerosTfMask = ballot(isAllZerosTf);
+    auto isAllZerosTfInWave = builder.CreateICmpEQ(allZerosTfMask, validhMask);
+
+    specialTfInWave = std::make_pair(isAllOnesTfInWave, isAllZerosTfInWave);
+
+    builder.CreateBr(endCheckSpecialTfInWaveBlock);
+  }
+
+  // Construct ".endCheckSpecialTfInWave" block
+  Value *hsPatchWaveCount = nullptr;
+  {
+    builder.SetInsertPoint(endCheckSpecialTfInWaveBlock);
+
+    outerTf = createPhi({PoisonValue::get(outerTf->getType()), insertBlock}, {outerTf, checkSpecilTfInWaveBlock});
+    outerTf->setName("outerTf");
+    if (innerTf) {
+      // Isoline doesn't have inner tessellation factors
+      innerTf = createPhi({PoisonValue::get(innerTf->getType()), insertBlock}, {innerTf, checkSpecilTfInWaveBlock});
+      innerTf->setName("innerTf");
+    }
+
+    auto isAllOnesTfInWave =
+        createPhi({builder.getTrue(), insertBlock}, {specialTfInWave.first, checkSpecilTfInWaveBlock});
+    isAllOnesTfInWave->setName("isAllOnesTfInWave");
+    auto isAllZerosTfInWave =
+        createPhi({builder.getTrue(), insertBlock}, {specialTfInWave.second, checkSpecilTfInWaveBlock});
+    isAllZerosTfInWave->setName("isAllZerosTfInWave");
+    specialTfInWave = std::make_pair(isAllOnesTfInWave, isAllZerosTfInWave);
+
+    // hsPatchWaveCount = alignTo(hsPatchCount, waveSize) / waveSize = (hsPatchCount + waveSize - 1) / waveSize
+    hsPatchWaveCount = builder.CreateAdd(hsPatchCount, builder.getInt32(waveSize - 1));
+    hsPatchWaveCount = builder.CreateLShr(hsPatchWaveCount, Log2_32(waveSize), "hsPatchWaveCount");
+
+    auto multiWave = builder.CreateICmpUGT(hsPatchWaveCount, builder.getInt32(1), "multiWave");
+    builder.CreateCondBr(multiWave, handleMultiWaveBlock, endHandleMultiWaveBlock);
+  }
+
+  // Construct ".handleMultiWave" block
+  {
+    builder.SetInsertPoint(handleMultiWaveBlock);
+
+    const unsigned specialTfValueStart = calcFactor.onChip.specialTfValueStart;
+
+    // ldsOffset = specialTfValueStart + 2 * waveIdInGroup
+    auto ldsOffset = builder.CreateAdd(builder.getInt32(specialTfValueStart), builder.CreateShl(waveIdInGroup, 1));
+    writeValueToLds(builder.CreateZExt(specialTfInWave.first, builder.getInt32Ty()), ldsOffset,
+                    builder); // Write isAllOnesTfInWave to LDS
+
+    ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(1));
+    writeValueToLds(builder.CreateZExt(specialTfInWave.second, builder.getInt32Ty()), ldsOffset,
+                    builder); // Write isAllZerosTfInWave to LDS
+
+    SyncScope::ID syncScope = m_context->getOrInsertSyncScopeID("workgroup");
+    builder.CreateFence(AtomicOrdering::Release, syncScope);
+    builder.CreateIntrinsic(Intrinsic::amdgcn_s_barrier, {}, {});
+    builder.CreateFence(AtomicOrdering::Acquire, syncScope);
+
+    auto validHsPatchWave = builder.CreateICmpULT(threadIdInWave, hsPatchWaveCount, "validHsPatchWave");
+    builder.CreateCondBr(validHsPatchWave, checkSpecilTfInGroupBlock, endCheckSpecialTfInGroupBlock);
+  }
+
+  // Construct ".checkSpecialTfInGroup" block
+  std::pair<Value *, Value *> specialTfInGroup = {}; // Special TF in this group
+  {
+    builder.SetInsertPoint(checkSpecilTfInGroupBlock);
+
+    const unsigned specialTfValueStart = calcFactor.onChip.specialTfValueStart;
+
+    // ldsOffset = specialTfValueStart + 2 * threadIdInWave
+    auto ldsOffset = builder.CreateAdd(builder.getInt32(specialTfValueStart), builder.CreateShl(threadIdInWave, 1));
+    Value *isAllOnesTf = readValueFromLds(builder.getInt32Ty(), ldsOffset, builder);
+    isAllOnesTf = builder.CreateTrunc(isAllOnesTf, builder.getInt1Ty());
+
+    ldsOffset = builder.CreateAdd(ldsOffset, builder.getInt32(1));
+    Value *isAllZerosTf = readValueFromLds(builder.getInt32Ty(), ldsOffset, builder);
+    isAllZerosTf = builder.CreateTrunc(isAllZerosTf, builder.getInt1Ty());
+
+    auto validMask = ballot(builder.getTrue());
+
+    // Check if the group has all-ones TFs uniformly
+    Value *allOnesTfMask = ballot(isAllOnesTf);
+    Value *isAllOnesTfInGroup = builder.CreateICmpEQ(allOnesTfMask, validMask);
+
+    // Check if the group has all-zeros TFs uniformly
+    Value *allZerosTfMask = ballot(isAllZerosTf);
+    Value *isAllZerosTfInGroup = builder.CreateICmpEQ(allZerosTfMask, validMask);
+
+    specialTfInGroup = std::make_pair(isAllOnesTfInGroup, isAllZerosTfInGroup);
+
+    builder.CreateBr(endCheckSpecialTfInGroupBlock);
+  }
+
+  // Construct ".endCheckSpecialTfInGroup" block
+  {
+    builder.SetInsertPoint(endCheckSpecialTfInGroupBlock);
+
+    auto isAllOnesTfInGroup =
+        createPhi({builder.getTrue(), handleMultiWaveBlock}, {specialTfInGroup.first, checkSpecilTfInGroupBlock});
+    isAllOnesTfInGroup->setName("isAllOnesTfInGroup");
+    auto isAllZerosTfInGroup =
+        createPhi({builder.getTrue(), handleMultiWaveBlock}, {specialTfInGroup.second, checkSpecilTfInGroupBlock});
+    isAllZerosTfInGroup->setName("isAllZerosTfInGroup");
+    specialTfInGroup = std::make_pair(isAllOnesTfInGroup, isAllZerosTfInGroup);
+
+    builder.CreateBr(endHandleMultiWaveBlock);
+  }
+
+  // Construct ".endHandleMultiWave" block
+  std::pair<Value *, Value *> specialTf = {}; // Finalized special TF
+  {
+    builder.SetInsertPoint(endHandleMultiWaveBlock);
+
+    auto isAllOnesTf = createPhi({specialTfInWave.first, endCheckSpecialTfInWaveBlock},
+                                 {specialTfInGroup.first, endCheckSpecialTfInGroupBlock});
+    isAllOnesTf->setName("isAllOnesTf");
+    auto isAllZerosTf = createPhi({specialTfInWave.second, endCheckSpecialTfInWaveBlock},
+                                  {specialTfInGroup.second, endCheckSpecialTfInGroupBlock});
+    isAllZerosTf->setName("isAllZerosTf");
+    specialTf = std::make_pair(isAllOnesTf, isAllZerosTf);
+
+    builder.CreateCondBr(validHsPatch, tryStoreTfBlock, endTryStoreTfBlock);
+  }
+
+  // Construct ".tryStoreTf" block
+  {
+    builder.SetInsertPoint(tryStoreTfBlock);
+
+    auto isSpecialTf = builder.CreateOr(specialTf.first, specialTf.second, "isSpecialTf");
+    builder.CreateCondBr(isSpecialTf, checkSendTfMessageBlock, storeTfBlock);
+  }
+
+  // Construct ".checkSendTfMessage" block
+  {
+    builder.SetInsertPoint(checkSendTfMessageBlock);
+
+    auto firstWaveInGroup = builder.CreateICmpEQ(waveIdInGroup, builder.getInt32(0), "firstWaveInGroup");
+    builder.CreateCondBr(firstWaveInGroup, sendTfMessageBlock, endTryStoreTfBlock);
+  }
+
+  // Construct ".sendTfMessage" block
+  {
+    builder.SetInsertPoint(sendTfMessageBlock);
+
+    // M0[0] = 1 (allOnesTf), 0 (allZerosTf)
+    auto m0 = builder.CreateZExt(specialTf.first, builder.getInt32Ty());
+    builder.CreateIntrinsic(Intrinsic::amdgcn_s_sendmsg, {}, {builder.getInt32(HsTessFactor), m0});
+    builder.CreateBr(endTryStoreTfBlock);
+  }
+
+  // Construct ".storeTf" block
+  {
+    builder.SetInsertPoint(storeTfBlock);
+
+    auto userData = getFunctionArgument(entryPoint, NumSpecialSgprInputs);
+    auto globalTable = builder.CreateExtractElement(
+        userData, static_cast<uint64_t>(0)); // The first element of user data argument is always internal global tabl
+
+    Value *pc = builder.CreateIntrinsic(Intrinsic::amdgcn_s_getpc, {}, {});
+    pc = builder.CreateBitCast(pc, FixedVectorType::get(builder.getInt32Ty(), 2));
+
+    Value *globalTablePtr = builder.CreateInsertElement(pc, globalTable, static_cast<uint64_t>(0));
+    globalTablePtr = builder.CreateBitCast(globalTablePtr, builder.getInt64Ty());
+    Type *tfBufferDescTy = FixedVectorType::get(builder.getInt32Ty(), 4);
+    globalTablePtr =
+        builder.CreateIntToPtr(globalTablePtr, PointerType::get(tfBufferDescTy, ADDR_SPACE_CONST), "globalTablePtr");
+
+    Value *tfBufferDescPtr =
+        builder.CreateGEP(tfBufferDescTy, globalTablePtr, builder.getInt32(SiDrvTableTfBufferOffs), "tfBufferDescPtr");
+    auto tfBufferDesc = builder.CreateLoad(tfBufferDescTy, tfBufferDescPtr, "tfBufferDesc");
+    Value *tfBufferBase = getFunctionArgument(entryPoint, getSpecialSgprInputIndex(m_gfxIp, LsHs::TfBufferBase));
+
+    // Store TFs to TF buffer
+    PatchPreparePipelineAbi::writeTessFactors(m_pipelineState, tfBufferDesc, tfBufferBase, threadIdInGroup, outerTf,
+                                              innerTf, builder);
+    builder.CreateBr(endTryStoreTfBlock);
+  }
+
+  // Construct ".endTryStoreTf" block
+  {
+    builder.SetInsertPoint(endTryStoreTfBlock);
+    // Do nothing
+  }
+}
+
+// =====================================================================================================================
+// Read value from LDS.
+//
+// @param readTy : Type of value to read
+// @param ldsOffset : LDS offset in dwords
+// @param builder : IR builder to insert instructions
+// @returns : The Value read from LDS
+Value *ShaderMerger::readValueFromLds(Type *readTy, Value *ldsOffset, IRBuilder<> &builder) {
+  assert(readTy->getScalarSizeInBits() == 32); // Only accept 32-bit data
+
+  auto lds = Patch::getLdsVariable(m_pipelineState, builder.GetInsertBlock()->getModule());
+  Value *readPtr = builder.CreateGEP(lds->getValueType(), lds, {builder.getInt32(0), ldsOffset});
+  readPtr = builder.CreateBitCast(readPtr, PointerType::get(readTy, readPtr->getType()->getPointerAddressSpace()));
+  return builder.CreateAlignedLoad(readTy, readPtr, Align(4));
+}
+
+// =====================================================================================================================
+// Write value to mesh shader LDS.
+//
+// @param writeValue : Value to write
+// @param ldsOffset : LDS offset in dwords
+// @param builder : IR builder to insert instructions
+void ShaderMerger::writeValueToLds(Value *writeValue, Value *ldsOffset, IRBuilder<> &builder) {
+  auto writeTy = writeValue->getType();
+  assert(writeTy->getScalarSizeInBits() == 32); // Only accept 32-bit data
+
+  auto lds = Patch::getLdsVariable(m_pipelineState, builder.GetInsertBlock()->getModule());
+  Value *writePtr = builder.CreateGEP(lds->getValueType(), lds, {builder.getInt32(0), ldsOffset});
+  writePtr = builder.CreateBitCast(writePtr, PointerType::get(writeTy, writePtr->getType()->getPointerAddressSpace()));
+  builder.CreateAlignedStore(writeValue, writePtr, Align(4));
+}
+#endif
diff --git a/lgc/patch/ShaderMerger.h b/lgc/patch/ShaderMerger.h
index e32ebcbaa..e9dba3400 100644
--- a/lgc/patch/ShaderMerger.h
+++ b/lgc/patch/ShaderMerger.h
@@ -49,40 +49,50 @@ enum SpecialSgprInput : unsigned {
   UserDataAddrHigh,
   OffChipLdsBase,
   MergedWaveInfo,
   TfBufferBase,
   HsShaderAddrLow,
   HsShaderAddrHigh,
 
   // GFX9~GFX10
   SharedScratchOffset,
 
+#if LLPC_BUILD_GFX11
+  // GFX11+
+  waveIdInGroup,
+#endif
 };
 } // namespace LsHs
 
 // Enumerates first 8 SGPRs (always loaded) for the ES-GS merged shader
 namespace EsGs {
 enum SpecialSgprInput : unsigned {
   UserDataAddrLow = 0,
   UserDataAddrHigh,
   MergedWaveInfo,
   OffChipLdsBase,
   GsShaderAddrLow,
   GsShaderAddrHigh,
 
   // GFX9~GFX10
   GsVsOffset, // Non-NGG
   SharedScratchOffset,
 
   // GFX10+
   MergedGroupInfo, // NGG
 
+#if LLPC_BUILD_GFX11
+  // GFX11+
+  AttribRingBase,
+  FlatScratchLow,
+  FlatScratchHigh,
+#endif
 };
 } // namespace EsGs
 
 static constexpr unsigned NumSpecialSgprInputs = 8; // First 8 SGPRs are defined or reserved by HW
 
 // =====================================================================================================================
 // Represents the manager doing shader merge operations.
 class ShaderMerger {
 public:
   ShaderMerger(PipelineState *pipelineState, PipelineShadersResult *pipelineShaders);
@@ -109,20 +119,26 @@ private:
   void appendVertexFetchTypes(std::vector<llvm::Type *> &argTys) const;
   void appendArguments(llvm::SmallVectorImpl<llvm::Value *> &args, llvm::Argument *begin, llvm::Argument *end) const;
 
   void gatherTuningAttributes(llvm::AttrBuilder &tuningAttrs, const llvm::Function *srcEntryPoint) const;
   void applyTuningAttributes(llvm::Function *dstEntryPoint, const llvm::AttrBuilder &tuningAttrs) const;
 
 #if VKI_RAY_TRACING
   void processRayQueryLdsStack(llvm::Function *entryPoint1, llvm::Function *entryPoint2) const;
 #endif
 
+#if LLPC_BUILD_GFX11
+  void storeTessFactorsWithOpt(llvm::Value *threadIdInWave, llvm::IRBuilder<> &builder);
+  llvm::Value *readValueFromLds(llvm::Type *readTy, llvm::Value *ldsOffset, llvm::IRBuilder<> &builder);
+  void writeValueToLds(llvm::Value *writeValue, llvm::Value *ldsOffset, llvm::IRBuilder<> &builder);
+#endif
+
   PipelineState *m_pipelineState; // Pipeline state
   llvm::LLVMContext *m_context;   // LLVM context
   GfxIpVersion m_gfxIp;           // Graphics IP version info
 
   bool m_hasVs;  // Whether the pipeline has vertex shader
   bool m_hasTcs; // Whether the pipeline has tessellation control shader
   bool m_hasTes; // Whether the pipeline has tessellation evaluation shader
   bool m_hasGs;  // Whether the pipeline has geometry shader
 };
 
diff --git a/lgc/patch/SystemValues.cpp b/lgc/patch/SystemValues.cpp
index 136b3a9c0..6a96a8851 100644
--- a/lgc/patch/SystemValues.cpp
+++ b/lgc/patch/SystemValues.cpp
@@ -92,20 +92,37 @@ Value *ShaderSystemValues::getEsGsRingBufDesc() {
 Value *ShaderSystemValues::getTessFactorBufDesc() {
   assert(m_shaderStage == ShaderStageTessControl);
   if (!m_tfBufDesc) {
     // Ensure we have got the global table pointer first, and insert new code after that.
     BuilderBase builder(getInternalGlobalTablePtr()->getNextNode());
     m_tfBufDesc = loadDescFromDriverTable(SiDrvTableTfBufferOffs, builder);
   }
   return m_tfBufDesc;
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Get the descriptor for vertex attribute ring buffer (for VS, TES, and copy shader output)
+Value *ShaderSystemValues::getAttribRingBufDesc() {
+  // Vertex attributes through memory is for GFX11+
+  assert(m_pipelineState->getTargetInfo().getGfxIpVersion().major >= 11);
+  assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
+         m_shaderStage == ShaderStageCopyShader || m_shaderStage == ShaderStageMesh);
+  if (!m_attribRingBufDesc) {
+    // Ensure we have got the global table pointer first, and insert new code after that.
+    BuilderBase builder(getInternalGlobalTablePtr()->getNextNode());
+    m_attribRingBufDesc = loadDescFromDriverTable(SiDrvTableOffChipParamCache, builder);
+  }
+  return m_attribRingBufDesc;
+}
+
+#endif
 // =====================================================================================================================
 // Get the descriptor for task payload ring buffer (for task and mesh shader)
 Value *ShaderSystemValues::getTaskPayloadRingBufDesc() {
   assert(m_pipelineState->getTargetInfo().getGfxIpVersion() >= GfxIpVersion({10, 3})); // Must be GFX10.3+
   assert(m_shaderStage == ShaderStageTask || m_shaderStage == ShaderStageMesh);
   if (!m_taskPayloadRingBufDesc) {
     // Ensure we have got the global table pointer first, and insert new code after that.
     BuilderBase builder(getInternalGlobalTablePtr()->getNextNode());
     m_taskPayloadRingBufDesc = loadDescFromDriverTable(SiDrvTableTaskPayloadRingOffs, builder);
   }
@@ -403,20 +420,58 @@ Value *ShaderSystemValues::getStreamOutBufDesc(unsigned xfbBuffer) {
     assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(streamOutBufDescPtr->getType(), streamOutBufDescTy));
 
     auto streamOutBufDesc = new LoadInst(streamOutBufDescTy, streamOutBufDescPtr, "", false, Align(16), insertPos);
     streamOutBufDesc->setMetadata(LLVMContext::MD_invariant_load, MDNode::get(streamOutBufDesc->getContext(), {}));
 
     m_streamOutBufDescs[xfbBuffer] = streamOutBufDesc;
   }
   return m_streamOutBufDescs[xfbBuffer];
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Get stream-out buffer offset
+//
+// @param xfbBuffer : Transform feedback buffer ID
+Value *ShaderSystemValues::getStreamOutBufOffset(unsigned xfbBuffer) {
+  assert(m_pipelineState->enableSwXfb());
+  assert(xfbBuffer < MaxTransformFeedbackBuffers);
+  if (m_streamOutBufOffsets.size() <= xfbBuffer)
+    m_streamOutBufOffsets.resize(xfbBuffer + 1);
+
+  if (!m_streamOutBufOffsets[xfbBuffer]) {
+    auto streamOutControlBufPtr = getStreamOutControlBufPtr();
+    auto insertPos = streamOutControlBufPtr->getNextNode();
+
+    Value *idxs[] = {ConstantInt::get(Type::getInt64Ty(*m_context), 0),
+                     ConstantInt::get(Type::getInt64Ty(*m_context), 0), // 0: OFFSET[X], 1: FILLED_SIZE[X]
+                     ConstantInt::get(Type::getInt64Ty(*m_context), xfbBuffer)};
+
+    auto streamOutControlBufType = streamOutControlBufPtr->getType()->getPointerElementType();
+    auto streamOutBufOffsetPtr =
+        GetElementPtrInst::Create(streamOutControlBufType, streamOutControlBufPtr, idxs, "", insertPos);
+    streamOutBufOffsetPtr->setMetadata(MetaNameUniform, MDNode::get(streamOutBufOffsetPtr->getContext(), {}));
+    auto streamOutBufOffsetTy = streamOutBufOffsetPtr->getType()->getPointerElementType();
+
+    auto streamOutBufOffset = new LoadInst(streamOutBufOffsetTy, streamOutBufOffsetPtr, "", false, Align(4), insertPos);
+    // NOTE: PAL decided not to invalidate the SQC and L1 for every stream-out update, mainly because that will hurt
+    // overall performance worse than just forcing this one buffer to be read via L2. Since PAL would not have wider
+    // context, PAL believed that they would have to perform that invalidation on every Set/Load unconditionally.
+    // Thus, we force the load of stream-out control buffer to be volatile to let LLVM backend add GLC and DLC flags.
+    streamOutBufOffset->setVolatile(true);
+
+    m_streamOutBufOffsets[xfbBuffer] = streamOutBufOffset;
+  }
+  return m_streamOutBufOffsets[xfbBuffer];
+}
+#endif
+
 // =====================================================================================================================
 // Get stream-out buffer table pointer
 std::pair<Type *, Instruction *> ShaderSystemValues::getStreamOutTablePtr() {
   assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
          m_shaderStage == ShaderStageCopyShader);
 
   auto *streamOutTableTy =
       ArrayType::get(FixedVectorType::get(Type::getInt32Ty(*m_context), 4), MaxTransformFeedbackBuffers);
   if (!m_streamOutTablePtr) {
     auto intfData = m_pipelineState->getShaderInterfaceData(m_shaderStage);
@@ -440,20 +495,63 @@ std::pair<Type *, Instruction *> ShaderSystemValues::getStreamOutTablePtr() {
     assert(entryArgIdx != 0);
 
     // Get the 64-bit extended node value.
     auto streamOutTablePtrLow = getFunctionArgument(m_entryPoint, entryArgIdx, "streamOutTable");
     auto streamOutTablePtrTy = PointerType::get(streamOutTableTy, ADDR_SPACE_CONST);
     m_streamOutTablePtr = makePointer(streamOutTablePtrLow, streamOutTablePtrTy, InvalidValue);
   }
   return std::make_pair(streamOutTableTy, m_streamOutTablePtr);
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Get stream-out control buffer pointer
+Instruction *ShaderSystemValues::getStreamOutControlBufPtr() {
+  assert(m_pipelineState->enableSwXfb());
+  assert(m_shaderStage == ShaderStageVertex || m_shaderStage == ShaderStageTessEval ||
+         m_shaderStage == ShaderStageCopyShader);
+
+  if (!m_streamOutControlBufPtr) {
+    auto intfData = m_pipelineState->getShaderInterfaceData(m_shaderStage);
+    unsigned entryArgIdx = 0;
+
+    // Get the SGPR number of the stream-out control buffer pointer.
+    switch (m_shaderStage) {
+    case ShaderStageVertex:
+      entryArgIdx = intfData->entryArgIdxs.vs.streamOutData.controlBufPtr;
+      break;
+    case ShaderStageTessEval:
+      entryArgIdx = intfData->entryArgIdxs.tes.streamOutData.controlBufPtr;
+      break;
+    case ShaderStageCopyShader:
+      entryArgIdx = intfData->userDataUsage.gs.copyShaderStreamOutControlBuf;
+      break;
+    default:
+      llvm_unreachable("Should never be called!");
+      break;
+    }
+    assert(entryArgIdx != 0);
+
+    // Get the 64-bit extended node value.
+    auto streamOutControlBufPtrLow = getFunctionArgument(m_entryPoint, entryArgIdx, "streamOutControlBuf");
+    // NOTE: The stream-out control buffer has the following memory layout:
+    //   OFFSET[X]: OFFSET0, OFFSET1, ..., OFFSETN
+    //   FILLED_SIZE[X]: FILLED_SIZE0, FILLED_SIZE1, ..., FILLED_SIZEN
+    auto streamOutControlBufPtrTy = PointerType::get(
+        ArrayType::get(FixedVectorType::get(Type::getInt32Ty(*m_context), MaxTransformFeedbackBuffers), 2),
+        ADDR_SPACE_CONST);
+    m_streamOutControlBufPtr = makePointer(streamOutControlBufPtrLow, streamOutControlBufPtrTy, InvalidValue);
+  }
+  return m_streamOutControlBufPtr;
+}
+#endif
+
 // =====================================================================================================================
 // Make 64-bit pointer of specified type from 32-bit int, extending with the specified value, or PC if InvalidValue
 //
 // @param lowValue : 32-bit int value to extend
 // @param ptrTy : Type that result pointer needs to be
 // @param highValue : Value to use for high part, or InvalidValue to use PC
 Instruction *ShaderSystemValues::makePointer(Value *lowValue, Type *ptrTy, unsigned highValue) {
   // Insert extending code after lowValue if it is an instruction.
   Instruction *insertPos = nullptr;
   auto lowValueInst = dyn_cast<Instruction>(lowValue);
diff --git a/lgc/patch/VertexFetch.cpp b/lgc/patch/VertexFetch.cpp
index 05ee3fd6f..6ff60646c 100644
--- a/lgc/patch/VertexFetch.cpp
+++ b/lgc/patch/VertexFetch.cpp
@@ -125,20 +125,23 @@ private:
   LgcContext *m_lgcContext = nullptr;   // LGC context
   LLVMContext *m_context = nullptr;     // LLVM context
   Value *m_vertexBufTablePtr = nullptr; // Vertex buffer table pointer
   Value *m_vertexIndex = nullptr;       // Vertex index
   Value *m_instanceIndex = nullptr;     // Instance index
   Function *m_fetchVertex64 = nullptr;  // 64-bit fetch vertex function
   Function *m_fetchVertex32 = nullptr;  // 32-bit fetch vertex function
 
   static const VertexCompFormatInfo m_vertexCompFormatInfo[]; // Info table of vertex component format
   static const unsigned char m_vertexFormatMapGfx10[][8];     // Info table of vertex format mapping for GFX10
+#if LLPC_BUILD_GFX11
+  static const unsigned char m_vertexFormatMapGfx11[][8]; // Info table of vertex format mapping for GFX11
+#endif
 
   // Default values for vertex fetch (<4 x i32> or <8 x i32>)
   struct {
     Constant *int8;     // < 0, 0, 0, 1 >
     Constant *int16;    // < 0, 0, 0, 1 >
     Constant *int32;    // < 0, 0, 0, 1 >
     Constant *int64;    // < 0, 0, 0, 0, 0, 0, 0, 1 >
     Constant *float16;  // < 0, 0, 0, 0x3C00 >
     Constant *float32;  // < 0, 0, 0, 0x3F800000 >
     Constant *double64; // < 0, 0, 0, 0, 0, 0, 0, 0x3FF00000 >
@@ -339,20 +342,196 @@ const unsigned char VertexFetchImpl::m_vertexFormatMapGfx10[][8] = {
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID,
      BUF_FORMAT_INVALID},
 };
 // clang-format on
 
+#if LLPC_BUILD_GFX11
+// clang-format off
+const unsigned char VertexFetchImpl::m_vertexFormatMapGfx11[][8] = {
+    // BUF_DATA_FORMAT
+    //   BUF_NUM_FORMAT_UNORM
+    //   BUF_NUM_FORMAT_SNORM
+    //   BUF_NUM_FORMAT_USCALED
+    //   BUF_NUM_FORMAT_SSCALED
+    //   BUF_NUM_FORMAT_UINT
+    //   BUF_NUM_FORMAT_SINT
+    //   BUF_NUM_FORMAT_SNORM_NZ
+    //   BUF_NUM_FORMAT_FLOAT
+
+    // BUF_DATA_FORMAT_INVALID
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_8
+    {BUF_FORMAT_8_UNORM,
+     BUF_FORMAT_8_SNORM,
+     BUF_FORMAT_8_USCALED,
+     BUF_FORMAT_8_SSCALED,
+     BUF_FORMAT_8_UINT,
+     BUF_FORMAT_8_SINT,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_16
+    {BUF_FORMAT_16_UNORM,
+     BUF_FORMAT_16_SNORM,
+     BUF_FORMAT_16_USCALED,
+     BUF_FORMAT_16_SSCALED,
+     BUF_FORMAT_16_UINT,
+     BUF_FORMAT_16_SINT,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_16_FLOAT},
+
+    // BUF_DATA_FORMAT_8_8
+    {BUF_FORMAT_8_8_UNORM,
+     BUF_FORMAT_8_8_SNORM,
+     BUF_FORMAT_8_8_USCALED,
+     BUF_FORMAT_8_8_SSCALED,
+     BUF_FORMAT_8_8_UINT,
+     BUF_FORMAT_8_8_SINT,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_32
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_UINT,
+     BUF_FORMAT_32_SINT,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_FLOAT},
+
+    // BUF_DATA_FORMAT_16_16
+    {BUF_FORMAT_16_16_UNORM,
+     BUF_FORMAT_16_16_SNORM,
+     BUF_FORMAT_16_16_USCALED,
+     BUF_FORMAT_16_16_SSCALED,
+     BUF_FORMAT_16_16_UINT,
+     BUF_FORMAT_16_16_SINT,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_16_16_FLOAT},
+
+    // BUF_DATA_FORMAT_10_11_11
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_10_11_11_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_11_11_10
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_11_11_10_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_10_10_10_2
+    {BUF_FORMAT_10_10_10_2_UNORM_GFX11,
+     BUF_FORMAT_10_10_10_2_SNORM_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_10_10_10_2_UINT_GFX11,
+     BUF_FORMAT_10_10_10_2_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_2_10_10_10
+    {BUF_FORMAT_2_10_10_10_UNORM_GFX11,
+     BUF_FORMAT_2_10_10_10_SNORM_GFX11,
+     BUF_FORMAT_2_10_10_10_USCALED_GFX11,
+     BUF_FORMAT_2_10_10_10_SSCALED_GFX11,
+     BUF_FORMAT_2_10_10_10_UINT_GFX11,
+     BUF_FORMAT_2_10_10_10_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_8_8_8_8
+    {BUF_FORMAT_8_8_8_8_UNORM_GFX11,
+     BUF_FORMAT_8_8_8_8_SNORM_GFX11,
+     BUF_FORMAT_8_8_8_8_USCALED_GFX11,
+     BUF_FORMAT_8_8_8_8_SSCALED_GFX11,
+     BUF_FORMAT_8_8_8_8_UINT_GFX11,
+     BUF_FORMAT_8_8_8_8_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+
+    // BUF_DATA_FORMAT_32_32
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_UINT_GFX11,
+     BUF_FORMAT_32_32_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_16_16_16_16
+    {BUF_FORMAT_16_16_16_16_UNORM_GFX11,
+     BUF_FORMAT_16_16_16_16_SNORM_GFX11,
+     BUF_FORMAT_16_16_16_16_USCALED_GFX11,
+     BUF_FORMAT_16_16_16_16_SSCALED_GFX11,
+     BUF_FORMAT_16_16_16_16_UINT_GFX11,
+     BUF_FORMAT_16_16_16_16_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_16_16_16_16_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_32_32_32
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_32_UINT_GFX11,
+     BUF_FORMAT_32_32_32_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_32_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_32_32_32_32
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_32_32_UINT_GFX11,
+     BUF_FORMAT_32_32_32_32_SINT_GFX11,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_32_32_32_32_FLOAT_GFX11},
+
+    // BUF_DATA_FORMAT_RESERVED_15
+    {BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID,
+     BUF_FORMAT_INVALID},
+};
+// clang-format on
+#endif
+
 char LegacyLowerVertexFetch::ID = 0;
 
 // =====================================================================================================================
 // Create the vertex fetch pass
 ModulePass *lgc::createLegacyLowerVertexFetch() {
   return new LegacyLowerVertexFetch();
 }
 
 // =====================================================================================================================
 LegacyLowerVertexFetch::LegacyLowerVertexFetch() : ModulePass(ID) {
@@ -1390,20 +1569,27 @@ unsigned VertexFetchImpl::mapVertexFormat(unsigned dfmt, unsigned nfmt) const {
     formatOprd.bits.dfmt = dfmt;
     formatOprd.bits.nfmt = nfmt;
     format = formatOprd.u32All;
     break;
   }
   case 10:
     assert(dfmt < sizeof(m_vertexFormatMapGfx10) / sizeof(m_vertexFormatMapGfx10[0]));
     assert(nfmt < sizeof(m_vertexFormatMapGfx10[0]) / sizeof(m_vertexFormatMapGfx10[0][0]));
     format = m_vertexFormatMapGfx10[dfmt][nfmt];
     break;
+#if LLPC_BUILD_GFX11
+  case 11:
+    assert(dfmt < sizeof(m_vertexFormatMapGfx11) / sizeof(m_vertexFormatMapGfx11[0]));
+    assert(nfmt < sizeof(m_vertexFormatMapGfx11[0]) / sizeof(m_vertexFormatMapGfx11[0][0]));
+    format = m_vertexFormatMapGfx11[dfmt][nfmt];
+    break;
+#endif
   }
   return format;
 }
 
 // =====================================================================================================================
 // Loads vertex descriptor based on the specified vertex input location.
 //
 // @param binding : ID of vertex buffer binding
 // @param builder : Builder with insert point set
 Value *VertexFetchImpl::loadVertexBufferDescriptor(unsigned binding, BuilderBase &builder) {
diff --git a/lgc/state/Compiler.cpp b/lgc/state/Compiler.cpp
index fdd328a0d..1b9f81907 100644
--- a/lgc/state/Compiler.cpp
+++ b/lgc/state/Compiler.cpp
@@ -28,20 +28,26 @@
  * @brief LLPC source file: PipelineState methods that do IR linking and compilation
  ***********************************************************************************************************************
  */
 #include "lgc/LgcContext.h"
 #include "lgc/PassManager.h"
 #include "lgc/patch/Patch.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/IR/IRPrintingPasses.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Linker/Linker.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Target/TargetMachine.h"
 
 #define DEBUG_TYPE "lgc-compiler"
 
 using namespace lgc;
 using namespace llvm;
 
@@ -207,21 +213,21 @@ bool PipelineState::generate(std::unique_ptr<Module> pipelineModule, raw_pwrite_
 
 void PipelineState::generateWithNewPassManager(std::unique_ptr<Module> pipelineModule, raw_pwrite_stream &outStream,
                                                Pipeline::CheckShaderCacheFunc checkShaderCacheFunc,
                                                ArrayRef<Timer *> timers) {
   unsigned passIndex = 1000;
   Timer *patchTimer = timers.size() >= 1 ? timers[0] : nullptr;
   Timer *optTimer = timers.size() >= 2 ? timers[1] : nullptr;
   Timer *codeGenTimer = timers.size() >= 3 ? timers[2] : nullptr;
 
   // Set up "whole pipeline" passes, where we have a single module representing the whole pipeline.
-  std::unique_ptr<lgc::PassManager> passMgr(lgc::PassManager::Create(getLgcContext()->getTargetMachine()));
+  std::unique_ptr<lgc::PassManager> passMgr(lgc::PassManager::Create(getLgcContext()));
   passMgr->setPassIndex(&passIndex);
   Patch::registerPasses(*passMgr);
   passMgr->registerFunctionAnalysis([&] { return getLgcContext()->getTargetMachine()->getTargetIRAnalysis(); });
   passMgr->registerModuleAnalysis([&] { return PipelineShaders(); });
 
   // Manually add a target-aware TLI pass, so optimizations do not think that we have library functions.
   getLgcContext()->preparePassManager(*passMgr);
 
   // Manually add a PipelineStateWrapper pass.
   // We were using BuilderRecorder, so we do not give our PipelineState to it.
diff --git a/lgc/state/LgcContext.cpp b/lgc/state/LgcContext.cpp
index e88eb7a13..3e641f3c8 100644
--- a/lgc/state/LgcContext.cpp
+++ b/lgc/state/LgcContext.cpp
@@ -35,29 +35,23 @@
 #include "lgc/state/PassManagerCache.h"
 #include "lgc/state/PipelineState.h"
 #include "lgc/state/TargetInfo.h"
 #include "lgc/util/Debug.h"
 #include "lgc/util/Internal.h"
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
 #include "llvm/CodeGen/CommandFlags.h"
 #include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/InitializePasses.h"
+#include "llvm/MC/TargetRegistry.h"
 #include "llvm/Support/CodeGen.h"
 #include "llvm/Support/CommandLine.h"
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 401324
-// Old version
-#include "llvm/Support/TargetRegistry.h"
-#else
-// New version (and unknown version)
-#include "llvm/MC/TargetRegistry.h"
-#endif
 #include "llvm/Support/TargetSelect.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Target/TargetOptions.h"
 
 #define DEBUG_TYPE "lgc-context"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace llvm {
@@ -131,21 +125,20 @@ void LgcContext::initialize() {
   LLVMInitializeAMDGPUAsmPrinter();
   LLVMInitializeAMDGPUAsmParser();
   LLVMInitializeAMDGPUDisassembler();
 
   // Initialize core LLVM passes so they can be referenced by -stop-before etc.
   initializeCore(passRegistry);
   initializeTransformUtils(passRegistry);
   initializeScalarOpts(passRegistry);
   initializeVectorization(passRegistry);
   initializeInstCombine(passRegistry);
-  initializeAggressiveInstCombine(passRegistry);
   initializeIPO(passRegistry);
   initializeCodeGen(passRegistry);
   initializeShadowStackGCLoweringPass(passRegistry);
   initializeExpandReductionsPass(passRegistry);
   initializeRewriteSymbolsLegacyPassPass(passRegistry);
 
   // Initialize LGC passes so they can be referenced by -stop-before etc.
   initializeUtilPasses(passRegistry);
   initializeStatePasses(passRegistry);
   initializeLegacyBuilderReplayerPass(passRegistry);
@@ -252,22 +245,21 @@ LgcContext *LgcContext::create(LLVMContext &context, StringRef gpuName, unsigned
   // Save optimization level given at initialization.
   builderContext->m_initialOptLevel = optLevel;
 
   // If the "opt" option is given, set the optimization level to that value.
   if (OptLevel.getPosition() != 0) {
     optLevel = OptLevel;
   }
 
   LLPC_OUTS("TargetMachine optimization level = " << optLevel << "\n");
 
-  builderContext->m_targetMachine =
-      target->createTargetMachine(triple, gpuName, "", targetOpts, Optional<Reloc::Model>(), None, optLevel);
+  builderContext->m_targetMachine = target->createTargetMachine(triple, gpuName, "", targetOpts, {}, {}, optLevel);
   assert(builderContext->m_targetMachine);
   return builderContext;
 }
 
 // =====================================================================================================================
 //
 // @param context : LLVM context to give each Builder
 // @param palAbiVersion : PAL pipeline ABI version to compile for
 LgcContext::LgcContext(LLVMContext &context, unsigned palAbiVersion) : m_context(context) {
 }
diff --git a/lgc/state/PalMetadata.cpp b/lgc/state/PalMetadata.cpp
index 58e08d924..90038070e 100644
--- a/lgc/state/PalMetadata.cpp
+++ b/lgc/state/PalMetadata.cpp
@@ -401,23 +401,61 @@ void PalMetadata::setUserDataEntry(ShaderStage stage, unsigned userDataIndex, un
 // Mark that the user data spill table is used at the given offset. The SpillThreshold PAL metadata entry is
 // set to the minimum of any call to this function in any shader.
 //
 // @param dwordOffset : Dword offset that the spill table is used at
 void PalMetadata::setUserDataSpillUsage(unsigned dwordOffset) {
   if (dwordOffset < m_spillThreshold->getUInt())
     *m_spillThreshold = dwordOffset;
 }
 
 // =====================================================================================================================
-// Fix up user data registers. Any user data register that has one of the unlinked UserDataMapping values defined
-// in AbiUnlinked.h is fixed up by looking at pipeline state.
+// Fix up registers. Any user data register that has one of the unlinked UserDataMapping values defined in
+// AbiUnlinked.h is fixed up by looking at pipeline state; And some dynamic states also need to be fixed.
 void PalMetadata::fixUpRegisters() {
+  // Fix GS output primitive type (VGT_GS_OUT_PRIM_TYPE). Unlinked compiling VS + NGG, we can't determine
+  // the output primitive type, we must fix up it when linking.
+  // If pipeline includes GS or TS, the type is from shader, we don't need to fix it. We only must fix a case
+  // which includes VS + FS + NGG.
+  if (m_pipelineState->isGraphics()) {
+    const bool hasTs =
+        m_pipelineState->hasShaderStage(ShaderStageTessControl) || m_pipelineState->hasShaderStage(ShaderStageTessEval);
+    const bool hasGs = m_pipelineState->hasShaderStage(ShaderStageGeometry);
+    if (!hasTs && !hasGs) {
+      // Here we use register field to determine if NGG is enabled, because enabling NGG depends on other conditions.
+      // see PatchResourceCollect::canUseNgg.
+      if (m_registers.find(m_document->getNode(mmVGT_GS_OUT_PRIM_TYPE)) != m_registers.end()) {
+        const auto primType = m_pipelineState->getInputAssemblyState().primitiveType;
+        unsigned gsOutputPrimitiveType = 0;
+        switch (primType) {
+        case PrimitiveType::Point:
+          gsOutputPrimitiveType = 0; // POINTLIST
+          break;
+        case PrimitiveType::LineList:
+        case PrimitiveType::LineStrip:
+          gsOutputPrimitiveType = 1; // LINESTRIP
+          break;
+        case PrimitiveType::TriangleList:
+        case PrimitiveType::TriangleStrip:
+        case PrimitiveType::TriangleFan:
+        case PrimitiveType::TriangleListAdjacency:
+        case PrimitiveType::TriangleStripAdjacency:
+          gsOutputPrimitiveType = 2; // TRISTRIP
+          break;
+        default:
+          llvm_unreachable("Should never be called!");
+          break;
+        }
+        m_registers[mmVGT_GS_OUT_PRIM_TYPE] = gsOutputPrimitiveType;
+      }
+    }
+  }
+
   static const std::pair<unsigned, unsigned> ComputeRegRanges[] = {{mmCOMPUTE_USER_DATA_0, 16}};
   static const std::pair<unsigned, unsigned> Gfx8RegRanges[] = {
       {mmSPI_SHADER_USER_DATA_PS_0, 16}, {mmSPI_SHADER_USER_DATA_VS_0, 16}, {mmSPI_SHADER_USER_DATA_GS_0, 16},
       {mmSPI_SHADER_USER_DATA_ES_0, 16}, {mmSPI_SHADER_USER_DATA_HS_0, 16}, {mmSPI_SHADER_USER_DATA_LS_0, 16}};
   static const std::pair<unsigned, unsigned> Gfx9RegRanges[] = {{mmSPI_SHADER_USER_DATA_PS_0, 32},
                                                                 {mmSPI_SHADER_USER_DATA_VS_0, 32},
                                                                 {mmSPI_SHADER_USER_DATA_ES_0, 32},
                                                                 {mmSPI_SHADER_USER_DATA_HS_0, 32}};
   static const std::pair<unsigned, unsigned> Gfx10RegRanges[] = {{mmSPI_SHADER_USER_DATA_PS_0, 32},
                                                                  {mmSPI_SHADER_USER_DATA_VS_0, 32},
diff --git a/lgc/state/PassManagerCache.cpp b/lgc/state/PassManagerCache.cpp
index cdf1418ef..cf3c4754d 100644
--- a/lgc/state/PassManagerCache.cpp
+++ b/lgc/state/PassManagerCache.cpp
@@ -24,21 +24,27 @@
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  PassManagerCache.cpp
  * @brief LGC source file: Pass manager creator and cache
  ***********************************************************************************************************************
  */
 #include "lgc/state/PassManagerCache.h"
 #include "lgc/LgcContext.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
 #include "llvm/IR/IRPrintingPasses.h"
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/InstCombine/InstCombine.h"
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Scalar/EarlyCSE.h"
 #include "llvm/Transforms/Scalar/InstSimplifyPass.h"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace lgc {
@@ -75,21 +81,21 @@ std::pair<lgc::PassManager &, LegacyPassManager &> PassManagerCache::getPassMana
   // Check the cache.
   std::pair<std::unique_ptr<lgc::PassManager>, std::unique_ptr<LegacyPassManager>> &passManagers =
       m_cache[StringRef(reinterpret_cast<const char *>(&info), sizeof(info))];
   if (passManagers.first)
     return {*passManagers.first, *passManagers.second};
 
   // Need to create the pass manager.
   // TODO: Creation of a normal compilation pass manager, not just one for a glue shader.
   assert(info.isGlue && "Non-glue shader compilation not implemented yet");
 
-  passManagers.first.reset(PassManager::Create(m_lgcContext->getTargetMachine()));
+  passManagers.first.reset(PassManager::Create(m_lgcContext));
   passManagers.first->registerFunctionAnalysis([&] { return m_lgcContext->getTargetMachine()->getTargetIRAnalysis(); });
 
   // Manually add a target-aware TLI pass, so optimizations do not think that we have library functions.
   m_lgcContext->preparePassManager(*passManagers.first);
 
   // Add a few optimizations.
   FunctionPassManager fpm;
   fpm.addPass(InstCombinePass(5));
   fpm.addPass(InstSimplifyPass());
   fpm.addPass(EarlyCSEPass(true));
diff --git a/lgc/state/PipelineState.cpp b/lgc/state/PipelineState.cpp
index d9e2139f0..9fefa7b4f 100644
--- a/lgc/state/PipelineState.cpp
+++ b/lgc/state/PipelineState.cpp
@@ -337,20 +337,21 @@ void PipelineState::readState(Module *module) {
   getShaderModes()->readModesFromPipeline(module);
   readShaderStageMask(module);
   readOptions(module);
   readUserDataNodes(module);
   readDeviceIndex(module);
   readVertexInputDescriptions(module);
   readColorExportState(module);
   readGraphicsState(module);
   if (!m_palMetadata)
     m_palMetadata = new PalMetadata(this, module);
+  setXfbStateMetadata(module);
 }
 
 // =====================================================================================================================
 // Read shaderStageMask from IR. This consists of checking what shader stage functions are present in the IR.
 // It also sets the m_computeLibrary flag if there are no shader entry-points.
 //
 // @param module : LLVM module
 void PipelineState::readShaderStageMask(Module *module) {
   m_stageMask = 0;
   for (auto &func : *module) {
@@ -1265,20 +1266,24 @@ void PipelineState::setShaderDefaultWaveSize(ShaderStage stage) {
       //  3) If gl_SubgroupSize is used in shader, use the specified subgroup size when required.
       //  4) If gl_SubgroupSize is not used in the (mesh/task/compute) shader, and the workgroup size is
       //     not larger than 32, use wave size 32.
 
       if (checkingStage == ShaderStageFragment) {
         // Per programming guide, it's recommended to use wave64 for fragment shader.
         waveSize = 64;
       } else if (hasShaderStage(ShaderStageGeometry)) {
         // Legacy (non-NGG) hardware path for GS does not support wave32.
         waveSize = 64;
+#if LLPC_BUILD_GFX11
+        if (getTargetInfo().getGfxIpVersion().major >= 11)
+          waveSize = 32;
+#endif
       }
 
       // Experimental data from performance tuning show that wave64 is more efficient than wave32 in most cases for CS
       // on post-GFX10.3. Hence, set the wave size to wave64 by default.
       if (getTargetInfo().getGfxIpVersion() >= GfxIpVersion({10, 3}) && stage == ShaderStageCompute)
         waveSize = 64;
 
       unsigned waveSizeOption = getShaderOptions(checkingStage).waveSize;
       if (waveSizeOption != 0)
         waveSize = waveSizeOption;
@@ -1315,35 +1320,73 @@ void PipelineState::setShaderDefaultWaveSize(ShaderStage stage) {
     }
     m_waveSize[checkingStage] = waveSize;
     m_subgroupSize[checkingStage] = subgroupSize;
   }
   if (stage != checkingStage) {
     m_waveSize[stage] = m_waveSize[checkingStage];
     m_subgroupSize[stage] = m_subgroupSize[checkingStage];
   }
 }
 
+// =====================================================================================================================
+// Whether WGP mode is enabled for the given shader stage
+//
+// @param stage : Shader stage
+bool PipelineState::getShaderWgpMode(ShaderStage stage) const {
+  if (stage == ShaderStageCopyShader) {
+    // Treat copy shader as part of geometry shader
+    stage = ShaderStageGeometry;
+  }
+
+  assert(stage <= ShaderStageCompute);
+  assert(stage < m_shaderOptions.size());
+
+  return m_shaderOptions[stage].wgpMode;
+}
+
 // =====================================================================================================================
 // Checks if SW-emulated mesh pipeline statistics is needed
 bool PipelineState::needSwMeshPipelineStats() const {
   return getTargetInfo().getGfxIpVersion().major < 11;
 }
 
 // =====================================================================================================================
 // Checks if row export for mesh shader is enabled or not
 bool PipelineState::enableMeshRowExport() const {
   if (getTargetInfo().getGfxIpVersion().major < 11)
     return false; // Row export is not supported by HW
 
   return m_meshRowExport;
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Checks if SW-emulated stream-out should be enabled.
+bool PipelineState::enableSwXfb() const {
+  assert(isGraphics());
+
+  // SW-emulated stream-out is enabled on GFX11+
+  if (getTargetInfo().getGfxIpVersion().major < 11)
+    return false;
+
+  auto lastVertexStage = getLastVertexProcessingStage();
+  lastVertexStage = lastVertexStage == ShaderStageCopyShader ? ShaderStageGeometry : lastVertexStage;
+
+  if (lastVertexStage == ShaderStageInvalid) {
+    assert(isUnlinked()); // Unlinked pipeline only having fragment shader.
+    return false;
+  }
+
+  return const_cast<PipelineState *>(this)->getShaderResourceUsage(lastVertexStage)->inOutUsage.enableXfb;
+}
+#endif
+
 // =====================================================================================================================
 // Gets resource usage of the specified shader stage
 //
 // @param shaderStage : Shader stage
 ResourceUsage *PipelineState::getShaderResourceUsage(ShaderStage shaderStage) {
   if (shaderStage == ShaderStageCopyShader)
     shaderStage = ShaderStageGeometry;
 
   auto &resUsage = MutableArrayRef<std::unique_ptr<ResourceUsage>>(m_resourceUsage)[shaderStage];
   if (!resUsage) {
@@ -1526,20 +1569,35 @@ StringRef PipelineState::getBuiltInName(BuiltInKind builtIn) {
   case BuiltInInterpPerspSample:
     return "InterpPerspSample";
   case BuiltInInterpLinearSample:
     return "InterpLinearSample";
   default:
     llvm_unreachable("Should never be called!");
     return "unknown";
   }
 }
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// Determine whether can use tessellation factor optimization
+bool PipelineState::canOptimizeTessFactor() {
+  if (getTargetInfo().getGfxIpVersion().major < 11)
+    return false;
+  auto resUsage = getShaderResourceUsage(ShaderStageTessControl);
+  auto &perPatchBuiltInOutLocMap = resUsage->inOutUsage.perPatchBuiltInOutputLocMap;
+  // Disable tessellation factor optimization if TFs are read in TES or TCS
+  if (perPatchBuiltInOutLocMap.count(BuiltInTessLevelOuter) || perPatchBuiltInOutLocMap.count(BuiltInTessLevelInner))
+    return false;
+  return getOptions().optimizeTessFactor;
+}
+#endif
+
 // =====================================================================================================================
 // Set the packable state of generic input/output
 //
 void PipelineState::initializeInOutPackState() {
   // If the pipeline is not unlinked, the state of input/output pack in specified shader stages is enabled
   if (!isUnlinked()) {
     // The generic input imports of {TCS, GS, FS} are packed by default
     m_inputPackState[ShaderStageTessControl] = true;
     m_inputPackState[ShaderStageGeometry] = true;
     m_inputPackState[ShaderStageFragment] = true;
@@ -1674,20 +1732,48 @@ PrimitiveType PipelineState::getPrimitiveType() {
       return PrimitiveType::LineStrip;
     if (tessMode.primitiveMode == PrimitiveMode::Triangles || tessMode.primitiveMode == PrimitiveMode::Quads)
       return PrimitiveType::TriangleStrip;
   } else {
     return getInputAssemblyState().primitiveType;
   }
   llvm_unreachable("Unable to get primitive type!");
   return PrimitiveType::TriangleStrip;
 }
 
+// =====================================================================================================================
+// Set transform feedback state metadata
+//
+// @param xfbStateMetadata : XFB state metadata
+void PipelineState::setXfbStateMetadata(Module *module) {
+  // Read XFB state metadata
+  for (auto &func : *module) {
+    if (isShaderEntryPoint(&func)) {
+      MDNode *xfbStateMetaNode = func.getMetadata(XfbStateMetadataName);
+      if (xfbStateMetaNode) {
+        m_xfbStateMetadata.enableXfb = true;
+        auto &streamXfbBuffers = m_xfbStateMetadata.streamXfbBuffers;
+        auto &xfbStrides = m_xfbStateMetadata.xfbStrides;
+        for (unsigned xfbBuffer = 0; xfbBuffer < MaxTransformFeedbackBuffers; ++xfbBuffer) {
+          // Get the vertex streamId from metadata
+          auto metaOp = cast<ConstantAsMetadata>(xfbStateMetaNode->getOperand(2 * xfbBuffer));
+          int streamId = cast<ConstantInt>(metaOp->getValue())->getSExtValue();
+          if (streamId != InvalidValue)
+            streamXfbBuffers[streamId] |= 1 << xfbBuffer; // Bit mask of used xfbBuffers in a stream
+          // Get the stride from metadata
+          metaOp = cast<ConstantAsMetadata>(xfbStateMetaNode->getOperand(2 * xfbBuffer + 1));
+          xfbStrides[xfbBuffer] = cast<ConstantInt>(metaOp->getValue())->getZExtValue();
+        }
+      }
+    }
+  }
+}
+
 // =====================================================================================================================
 // Get (create if necessary) the PipelineState from this wrapper pass.
 //
 // @param module : IR module
 PipelineState *LegacyPipelineStateWrapper::getPipelineState(Module *module) {
   if (!m_pipelineState) {
     m_allocatedPipelineState = std::make_unique<PipelineState>(m_builderContext);
     m_pipelineState = &*m_allocatedPipelineState;
     m_pipelineState->readState(module);
     m_pipelineState->initializeInOutPackState();
diff --git a/lgc/state/ShaderStage.cpp b/lgc/state/ShaderStage.cpp
index e547ecda2..59dae18d8 100644
--- a/lgc/state/ShaderStage.cpp
+++ b/lgc/state/ShaderStage.cpp
@@ -159,52 +159,36 @@ Function *lgc::addFunctionArgs(Function *oldFunc, Type *retTy, ArrayRef<Type *>
     block->insertInto(newFunc);
   }
 
   // Copy attributes and shader stage from the old function. The new arguments have InReg set iff the corresponding
   // bit is set in inRegMask.
   AttributeList oldAttrList = oldFunc->getAttributes();
   SmallVector<AttributeSet, 8> argAttrs;
   if (append) {
     // Old arguments first.
     for (unsigned idx = 0; idx != oldFuncTy->getNumParams(); ++idx)
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-      // Old version of the code
-      argAttrs.push_back(oldAttrList.getParamAttributes(idx));
-#else
-      // New version of the code (also handles unknown version, which we treat as latest)
       argAttrs.push_back(oldAttrList.getParamAttrs(idx));
-#endif
   }
 
   // New arguments.
   AttributeSet emptyAttrSet;
   AttributeSet inRegAttrSet = emptyAttrSet.addAttribute(oldFunc->getContext(), Attribute::InReg);
   for (unsigned idx = 0; idx != argTys.size(); ++idx)
     argAttrs.push_back((inRegMask >> idx) & 1 ? inRegAttrSet : emptyAttrSet);
   if (!append) {
     // Old arguments.
     for (unsigned idx = 0; idx != argTys.size(); ++idx)
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-      // Old version of the code
-      argAttrs.push_back(oldAttrList.getParamAttributes(idx));
-  }
-  // Construct new AttributeList and set it on the new function.
-  newFunc->setAttributes(AttributeList::get(oldFunc->getContext(), oldAttrList.getFnAttributes(),
-                                            oldAttrList.getRetAttributes(), argAttrs));
-#else
-      // New version of the code (also handles unknown version, which we treat as latest)
       argAttrs.push_back(oldAttrList.getParamAttrs(idx));
   }
   // Construct new AttributeList and set it on the new function.
   newFunc->setAttributes(
       AttributeList::get(oldFunc->getContext(), oldAttrList.getFnAttrs(), oldAttrList.getRetAttrs(), argAttrs));
-#endif
 
   // Set the shader stage on the new function (implemented with IR metadata).
   setShaderStage(newFunc, getShaderStage(oldFunc));
 
   // Replace uses of the old args.
   // Set inreg attributes correctly. We have to use removeAttr because arg attributes are actually attached
   // to the Function, and the attribute copy above copied the arg attributes at their original arg numbers.
   // Also set name of each new arg that comes from old arg.
   for (unsigned idx = 0; idx != argTys.size(); ++idx) {
     Argument *arg = newFunc->getArg(append ? idx + oldFuncTy->getNumParams() : idx);
diff --git a/lgc/state/TargetInfo.cpp b/lgc/state/TargetInfo.cpp
index 5d6a07a2a..c651674e1 100644
--- a/lgc/state/TargetInfo.cpp
+++ b/lgc/state/TargetInfo.cpp
@@ -432,62 +432,95 @@ static void setGfx1032Info(TargetInfo *targetInfo) {
 // gfx1034
 //
 // @param [in/out] targetInfo : Target info
 static void setGfx1034Info(TargetInfo *targetInfo) {
   setGfx10Info(targetInfo);
   setGfx103Info(targetInfo);
 
   targetInfo->getGpuProperty().numShaderEngines = 1;
 }
 
+#if LLPC_BUILD_GFX11
+// gfx11
+//
+// @param [in/out] targetInfo : Target info
+static void setGfx11Info(TargetInfo *targetInfo) {
+  setGfx10Info(targetInfo);
+
+  targetInfo->getGpuProperty().supportIntegerDotFlag.compBitwidth16 = false;
+  targetInfo->getGpuProperty().supportIntegerDotFlag.compBitwidth8 = true;
+  targetInfo->getGpuProperty().supportIntegerDotFlag.compBitwidth4 = true;
+  targetInfo->getGpuProperty().supportIntegerDotFlag.sameSignedness = true;
+  targetInfo->getGpuProperty().supportIntegerDotFlag.diffSignedness = true;
+}
+
+#endif
+
+#if LLPC_BUILD_NAVI31
+// gfx1100
+//
+// @param [in/out] targetInfo : Target info
+static void setGfx1100Info(TargetInfo *targetInfo) {
+  setGfx11Info(targetInfo);
+
+  targetInfo->getGpuWorkarounds().gfx11.waUserSgprInitBug = 1;
+  targetInfo->getGpuWorkarounds().gfx11.waAtmPrecedesPos = 1;
+
+  targetInfo->getGpuProperty().numShaderEngines = 6;
+}
+#endif
+
 // =====================================================================================================================
 // Set TargetInfo. Returns false if the GPU name is not found or not supported.
 //
 // @param gpuName : LLVM GPU name, e.g. "gfx900"
 bool TargetInfo::setTargetInfo(StringRef gpuName) {
   struct GpuNameStringMap {
     const char *gpuName;
     void (*setTargetInfoFunc)(TargetInfo *targetInfo);
   };
 
   static const GpuNameStringMap GpuNameMap[] = {
-      {"gfx600", &setGfx600Info},   // gfx600, tahiti
-      {"gfx601", &setGfx601Info},   // gfx601, pitcairn, verde
-      {"gfx602", &setGfx602Info},   // gfx601, oland, hainan
-      {"gfx700", &setGfx700Info},   // gfx700, kaveri
-      {"gfx701", &setGfx701Info},   // gfx701, hawaii
-      {"gfx702", &setGfx7Info},     // gfx702
-      {"gfx703", &setGfx703Info},   // gfx703, kabini, mullins
-      {"gfx704", &setGfx703Info},   // gfx704, bonaire
-      {"gfx705", &setGfx705Info},   // gfx705
-      {"gfx800", &setGfx800Info},   // gfx800, iceland
-      {"gfx801", &setGfx800Info},   // gfx801, carrizo
-      {"gfx802", &setGfx802Info},   // gfx802, tonga
-      {"gfx803", &setGfx803Info},   // gfx803, fiji, polaris10, polaris11
-      {"gfx804", &setGfx803Info},   // gfx804
-      {"gfx805", &setGfx802Info},   // gfx805, tongapro
-      {"gfx810", &setGfx81Info},    // gfx810, stoney
-      {"gfx900", &setGfx900Info},   // gfx900
-      {"gfx901", &setGfx9Info},     // gfx901
-      {"gfx902", &setGfx900Info},   // gfx902
-      {"gfx903", &setGfx9Info},     // gfx903
-      {"gfx904", &setGfx9Info},     // gfx904, vega12
-      {"gfx906", &setGfx906Info},   // gfx906, vega20
-      {"gfx909", &setGfx9Info},     // gfx909, raven2
-      {"gfx90c", &setGfx9Info},     // gfx90c
-      {"gfx1010", &setGfx1010Info}, // gfx1010
-      {"gfx1011", &setGfx1011Info}, // gfx1011, navi12
-      {"gfx1012", &setGfx1012Info}, // gfx1012, navi14
-      {"gfx1030", &setGfx1030Info}, // gfx1030, navi21
-      {"gfx1031", &setGfx1031Info}, // gfx1031, navi22
-      {"gfx1032", &setGfx1032Info}, // gfx1032, navi23
-      {"gfx1034", &setGfx1034Info}, // gfx1034, navi24
+    {"gfx600", &setGfx600Info},   // gfx600, tahiti
+    {"gfx601", &setGfx601Info},   // gfx601, pitcairn, verde
+    {"gfx602", &setGfx602Info},   // gfx601, oland, hainan
+    {"gfx700", &setGfx700Info},   // gfx700, kaveri
+    {"gfx701", &setGfx701Info},   // gfx701, hawaii
+    {"gfx702", &setGfx7Info},     // gfx702
+    {"gfx703", &setGfx703Info},   // gfx703, kabini, mullins
+    {"gfx704", &setGfx703Info},   // gfx704, bonaire
+    {"gfx705", &setGfx705Info},   // gfx705
+    {"gfx800", &setGfx800Info},   // gfx800, iceland
+    {"gfx801", &setGfx800Info},   // gfx801, carrizo
+    {"gfx802", &setGfx802Info},   // gfx802, tonga
+    {"gfx803", &setGfx803Info},   // gfx803, fiji, polaris10, polaris11
+    {"gfx804", &setGfx803Info},   // gfx804
+    {"gfx805", &setGfx802Info},   // gfx805, tongapro
+    {"gfx810", &setGfx81Info},    // gfx810, stoney
+    {"gfx900", &setGfx900Info},   // gfx900
+    {"gfx901", &setGfx9Info},     // gfx901
+    {"gfx902", &setGfx900Info},   // gfx902
+    {"gfx903", &setGfx9Info},     // gfx903
+    {"gfx904", &setGfx9Info},     // gfx904, vega12
+    {"gfx906", &setGfx906Info},   // gfx906, vega20
+    {"gfx909", &setGfx9Info},     // gfx909, raven2
+    {"gfx90c", &setGfx9Info},     // gfx90c
+    {"gfx1010", &setGfx1010Info}, // gfx1010
+    {"gfx1011", &setGfx1011Info}, // gfx1011, navi12
+    {"gfx1012", &setGfx1012Info}, // gfx1012, navi14
+    {"gfx1030", &setGfx1030Info}, // gfx1030, navi21
+    {"gfx1031", &setGfx1031Info}, // gfx1031, navi22
+    {"gfx1032", &setGfx1032Info}, // gfx1032, navi23
+    {"gfx1034", &setGfx1034Info}, // gfx1034, navi24
+#if LLPC_BUILD_NAVI31
+    {"gfx1100", &setGfx1100Info}, // gfx1100, navi31
+#endif
   };
 
   void (*setTargetInfoFunc)(TargetInfo * targetInfo) = nullptr;
   for (const GpuNameStringMap &mapEntry : ArrayRef<GpuNameStringMap>(GpuNameMap)) {
     if (gpuName == mapEntry.gpuName) {
       setTargetInfoFunc = mapEntry.setTargetInfoFunc;
       break;
     }
   }
   if (!setTargetInfoFunc)
diff --git a/lgc/test/CallLibFromCs-indirect.lgc b/lgc/test/CallLibFromCs-indirect.lgc
index 12d4fb3f8..117e85b38 100644
--- a/lgc/test/CallLibFromCs-indirect.lgc
+++ b/lgc/test/CallLibFromCs-indirect.lgc
@@ -1,16 +1,16 @@
 ; Call an extern compute library function from a compute shader.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 ; CHECK: IR Dump After Patch LLVM for entry-point mutation
-; CHECK: define dllexport amdgpu_cs void @lgc.shader.CS.main(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
-; CHECK: %[[#]] = call amdgpu_gfx i32 %[[#]](i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId)
+; CHECK: define dllexport amdgpu_cs void @lgc.shader.CS.main(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
+; CHECK: call amdgpu_gfx i32 %func_ptr(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId)
 ; CHECK: !7 = !{i32 7}
 
 ; ModuleID = 'lgcPipeline'
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; Function Attrs: nounwind
 define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !7 {
 .entry:
   %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 2, i32 0, i32 2)
diff --git a/lgc/test/CallLibFromCs.lgc b/lgc/test/CallLibFromCs.lgc
index 77427e722..0f3aaa3b4 100644
--- a/lgc/test/CallLibFromCs.lgc
+++ b/lgc/test/CallLibFromCs.lgc
@@ -1,17 +1,17 @@
 ; Call an extern compute library function from a compute shader.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 ; CHECK: IR Dump After Patch LLVM for entry-point mutation
 ; CHECK: declare amdgpu_gfx i32 @compute_library_func() #0
-; CHECK: define dllexport amdgpu_cs void @lgc.shader.CS.main(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #1 !lgc.shaderstage !7 {
-; CHECK: %[[#]] = call amdgpu_gfx i32 bitcast (i32 ()* @compute_library_func to i32 (i32, i32, <3 x i32> addrspace(4)*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, <3 x i32>, i32, <3 x i32>)*)(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId)
+; CHECK: define dllexport amdgpu_cs void @lgc.shader.CS.main(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #1 !lgc.shaderstage !7 {
+; CHECK: call amdgpu_gfx i32 @compute_library_func(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId)
 ; CHECK: !7 = !{i32 7}
 
 ; ModuleID = 'lgcPipeline'
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 declare spir_func i32 @compute_library_func() #0
 
 ; Function Attrs: nounwind
 define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !7 {
diff --git a/lgc/test/ComputeLibraryPushConstantSpill.lgc b/lgc/test/ComputeLibraryPushConstantSpill.lgc
index 1ed714fd1..e2d22ddea 100644
--- a/lgc/test/ComputeLibraryPushConstantSpill.lgc
+++ b/lgc/test/ComputeLibraryPushConstantSpill.lgc
@@ -16,15 +16,15 @@ define spir_func void @func() local_unnamed_addr #0 !lgc.shaderstage !6 {
 
 attributes #0 = { nounwind }
 
 !llpc.compute.mode = !{!0}
 !lgc.options = !{!1}
 !lgc.options.CS = !{!2}
 !lgc.user.data.nodes = !{!3, !4, !5}
 
 !0 = !{i32 64, i32 1, i32 1}
 !1 = !{i32 1864795321, i32 1368232169, i32 -1918754832, i32 -2075327836, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2}
-!2 = !{i32 1108170314, i32 -1466425303, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 64, i32 0, i32 0, i32 3, i32 -859045888, i32 0, i32 0, i32 -858993664, i32 0, i32 846145024, i32 20}
+!2 = !{i32 1108170314, i32 -1466425303, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 64, i32 0, i32 0, i32 3, i32 0, i32 0, i32 0, i32 0, i32 0, i32 846145024, i32 20}
 !3 = !{!"StreamOutTableVaPtr", i32 0, i32 0, i32 1, i32 0, i32 -1, i32 -1}
 !4 = !{!"PushConst", i32 9, i32 1, i32 6, i32 0, i32 -1, i32 0}
 !5 = !{!"DescriptorTableVaPtr", i32 0, i32 8, i32 1, i32 0, i32 1, i32 4}
 !6 = !{i32 7}
diff --git a/lgc/test/CsBuiltInsNext.lgc b/lgc/test/CsBuiltInsNext.lgc
index 568d48432..e4ee684c6 100644
--- a/lgc/test/CsBuiltInsNext.lgc
+++ b/lgc/test/CsBuiltInsNext.lgc
@@ -1,3 +1,170 @@
 ; Test requires at least a RUN line - this one does nothing
 ; RUN: echo "Empty test"
 
+;#if LLPC_BUILD_NAVI31
+; BEGIN_LGC_TEST
+; GFX11 variants - integrate into main body when upstreamed
+; REQUIRES: gfx11
+; ----------------------------------------------------------------------
+; Extract 1: LocalInvocationId test, from three VGPRs (GFX8) or one VGPR (GFX11) set up by hardware
+
+; RUN: lgc -extract=1 -mcpu=gfx1100 %s -o - | FileCheck --check-prefixes=CHECK6_GFX11 %s
+
+; CHECK6_GFX11-LABEL: _amdgpu_cs_main:
+; CHECK6_GFX11-NOT: v0
+; CHECK6_GFX11-DAG: v_and_b32_e32 v[[#REG1:]], 0x3ff, v0
+; CHECK6_GFX11-DAG: v_bfe_u32 v[[#REG1+1]], v0, 10, 10
+; CHECK6_GFX11-DAG: v_lshrrev_b32_e32 v[[#REG1+2]], 20, v0
+; CHECK6_GFX11: buffer_store_b96 v{{\[}}[[#REG1]]:[[#REG1+2]]{{\]}},
+
+define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !0 {
+.entry:
+  %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 0, i32 0, i32 2)
+  %1 = call <3 x i32> (...) @lgc.create.read.builtin.input.v3i32(i32 27, i32 0, i32 undef, i32 undef)
+  %2 = bitcast i8 addrspace(7)* %0 to <3 x i32> addrspace(7)*
+  store <3 x i32> %1, <3 x i32> addrspace(7)* %2, align 4
+  ret void
+}
+
+declare <3 x i32> @lgc.create.read.builtin.input.v3i32(...) local_unnamed_addr #0
+declare i8 addrspace(7)* @lgc.create.load.buffer.desc.p7i8(...) local_unnamed_addr #0
+
+attributes #0 = { nounwind }
+
+!lgc.user.data.nodes = !{!1, !2}
+!llpc.compute.mode = !{!3}
+
+; ShaderStageCompute
+!0 = !{i32 7}
+; type, offset, size, count
+!1 = !{!"DescriptorTableVaPtr", i32 0, i32 2, i32 1, i32 1}
+; type, offset, size, set, binding, stride
+!2 = !{!"DescriptorBuffer", i32 6, i32 0, i32 4, i32 0, i32 0, i32 4}
+; Compute mode, containing workgroup size
+!3 = !{i32 5, i32 6, i32 7}
+
+; ----------------------------------------------------------------------
+; Extract 2: GlobalInvocationId test, from WorkgroupId * WorkgroupSize + LocalInvocationId
+; WorkgroupId is in three SGPRs set by hardware
+; WorkgroupSize is constant from shader mode
+; LocalInvocationId is in three VGPRs (GFX8) or one VGPR (GFX11) set by hardware
+
+; RUN: lgc -extract=2 -mcpu=gfx1100 %s -o - | FileCheck --check-prefixes=CHECK10_GFX11 %s
+
+; CHECK10_GFX11-LABEL: _amdgpu_cs_main:
+; CHECK10_GFX11-DAG: v_and_b32_e32 v[[#REG1:]], 0x3ff, v0
+; CHECK10_GFX11-DAG: v_bfe_u32 v[[#REG2:]], v0, 10, 10
+; CHECK10_GFX11-DAG: v_lshrrev_b32_e32 v[[#REG3:]], 20, v0
+; CHECK10_GFX11-DAG: s_mov_b32 [[INPUT0:s[0-9]+]], s3
+; CHECK10_GFX11-DAG: v_mad_u64_u32 v[[[#REG4:]]:[[#]]], null, [[INPUT0]], 5, v[[[#REG1]]:[[#REG1+1]]]
+; CHECK10_GFX11-DAG: v_mad_u64_u32 v[[[#REG5:]]:[[#]]], null, s4, 6, v[[[#REG2]]:[[#REG2+1]]]
+; CHECK10_GFX11-DAG: v_mad_u64_u32 v[[[#REG6:]]:[[#]]], null, s5, 7, v[[[#REG3]]:[[#REG3+1]]]
+; CHECK10_GFX11: buffer_store_b96 v{{\[}}[[#REG4]]:[[#REG4+2]]{{\]}},
+; rsrc2 bits 7,8,9 need to be set to enable the three WorkgroupId SGPRs
+; CHECK10_GFX11: COMPUTE_PGM_RSRC2): 0x{{[0-9a-f]*[7f][89a-f][0-9a-f]$}}
+
+define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !0 {
+.entry:
+  %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 0, i32 0, i32 2)
+  %1 = call <3 x i32> (...) @lgc.create.read.builtin.input.v3i32(i32 28, i32 0, i32 undef, i32 undef)
+  %2 = bitcast i8 addrspace(7)* %0 to <3 x i32> addrspace(7)*
+  store <3 x i32> %1, <3 x i32> addrspace(7)* %2, align 4
+  ret void
+}
+
+declare <3 x i32> @lgc.create.read.builtin.input.v3i32(...) local_unnamed_addr #0
+declare i8 addrspace(7)* @lgc.create.load.buffer.desc.p7i8(...) local_unnamed_addr #0
+
+attributes #0 = { nounwind }
+
+!lgc.user.data.nodes = !{!1, !2}
+!llpc.compute.mode = !{!3}
+
+; ShaderStageCompute
+!0 = !{i32 7}
+; type, offset, size, count
+!1 = !{!"DescriptorTableVaPtr", i32 0, i32 2, i32 1, i32 1}
+; type, offset, size, set, binding, stride
+!2 = !{!"DescriptorBuffer", i32 6, i32 0, i32 4, i32 0, i32 0, i32 4}
+; Compute mode, containing workgroup size
+!3 = !{i32 5, i32 6, i32 7}
+
+; ----------------------------------------------------------------------
+; Extract 3: LocalInvocationIndex test, linearized from LocalInvocationId and WorkgroupSize
+; LocalInvocationId from three VGPRs (GFX8) or one VGPR (GFX11) set up by hardware
+
+; RUN: lgc -extract=3 -mcpu=gfx1100 %s -o - | FileCheck --check-prefixes=CHECK11_GFX11 %s
+
+; CHECK11_GFX11-LABEL: _amdgpu_cs_main:
+; CHECK11_GFX11-DAG: v_and_b32_e32 v[[#REG1:]], 0x3ff, v0
+; CHECK11_GFX11-DAG: v_bfe_u32 v[[#REG2:]], v0, 10, 10
+; CHECK11_GFX11-DAG: v_lshrrev_b32_e32 v[[#REG3:]], 20, v0
+; CHECK11_GFX11: v_mad_u32_u24 v[[#REG4:]], v[[#REG3]], 6, v[[#REG2]]
+; CHECK11_GFX11: v_mad_u32_u24 v[[#REG5:]], v[[#REG4]], 5, v[[#REG1]]
+; CHECK11_GFX11: buffer_store_b32 v[[#REG5]],
+
+define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !0 {
+.entry:
+  %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 0, i32 0, i32 2)
+  %1 = call i32 (...) @lgc.create.read.builtin.input.i32(i32 29, i32 0, i32 undef, i32 undef)
+  %2 = bitcast i8 addrspace(7)* %0 to i32 addrspace(7)*
+  store i32 %1, i32 addrspace(7)* %2, align 4
+  ret void
+}
+
+declare i32 @lgc.create.read.builtin.input.i32(...) local_unnamed_addr #0
+declare i8 addrspace(7)* @lgc.create.load.buffer.desc.p7i8(...) local_unnamed_addr #0
+
+attributes #0 = { nounwind }
+
+!lgc.user.data.nodes = !{!1, !2}
+!llpc.compute.mode = !{!3}
+
+; ShaderStageCompute
+!0 = !{i32 7}
+; type, offset, size, count
+!1 = !{!"DescriptorTableVaPtr", i32 0, i32 2, i32 1, i32 1}
+; type, offset, size, set, binding, stride
+!2 = !{!"DescriptorBuffer", i32 6, i32 0, i32 4, i32 0, i32 0, i32 4}
+; Compute mode, containing workgroup size
+!3 = !{i32 5, i32 6, i32 7}
+
+; ----------------------------------------------------------------------
+; Extract 4: SubgroupId, calculated as LocalInvocationIndex divided by wave size
+; LocalInvocationIndex linearized from LocalInvocationId and WorkgroupSize
+; LocalInvocationId from three VGPRs (GFX8) or one SGPR (>= GFX10.3) set up by hardware
+
+; RUN: lgc -extract=4 -mcpu=gfx1100 %s -o - | FileCheck --check-prefixes=CHECK12_GFX11 %s
+
+; CHECK12_GFX11-LABEL: _amdgpu_cs_main:
+; CHECK12_GFX11-DAG: s_bfe_u32 s[[#REG:]], s6, 0x50014
+; CHECK12_GFX11-DAG: v_mov_b32_e32 v[[#REG1:]], s[[#REG]]
+; CHECK12_GFX11: buffer_store_b32 v[[#REG1]],
+
+define dllexport spir_func void @lgc.shader.CS.main() local_unnamed_addr #0 !lgc.shaderstage !0 {
+.entry:
+  %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 0, i32 0, i32 2)
+  %1 = call i32 (...) @lgc.create.read.builtin.input.i32(i32 40, i32 0, i32 undef, i32 undef)
+  %2 = bitcast i8 addrspace(7)* %0 to i32 addrspace(7)*
+  store i32 %1, i32 addrspace(7)* %2, align 4
+  ret void
+}
+
+declare i32 @lgc.create.read.builtin.input.i32(...) local_unnamed_addr #0
+declare i8 addrspace(7)* @lgc.create.load.buffer.desc.p7i8(...) local_unnamed_addr #0
+
+attributes #0 = { nounwind }
+
+!lgc.user.data.nodes = !{!1, !2}
+!llpc.compute.mode = !{!3}
+
+; ShaderStageCompute
+!0 = !{i32 7}
+; type, offset, size, count
+!1 = !{!"DescriptorTableVaPtr", i32 0, i32 2, i32 1, i32 1}
+; type, offset, size, set, binding, stride
+!2 = !{!"DescriptorBuffer", i32 6, i32 0, i32 4, i32 0, i32 0, i32 4}
+; Compute mode, containing workgroup size
+!3 = !{i32 5, i32 6, i32 7}
+
+;#endif
diff --git a/lgc/test/CsComputeLibrary.lgc b/lgc/test/CsComputeLibrary.lgc
index 87f3ec45a..086ae503a 100644
--- a/lgc/test/CsComputeLibrary.lgc
+++ b/lgc/test/CsComputeLibrary.lgc
@@ -1,21 +1,21 @@
 ; Define a compute library that can be called from a compute shader.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -print-after=lgc-patch-setup-target-features -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -print-after=lgc-patch-setup-target-features -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 ; CHECK: IR Dump After Patch LLVM for entry-point mutation
-; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
+; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
 ; CHECK: !7 = !{i32 7}
 ; CHECK: IR Dump After Patch LLVM for preparing pipeline ABI
-; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
+; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %descTable2, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !7 {
 
 ; CHECK: IR Dump After Patch LLVM to set up target features
-; CHECK: attributes #0 = { nounwind "amdgpu-flat-work-group-size"="6,6"
+; CHECK: attributes #0 = { nounwind {{.*}}"amdgpu-flat-work-group-size"="6,6"
 
 ; ModuleID = 'lgcPipeline'
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; Function Attrs: nounwind
 define spir_func void @func() local_unnamed_addr #0 !lgc.shaderstage !7 {
 .entry:
   %0 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 2, i32 0, i32 2)
   %1 = call i8 addrspace(7)* (...) @lgc.create.load.buffer.desc.p7i8(i32 0, i32 0, i32 0, i32 2)
diff --git a/lgc/test/FsComputeLibrary.lgc b/lgc/test/FsComputeLibrary.lgc
index 3cf36eaee..3fc97fb6c 100644
--- a/lgc/test/FsComputeLibrary.lgc
+++ b/lgc/test/FsComputeLibrary.lgc
@@ -1,18 +1,18 @@
 ; Define a compute library that can be called from a compute shader.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 ; CHECK: IR Dump After Patch LLVM for entry-point mutation
-; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !5 {
+; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !5 {
 ; CHECK: !5 = !{i32 6}
 ; CHECK: IR Dump After Patch LLVM for preparing pipeline ABI
-; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !5 {
+; CHECK: define amdgpu_gfx void @func(i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %0, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !5 {
 
 ; ModuleID = 'lgcPipeline'
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; Function Attrs: nounwind
 define spir_func void @func() local_unnamed_addr #0 !lgc.shaderstage !5 {
 .entry:
   ret void
 }
diff --git a/lgc/test/InOutPackingNonZeroBase.lgc b/lgc/test/InOutPackingNonZeroBase.lgc
index cdc23f29e..a0af07d37 100644
--- a/lgc/test/InOutPackingNonZeroBase.lgc
+++ b/lgc/test/InOutPackingNonZeroBase.lgc
@@ -58,21 +58,21 @@ define dllexport spir_func void @lgc.shader.VS.main() local_unnamed_addr #0 !spi
   call void (...) @lgc.create.write.generic.output(float %1, i32 7, i32 0, i32 0, i32 0, i32 0, i32 undef)
   call void (...) @lgc.create.write.generic.output(float %2, i32 8, i32 0, i32 0, i32 0, i32 0, i32 undef)
   call void (...) @lgc.create.write.generic.output(float %3, i32 9, i32 0, i32 0, i32 0, i32 0, i32 undef)
 
 ; CHECK: call void @llvm.amdgcn.exp.f32(i32 33, i32 8, float undef, float undef, float undef, float %[[e0]], i1 false, i1 false)
 ; CHECK: call void @llvm.amdgcn.exp.f32(i32 34, i32 3, float %[[e1]], float %[[e2]], float undef, float undef, i1 false, i1 false)
 
   ret void
 }
 
-; Function Attrs: nounwind readonly willreturn
+; Function Attrs: nounwind {{readonly willreturn|willreturn memory\(read\)}}
 declare <3 x float> @lgc.create.read.generic.input.v3f32(...) local_unnamed_addr #1
 
 ; Function Attrs: nounwind
 declare void @lgc.create.write.generic.output(...) local_unnamed_addr #0
 
 ; Function Attrs: nounwind
 define dllexport spir_func void @lgc.shader.FS.main() local_unnamed_addr #0 !spirv.ExecutionModel !11 !lgc.shaderstage !12 {
 .entry:
 ; CHECK:       define dllexport amdgpu_ps void @_amdgpu_ps_main
 ; CHECK-NEXT:  .entry
@@ -94,25 +94,25 @@ define dllexport spir_func void @lgc.shader.FS.main() local_unnamed_addr #0 !spi
   %15 = fadd reassoc nnan nsz arcp contract afn float %14, %3
   %16 = fadd reassoc nnan nsz arcp contract afn float %15, %2
   %17 = fadd reassoc nnan nsz arcp contract afn float %16, %1
   %18 = fadd reassoc nnan nsz arcp contract afn float %17, %0
   %19 = insertelement <4 x float> undef, float %18, i64 0
   %20 = shufflevector <4 x float> %19, <4 x float> poison, <4 x i32> zeroinitializer
   call void (...) @lgc.create.write.generic.output(<4 x float> %20, i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
   ret void
 }
 
-; Function Attrs: nounwind readonly willreturn
+; Function Attrs: nounwind {{readonly willreturn|willreturn memory\(read\)}}
 declare float @lgc.create.read.generic.input.f32(...) local_unnamed_addr #1
 
 attributes #0 = { nounwind }
-attributes #1 = { nounwind readonly willreturn }
+attributes #1 = { nounwind willreturn }
 
 !lgc.client = !{!0}
 !lgc.options = !{!1}
 !lgc.options.VS = !{!2}
 !lgc.options.FS = !{!3}
 !lgc.vertex.inputs = !{!4, !5}
 !lgc.color.export.formats = !{!6}
 !lgc.input.assembly.state = !{!7}
 !amdgpu.pal.metadata.msgpack = !{!8}
 
diff --git a/lgc/test/IntToPtrWithAdd.lgc b/lgc/test/IntToPtrWithAdd.lgc
index 752781849..96434f1b1 100644
--- a/lgc/test/IntToPtrWithAdd.lgc
+++ b/lgc/test/IntToPtrWithAdd.lgc
@@ -1,40 +1,40 @@
 ; Change inttoptr ( add x, const ) -> gep ( inttoptr x, const )
 
-; RUN: lgc -mcpu=gfx900 -print-after=lgc-patch-peephole-opt -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -enable-opaque-pointers=true -mcpu=gfx900 -print-after=lgc-patch-peephole-opt -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; Function Attrs: nounwind
 define dllexport spir_func void @lgc.shader.VS.main(i64 %0, <4 x i32> addrspace(1)* %1) local_unnamed_addr #0 !lgc.shaderstage !10 {
 ; CHECK: IR Dump After Patch LLVM for peephole optimizations
-; CHECK: [[INTTOPTR:%[0-9]+]] = inttoptr i64 %[[#]] to i32 addrspace(1)*
-; CHECK: [[LOAD:%[0-9]+]] = load i32, i32 addrspace(1)* [[INTTOPTR]], align 4
+; CHECK: [[INTTOPTR:%[0-9]+]] = inttoptr i64 %[[#]] to ptr addrspace(1)
+; CHECK: [[LOAD:%[0-9]+]] = load i32, ptr addrspace(1) [[INTTOPTR]], align 4
 ; CHECK: [[INSERTELEMENT:%[0-9]+]] = insertelement <4 x i32> undef, i32 [[LOAD]], i{{32|64}} 0
 
-; CHECK: [[INTTOPTR1:%[0-9]+]] = inttoptr i64 %[[#]] to i32 addrspace(1)*
-; CHECK: [[GEP1:%[0-9]+]] = getelementptr i32, i32 addrspace(1)* [[INTTOPTR1]], i64 1
-; CHECK: [[LOAD1:%[0-9]+]] = load i32, i32 addrspace(1)* [[GEP1]], align 4
+; CHECK: [[INTTOPTR1:%[0-9]+]] = inttoptr i64 %[[#]] to ptr addrspace(1)
+; CHECK: [[GEP1:%[0-9]+]] = getelementptr i32, ptr addrspace(1) [[INTTOPTR1]], i64 1
+; CHECK: [[LOAD1:%[0-9]+]] = load i32, ptr addrspace(1) [[GEP1]], align 4
 ; CHECK: [[INSERTELEMENT1:%[0-9]+]] = insertelement <4 x i32> [[INSERTELEMENT]], i32 [[LOAD1]], i{{32|64}} 1
 
-; CHECK: [[INTTOPTR2:%[0-9]+]] = inttoptr i64 %[[#]] to i32 addrspace(1)*
-; CHECK: [[GEP2:%[0-9]+]] = getelementptr i32, i32 addrspace(1)* [[INTTOPTR2]], i64 2
-; CHECK: [[LOAD2:%[0-9]+]] = load i32, i32 addrspace(1)* [[GEP2]], align 4
+; CHECK: [[INTTOPTR2:%[0-9]+]] = inttoptr i64 %[[#]] to ptr addrspace(1)
+; CHECK: [[GEP2:%[0-9]+]] = getelementptr i32, ptr addrspace(1) [[INTTOPTR2]], i64 2
+; CHECK: [[LOAD2:%[0-9]+]] = load i32, ptr addrspace(1) [[GEP2]], align 4
 ; CHECK: [[INSERTELEMENT2:%[0-9]+]] = insertelement <4 x i32> [[INSERTELEMENT1]], i32 [[LOAD2]], i{{32|64}} 2
 
-; CHECK: [[INTTOPTR3:%[0-9]+]] = inttoptr i64 %[[#]] to i32 addrspace(1)*
-; CHECK: [[GEP3:%[0-9]+]] = getelementptr i32, i32 addrspace(1)* [[INTTOPTR3]], i64 3
-; CHECK: [[LOAD3:%[0-9]+]] = load i32, i32 addrspace(1)* [[GEP3]], align 4
+; CHECK: [[INTTOPTR3:%[0-9]+]] = inttoptr i64 %[[#]] to ptr addrspace(1)
+; CHECK: [[GEP3:%[0-9]+]] = getelementptr i32, ptr addrspace(1) [[INTTOPTR3]], i64 3
+; CHECK: [[LOAD3:%[0-9]+]] = load i32, ptr addrspace(1) [[GEP3]], align 4
 ; CHECK: [[INSERTELEMENT3:%[0-9]+]] = insertelement <4 x i32> [[INSERTELEMENT2]], i32 [[LOAD3]], i{{32|64}} 3
 
-; CHECK: store <4 x i32> [[INSERTELEMENT3]], <4 x i32> addrspace(1)* %[[#]], align 16
+; CHECK: store <4 x i32> [[INSERTELEMENT3]], ptr addrspace(1) %[[#]], align 16
 .entry:
   %2 = inttoptr i64 %0 to i32 addrspace(1)*
   %3 = load i32, i32 addrspace(1)* %2, align 4
   %4 = insertelement <4 x i32> undef, i32 %3, i32 0
   %5 = add i64 %0, 4
   %6 = inttoptr i64 %5 to i32 addrspace(1)*
   %7 = load i32, i32 addrspace(1)* %6, align 4
   %8 = insertelement <4 x i32> %4, i32 %7, i32 1
   %9 = add i64 %0, 8
   %10 = inttoptr i64 %9 to i32 addrspace(1)*
diff --git a/lgc/test/PatchReadLane.lgc b/lgc/test/PatchReadLane.lgc
index 686f88c7b..8a3c529d0 100644
--- a/lgc/test/PatchReadLane.lgc
+++ b/lgc/test/PatchReadLane.lgc
@@ -1,25 +1,25 @@
-; RUN: lgc -mcpu=gfx900 -print-after=lgc-patch-read-first-lane %s -o /dev/null 2>&1 | FileCheck  %s
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-read-first-lane %s -o /dev/null 2>&1 | FileCheck %s
+; RUN: lgc -mcpu=gfx900 -print-after=lgc-patch-read-first-lane -enable-opaque-pointers=true %s -o /dev/null 2>&1 | FileCheck  %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-read-first-lane -enable-opaque-pointers=true %s -o /dev/null 2>&1 | FileCheck %s
 
 ; ModuleID = 'lgcPipeline'
 source_filename = "llpccompute6"
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
 target triple = "amdgcn--amdpal"
 
 @lds = local_unnamed_addr addrspace(3) global i32 undef, align 16
 @lds_float = local_unnamed_addr addrspace(3) global float undef, align 16
 
 ; Test that %LocalInvocationId.i0 gets replaced with %scalar in BB1.
 ; CHECK: @icmp_eq_true
 ; CHECK: %use = add i32 %scalar, 1
-; CHECK: store i32 %use, i32 addrspace(3)* @lds, align 16
+; CHECK: store i32 %use, ptr addrspace(3) @lds, align 16
 
 ; Function Attrs: nounwind
 define dllexport amdgpu_cs void @icmp_eq_true(i32 inreg %0, i32 inreg %1, <3 x i32> inreg %2, i32 inreg %3, <3 x i32> %LocalInvocationId) local_unnamed_addr #0 !lgc.shaderstage !4 {
 .entry:
   %LocalInvocationId.i0 = extractelement <3 x i32> %LocalInvocationId, i32 0
   %scalar = call i32 @llvm.amdgcn.readlane(i32 %LocalInvocationId.i0, i32 0)
   %cmp = icmp eq i32 %LocalInvocationId.i0, %scalar
   br i1 %cmp, label %BB1, label %BB2
 
  BB1:
@@ -30,21 +30,21 @@ define dllexport amdgpu_cs void @icmp_eq_true(i32 inreg %0, i32 inreg %1, <3 x i
  BB2:
   br label %BB3
 
  BB3:
   ret void
 }
 
 ; Test that %LocalInvocationId.i0 gets replaced with %scalar in BB1.
 ; CHECK: @icmp_ne_false
 ; CHECK: %use = add i32 %scalar, 1
-; CHECK: store i32 %use, i32 addrspace(3)* @lds, align 16
+; CHECK: store i32 %use, ptr addrspace(3) @lds, align 16
 
 ; Function Attrs: nounwind
 define dllexport amdgpu_cs void @icmp_ne_false(i32 inreg %0, i32 inreg %1, <3 x i32> inreg %2, i32 inreg %3, <3 x i32> %LocalInvocationId) local_unnamed_addr #0 !lgc.shaderstage !4 {
 .entry:
   %LocalInvocationId.i0 = extractelement <3 x i32> %LocalInvocationId, i32 0
   %scalar = call i32 @llvm.amdgcn.readlane(i32 %LocalInvocationId.i0, i32 0)
   %cmp = icmp ne i32 %LocalInvocationId.i0, %scalar
   br i1 %cmp, label %BB2, label %BB1
 
  BB1:
@@ -55,21 +55,21 @@ define dllexport amdgpu_cs void @icmp_ne_false(i32 inreg %0, i32 inreg %1, <3 x
  BB2:
   br label %BB3
 
  BB3:
   ret void
 }
 
 ; Test that %LocalInvocationId.i0 does not get replaced with %scalar in BB1.
 ; CHECK: @icmp_eq_false
 ; CHECK: %use = add i32 %LocalInvocationId1.i0, 1
-; CHECK: store i32 %use, i32 addrspace(3)* @lds, align 16
+; CHECK: store i32 %use, ptr addrspace(3) @lds, align 16
 
 ; Function Attrs: nounwind
 define dllexport amdgpu_cs void @icmp_eq_false(i32 inreg %0, i32 inreg %1, <3 x i32> inreg %2, i32 inreg %3, <3 x i32> %LocalInvocationId) local_unnamed_addr #0 !lgc.shaderstage !4 {
 .entry:
   %LocalInvocationId.i0 = extractelement <3 x i32> %LocalInvocationId, i32 0
   %scalar = call i32 @llvm.amdgcn.readlane(i32 %LocalInvocationId.i0, i32 0)
   %cmp = icmp eq i32 %LocalInvocationId.i0, %scalar
   br i1 %cmp, label %BB2, label %BB1
 
  BB1:
@@ -80,21 +80,21 @@ define dllexport amdgpu_cs void @icmp_eq_false(i32 inreg %0, i32 inreg %1, <3 x
  BB2:
   br label %BB3
 
  BB3:
   ret void
 }
 
 ; Test that %LocalInvocationId.i0 does not get replaced with %scalar in BB1.
 ; CHECK: @icmp_ne_true
 ; CHECK: %use = add i32 %LocalInvocationId1.i0, 1
-; CHECK: store i32 %use, i32 addrspace(3)* @lds, align 16
+; CHECK: store i32 %use, ptr addrspace(3) @lds, align 16
 
 ; Function Attrs: nounwind
 define dllexport amdgpu_cs void @icmp_ne_true(i32 inreg %0, i32 inreg %1, <3 x i32> inreg %2, i32 inreg %3, <3 x i32> %LocalInvocationId) local_unnamed_addr #0 !lgc.shaderstage !4 {
 .entry:
   %LocalInvocationId.i0 = extractelement <3 x i32> %LocalInvocationId, i32 0
   %scalar = call i32 @llvm.amdgcn.readlane(i32 %LocalInvocationId.i0, i32 0)
   %cmp = icmp ne i32 %LocalInvocationId.i0, %scalar
   br i1 %cmp, label %BB1, label %BB2
 
  BB1:
diff --git a/lgc/test/PeepholeOptPhiWithIdenticalLoad.lgc b/lgc/test/PeepholeOptPhiWithIdenticalLoad.lgc
index 1e34d2ba3..ef427bed3 100644
--- a/lgc/test/PeepholeOptPhiWithIdenticalLoad.lgc
+++ b/lgc/test/PeepholeOptPhiWithIdenticalLoad.lgc
@@ -1,15 +1,15 @@
 ; Test that PHI with incoming value that may read from memory should not be optimized.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-peephole-opt -o - - <%s 2>&1 | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-peephole-opt -enable-opaque-pointers=true -o - - <%s 2>&1 | FileCheck --check-prefixes=CHECK %s
 
-; CHECK: [[LOAD:%[0-9a-z]*]] = load i32, i32 addrspace(3)* @lds, align 16
+; CHECK: [[LOAD:%[0-9a-z]*]] = load i32, ptr addrspace(3) @lds, align 16
 ; CHECK: [[PHI:%[0-9a-z]*]] = phi i32 [ [[LOAD]], %.entry ], [ [[INC:%[0-9a-z]*]], %.block2 ]
 ; CHECK: .block2:
 ; CHECK-NEXT: [[INC]] = add i32 [[PHI]], 1
 
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 @lds = addrspace(3) global i32 undef, align 16
 
 ; Function Attrs: nounwind
diff --git a/lgc/test/TaskShaderOps.lgc b/lgc/test/TaskShaderOps.lgc
index 4888c812f..6c0e3484b 100644
--- a/lgc/test/TaskShaderOps.lgc
+++ b/lgc/test/TaskShaderOps.lgc
@@ -1,13 +1,13 @@
 ; Test that the operations of task shader are handled as expected.
 
-; RUN: lgc -mcpu=gfx1030 --emit-llvm -v -o=- - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1030 --emit-llvm -v -enable-opaque-pointers=true -o=- - <%s | FileCheck --check-prefixes=CHECK %s
 
 ; In this test case, we check if the operations of a task shader is correctly handled. Three operations
 ; are ReadTaskPayload, WriteTaskPayload, EmitMeshTasks.
 ;
 ; CHECK-LABEL: lgc.shader.TASK.main
 ; CHECK: call float @lgc.mesh.task.read.task.payload.f32.i32(i32 %{{[0-9]*}})
 ; CHECK: call void @lgc.mesh.task.write.task.payload.i32.f32(i32 %{{[0-9]*}}, float %{{[0-9]*}})
 ; CHECK: call void @lgc.mesh.task.emit.mesh.tasks(i32 3, i32 1, i32 1)
 ;
 ; CHECK-LABEL: _amdgpu_cs_main
@@ -15,42 +15,39 @@
 ; CHECK-DAG: [[groupIdZ:%[0-9]*]] = extractelement <3 x i32> %WorkgroupId, i64 2
 ; CHECK-DAG: [[dimY:%[0-9]*]] = extractelement <3 x i32> %meshTaskDispatchDims, i64 1
 ; CHECK-NEXT: [[tempResult0:%[0-9]*]] = mul i32 [[groupIdZ]], [[dimY]]
 ; CHECK-NEXT: [[groupIdY:%[0-9]*]] = extractelement <3 x i32> %WorkgroupId, i64 1
 ; CHECK-NEXT: [[tempResult1:%[0-9]*]] = add i32 [[tempResult0]], [[groupIdY]]
 ; CHECK-NEXT: [[dimX:%[0-9]*]] = extractelement <3 x i32> %meshTaskDispatchDims, i64 0
 ; CHECK-NEXT: [[tempResult2:%[0-9]*]] = mul i32 [[tempResult1]], [[dimX]]
 ; CHECK-NEXT: [[groupIdX:%[0-9]*]] = extractelement <3 x i32> %WorkgroupId, i64 0
 ; CHECK-NEXT: [[flattenId:%[0-9]*]] = add i32 [[tempResult2]], [[groupIdX]]
 ; CHECK-NEXT: [[entryIndex:%[0-9]*]] = add i32 [[flattenId]], %meshTaskRingIndex
-; CHECK: [[payloadRingDescPtr:%[0-9]*]] = getelementptr i8, i8 addrspace(4)* %{{[0-9]*}}, i64 208
-; CHECK-NEXT: [[payloadRingDescPtr_cast:%[0-9]*]] = bitcast i8 addrspace(4)* [[payloadRingDescPtr]] to <4 x i32> addrspace(4)*
-; CHECK-NEXT: [[payloadRingDesc:%[0-9]*]] = load <4 x i32>, <4 x i32> addrspace(4)* [[payloadRingDescPtr_cast]], align 16
-; CHECK: [[drawDataRingDescPtr:%[0-9]*]] = getelementptr i8, i8 addrspace(4)* %{{[0-9]*}}, i64 224
-; CHECK-NEXT: [[drawDataRingDescPtr_cast:%[0-9]*]] = bitcast i8 addrspace(4)* [[drawDataRingDescPtr]] to <4 x i32> addrspace(4)*
-; CHECK-NEXT: [[drawDataRingDesc:%[0-9]*]] = load <4 x i32>, <4 x i32> addrspace(4)* [[drawDataRingDescPtr_cast]], align 16
+; CHECK: [[payloadRingDescPtr:%[0-9]*]] = getelementptr <4 x i32>, ptr addrspace(4) %{{[0-9]*}}, i64 13
+; CHECK-NEXT: [[payloadRingDesc:%[0-9]*]] = load <4 x i32>, ptr addrspace(4) [[payloadRingDescPtr]], align 16
+; CHECK: [[drawDataRingDescPtr:%[0-9]*]] = getelementptr <4 x i32>, ptr addrspace(4) %{{[0-9]*}}, i64 14
+; CHECK-NEXT: [[drawDataRingDesc:%[0-9]*]] = load <4 x i32>, ptr addrspace(4) [[drawDataRingDescPtr]], align 16
 ; CHECK: [[meshPipeStatsBufAddr2x32:%[0-9]*]] = insertelement <2 x i32> %{{[0-9]*}}, i32 %meshPipeStatsBuf, i64 0
 ; CHECK-NEXT: [[meshPipeStatsBufAddr64:%[0-9]*]] = bitcast <2 x i32> [[meshPipeStatsBufAddr2x32]] to i64
-; CHECK-NEXT: [[meshPipeStatsBufAddr:%[0-9]*]] = inttoptr i64 [[meshPipeStatsBufAddr64]] to i8 addrspace(1)*
+; CHECK-NEXT: [[meshPipeStatsBufAddr:%[0-9]*]] = inttoptr i64 [[meshPipeStatsBufAddr64]] to ptr addrspace(1)
 ; CHECK: [[ringSize:%[0-9]*]] = extractelement <4 x i32> [[payloadRingDesc]], i64 2
 ; CHECK-NEXT: [[numEntries:%[0-9]*]] = lshr i32 [[ringSize]], 14
 ; CHECK-NEXT: [[wrapMask:%[0-9]*]] = add nuw nsw i32 [[numEntries]], 262143
 ; CHECK-NEXT: [[wrappedEntryIndex:%[0-9]*]] = and i32 [[entryIndex]], [[wrapMask]]
 ; CHECK-NEXT: [[entryOffset:%[0-9]*]] = shl i32 [[wrappedEntryIndex]], 14
 ; CHECK: %{{[0-9]*}} = call float @llvm.amdgcn.raw.buffer.load.f32(<4 x i32> [[payloadRingDesc]], i32 %{{[0-9]*}}, i32 [[entryOffset]], i32 5)
 ; CHECK: call void @llvm.amdgcn.raw.buffer.store.f32(float %{{[0-9]*}}, <4 x i32> [[payloadRingDesc]], i32 %{{[0-9]*}}, i32 [[entryOffset]], i32 1)
 ; CHECK: br i1 %{{[0-9]*}}, label %.emitMeshs, label %.endEmitMeshs
 ;
 ; CHECK: .emitMeshs:
-; CHECK: [[numTaskThreadsPtr8:%[0-9]*]] = getelementptr i8, i8 addrspace(1)* [[meshPipeStatsBufAddr]], i64 16
-; CHECK-NEXT: [[numTaskThreadsPtr:%[0-9]*]] = bitcast i8 addrspace(1)* [[numTaskThreadsPtr8]] to i64 addrspace(1)*
-; CHECK: %{{[0-9]*}} = atomicrmw add i64 addrspace(1)* [[numTaskThreadsPtr]], i64 %{{[0-9]*}} monotonic, align 8
+; CHECK: [[numTaskThreadsPtr8:%[0-9]*]] = getelementptr i8, ptr addrspace(1) [[meshPipeStatsBufAddr]], i64 16
+; CHECK: %{{[0-9]*}} = atomicrmw add ptr addrspace(1) [[numTaskThreadsPtr8]], i64 %{{[0-9]*}} monotonic, align 8
 ; CHECK: [[ringSize:%[0-9]*]] = extractelement <4 x i32> [[drawDataRingDesc]], i64 2
 ; CHECK-NEXT: [[numEntries:%[0-9]*]] = lshr i32 [[ringSize]], 4
 ; CHECK-NEXT: [[wrapMask:%[0-9]*]] = add nuw nsw i32 [[numEntries]], 268435455
 ; CHECK-NEXT: [[wrappedEntryIndex:%[0-9]*]] = and i32 [[entryIndex]], [[wrapMask]]
 ; CHECK-NEXT: [[entryOffset:%[0-9]*]] = shl i32 [[wrappedEntryIndex]], 4
 ; CHECK: [[ringSize:%[0-9]*]] = extractelement <4 x i32> [[drawDataRingDesc]], i64 2
 ; CHECK-NEXT: [[numEntries:%[0-9]*]] = lshr i32 [[ringSize]], 4
 ; CHECK-NEXT: [[checkReadyBit:%[0-9]*]] = and i32 [[entryIndex]], [[numEntries]]
 ; CHECK-NEXT: [[readyBit:%[0-9]*]] = icmp ne i32 [[checkReadyBit]], 0
 ; CHECK-NEXT: [[readyBit32:%[0-9]*]] = zext i1 [[readyBit]] to i32
diff --git a/lgc/test/TextureRange.lgc b/lgc/test/TextureRange.lgc
index 36a20e29a..22311adba 100644
--- a/lgc/test/TextureRange.lgc
+++ b/lgc/test/TextureRange.lgc
@@ -1,24 +1,24 @@
 
-; RUN: lgc %s -print-after=lgc-builder-replayer -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc %s -print-after=lgc-builder-replayer -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 
-; CHECK: [[desc0:%[0-9]+]] = call i8 addrspace(4)* @lgc.descriptor.table.addr(i32 6
-; CHECK-NEXT: %{{.*}} = getelementptr i8, i8 addrspace(4)* [[desc0]], i32 16
+; CHECK: [[desc0:%[0-9]+]] = call ptr addrspace(4) @lgc.descriptor.table.addr(i32 6
+; CHECK-NEXT: %{{.*}} = getelementptr i8, ptr addrspace(4) [[desc0]], i32 16
 ; CHECK: call <2 x i32> @lgc.root.descriptor.v2i32(i32 6)
-; CHECK: call i8 addrspace(7)* @lgc.late.launder.fat.pointer(<4 x i32>
-; CHECK: [[varindex0:%[0-9]+]] = call i8 addrspace(7)* @lgc.late.launder.fat.pointer(<4 x i32>
-; CHECK: [[varindex1:%[0-9]+]] = bitcast i8 addrspace(7)* [[varindex0]] to i32 addrspace(7)*
-; CHECK-NEXT: [[varindex2:%[0-9]+]] = load i32, i32 addrspace(7)* [[varindex1]], align 4
+; CHECK: call ptr addrspace(7) @lgc.late.launder.fat.pointer(<4 x i32>
+; CHECK: [[varindex0:%[0-9]+]] = call ptr addrspace(7) @lgc.late.launder.fat.pointer(<4 x i32>
+; CHECK: [[varindex1:%[0-9]+]] = bitcast ptr addrspace(7) [[varindex0]] to ptr addrspace(7)
+; CHECK-NEXT: [[varindex2:%[0-9]+]] = load i32, ptr addrspace(7) [[varindex1]], align 4
 ; CHECK-NEXT: [[varindex3:%[0-9]+]] = sext i32 [[varindex2]] to i64
-; CHECK-NEXT: getelementptr <{ [4294967295 x float] }>, <{ [4294967295 x float] }> addrspace(7)* %{{.*}}, i64 0, i32 0, i64 [[varindex3]]
-; CHECK: [[desc1:%[0-9]+]] = call i8 addrspace(4)* @lgc.descriptor.table.addr(i32 1
-; CHECK-NEXT: %{{.*}} = getelementptr i8, i8 addrspace(4)* [[desc1]], i32 32
+; CHECK-NEXT: getelementptr <{ [4294967295 x float] }>, ptr addrspace(7) %{{.*}}, i64 0, i32 0, i64 [[varindex3]]
+; CHECK: [[desc1:%[0-9]+]] = call ptr addrspace(4) @lgc.descriptor.table.addr(i32 1
+; CHECK-NEXT: %{{.*}} = getelementptr i8, ptr addrspace(4) [[desc1]], i32 32
 
 ; RUN: lgc -mcpu=gfx1030 -o - - <%s | FileCheck --check-prefixes=SHADER_TEST %s
 ; SHADER_TEST: s_and_b32 s5, s5, 0xffff
 ; SHADER_TEST: s_mov_b32 s7, 0x21014fac
 ; SHADER_TEST: s_mov_b32 s6, -1
 ; SHADER_TEST: s_load_dwordx8 [[desc:.*]], {{.*}}, 0x20
 ; SHADER_TEST: buffer_load_dword {{.*}}, {{.*}}, s[4:7], 0 offen
 ; SHADER_TEST: image_sample {{.*}}, {{.*}}, [[desc]], {{.*}} dmask:0xf
 ; SHADER_TEST: s_load_dwordx4 {{.*}}, {{.*}}, 0x10
 ; SHADER_TEST: .registers:
diff --git a/lgc/test/Transforms/PatchBufferOp/simple.lgc b/lgc/test/Transforms/PatchBufferOp/simple.lgc
new file mode 100644
index 000000000..0bf0cf7f9
--- /dev/null
+++ b/lgc/test/Transforms/PatchBufferOp/simple.lgc
@@ -0,0 +1,17 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc
+; RUN: lgc -o - -passes='require<lgc-pipeline-state>,function(lgc-patch-buffer-op)' -enable-opaque-pointers %s | FileCheck --check-prefixes=CHECK %s
+
+define amdgpu_gfx float @simple(<4 x i32> inreg %desc) !lgc.shaderstage !0 {
+; CHECK-LABEL: @simple(
+; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.raw.buffer.load.i32(<4 x i32> [[DESC:%.*]], i32 0, i32 0, i32 0)
+; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to float
+; CHECK-NEXT:    ret float [[TMP2]]
+;
+  %ptr = call ptr addrspace(7) @lgc.late.launder.fat.pointer(<4 x i32> %desc)
+  %r = load float, ptr addrspace(7) %ptr
+  ret float %r
+}
+
+declare ptr addrspace(7) @lgc.late.launder.fat.pointer(<4 x i32>) nounwind readnone
+
+!0 = !{i32 7}
diff --git a/lgc/test/VsComputeLibrary.lgc b/lgc/test/VsComputeLibrary.lgc
index a1f96d643..611438677 100644
--- a/lgc/test/VsComputeLibrary.lgc
+++ b/lgc/test/VsComputeLibrary.lgc
@@ -1,18 +1,18 @@
 ; Define a compute library that can be called from a vertex shader.
 
-; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
+; RUN: lgc -mcpu=gfx1010 -print-after=lgc-patch-entry-point-mutate -print-after=lgc-patch-prepare-pipeline-abi -enable-opaque-pointers=true -o /dev/null 2>&1 - <%s | FileCheck --check-prefixes=CHECK %s
 ; CHECK: IR Dump After Patch LLVM for entry-point mutation
-; CHECK: define amdgpu_gfx <4 x float> @func(<4 x float> %0, i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #1 !lgc.shaderstage !0 {
+; CHECK: define amdgpu_gfx <4 x float> @func(<4 x float> %0, i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #1 !lgc.shaderstage !0 {
 ; CHECK: !0 = !{i32 1}
 ; CHECK: IR Dump After Patch LLVM for preparing pipeline ABI
-; CHECK: define amdgpu_gfx <4 x float> @func(<4 x float> %0, i32 inreg %globalTable, i32 inreg %perShaderTable, <3 x i32> addrspace(4)* inreg %numWorkgroupsPtr, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !0 {
+; CHECK: define amdgpu_gfx <4 x float> @func(<4 x float> %0, i32 inreg %globalTable, i32 inreg %perShaderTable, ptr addrspace(4) inreg %numWorkgroupsPtr, i32 inreg %1, i32 inreg %2, i32 inreg %3, i32 inreg %4, i32 inreg %5, i32 inreg %6, i32 inreg %7, i32 inreg %8, i32 inreg %9, i32 inreg %10, i32 inreg %11, i32 inreg %spillTable, <3 x i32> inreg %WorkgroupId, i32 inreg %MultiDispatchInfo, <3 x i32> %LocalInvocationId) #0 !lgc.shaderstage !0 {
 
 ; ModuleID = 'lgcPipeline'
 target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
 target triple = "amdgcn--amdpal"
 
 ; Function Attrs: nounwind
 define spir_func <4 x float> @func() local_unnamed_addr #0 !lgc.shaderstage !0 {
 .entry:
   %0 = call <4 x i32> (...) @lgc.create.read.generic.input.v4i32(i32 5, i32 0, i32 0, i32 0, i32 0, i32 undef)
   %bc = bitcast <4 x i32> %0 to <4 x float>
diff --git a/lgc/test/lit.cfg.py b/lgc/test/lit.cfg.py
index b7949419f..35d22c713 100644
--- a/lgc/test/lit.cfg.py
+++ b/lgc/test/lit.cfg.py
@@ -31,11 +31,20 @@ config.excludes = ['Inputs', 'CMakeLists.txt', 'README.txt', 'LICENSE.txt']
 
 # test_source_root: The root path where tests are located.
 config.test_source_root = os.path.dirname(__file__)
 
 # test_exec_root: The root path where tests should be run.
 config.test_exec_root = os.path.join(config.llvm_obj_root, 'test')
 
 # Tweak the PATH to include the tools dir.
 llvm_config.with_environment('PATH', config.llvm_tools_dir, append_path=True)
 
+#if LLPC_BUILD_NAVI31
+# Propagate options for lit feature tests. These can be used in XFAIL, REQUIRES, and UNSUPPORTED
+p = subprocess.Popen([config.llvm_tools_dir + "/lgc", "-mcpu=gfx1100","dummy.lgc"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+out,err = p.communicate()
+check_str = out.decode("utf-8")
+if check_str.find("'gfx1100' not recognized") == -1:
+    config.available_features.add('gfx11')
+#endif
+
 llvm_config.use_default_substitutions()
diff --git a/lgc/tool/lgc/lgc.cpp b/lgc/tool/lgc/lgc.cpp
index ec4a46883..ba052fb3c 100644
--- a/lgc/tool/lgc/lgc.cpp
+++ b/lgc/tool/lgc/lgc.cpp
@@ -34,22 +34,28 @@
 #include "lgc/PassManager.h"
 #include "lgc/Pipeline.h"
 #include "lgc/patch/Patch.h"
 #include "lgc/state/PipelineShaders.h"
 #include "lgc/state/PipelineState.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/AsmParser/Parser.h"
 #include "llvm/BinaryFormat/ELF.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
 #include "llvm/CodeGen/CommandFlags.h"
-#include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/IR/Verifier.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#include "llvm/IR/IRPrintingPasses.h"
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Passes/PassBuilder.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Path.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Target/TargetMachine.h"
 
 using namespace lgc;
 using namespace llvm;
 
 namespace {
@@ -124,30 +130,30 @@ static bool isIsaText(StringRef data) {
 
 // =====================================================================================================================
 // Run the pass pipeline given by the -passes command-line option and output the final IR to outStream.
 //
 // @param pipeline : The LGC pipeline for the module
 // @param module : The module
 // @param outStream : The output stream for the final IR
 static bool runPassPipeline(Pipeline &pipeline, Module &module, raw_pwrite_stream &outStream) {
   // Set up "whole pipeline" passes, where we have a single module representing the whole pipeline.
   LgcContext *lgcContext = pipeline.getLgcContext();
-  std::unique_ptr<lgc::PassManager> passMgr(lgc::PassManager::Create(lgcContext->getTargetMachine()));
+  std::unique_ptr<lgc::PassManager> passMgr(lgc::PassManager::Create(lgcContext));
   passMgr->registerFunctionAnalysis([&] { return lgcContext->getTargetMachine()->getTargetIRAnalysis(); });
   passMgr->registerModuleAnalysis([&] { return PipelineShaders(); });
   passMgr->registerModuleAnalysis([&] { return PipelineStateWrapper(static_cast<PipelineState *>(&pipeline)); });
   Patch::registerPasses(*passMgr);
 
   // Manually add a target-aware TLI pass, so optimizations do not think that we have library functions.
   lgcContext->preparePassManager(*passMgr);
 
-  PassBuilder passBuilder(lgcContext->getTargetMachine(), PipelineTuningOptions(), None,
+  PassBuilder passBuilder(lgcContext->getTargetMachine(), PipelineTuningOptions(), {},
                           &passMgr->getInstrumentationCallbacks());
   Patch::registerPasses(passBuilder);
 
   if (auto err = passBuilder.parsePassPipeline(*passMgr, Passes)) {
     errs() << "Failed to parse -passes: " << toString(std::move(err)) << '\n';
     return false;
   }
 
   // This mode of the tool is only ever used for development and testing, so unconditionally run the verifier on the
   // final output.
diff --git a/lgc/util/GfxRegHandler.cpp b/lgc/util/GfxRegHandler.cpp
index b5c48ecc3..193d38017 100644
--- a/lgc/util/GfxRegHandler.cpp
+++ b/lgc/util/GfxRegHandler.cpp
@@ -111,20 +111,23 @@ static constexpr BitsInfo SqImgSampRegBitsGfx9[static_cast<unsigned>(SqSampRegs:
 SqImgSampRegHandler::SqImgSampRegHandler(IRBuilder<> *builder, Value *reg, GfxIpVersion *gfxIpVersion)
     : GfxRegHandler(builder, reg) {
   m_gfxIpVersion = gfxIpVersion;
 
   switch (gfxIpVersion->major) {
   case 6:
   case 7:
   case 8:
   case 9:
   case 10:
+#if LLPC_BUILD_GFX11
+  case 11:
+#endif
     m_bitsInfo = SqImgSampRegBitsGfx9;
     break;
   default:
     llvm_unreachable("GFX IP is not supported!");
     break;
   }
   setBitsState(m_bitsState);
 }
 
 // =====================================================================================================================
@@ -222,20 +225,44 @@ static constexpr BitsInfo SqImgRsrcRegBitsGfx10[static_cast<unsigned>(SqRsrcRegs
     {},          // Pitch
     {3, 25, 3},  // BcSwizzle
     {3, 12, 4},  // BaseLevel
     {3, 16, 4},  // LastLevel
     {4, 16, 13}, // BaseArray
     {},          // LastArray
     {1, 30, 2},  // WidthLo
     {2, 0, 12},  // WidthHi
 };
 
+#if LLPC_BUILD_GFX11
+// =====================================================================================================================
+// SqImgSampReg Bits information look up table (Gfx11)
+// TODO: update comment when the registers file is available
+static constexpr BitsInfo SqImgRsrcRegBitsGfx11[static_cast<unsigned>(SqRsrcRegs::Count)] = {
+    {0, 0, 32},  // BaseAddress
+    {1, 0, 8},   // BaseAddressHi
+    {1, 20, 8},  // Format
+    {},          // Width
+    {2, 14, 14}, // Height
+    {3, 0, 12},  // DstSelXYZW
+    {3, 20, 5},  // SwizzleMode
+    {4, 0, 13},  // Depth
+    {},          // Pitch
+    {3, 25, 3},  // BcSwizzle
+    {3, 12, 4},  // BaseLevel
+    {3, 16, 4},  // LastLevel
+    {4, 16, 13}, // BaseArray
+    {},          // LastArray
+    {1, 30, 2},  // WidthLo
+    {2, 0, 12},  // WidthHi
+};
+#endif
+
 // =====================================================================================================================
 // Helper class for handling Registers defined in SQ_IMG_RSRC_WORD
 //
 // @param builder : Bound builder context
 // @param reg : Bound register vec <n x i32>
 // @param gfxIpVersion : Current GFX IP version
 SqImgRsrcRegHandler::SqImgRsrcRegHandler(IRBuilder<> *builder, Value *reg, GfxIpVersion *gfxIpVersion)
     : GfxRegHandler(builder, reg) {
   m_gfxIpVersion = gfxIpVersion;
 
@@ -244,20 +271,25 @@ SqImgRsrcRegHandler::SqImgRsrcRegHandler(IRBuilder<> *builder, Value *reg, GfxIp
   case 7:
   case 8:
     m_bitsInfo = SqImgRsrcRegBitsGfx6;
     break;
   case 9:
     m_bitsInfo = SqImgRsrcRegBitsGfx9;
     break;
   case 10:
     m_bitsInfo = SqImgRsrcRegBitsGfx10;
     break;
+#if LLPC_BUILD_GFX11
+  case 11:
+    m_bitsInfo = SqImgRsrcRegBitsGfx11;
+    break;
+#endif
   default:
     llvm_unreachable("GFX IP is not supported!");
     break;
   }
   setBitsState(m_bitsState);
 }
 
 // =====================================================================================================================
 // Get the current value for the hardware register
 //
@@ -278,20 +310,23 @@ Value *SqImgRsrcRegHandler::getReg(SqRsrcRegs regId) {
   case SqRsrcRegs::Pitch:
     return m_builder->CreateAdd(getRegCommon(static_cast<unsigned>(regId)), m_one);
   case SqRsrcRegs::Width:
     switch (m_gfxIpVersion->major) {
     case 6:
     case 7:
     case 8:
     case 9:
       return m_builder->CreateAdd(getRegCommon(static_cast<unsigned>(regId)), m_one);
     case 10:
+#if LLPC_BUILD_GFX11
+    case 11:
+#endif
       return m_builder->CreateAdd(
           getRegCombine(static_cast<unsigned>(SqRsrcRegs::WidthLo), static_cast<unsigned>(SqRsrcRegs::WidthHi)), m_one);
     default:
       llvm_unreachable("GFX IP is not supported!");
       break;
     }
   case SqRsrcRegs::LastArray:
     switch (m_gfxIpVersion->major) {
     case 6:
     case 7:
@@ -330,20 +365,23 @@ void SqImgRsrcRegHandler::setReg(SqRsrcRegs regId, Value *regValue) {
     break;
   case SqRsrcRegs::Width:
     switch (m_gfxIpVersion->major) {
     case 6:
     case 7:
     case 8:
     case 9:
       setRegCommon(static_cast<unsigned>(regId), m_builder->CreateSub(regValue, m_one));
       break;
     case 10:
+#if LLPC_BUILD_GFX11
+    case 11:
+#endif
       setRegCombine(static_cast<unsigned>(SqRsrcRegs::WidthLo), static_cast<unsigned>(SqRsrcRegs::WidthHi),
                     m_builder->CreateSub(regValue, m_one));
       break;
     default:
       llvm_unreachable("GFX IP is not supported!");
       break;
     }
     break;
   default:
     llvm_unreachable("Bad SqImgRsrcRegHandler::SetReg!");
diff --git a/lgc/util/PassManager.cpp b/lgc/util/PassManager.cpp
index 1d7485720..a3b6a9491 100644
--- a/lgc/util/PassManager.cpp
+++ b/lgc/util/PassManager.cpp
@@ -22,25 +22,32 @@
  *  SOFTWARE.
  *
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  PassManager.cpp
  * @brief LLPC source file: contains implementation of class lgc::PassManagerImpl.
  ***********************************************************************************************************************
  */
 #include "lgc/PassManager.h"
+#include "lgc/LgcContext.h"
 #include "lgc/util/Debug.h"
 #include "llvm/Analysis/CFGPrinter.h"
-#include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/IR/PrintPasses.h"
 #include "llvm/IR/Verifier.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#include "llvm/IR/IRPrintingPasses.h"
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Passes/PassBuilder.h"
 #include "llvm/Passes/StandardInstrumentations.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Transforms/Scalar/JumpThreading.h"
 
 namespace llvm {
 namespace cl {
 
 // -verify-ir : verify the IR after each pass
 static cl::opt<bool> VerifyIr("verify-ir", cl::desc("Verify IR after each pass"), cl::init(false));
@@ -90,21 +97,21 @@ private:
   AnalysisID m_printModule = nullptr;   // Pass id of dump pass "Print Module IR"
   AnalysisID m_jumpThreading = nullptr; // Pass id of opt pass "Jump Threading"
   unsigned *m_passIndex = nullptr;      // Pass Index
 };
 
 // =====================================================================================================================
 // LLPC's PassManager override.
 // This is the implementation subclass of the PassManager class declared in PassManager.h
 class PassManagerImpl final : public lgc::PassManager {
 public:
-  PassManagerImpl(TargetMachine *targetMachine);
+  PassManagerImpl(LgcContext *lgcContext);
   void registerPass(StringRef passName, StringRef className) override;
   void run(Module &module) override;
   void setPassIndex(unsigned *passIndex) override { m_passIndex = passIndex; }
   PassInstrumentationCallbacks &getInstrumentationCallbacks() override { return m_instrumentationCallbacks; }
 
 private:
   void registerCallbacks();
   TargetMachine *m_targetMachine;
 
   // -----------------------------------------------------------------------------------------------------------------
@@ -148,38 +155,43 @@ static AnalysisID getPassIdFromName(StringRef passName) {
 // Create a LegacyPassManagerImpl
 lgc::LegacyPassManager *lgc::LegacyPassManager::Create() {
   return new LegacyPassManagerImpl;
 }
 
 // =====================================================================================================================
 // Create a PassManagerImpl
 //
 // @param targetMachine : Optional target machine argument. Must be provided if the AMDLLPC target specific alias
 // analysis pass needs to be registered.
-lgc::PassManager *lgc::PassManager::Create(TargetMachine *targetMachine) {
-  return new PassManagerImpl(targetMachine);
+lgc::PassManager *lgc::PassManager::Create(LgcContext *lgcContext) {
+  return new PassManagerImpl(lgcContext);
 }
 
 // =====================================================================================================================
 LegacyPassManagerImpl::LegacyPassManagerImpl() : LegacyPassManager() {
   if (!cl::DumpCfgAfter.empty())
     m_dumpCfgAfter = getPassIdFromName(cl::DumpCfgAfter);
 
   m_jumpThreading = getPassIdFromName("jump-threading");
   m_printModule = getPassIdFromName("print-module");
 }
 
 // =====================================================================================================================
-PassManagerImpl::PassManagerImpl(TargetMachine *targetMachine)
-    : PassManager(), m_targetMachine(targetMachine),
-      m_instrumentationStandard(cl::DebugPassManager, cl::DebugPassManager || cl::VerifyIr,
-                                /*PrintPassOpts=*/{true, false, true}) {
+PassManagerImpl::PassManagerImpl(LgcContext *lgcContext)
+    : PassManager(), m_targetMachine(lgcContext->getTargetMachine()),
+      m_instrumentationStandard(
+#if !LLVM_MAIN_REVISION || LLVM_MAIN_REVISION >= 442861
+          // New version of the code (also handles unknown version, which we treat as latest)
+          lgcContext->getContext(),
+#endif
+          cl::DebugPassManager, cl::DebugPassManager || cl::VerifyIr,
+          /*PrintPassOpts=*/{true, false, true}) {
   if (!cl::DumpCfgAfter.empty())
     report_fatal_error("The --dump-cfg-after option is not supported with the new pass manager.");
 
   // Setup custom instrumentation callbacks and register LLVM's default module
   // analyses to the analysis manager.
   registerCallbacks();
 
   // Register standard instrumentation callbacks.
   m_instrumentationStandard.registerCallbacks(m_instrumentationCallbacks);
 }
@@ -194,21 +206,21 @@ void PassManagerImpl::registerPass(StringRef passName, StringRef className) {
 }
 
 // =====================================================================================================================
 // Run all the added passes with the pass managers's module analysis manager
 //
 // @param module : Module to run the passes on
 void PassManagerImpl::run(Module &module) {
   // We register LLVM's default analysis sets late to be sure our custom
   // analyses are added beforehand.
   if (!initialized) {
-    PassBuilder passBuilder(m_targetMachine, PipelineTuningOptions(), None, &m_instrumentationCallbacks);
+    PassBuilder passBuilder(m_targetMachine, PipelineTuningOptions(), {}, &m_instrumentationCallbacks);
     passBuilder.registerModuleAnalyses(m_moduleAnalysisManager);
     passBuilder.registerCGSCCAnalyses(m_cgsccAnalysisManager);
     passBuilder.registerFunctionAnalyses(m_functionAnalysisManager);
     passBuilder.registerLoopAnalyses(m_loopAnalysisManager);
     passBuilder.crossRegisterProxies(m_loopAnalysisManager, m_functionAnalysisManager, m_cgsccAnalysisManager,
                                      m_moduleAnalysisManager);
     m_loopAnalysisManager.registerPass([&] { return ModuleAnalysisManagerLoopProxy(m_moduleAnalysisManager); });
     initialized = true;
   }
   ModulePassManager::run(module, m_moduleAnalysisManager);
diff --git a/llpc/CMakeLists.txt b/llpc/CMakeLists.txt
index 089f334ef..489a91ae3 100644
--- a/llpc/CMakeLists.txt
+++ b/llpc/CMakeLists.txt
@@ -42,21 +42,20 @@ if(ICD_BUILD_LLPC)
 endif()
 
 ### Set Options and build LLVM #########################################################################################
 if(ICD_BUILD_LLPC)
     # Set LLVM options and build LLVM
     # Add LGC as an LLVM external project, but only if its CMakeLists.txt exists.
     set(LLVM_EXTERNAL_PROJECTS lgc)
     set(LLVM_EXTERNAL_LGC_SOURCE_DIR ${PROJECT_SOURCE_DIR}/../lgc)
 
     # Set other LLVM settings.
-    set(LLVM_ENABLE_ASSERTIONS ${CMAKE_BUILD_TYPE_DEBUG} CACHE BOOL Force)
     set(LLVM_TARGETS_TO_BUILD AMDGPU CACHE STRING Force)
     set(LLVM_BUILD_TESTS OFF CACHE BOOL Force)
     set(LLVM_BUILD_TOOLS ${LLPC_BUILD_LLVM_TOOLS} CACHE BOOL Force)
     set(LLVM_BUILD_UTILS OFF CACHE BOOL Force)
     set(LLVM_INCLUDE_DOCS OFF CACHE BOOL Force)
     set(LLVM_INCLUDE_EXAMPLES OFF CACHE BOOL Force)
     set(LLVM_INCLUDE_GO_TESTS OFF CACHE BOOL Force)
     if(LLPC_BUILD_TESTS)
         set(LLVM_INCLUDE_TESTS ON CACHE BOOL Force)
     else()
@@ -217,20 +216,21 @@ if(VKI_RAY_TRACING)
     target_sources(llpc PRIVATE
          context/llpcRayTracingContext.cpp
          )
 endif()
 #endif
 
 # llpc/lower
     target_sources(llpc PRIVATE
         lower/llpcSpirvLower.cpp
         lower/llpcSpirvLowerAccessChain.cpp
+        lower/llpcSpirvLowerCfgMerges.cpp
         lower/llpcSpirvLowerConstImmediateStore.cpp
         lower/llpcSpirvLowerGlobal.cpp
         lower/llpcSpirvLowerInstMetaRemove.cpp
         lower/llpcSpirvLowerMath.cpp
         lower/llpcSpirvLowerMemoryOp.cpp
         lower/llpcSpirvLowerTerminator.cpp
         lower/llpcSpirvLowerTranslator.cpp
         lower/llpcSpirvLowerUtil.cpp
     )
 
@@ -375,24 +375,22 @@ target_include_directories(llpc_standalone_compiler PUBLIC
     ${LLVM_INCLUDE_DIRS}
 )
 
 target_link_libraries(llpc_standalone_compiler PUBLIC
     cwpack
     llpc
     metrohash
     spvgen_static
     vfx
     vkgc_headers
+    ${CMAKE_DL_LIBS}
 )
-if(UNIX)
-    target_link_libraries(llpc_standalone_compiler PUBLIC dl)
-endif()
 
 if (NOT LLVM_LINK_LLVM_DYLIB)
     llvm_map_components_to_libnames(llvm_libs
         AsmParser
     )
     target_link_libraries(llpc_standalone_compiler PUBLIC ${llvm_libs})
 endif()
 
 set_compiler_options(llpc_standalone_compiler ${LLPC_ENABLE_WERROR})
 
diff --git a/llpc/context/llpcCompiler.cpp b/llpc/context/llpcCompiler.cpp
index cb012767f..1c2863f9f 100644
--- a/llpc/context/llpcCompiler.cpp
+++ b/llpc/context/llpcCompiler.cpp
@@ -37,20 +37,21 @@
 #include "llpcDebug.h"
 #include "llpcElfWriter.h"
 #include "llpcError.h"
 #include "llpcFile.h"
 #include "llpcGraphicsContext.h"
 #if VKI_RAY_TRACING
 #include "llpcRayTracingContext.h"
 #endif
 #include "llpcShaderModuleHelper.h"
 #include "llpcSpirvLower.h"
+#include "llpcSpirvLowerCfgMerges.h"
 #if VKI_RAY_TRACING
 #include "llpcSpirvLowerRayTracing.h"
 #endif
 #include "llpcSpirvLowerTranslator.h"
 #include "llpcSpirvLowerUtil.h"
 #include "llpcTimerProfiler.h"
 #include "llpcUtil.h"
 #include "spirvExt.h"
 #include "vkgcDefs.h"
 #include "vkgcElfReader.h"
@@ -61,20 +62,26 @@
 #include "lgc/PassManager.h"
 #include "llvm/ADT/ScopeExit.h"
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/BinaryFormat/MsgPackDocument.h"
 #include "llvm/Bitcode/BitcodeReader.h"
 #include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
 #include "llvm/IR/DiagnosticInfo.h"
 #include "llvm/IR/DiagnosticPrinter.h"
 #include "llvm/IR/IRPrintingPasses.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Linker/Linker.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Format.h"
 #include "llvm/Support/ManagedStatic.h"
 #include "llvm/Support/Mutex.h"
 #include "llvm/Support/SmallVectorMemoryBuffer.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #if VKI_RAY_TRACING
@@ -169,26 +176,20 @@ static opt<std::string> ExecutableName("executable-name", desc("Executable file
 // -enable-per-stage-cache: Enable shader cache per shader stage
 opt<bool> EnablePerStageCache("enable-per-stage-cache", cl::desc("Enable shader cache per shader stage"), init(true));
 
 // -context-reuse-limit: The maximum number of times a compiler context can be reused.
 opt<int> ContextReuseLimit("context-reuse-limit",
                            cl::desc("The maximum number of times a compiler context can be reused"), init(100));
 
 // -fatal-llvm-errors: Make all LLVM errors fatal
 opt<bool> FatalLlvmErrors("fatal-llvm-errors", cl::desc("Make all LLVM errors fatal"), init(false));
 
-// -new-pass-manager: Use LLVM's new pass manager (experimental)
-opt<unsigned> NewPassManager("new-pass-manager",
-                             cl::desc("0 - Legacy pass manager, 1 - New pass manager front-end, 2 - New pass manager "
-                                      "front-end and middle-end"),
-                             init(2));
-
 // -enable-part-pipeline: Use part pipeline compilation scheme (experimental)
 opt<bool> EnablePartPipeline("enable-part-pipeline", cl::desc("Enable part pipeline compilation scheme"), init(false));
 
 extern opt<bool> EnableOuts;
 
 extern opt<bool> EnableErrs;
 
 extern opt<std::string> LogFileDbgs;
 
 extern opt<std::string> LogFileOuts;
@@ -233,27 +234,21 @@ struct HelperThreadBuildRayTracingPipelineElfPayload {
 sys::Mutex Compiler::m_helperThreadMutex;
 std::condition_variable_any Compiler::m_helperThreadConditionVariable;
 #endif
 
 // =====================================================================================================================
 // Handler for LLVM fatal error.
 //
 // @param userData : An argument which will be passed to the installed error handler
 // @param reason : Error reason
 // @param genCrashDiag : Whether diagnostic should be generated
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 400826
-// Old version of the code
-static void fatalErrorHandler(void *userData, const std::string &reason, bool genCrashDiag) {
-#else
-// New version of the code (also handles unknown version, which we treat as latest)
 static void fatalErrorHandler(void *userData, const char *reason, bool genCrashDiag) {
-#endif
   LLPC_ERRS("LLVM FATAL ERROR: " << reason << "\n");
 #if LLPC_ENABLE_EXCEPTION
   throw("LLVM fatal error");
 #endif
 }
 
 // =====================================================================================================================
 // Returns the cache accessor object resulting from checking the caches for the glue shader for the given identifier.
 //
 // @param glueShaderIdentifier : The linker object for which the glue shaders are needed.
@@ -591,21 +586,21 @@ Result Compiler::BuildShaderModule(const ShaderModuleBuildInfo *shaderInfo, Shad
 }
 
 // =====================================================================================================================
 // Helper function for formatting raw data into a space-separated string of lowercase hex bytes.
 // This assumes Little Endian byte order, e.g., {45u} --> `2d 00 00 00`.
 //
 // @param data : Raw data to be formatted.
 // @returns : Formatted bytes, e.g., `ab c4 ef 00`.
 template <typename T> static FormattedBytes formatBytesLittleEndian(ArrayRef<T> data) {
   ArrayRef<uint8_t> bytes(reinterpret_cast<const uint8_t *>(data.data()), data.size() * sizeof(T));
-  return format_bytes(bytes, /* FirstByteOffset = */ None, /* NumPerLine = */ 16, /* ByteGroupSize = */ 1);
+  return format_bytes(bytes, /* FirstByteOffset = */ {}, /* NumPerLine = */ 16, /* ByteGroupSize = */ 1);
 }
 
 // =====================================================================================================================
 // Helper function for dumping compiler options
 //
 // @param pipelineDumpFile : Handle of pipeline dump file
 void Compiler::dumpCompilerOptions(void *pipelineDumpFile) {
   if (!pipelineDumpFile)
     return;
   std::string extraInfo;
@@ -1089,21 +1084,21 @@ Result Compiler::buildPipelineInternal(Context *context, ArrayRef<const Pipeline
       const PipelineShaderInfo *shaderInfoEntry = shaderInfo[shaderIndex];
       if (!shaderInfoEntry || !shaderInfoEntry->pModuleData)
         continue;
 
       const ShaderModuleData *moduleDataEx = reinterpret_cast<const ShaderModuleData *>(shaderInfoEntry->pModuleData);
 
       Module *module = nullptr;
       if (moduleDataEx->binType == BinaryType::MultiLlvmBc) {
         result = Result::ErrorInvalidShader;
       } else {
-        module = new Module((Twine("llpc") + getShaderStageName(shaderInfoEntry->entryStage)).str() +
+        module = new Module((Twine("llpc") + "_" + getShaderStageName(shaderInfoEntry->entryStage)).str() + "_" +
                                 std::to_string(getModuleIdByIndex(shaderIndex)),
                             *context);
       }
 
       modules[shaderIndex] = module;
       context->setModuleTargetMachine(module);
     }
 
 #if VKI_RAY_TRACING
     unsigned rayQueryLibraryIndex = InvalidValue;
@@ -1114,94 +1109,56 @@ Result Compiler::buildPipelineInternal(Context *context, ArrayRef<const Pipeline
       ShaderStage entryStage = shaderInfoEntry ? shaderInfoEntry->entryStage : ShaderStageInvalid;
 
       if (entryStage == ShaderStageFragment)
         fragmentShaderInfo = shaderInfoEntry;
       if (!shaderInfoEntry || !shaderInfoEntry->pModuleData || (stageSkipMask & shaderStageToMask(entryStage)))
         continue;
 
       // Set the shader stage in the Builder.
       context->getBuilder()->setShaderStage(getLgcShaderStage(entryStage));
 
-      if (cl::NewPassManager) {
-        std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create());
-        lowerPassMgr->setPassIndex(&passIndex);
-        SpirvLower::registerPasses(*lowerPassMgr);
-
-        // Start timer for translate.
-        timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, true);
-
-        // SPIR-V translation, then dump the result.
-        lowerPassMgr->addPass(SpirvLowerTranslator(entryStage, shaderInfoEntry));
-        if (EnableOuts()) {
-          lowerPassMgr->addPass(PrintModulePass(
-              outs(), "\n"
-                      "===============================================================================\n"
-                      "// LLPC SPIRV-to-LLVM translation results\n"));
-        }
-
-#if VKI_RAY_TRACING
-        const ShaderModuleData *moduleData = reinterpret_cast<const ShaderModuleData *>(shaderInfoEntry->pModuleData);
-        if (moduleData->usage.enableRayQuery) {
-          lowerPassMgr->addPass(SpirvLowerRayQuery(moduleData->usage.rayQueryLibrary));
-          rayQueryLibraryIndex = shaderIndex;
-        }
-
-        isInternalRtShader = moduleData->usage.isInternalRtShader;
+      std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create(context->getLgcContext()));
+      lowerPassMgr->setPassIndex(&passIndex);
+      SpirvLower::registerPasses(*lowerPassMgr);
 
-        if (isInternalRtShader)
-          assert(entryStage == ShaderStageCompute);
-#endif
+      // Start timer for translate.
+      timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, true);
 
-        // Stop timer for translate.
-        timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, false);
+      // SPIR-V translation, then dump the result.
+      lowerPassMgr->addPass(SpirvLowerTranslator(entryStage, shaderInfoEntry));
+      if (EnableOuts()) {
+        lowerPassMgr->addPass(
+            PrintModulePass(outs(), "\n"
+                                    "===============================================================================\n"
+                                    "// LLPC SPIRV-to-LLVM translation results\n"));
+      }
 
-        bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-        if (!success) {
-          LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
-          result = Result::ErrorInvalidShader;
-        }
-      } else {
-        std::unique_ptr<lgc::LegacyPassManager> lowerPassMgr(lgc::LegacyPassManager::Create());
-        lowerPassMgr->setPassIndex(&passIndex);
-
-        // Start timer for translate.
-        timerProfiler.addTimerStartStopPass(&*lowerPassMgr, TimerTranslate, true);
-
-        // SPIR-V translation, then dump the result.
-        lowerPassMgr->add(createSpirvLowerTranslator(entryStage, shaderInfoEntry));
-        if (EnableOuts()) {
-          lowerPassMgr->add(createPrintModulePass(
-              outs(), "\n"
-                      "===============================================================================\n"
-                      "// LLPC SPIRV-to-LLVM translation results\n"));
-        }
 #if VKI_RAY_TRACING
-        const ShaderModuleData *moduleData = reinterpret_cast<const ShaderModuleData *>(shaderInfoEntry->pModuleData);
-        if (moduleData->usage.enableRayQuery) {
-          lowerPassMgr->add(createLegacySpirvLowerRayQuery(moduleData->usage.rayQueryLibrary));
-          rayQueryLibraryIndex = shaderIndex;
-        }
+      const ShaderModuleData *moduleData = reinterpret_cast<const ShaderModuleData *>(shaderInfoEntry->pModuleData);
+      if (moduleData->usage.enableRayQuery) {
+        lowerPassMgr->addPass(SpirvLowerRayQuery(moduleData->usage.rayQueryLibrary));
+        rayQueryLibraryIndex = shaderIndex;
+      }
 
-        isInternalRtShader = moduleData->usage.isInternalRtShader;
+      isInternalRtShader = moduleData->usage.isInternalRtShader;
 
-        if (isInternalRtShader)
-          assert(entryStage == ShaderStageCompute);
+      if (isInternalRtShader)
+        assert(entryStage == ShaderStageCompute);
 #endif
-        // Stop timer for translate.
-        timerProfiler.addTimerStartStopPass(&*lowerPassMgr, TimerTranslate, false);
 
-        // Run the passes.
-        bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-        if (!success) {
-          LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
-          result = Result::ErrorInvalidShader;
-        }
+      // Stop timer for translate.
+      timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, false);
+
+      bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
+      if (!success) {
+        LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
+        result = Result::ErrorInvalidShader;
       }
     }
 #if VKI_RAY_TRACING
     std::vector<const PipelineShaderInfo *> newShaderInfos;
     bool rayQuery = (rayQueryLibraryIndex != InvalidValue);
     if (rayQuery) {
       LLPC_OUTS("// LLPC link ray query modules");
       assert(rayQueryLibraryIndex != InvalidValue);
       newShaderInfos.clear();
       auto shaderLibraryModule = modules[rayQueryLibraryIndex];
@@ -1232,47 +1189,32 @@ Result Compiler::buildPipelineInternal(Context *context, ArrayRef<const Pipeline
       if (!shaderInfoEntry || !shaderInfoEntry->pModuleData)
         continue;
       if (stageSkipMask & shaderStageToMask(entryStage)) {
         // Do not run SPIR-V translator and lowering passes on this shader; we were given it as IR ready
         // to link into pipeline module.
         modulesToLink.push_back(modules[shaderIndex]);
         continue;
       }
 
       context->getBuilder()->setShaderStage(getLgcShaderStage(entryStage));
-      bool success;
-      if (cl::NewPassManager) {
-        std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create());
-        lowerPassMgr->setPassIndex(&passIndex);
-        SpirvLower::registerPasses(*lowerPassMgr);
-
-        SpirvLower::addPasses(context, entryStage, *lowerPassMgr, timerProfiler.getTimer(TimerLower)
-#if VKI_RAY_TRACING
-                                                                      ,
-                              false, rayQuery, isInternalRtShader
-#endif
-        );
-        // Run the passes.
-        success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-      } else {
-        std::unique_ptr<lgc::LegacyPassManager> lowerPassMgr(lgc::LegacyPassManager::Create());
-        lowerPassMgr->setPassIndex(&passIndex);
+      std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create(context->getLgcContext()));
+      lowerPassMgr->setPassIndex(&passIndex);
+      SpirvLower::registerPasses(*lowerPassMgr);
 
-        LegacySpirvLower::addPasses(context, entryStage, *lowerPassMgr, timerProfiler.getTimer(TimerLower)
+      SpirvLower::addPasses(context, entryStage, *lowerPassMgr, timerProfiler.getTimer(TimerLower)
 #if VKI_RAY_TRACING
-                                                                            ,
-                                    false, rayQuery, isInternalRtShader
+                                                                    ,
+                            false, rayQuery, isInternalRtShader
 #endif
-        );
-        // Run the passes.
-        success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-      }
+      );
+      // Run the passes.
+      bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
       if (!success) {
         LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
         result = Result::ErrorInvalidShader;
       }
 
       // Add the shader module to the list for the pipeline.
       modulesToLink.push_back(modules[shaderIndex]);
     }
 
     // If this is a part-pipeline compile of the pre-rasterization stages, give the "other" pipeline object
@@ -1318,21 +1260,21 @@ Result Compiler::buildPipelineInternal(Context *context, ArrayRef<const Pipeline
     result = Result::ErrorInvalidShader;
     try
 #endif
     {
       Timer *timers[] = {
           timerProfiler.getTimer(TimerPatch),
           timerProfiler.getTimer(TimerOpt),
           timerProfiler.getTimer(TimerCodeGen),
       };
 
-      pipeline->generate(std::move(pipelineModule), elfStream, checkShaderCacheFunc, timers, cl::NewPassManager == 2);
+      pipeline->generate(std::move(pipelineModule), elfStream, checkShaderCacheFunc, timers, true);
 #if LLPC_ENABLE_EXCEPTION
       result = Result::Success;
 #endif
     }
 #if LLPC_ENABLE_EXCEPTION
     catch (const char *) {
     }
 #endif
   }
   if (checkPerStageCache) {
@@ -2176,40 +2118,29 @@ Result Compiler::BuildRayTracingPipeline(const RayTracingPipelineBuildInfo *pipe
 // @param moduleIndex : Current processing module index
 // @param pipeline : The pipeline object
 // @param timerProfiler : Timer profiler
 Result Compiler::buildRayTracingPipelineElf(Context *context, Module *module, ElfPackage &pipelineElf,
                                             std::vector<RayTracingShaderProperty> &shaderProps,
                                             std::vector<bool> &moduleCallsTraceRay, unsigned moduleIndex,
                                             std::unique_ptr<Pipeline> &pipeline, TimerProfiler &timerProfiler) {
   // Per-shader SPIR-V lowering passes.
   context->getBuilder()->setShaderStage(getLgcShaderStage(ShaderStageCompute));
 
-  bool success;
   unsigned passIndex = 0;
-  if (cl::NewPassManager) {
-    std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create());
-    lowerPassMgr->setPassIndex(&passIndex);
-    SpirvLower::registerPasses(*lowerPassMgr);
-
-    SpirvLower::addPasses(context, ShaderStageCompute, *lowerPassMgr, timerProfiler.getTimer(TimerLower), true, false,
-                          false);
-    // Run the passes.
-    success = runPasses(&*lowerPassMgr, module);
-  } else {
-    std::unique_ptr<lgc::LegacyPassManager> lowerPassMgr(lgc::LegacyPassManager::Create());
-    lowerPassMgr->setPassIndex(&passIndex);
-
-    LegacySpirvLower::addPasses(context, ShaderStageCompute, *lowerPassMgr, timerProfiler.getTimer(TimerLower), true,
-                                false, false);
-    // Run the passes.
-    success = runPasses(&*lowerPassMgr, module);
-  }
+  std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create(context->getLgcContext()));
+  lowerPassMgr->setPassIndex(&passIndex);
+  SpirvLower::registerPasses(*lowerPassMgr);
+
+  SpirvLower::addPasses(context, ShaderStageCompute, *lowerPassMgr, timerProfiler.getTimer(TimerLower), true, false,
+                        false);
+  // Run the passes.
+  bool success = runPasses(&*lowerPassMgr, module);
   if (!success) {
     LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
     return Result::ErrorInvalidShader;
   }
 
   if (moduleIndex > 0) {
     const StringRef &funcName = module->getName();
     assert(funcName.size() <= RayTracingMaxShaderNameLength);
     auto pos = funcName.rfind('_');
     int index = 0;
@@ -2251,21 +2182,21 @@ Result Compiler::buildRayTracingPipelineElf(Context *context, Module *module, El
 #if LLPC_ENABLE_EXCEPTION
   try
 #endif
   {
     Timer *timers[] = {
         timerProfiler.getTimer(TimerPatch),
         timerProfiler.getTimer(TimerOpt),
         timerProfiler.getTimer(TimerCodeGen),
     };
 
-    pipeline->generate(std::move(pipelineModule), elfStream, nullptr, timers, cl::NewPassManager == 2);
+    pipeline->generate(std::move(pipelineModule), elfStream, nullptr, timers, true);
   }
 #if LLPC_ENABLE_EXCEPTION
   catch (const char *) {
     return Result::ErrorInvalidShader;
   }
 #endif
 
   if (moduleIndex > 0)
     addRayTracingIndirectPipelineMetadata(elfPackage);
 
@@ -2376,125 +2307,85 @@ Result Compiler::buildRayTracingPipelineInternal(Context *context, ArrayRef<cons
   Result result = Result::Success;
   unsigned passIndex = 0;
   TimerProfiler timerProfiler(context->getPipelineHashCode(), "LLPC", TimerProfiler::PipelineTimerEnableMask);
   RayTracingContext *rayTracingContext = static_cast<RayTracingContext *>(context->getPipelineContext());
   auto pipelineInfo = reinterpret_cast<const RayTracingPipelineBuildInfo *>(context->getPipelineBuildInfo());
   auto inputShaderCount = pipelineInfo->shaderCount;
   bool hasTraceRayModule = (shaderInfo.size() - inputShaderCount) > 1;
 
   bool hasError = false;
   context->setDiagnosticHandler(std::make_unique<LlpcDiagnosticHandler>(&hasError));
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 381316
-  // Old version of the code
-  context->setInlineAsmDiagnosticHandler(InlineAsmDiagHandler, &hasError);
-#endif
 
   // Set up middle-end objects.
   LgcContext *builderContext = context->getLgcContext();
   std::unique_ptr<Pipeline> pipeline(builderContext->createPipeline());
   rayTracingContext->setPipelineState(&*pipeline, /*hasher=*/nullptr, unlinked);
   context->setBuilder(builderContext->createBuilder(&*pipeline));
 
   // Create empty modules and set target machine in each.
   std::vector<Module *> modules(shaderInfo.size());
   for (unsigned shaderIndex = 0; shaderIndex < shaderInfo.size() && result == Result::Success; ++shaderIndex) {
     const PipelineShaderInfo *shaderInfoEntry = shaderInfo[shaderIndex];
     auto moduleName = std::string("_") + getShaderStageAbbreviation(shaderInfoEntry->entryStage) + "_" +
                       std::to_string(getModuleIdByIndex(shaderIndex));
     moduleName[1] = std::tolower(moduleName[1]);
     modules[shaderIndex] = new Module(moduleName, *context);
     context->setModuleTargetMachine(modules[shaderIndex]);
 
     if (!shaderInfoEntry->pModuleData)
       continue;
 
-    bool success;
-    if (cl::NewPassManager) {
-      std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create());
-      lowerPassMgr->setPassIndex(&passIndex);
-      SpirvLower::registerPasses(*lowerPassMgr);
-
-      // Set the shader stage in the Builder.
-      context->getBuilder()->setShaderStage(getLgcShaderStage(shaderInfoEntry->entryStage));
-
-      // SPIR-V translation, then dump the result.
-      lowerPassMgr->addPass(SpirvLowerTranslator(shaderInfoEntry->entryStage, shaderInfoEntry));
-
-      // Run the passes.
-      success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-    } else {
-      std::unique_ptr<lgc::LegacyPassManager> lowerPassMgr(lgc::LegacyPassManager::Create());
-      lowerPassMgr->setPassIndex(&passIndex);
+    std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create(context->getLgcContext()));
+    lowerPassMgr->setPassIndex(&passIndex);
+    SpirvLower::registerPasses(*lowerPassMgr);
 
-      // Set the shader stage in the Builder.
-      context->getBuilder()->setShaderStage(getLgcShaderStage(shaderInfoEntry->entryStage));
+    // Set the shader stage in the Builder.
+    context->getBuilder()->setShaderStage(getLgcShaderStage(shaderInfoEntry->entryStage));
 
-      // SPIR-V translation, then dump the result.
-      lowerPassMgr->add(createSpirvLowerTranslator(shaderInfoEntry->entryStage, shaderInfoEntry));
+    // SPIR-V translation, then dump the result.
+    lowerPassMgr->addPass(SpirvLowerTranslator(shaderInfoEntry->entryStage, shaderInfoEntry));
 
-      // Run the passes.
-      success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-    }
+    // Run the passes.
+    bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
     if (!success) {
       LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
       result = Result::ErrorInvalidShader;
     }
   }
 
   for (unsigned shaderIndex = 0; shaderIndex < shaderInfo.size() && result == Result::Success; ++shaderIndex) {
     ShaderStage entryStage = shaderInfo[shaderIndex]->entryStage;
 
-    bool success;
-    if (cl::NewPassManager) {
-      std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create());
-      lowerPassMgr->setPassIndex(&passIndex);
-      SpirvLower::registerPasses(*lowerPassMgr);
-
-      // Set the shader stage in the Builder.
-      context->getBuilder()->setShaderStage(getLgcShaderStage(entryStage));
-
-      // Start timer for translate.
-      timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, true);
-
-      // OpTerminateRay/OpIgnoreIntersection of anyhit shader and OpReportIntersection of intersection shader could
-      // terminate ray during inbetween of shader execution. So functions in these shaders need to be inlined.
-      if (entryStage == ShaderStageRayTracingAnyHit || entryStage == ShaderStageRayTracingIntersect)
-        lowerPassMgr->addPass(AlwaysInlinerPass());
-      lowerPassMgr->addPass(SpirvLowerRayTracing(false));
-
-      // Stop timer for translate.
-      timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, false);
-
-      // Run the passes.
-      success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-    } else {
-      std::unique_ptr<lgc::LegacyPassManager> lowerPassMgr(lgc::LegacyPassManager::Create());
-      lowerPassMgr->setPassIndex(&passIndex);
+    std::unique_ptr<lgc::PassManager> lowerPassMgr(lgc::PassManager::Create(context->getLgcContext()));
+    lowerPassMgr->setPassIndex(&passIndex);
+    SpirvLower::registerPasses(*lowerPassMgr);
 
-      // Set the shader stage in the Builder.
-      context->getBuilder()->setShaderStage(getLgcShaderStage(entryStage));
+    // Set the shader stage in the Builder.
+    context->getBuilder()->setShaderStage(getLgcShaderStage(entryStage));
 
-      // Start timer for translate.
-      timerProfiler.addTimerStartStopPass(&*lowerPassMgr, TimerTranslate, true);
+    // Start timer for translate.
+    timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, true);
 
-      // OpTerminateRay/OpIgnoreIntersection of anyhit shader and OpReportIntersection of intersection shader could
-      // terminate ray during inbetween of shader execution. So functions in these shaders need to be inlined.
-      if (entryStage == ShaderStageRayTracingAnyHit || entryStage == ShaderStageRayTracingIntersect)
-        lowerPassMgr->add(createAlwaysInlinerLegacyPass());
-      lowerPassMgr->add(createLegacySpirvLowerRayTracing(false));
+    // OpTerminateRay/OpIgnoreIntersection of anyhit shader and OpReportIntersection of intersection shader could
+    // terminate ray during inbetween of shader execution. So functions in these shaders need to be inlined.
+    if (entryStage == ShaderStageRayTracingAnyHit || entryStage == ShaderStageRayTracingIntersect) {
+      // Lower SPIR-V CFG merges before inlining
+      lowerPassMgr->addPass(SpirvLowerCfgMerges());
+      lowerPassMgr->addPass(AlwaysInlinerPass());
+    }
+    lowerPassMgr->addPass(SpirvLowerRayTracing(false));
 
-      // Stop timer for translate.
-      timerProfiler.addTimerStartStopPass(&*lowerPassMgr, TimerTranslate, false);
+    // Stop timer for translate.
+    timerProfiler.addTimerStartStopPass(*lowerPassMgr, TimerTranslate, false);
 
-      // Run the passes.
-      success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
-    }
+    // Run the passes.
+    bool success = runPasses(&*lowerPassMgr, modules[shaderIndex]);
     if (!success) {
       LLPC_ERRS("Failed to translate SPIR-V or run per-shader passes\n");
       result = Result::ErrorInvalidShader;
     }
   }
 
   std::vector<Module *> newModules;
   // Record which module calls TraceRay(), except the first one (For indirect mode, it is the entry function which will
   // never call TraceRay(). For inlined mode, we don't need to care).
   std::vector<bool> moduleCallsTraceRay;
diff --git a/llpc/context/llpcPipelineContext.cpp b/llpc/context/llpcPipelineContext.cpp
index 9a2a7a731..f9a1c03f5 100644
--- a/llpc/context/llpcPipelineContext.cpp
+++ b/llpc/context/llpcPipelineContext.cpp
@@ -339,21 +339,25 @@ void PipelineContext::setOptionsInPipeline(Pipeline *pipeline, Util::MetroHash64
       options.shadowDescriptorTable = ShadowDescTablePtrHigh;
   }
 
   if (isGraphics()) {
     options.enableUberFetchShader =
         reinterpret_cast<const GraphicsPipelineBuildInfo *>(getPipelineBuildInfo())->enableUberFetchShader;
     if (getGfxIpVersion().major >= 10) {
       // Only set NGG options for a GFX10+ graphics pipeline.
       auto pipelineInfo = reinterpret_cast<const GraphicsPipelineBuildInfo *>(getPipelineBuildInfo());
       const auto &nggState = pipelineInfo->nggState;
+#if VKI_BUILD_GFX11
+      if (!nggState.enableNgg && getGfxIpVersion().major < 11) // GFX11+ must enable NGG
+#else
       if (!nggState.enableNgg)
+#endif
         options.nggFlags |= NggFlagDisable;
       else {
         options.nggFlags = (nggState.enableGsUse ? NggFlagEnableGsUse : 0) |
                            (nggState.forceCullingMode ? NggFlagForceCullingMode : 0) |
                            (nggState.compactMode == NggCompactDisable ? NggFlagCompactDisable : 0) |
                            (nggState.enableVertexReuse ? NggFlagEnableVertexReuse : 0) |
                            (nggState.enableBackfaceCulling ? NggFlagEnableBackfaceCulling : 0) |
                            (nggState.enableFrustumCulling ? NggFlagEnableFrustumCulling : 0) |
                            (nggState.enableBoxFilterCulling ? NggFlagEnableBoxFilterCulling : 0) |
                            (nggState.enableSphereCulling ? NggFlagEnableSphereCulling : 0) |
@@ -381,20 +385,23 @@ void PipelineContext::setOptionsInPipeline(Pipeline *pipeline, Util::MetroHash64
         options.nggSubgroupSizing = static_cast<NggSubgroupSizing>(nggState.subgroupSizing);
 
         options.nggVertsPerSubgroup = nggState.vertsPerSubgroup;
         options.nggPrimsPerSubgroup = nggState.primsPerSubgroup;
       }
     }
   }
 
   options.allowNullDescriptor = getPipelineOptions()->extendedRobustness.nullDescriptor;
   options.disableImageResourceCheck = getPipelineOptions()->disableImageResourceCheck;
+#if VKI_BUILD_GFX11
+  options.optimizeTessFactor = getPipelineOptions()->optimizeTessFactor;
+#endif
   options.enableInterpModePatch = getPipelineOptions()->enableInterpModePatch;
   options.pageMigrationEnabled = getPipelineOptions()->pageMigrationEnabled;
   options.resourceLayoutScheme = static_cast<lgc::ResourceLayoutScheme>(getPipelineOptions()->resourceLayoutScheme);
 
   // Driver report full subgroup lanes for compute shader, here we just set fullSubgroups as default options
   options.fullSubgroups = true;
 #if VKI_RAY_TRACING
   // NOTE: raytracing waveSize and subgroupSize can be different.
   if (isRayTracing()) {
     options.fullSubgroups = false;
@@ -418,38 +425,50 @@ void PipelineContext::setOptionsInPipeline(Pipeline *pipeline, Util::MetroHash64
     // 128-bit hash
     shaderOptions.hash[0] = hash.lower;
     shaderOptions.hash[1] = hash.upper;
 
     const PipelineShaderInfo *shaderInfo = getPipelineShaderInfo(stage);
     shaderOptions.trapPresent = shaderInfo->options.trapPresent;
     shaderOptions.debugMode = shaderInfo->options.debugMode;
     shaderOptions.allowReZ = shaderInfo->options.allowReZ;
     shaderOptions.forceLateZ = shaderInfo->options.forceLateZ;
 
-    if (shaderInfo->options.vgprLimit != 0 && shaderInfo->options.vgprLimit != UINT_MAX)
-      shaderOptions.vgprLimit = shaderInfo->options.vgprLimit;
-    else
-      shaderOptions.vgprLimit = VgprLimit;
+    shaderOptions.vgprLimit = shaderInfo->options.vgprLimit;
+
+    if (shaderOptions.vgprLimit == UINT_MAX)
+      shaderOptions.vgprLimit = 0;
+
+    if (VgprLimit != 0) {
+      if (VgprLimit < shaderOptions.vgprLimit || shaderOptions.vgprLimit == 0) {
+        shaderOptions.vgprLimit = VgprLimit;
+      }
+    }
 
     if (ScalarizeWaterfallDescriptorLoads.getNumOccurrences() > 0) {
       shaderOptions.scalarizeWaterfallLoads = ScalarizeWaterfallDescriptorLoads;
     } else {
       shaderOptions.scalarizeWaterfallLoads = shaderInfo->options.scalarizeWaterfallLoads;
       // Enable waterfall load scalarization when vgpr limit is set.
       if (shaderOptions.vgprLimit != 0 && shaderOptions.vgprLimit != UINT_MAX)
         shaderOptions.scalarizeWaterfallLoads = true;
     }
 
-    if (shaderInfo->options.sgprLimit != 0 && shaderInfo->options.sgprLimit != UINT_MAX)
-      shaderOptions.sgprLimit = shaderInfo->options.sgprLimit;
-    else
-      shaderOptions.sgprLimit = SgprLimit;
+    shaderOptions.sgprLimit = shaderInfo->options.sgprLimit;
+
+    if (shaderOptions.sgprLimit == UINT_MAX)
+      shaderOptions.sgprLimit = 0;
+
+    if (SgprLimit != 0) {
+      if (SgprLimit < shaderOptions.sgprLimit || shaderOptions.sgprLimit == 0) {
+        shaderOptions.sgprLimit = SgprLimit;
+      }
+    }
 
     if (shaderInfo->options.maxThreadGroupsPerComputeUnit != 0)
       shaderOptions.maxThreadGroupsPerComputeUnit = shaderInfo->options.maxThreadGroupsPerComputeUnit;
     else
       shaderOptions.maxThreadGroupsPerComputeUnit = WavesPerEu;
 
     shaderOptions.waveSize = shaderInfo->options.waveSize;
     shaderOptions.wgpMode = shaderInfo->options.wgpMode;
 
     // If subgroupSize is specified, we should use the specified value.
diff --git a/llpc/context/llpcShaderCache.cpp b/llpc/context/llpcShaderCache.cpp
index 090c17826..fe154a77b 100644
--- a/llpc/context/llpcShaderCache.cpp
+++ b/llpc/context/llpcShaderCache.cpp
@@ -593,27 +593,33 @@ void ShaderCache::resetShader(CacheEntryHandle hEntry) {
   lockCacheMap(false);
   index->state = ShaderEntryState::New;
   index->header.size = 0;
   index->dataBlob = nullptr;
   unlockCacheMap(false);
   m_conditionVariable.notify_all();
 }
 
 // =====================================================================================================================
 // Retrieves the shader from the cache which is identified by the specified entry handle.
+// If ShaderIndex::state is not ShaderEntryState::Ready it fails and returns ErrorOutOfMemory, in this case
+// the code and codeSize arguments are not modified.
 //
 // @param hEntry : Handle of shader cache entry
 // @param [out] ppBlob : Shader data
 // @param [out] size : Size of shader data in bytes
 Result ShaderCache::retrieveShader(CacheEntryHandle hEntry, const void **ppBlob, size_t *size) {
   const auto *const index = static_cast<ShaderIndex *>(hEntry);
 
+  if (index->state != ShaderEntryState::Ready) {
+    return Result::ErrorOutOfMemory;
+  }
+
   assert(m_disableCache == false);
   assert(index);
   assert(index->header.size >= sizeof(ShaderHeader));
 
   lockCacheMap(true);
 
   *ppBlob = voidPtrInc(index->dataBlob, sizeof(ShaderHeader));
   *size = index->header.size - sizeof(ShaderHeader);
 
   unlockCacheMap(true);
diff --git a/llpc/lower/PassRegistry.inc b/llpc/lower/PassRegistry.inc
index 52ba0dfc9..851f3029e 100644
--- a/llpc/lower/PassRegistry.inc
+++ b/llpc/lower/PassRegistry.inc
@@ -27,20 +27,21 @@
  * @file  PassRegistry.inc
  * @brief LLPC header file: used as the registry of LLPC lowering passes
  ***********************************************************************************************************************
  */
 
 #ifndef LLPC_MODULE_PASS
 #define LLPC_MODULE_PASS LLPC_PASS
 #endif
 
 LLPC_MODULE_PASS("llpc-spirv-lower-access-chain", SpirvLowerAccessChain)
+LLPC_MODULE_PASS("llpc-spirv-lower-cfg-merges", SpirvLowerCfgMerges)
 LLPC_MODULE_PASS("llpc-spirv-lower-const-immediate-store", SpirvLowerConstImmediateStore)
 LLPC_MODULE_PASS("llpc-spirv-lower-inst-meta-remove", SpirvLowerInstMetaRemove)
 LLPC_MODULE_PASS("llpc-spirv-lower-terminator", SpirvLowerTerminator)
 LLPC_MODULE_PASS("llpc-spirv-lower-translator", SpirvLowerTranslator)
 LLPC_MODULE_PASS("llpc-spirv-lower-global", SpirvLowerGlobal)
 LLPC_MODULE_PASS("llpc-spirv-lower-math-const-folding", SpirvLowerMathConstFolding)
 LLPC_MODULE_PASS("llpc-spirv-lower-math-float-op", SpirvLowerMathFloatOp)
 LLPC_MODULE_PASS("llpc-spirv-lower-memory-op", SpirvLowerMemoryOp)
 #if VKI_RAY_TRACING
 LLPC_MODULE_PASS("llpc-spirv-lower-ray-tracing-intrinsics", SpirvLowerRayTracingIntrinsics)
diff --git a/llpc/lower/llpcSpirvLower.cpp b/llpc/lower/llpcSpirvLower.cpp
index 55c74fa7b..b90ec58d3 100644
--- a/llpc/lower/llpcSpirvLower.cpp
+++ b/llpc/lower/llpcSpirvLower.cpp
@@ -25,39 +25,46 @@
 /**
  ***********************************************************************************************************************
  * @file  llpcSpirvLower.cpp
  * @brief LLPC source file: contains implementation of class Llpc::SpirvLower.
  ***********************************************************************************************************************
  */
 #include "llpcSpirvLower.h"
 #include "llpcContext.h"
 #include "llpcDebug.h"
 #include "llpcSpirvLowerAccessChain.h"
+#include "llpcSpirvLowerCfgMerges.h"
 #include "llpcSpirvLowerConstImmediateStore.h"
 #include "llpcSpirvLowerGlobal.h"
 #include "llpcSpirvLowerInstMetaRemove.h"
 #include "llpcSpirvLowerMath.h"
 #include "llpcSpirvLowerMemoryOp.h"
 #if VKI_RAY_TRACING
 #include "llpcSpirvLowerRayQueryPostInline.h"
 #include "llpcSpirvLowerRayTracingBuiltIn.h"
 #include "llpcSpirvLowerRayTracingIntrinsics.h"
 #endif
 #include "llpcSpirvLowerTerminator.h"
 #include "llpcSpirvLowerTranslator.h"
 #include "llpcSpirvLowerUtil.h"
 #include "lgc/Builder.h"
 #include "lgc/LgcContext.h"
 #include "lgc/PassManager.h"
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/IR/IRPrintingPasses.h"
 #include "llvm/IR/Verifier.h"
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 442438
+// Old version of the code
+#else
+// New version of the code (also handles unknown version, which we treat as latest)
+#include "llvm/IRPrinter/IRPrintingPasses.h"
+#endif
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #include "llvm/Transforms/IPO/ForceFunctionAttrs.h"
 #include "llvm/Transforms/IPO/FunctionAttrs.h"
 #include "llvm/Transforms/IPO/GlobalDCE.h"
 #include "llvm/Transforms/IPO/GlobalOpt.h"
 #include "llvm/Transforms/IPO/InferFunctionAttrs.h"
 #include "llvm/Transforms/IPO/SCCP.h"
@@ -181,20 +188,23 @@ void SpirvLower::addPasses(Context *context, ShaderStage stage, lgc::PassManager
 
   // Start timer for lowering passes.
   if (lowerTimer)
     LgcContext::createAndAddStartStopTimer(passMgr, lowerTimer, true);
 
 #if VKI_RAY_TRACING
   if (isInternalRtShader)
     passMgr.addPass(SpirvLowerRayTracingIntrinsics());
 #endif
 
+  // Lower SPIR-V CFG merges before inlining
+  passMgr.addPass(SpirvLowerCfgMerges());
+
   // Function inlining. Use the "always inline" pass, since we want to inline all functions, and
   // we marked (non-entrypoint) functions as "always inline" just after SPIR-V reading.
   passMgr.addPass(AlwaysInlinerPass());
   passMgr.addPass(GlobalDCEPass());
 
   // Lower SPIR-V access chain
   passMgr.addPass(SpirvLowerAccessChain());
 
 #if VKI_RAY_TRACING
   if (rayTracing)
@@ -213,24 +223,26 @@ void SpirvLower::addPasses(Context *context, ShaderStage stage, lgc::PassManager
   passMgr.addPass(SpirvLowerConstImmediateStore());
 
   // Lower SPIR-V constant folding - must be done before instruction combining pass.
   passMgr.addPass(SpirvLowerMathConstFolding());
 
   // Lower SPIR-V memory operations
   passMgr.addPass(SpirvLowerMemoryOp());
 
   // Remove redundant load/store operations and do minimal optimization
   // It is required by SpirvLowerImageOp.
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 404149
-  passMgr.addPass(createModuleToFunctionPassAdaptor(SROA()));
-#else
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
+  // Old version of the code
   passMgr.addPass(createModuleToFunctionPassAdaptor(SROAPass()));
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  passMgr.addPass(createModuleToFunctionPassAdaptor(SROAPass(SROAOptions::ModifyCFG)));
 #endif
   passMgr.addPass(GlobalOptPass());
   passMgr.addPass(createModuleToFunctionPassAdaptor(ADCEPass()));
   passMgr.addPass(createModuleToFunctionPassAdaptor(InstCombinePass(2)));
   passMgr.addPass(createModuleToFunctionPassAdaptor(SimplifyCFGPass()));
   passMgr.addPass(createModuleToFunctionPassAdaptor(EarlyCSEPass()));
 
   // Lower SPIR-V floating point optimisation
   passMgr.addPass(SpirvLowerMathFloatOp());
 
@@ -302,20 +314,23 @@ void LegacySpirvLower::addPasses(Context *context, ShaderStage stage, legacy::Pa
 
   // Start timer for lowering passes.
   if (lowerTimer)
     passMgr.add(LgcContext::createStartStopTimer(lowerTimer, true));
 
 #if VKI_RAY_TRACING
   if (isInternalRtShader)
     passMgr.add(createLegacySpirvLowerRayTracingIntrinsics());
 #endif
 
+  // Lower SPIR-V CFG merges before inlining
+  passMgr.add(createLegacySpirvLowerCfgMerges());
+
   // Function inlining. Use the "always inline" pass, since we want to inline all functions, and
   // we marked (non-entrypoint) functions as "always inline" just after SPIR-V reading.
   passMgr.add(createAlwaysInlinerLegacyPass());
   passMgr.add(createGlobalDCEPass());
 
   // Lower SPIR-V access chain
   passMgr.add(createLegacySpirvLowerAccessChain());
 
 #if VKI_RAY_TRACING
   if (rayTracing)
@@ -334,21 +349,27 @@ void LegacySpirvLower::addPasses(Context *context, ShaderStage stage, legacy::Pa
   passMgr.add(createLegacySpirvLowerConstImmediateStore());
 
   // Lower SPIR-V constant folding - must be done before instruction combining pass.
   passMgr.add(createLegacySpirvLowerMathConstFolding());
 
   // Lower SPIR-V memory operations
   passMgr.add(createLegacySpirvLowerMemoryOp());
 
   // Remove redundant load/store operations and do minimal optimization
   // It is required by SpirvLowerImageOp.
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444780
+  // Old version of the code
   passMgr.add(createSROAPass());
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  passMgr.add(createSROAPass(false));
+#endif
   passMgr.add(createGlobalOptimizerPass());
   passMgr.add(createAggressiveDCEPass());
   passMgr.add(createInstructionCombiningPass(2));
   passMgr.add(createCFGSimplificationPass());
   passMgr.add(createEarlyCSEPass());
 
   // Lower SPIR-V floating point optimisation
   passMgr.add(createLegacySpirvLowerMathFloatOp());
 
   // Lower SPIR-V instruction metadata remove
@@ -375,15 +396,24 @@ void LegacySpirvLower::addPasses(Context *context, ShaderStage stage, legacy::Pa
 // @param module : LLVM module
 void SpirvLower::init(Module *module) {
   m_module = module;
   m_context = static_cast<Context *>(&m_module->getContext());
   if (m_module->empty()) {
     m_shaderStage = ShaderStageInvalid;
     m_entryPoint = nullptr;
   } else {
     m_shaderStage = getShaderStageFromModule(m_module);
     m_entryPoint = getEntryPoint(m_module);
+    if (m_shaderStage == ShaderStageInvalid) {
+#if VKI_RAY_TRACING
+      // There might be cases we fail to get shader stage from a module that is not directly converted from SPIR-V, for
+      // example, unified ray tracing pipeline shader, or entry for indirect ray tracing pipeline. In such case, clamp
+      // the shader stage to compute.
+#endif
+      assert(m_entryPoint);
+      m_shaderStage = ShaderStageCompute;
+    }
   }
   m_builder = m_context->getBuilder();
 }
 
 } // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLower.h b/llpc/lower/llpcSpirvLower.h
index 268ba87a4..412c6f31c 100644
--- a/llpc/lower/llpcSpirvLower.h
+++ b/llpc/lower/llpcSpirvLower.h
@@ -41,20 +41,21 @@ class GlobalVariable;
 class Timer;
 
 namespace legacy {
 
 class PassManager;
 
 } // namespace legacy
 
 class PassRegistry;
 void initializeLegacySpirvLowerAccessChainPass(PassRegistry &);
+void initializeLegacySpirvLowerCfgMergesPass(PassRegistry &);
 void initializeLegacySpirvLowerMathConstFoldingPass(PassRegistry &);
 void initializeLegacySpirvLowerMathFloatOpPass(PassRegistry &);
 void initializeLegacySpirvLowerConstImmediateStorePass(PassRegistry &);
 void initializeLegacySpirvLowerMemoryOpPass(PassRegistry &);
 void initializeLegacySpirvLowerGlobalPass(PassRegistry &);
 void initializeLegacySpirvLowerInstMetaRemovePass(PassRegistry &);
 #if VKI_RAY_TRACING
 void initializeLegacySpirvLowerRayTracingPass(PassRegistry &);
 void initializeLegacySpirvLowerRayTracingBuiltInPass(PassRegistry &);
 void initializeLegacySpirvLowerRayQueryPass(PassRegistry &);
@@ -72,40 +73,42 @@ class PassManager;
 
 } // namespace lgc
 
 namespace Llpc {
 
 // Initialize passes for SPIR-V lowering
 //
 // @param passRegistry : Pass registry
 inline void initializeLowerPasses(llvm::PassRegistry &passRegistry) {
   initializeLegacySpirvLowerAccessChainPass(passRegistry);
+  initializeLegacySpirvLowerCfgMergesPass(passRegistry);
   initializeLegacySpirvLowerConstImmediateStorePass(passRegistry);
   initializeLegacySpirvLowerMathConstFoldingPass(passRegistry);
   initializeLegacySpirvLowerMathFloatOpPass(passRegistry);
   initializeLegacySpirvLowerMemoryOpPass(passRegistry);
   initializeLegacySpirvLowerGlobalPass(passRegistry);
   initializeLegacySpirvLowerInstMetaRemovePass(passRegistry);
 #if VKI_RAY_TRACING
   initializeLegacySpirvLowerRayTracingPass(passRegistry);
   initializeLegacySpirvLowerRayTracingBuiltInPass(passRegistry);
   initializeLegacySpirvLowerRayQueryPass(passRegistry);
   initializeLegacySpirvLowerRayQueryPostInlinePass(passRegistry);
   initializeLegacySpirvLowerRayTracingIntrinsicsPass(passRegistry);
 #endif
   initializeLegacySpirvLowerTerminatorPass(passRegistry);
   initializeLegacySpirvLowerTranslatorPass(passRegistry);
 }
 
 class Context;
 
 llvm::ModulePass *createLegacySpirvLowerAccessChain();
+llvm::ModulePass *createLegacySpirvLowerCfgMerges();
 llvm::ModulePass *createLegacySpirvLowerConstImmediateStore();
 llvm::ModulePass *createLegacySpirvLowerMathConstFolding();
 llvm::ModulePass *createLegacySpirvLowerMathFloatOp();
 llvm::ModulePass *createLegacySpirvLowerMemoryOp();
 llvm::ModulePass *createLegacySpirvLowerGlobal();
 llvm::ModulePass *createLegacySpirvLowerInstMetaRemove();
 #if VKI_RAY_TRACING
 llvm::ModulePass *createLegacySpirvLowerRayTracing(bool rayQueryLibrary);
 llvm::ModulePass *createLegacySpirvLowerRayTracingBuiltIn();
 llvm::ModulePass *createLegacySpirvLowerRayQuery(bool rayQueryLibrary);
diff --git a/llpc/lower/llpcSpirvLowerAccessChain.cpp b/llpc/lower/llpcSpirvLowerAccessChain.cpp
index 4f73eaa5b..5bf221f13 100644
--- a/llpc/lower/llpcSpirvLowerAccessChain.cpp
+++ b/llpc/lower/llpcSpirvLowerAccessChain.cpp
@@ -24,20 +24,21 @@
  **********************************************************************************************************************/
 /**
  ***********************************************************************************************************************
  * @file  llpcSpirvLowerAccessChain.cpp
  * @brief LLPC source file: contains implementation of class Llpc::SpirvLowerAccessChain.
  ***********************************************************************************************************************
  */
 #include "llpcSpirvLowerAccessChain.h"
 #include "SPIRVInternal.h"
 #include "llvm/IR/Instructions.h"
+#include "llvm/IR/Operator.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #include <stack>
 
 #define DEBUG_TYPE "llpc-spirv-lower-access-chain"
 
 using namespace llvm;
 using namespace SPIRV;
 using namespace Llpc;
 
@@ -114,72 +115,101 @@ void SpirvLowerAccessChain::visitGetElementPtrInst(GetElementPtrInst &getElemPtr
 //      =>
 //
 //      %y = getelementptr %blockType, %blockType addrspace(N)* @block, i32 0, i32 L, i32 M, i32 N
 //
 //
 // @param getElemPtr : "getelementptr" instruction in the bottom to do coalescing
 // @param addrSpace : Address space of the pointer value of "getelementptr"
 GetElementPtrInst *SpirvLowerAccessChain::tryToCoalesceChain(GetElementPtrInst *getElemPtr, unsigned addrSpace) {
   GetElementPtrInst *coalescedGetElemPtr = getElemPtr;
 
-  std::stack<User *> chainedInsts;              // Order: from top to bottom
+  std::stack<GEPOperator *> chainedInsts;       // Order: from top to bottom
   std::stack<GetElementPtrInst *> removedInsts; // Order: from bottom to top
 
   // Collect chained "getelementptr" instructions and constants from bottom to top.
-  auto ptrVal = cast<User>(getElemPtr);
+  auto ptrVal = cast<GEPOperator>(getElemPtr);
   for (;;) {
     chainedInsts.push(ptrVal);
-    auto next = ptrVal->getOperand(0);
-    if (isa<GetElementPtrInst>(next)) {
-      ptrVal = cast<User>(next);
-      continue;
-    }
-    auto constant = dyn_cast<ConstantExpr>(next);
-    if (!constant || constant->getOpcode() != Instruction::GetElementPtr)
+    ptrVal = dyn_cast<GEPOperator>(ptrVal->getOperand(0));
+    if (!ptrVal)
       break;
-    ptrVal = cast<User>(next);
   }
 
   // If there are more than one "getelementptr" instructions/constants, do coalescing
   if (chainedInsts.size() > 1) {
-    std::vector<Value *> idxs;
+    SmallVector<Value *, 8> idxs;
     unsigned startOperand = 1;
-    Value *blockPtr = nullptr;
+    Value *basePtr = nullptr;
     Type *coalescedType = nullptr;
 
     do {
       ptrVal = chainedInsts.top();
       chainedInsts.pop();
 
+      if (coalescedType) {
+        Type *currentLevelGEPSourceType = ptrVal->getSourceElementType();
+        Type *oneLevelAboveGEPRetType = GetElementPtrInst::getIndexedType(coalescedType, idxs);
+        if (currentLevelGEPSourceType != oneLevelAboveGEPRetType) {
+          // For Opaque Pointers some of GEPs (all zero-index) will be removed and since Source Type of the coalesced
+          // GEP is equal to the top of chained GEPs, this will lead to accessing wrong place in memory.
+          //
+          // Example:
+          // %1 = getelementptr { i64, [3 x [4 x { <3 x i32>, <3 x i32> }]], [3 x [4 x i32]] }, ptr
+          // addrspace(5) %381, i32 0, i32 1
+          //
+          // %2 = getelementptr [3 x [4 x { <3 x i32>, <3 x i32> }]], ptr addrspace(5) %1, i32 0, i32 0
+          // ^^^ all zero-index GEP, lack of this instruction for opaque pointers
+          //
+          // %3 = getelementptr [4 x { <3 x i32>, <3 x i32> }], ptraddrspace(5) %2, i32 0, i32 0
+          // ^^^ all zero-index GEP, lack of this instruction for opaque pointers
+          //
+          // %4 = getelementptr { <3 x i32>, <3 x i32> }, ptr addrspace(5) %3, i32 0, i32 1
+          //
+          //
+          // Result after Lower Access Chain:
+          //
+          // In case of non opaque pointers
+          // %5 = getelementptr { i64, [3 x [4 x { <3 x i32>, <3 x i32> }]], [3 x [4 x i32]] }, ptr
+          // addrspace(5) %381, i32 0, i32 1, i32 0, i32 0, i32 1
+          //
+          // For opaque pointers
+          // %5 = getelementptr { i64, [3 x [4 x { <3 x i32>, <3 x i32> }]], [3 x [4 x i32]] }, ptr
+          // addrspace(5) %381, i32 0, i32 1, i32 1
+          //
+          // We need to compare two chained GEP instructions and see if return Type of one is the same as Source
+          // Type of the other. If Types are not the same than we need to add
+          // missing zero-index elements to the "idxs" which are used to create new (coalesced) GEP instruction.
+          appendZeroIndexToMatchTypes(idxs, currentLevelGEPSourceType, oneLevelAboveGEPRetType);
+        }
+      }
+
       for (unsigned i = startOperand; i != ptrVal->getNumOperands(); ++i)
         idxs.push_back(ptrVal->getOperand(i));
       // NOTE: For subsequent "getelementptr" instructions/constants, we skip the first two operands. The first
       // operand is the pointer value from which the element pointer is constructed. And the second one is always
       // 0 to dereference the pointer value.
       startOperand = 2;
 
-      auto inst = dyn_cast<GetElementPtrInst>(ptrVal);
-
-      if (!blockPtr && inst) {
-        blockPtr = ptrVal->getOperand(0);
-        coalescedType = inst->getSourceElementType();
+      if (!basePtr) {
+        basePtr = ptrVal->getOperand(0);
+        coalescedType = ptrVal->getSourceElementType();
       }
 
-      if (inst)
+      if (auto inst = dyn_cast<GetElementPtrInst>(ptrVal))
         removedInsts.push(inst);
     } while (!chainedInsts.empty());
 
     // TODO: Remove this when LLPC will switch fully to opaque pointers.
-    assert(cast<PointerType>(blockPtr->getType())->isOpaqueOrPointeeTypeMatches(coalescedType));
+    assert(cast<PointerType>(basePtr->getType())->isOpaqueOrPointeeTypeMatches(coalescedType));
 
     // Create the coalesced "getelementptr" instruction (do combining)
-    coalescedGetElemPtr = GetElementPtrInst::Create(coalescedType, blockPtr, idxs, "", getElemPtr);
+    coalescedGetElemPtr = GetElementPtrInst::Create(coalescedType, basePtr, idxs, "", getElemPtr);
     getElemPtr->replaceAllUsesWith(coalescedGetElemPtr);
 
     // Remove dead "getelementptr" instructions where possible.
     while (!removedInsts.empty()) {
       GetElementPtrInst *inst = removedInsts.top();
       if (inst->user_empty()) {
         if (inst == getElemPtr) {
           // We cannot remove the current instruction that InstWalker is on. Just stop it using its
           // pointer operand, and it will be DCEd later.
           auto &operand = inst->getOperandUse(0);
@@ -187,15 +217,42 @@ GetElementPtrInst *SpirvLowerAccessChain::tryToCoalesceChain(GetElementPtrInst *
         } else
           inst->eraseFromParent();
       }
       removedInsts.pop();
     }
   }
 
   return coalescedGetElemPtr;
 }
 
+// =====================================================================================================================
+// Append zero-index elements to "indexOperands" vector while unpacking "baseType" to match "typeToMatch"
+//
+// This function is used to workaround the elimination of zero-index GEP instructions which is taking place
+// when opaque pointers are enabled.
+//
+// @param indexOperands : vector to which zero-index elements will be added
+// @param typeToMatch : type used as destination of unpacking "baseType"
+// @param baseType : packed type which will be unpacked.
+void SpirvLowerAccessChain::appendZeroIndexToMatchTypes(SmallVectorImpl<Value *> &indexOperands, Type *typeToMatch,
+                                                        Type *baseType) {
+  Type *unpackType = baseType;
+  Value *zero = ConstantInt::get(Type::getInt32Ty(m_module->getContext()), 0);
+  while (unpackType != typeToMatch) {
+    // append zero-index
+    indexOperands.push_back(zero);
+    if (unpackType->isStructTy())
+      unpackType = unpackType->getStructElementType(0);
+    else if (unpackType->isArrayTy())
+      unpackType = unpackType->getArrayElementType();
+    else if (unpackType->isVectorTy())
+      unpackType = cast<VectorType>(unpackType)->getElementType();
+    else
+      llvm_unreachable("Should never be called!");
+  }
+}
+
 } // namespace Llpc
 
 // =====================================================================================================================
 // Initializes the pass of SPIR-V lowering operations for access chain.
 INITIALIZE_PASS(LegacySpirvLowerAccessChain, DEBUG_TYPE, "Lower SPIR-V access chain", false, false)
diff --git a/llpc/lower/llpcSpirvLowerAccessChain.h b/llpc/lower/llpcSpirvLowerAccessChain.h
index 9056118c3..886a170e2 100644
--- a/llpc/lower/llpcSpirvLowerAccessChain.h
+++ b/llpc/lower/llpcSpirvLowerAccessChain.h
@@ -44,20 +44,22 @@ class SpirvLowerAccessChain : public SpirvLower,
 public:
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
   virtual void visitGetElementPtrInst(llvm::GetElementPtrInst &getElemPtrInst);
 
   bool runImpl(llvm::Module &module);
 
   static llvm::StringRef name() { return "Lower SPIR-V access chain"; }
 
 private:
   llvm::GetElementPtrInst *tryToCoalesceChain(llvm::GetElementPtrInst *getElemPtr, unsigned addrSpace);
+  void appendZeroIndexToMatchTypes(llvm::SmallVectorImpl<llvm::Value *> &indexOperands, llvm::Type *typeToMatch,
+                                   llvm::Type *baseType);
 };
 
 // =====================================================================================================================
 // Represents the pass of SPIR-V lowering operations for access chain.
 class LegacySpirvLowerAccessChain : public llvm::ModulePass {
 public:
   LegacySpirvLowerAccessChain();
 
   virtual bool runOnModule(llvm::Module &module);
 
diff --git a/llpc/lower/llpcSpirvLowerCfgMerges.cpp b/llpc/lower/llpcSpirvLowerCfgMerges.cpp
new file mode 100644
index 000000000..025f837f6
--- /dev/null
+++ b/llpc/lower/llpcSpirvLowerCfgMerges.cpp
@@ -0,0 +1,676 @@
+/*
+ ***********************************************************************************************************************
+ *
+ *  Copyright (c) 2022 Advanced Micro Devices, Inc. All Rights Reserved.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy
+ *  of this software and associated documentation files (the "Software"), to deal
+ *  in the Software without restriction, including without limitation the rights
+ *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ *  copies of the Software, and to permit persons to whom the Software is
+ *  furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included in all
+ *  copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *  SOFTWARE.
+ *
+ **********************************************************************************************************************/
+/**
+ ***********************************************************************************************************************
+ * @file  llpcSpirvLowerCfgMerges.cpp
+ * @brief LLPC source file: contains implementation of class Llpc::SpirvLowerCfgMerges.
+ * @details This pass process loop merge operations defined in SPIRV.
+ *          It manipulates loops with subgroup operations to ensure the set of lanes leaving a loop through merges,
+ *          breaks and returns are maximal reconvergent subsets.
+ * @todo There a number of possible improvements for this transform:
+ *       - Loops that have uniform exit condition do not need to be transformed.
+ *       - Only convergent operations on loop break/return paths need to be considered.
+ *       - Blocks on the loop-break path after a convergent operation can be pulled out the loop.
+ ***********************************************************************************************************************
+ */
+#include "llpcSpirvLowerCfgMerges.h"
+#include "SPIRVInternal.h"
+#include "llpcContext.h"
+#include "llpcDebug.h"
+#include "llpcSpirvLower.h"
+#include "llpcSpirvLowerUtil.h"
+#include "lgc/Builder.h"
+#include "llvm/ADT/DepthFirstIterator.h"
+#include "llvm/ADT/SetVector.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+
+#define DEBUG_TYPE "llpc-spirv-lower-cfg-merges"
+
+// Silence cppcheck for LLVM_DEBUG by defining macro.
+// Note: cppcheck-suppress does not reliably work for this.
+#ifndef LLVM_DEBUG
+#define LLVM_DEBUG(...)
+#endif
+
+using namespace llvm;
+using namespace SPIRV;
+using namespace Llpc;
+
+// -enable-loop-reconvergence: force enable loop reconvergence transform
+static cl::opt<bool> EnableLoopReconvergence("enable-loop-reconvergence",
+                                             cl::desc("Force enable loop reconvergence transform"), cl::init(false));
+
+namespace Llpc {
+
+// =====================================================================================================================
+// Initializes static members.
+char LegacySpirvLowerCfgMerges::ID = 0;
+
+// =====================================================================================================================
+// Pass creator, creates the pass of SPIR-V lowering terminator operations
+ModulePass *createLegacySpirvLowerCfgMerges() {
+  return new LegacySpirvLowerCfgMerges();
+}
+
+// =====================================================================================================================
+LegacySpirvLowerCfgMerges::LegacySpirvLowerCfgMerges() : ModulePass(ID) {
+}
+
+// =====================================================================================================================
+// Executes this SPIR-V lowering pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on (empty on entry)
+bool LegacySpirvLowerCfgMerges::runOnModule(Module &module) {
+  return Impl.runImpl(module);
+}
+
+// =====================================================================================================================
+// Executes this SPIR-V lowering pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on (empty on entry)
+// @param [in/out] analysisManager : Analysis manager to use for this transformation
+PreservedAnalyses SpirvLowerCfgMerges::run(Module &module, ModuleAnalysisManager &analysisManager) {
+  bool changed = runImpl(module);
+  // In practice there are unlikely to be any analyses this early, but report accurate status anyway.
+  return changed ? PreservedAnalyses::none() : PreservedAnalyses::all();
+}
+
+/// Defines helper for print block and function identifiers during debugging
+class OpPrinter {
+  BasicBlock *m_block;
+  Function *m_func;
+
+public:
+  OpPrinter(BasicBlock *block) : m_block(block), m_func(nullptr) {}
+  OpPrinter(Function *F) : m_block(nullptr), m_func(F) {}
+
+  void print(raw_ostream &OS) const {
+    if (m_block) {
+      m_block->printAsOperand(OS);
+      OS << " (" << m_block << ")";
+    }
+    if (m_func) {
+      m_func->printAsOperand(OS);
+      OS << " (" << m_func << ")";
+    }
+  }
+};
+
+raw_ostream &operator<<(raw_ostream &OS, const OpPrinter &V) {
+  V.print(OS);
+  return OS;
+}
+
+/// Represent loop and hold references to its associated blocks and PHI nodes
+struct LoopDesc {
+  LoopDesc()
+      : loopHeader(nullptr), mergeBlock(nullptr), continueBlock(nullptr), backedgeBlock(nullptr), sigmaBlock(nullptr),
+        returnPhi(nullptr), returnValuePhi(nullptr), parent(nullptr), function(nullptr), depth(-1),
+        convergentOps(false){};
+
+  int computeDepth() {
+    if (depth < 0) {
+      if (parent)
+        depth = parent->computeDepth() + 1;
+      else
+        depth = 0;
+    }
+    return depth;
+  }
+
+  BasicBlock *loopHeader;
+  BasicBlock *mergeBlock;
+  BasicBlock *continueBlock;
+  BasicBlock *backedgeBlock;
+  BasicBlock *sigmaBlock;
+  PHINode *returnPhi;
+  PHINode *returnValuePhi;
+  LoopDesc *parent;
+  Function *function;
+  int depth;
+  bool convergentOps;
+  SmallVector<BasicBlock *, 2> returnBlocks;
+};
+
+// =====================================================================================================================
+// Allocate and setup a LoopDesc structure for a given loop
+//
+// @param [in] mergeInst : loop merge instruction
+// @param [in] loopHeader : loop header block
+// @param [in] loopHeader : parent loop (maybe null)
+// @param [in] loopDescriptors : loop descriptor storage
+// @returns : Pointer to new LoopDesc
+static LoopDesc *allocateLoop(CallInst *mergeInst, BasicBlock *loopHeader, LoopDesc *parent,
+                              SmallVector<std::unique_ptr<LoopDesc>> &loopDescriptors) {
+  // Merge instruction should have two users: continue and merge.
+  // However continueBlock can be unreachable in CFG and hence missing after inlining.
+  BasicBlock *continueBlock = nullptr;
+  BasicBlock *mergeBlock = nullptr;
+  for (auto user : mergeInst->users()) {
+    CallInst *callInst = dyn_cast<CallInst>(user);
+    if (!callInst)
+      continue;
+    auto callee = callInst->getCalledFunction();
+    if (!callee)
+      continue;
+    if (callee->getName() == "spirv.loop.continue.block") {
+      assert(!continueBlock);
+      continueBlock = callInst->getParent();
+    } else if (callee->getName() == "spirv.loop.merge.block") {
+      assert(!mergeBlock);
+      mergeBlock = callInst->getParent();
+    } else {
+      llvm_unreachable("Should never be called!");
+    }
+  }
+  if (!mergeBlock) {
+    LLVM_DEBUG(dbgs() << "abort loop convergence; loop missing merge block\n");
+    return nullptr;
+  }
+
+  loopDescriptors.push_back(std::make_unique<LoopDesc>());
+  LoopDesc *loop = loopDescriptors.back().get();
+
+  LLVM_DEBUG(dbgs() << "allocate loop " << loop << " for " << OpPrinter(loopHeader) << "\n");
+
+  loop->loopHeader = loopHeader;
+  loop->mergeBlock = mergeBlock;
+  loop->continueBlock = continueBlock;
+  loop->function = loopHeader->getParent();
+  loop->parent = parent;
+  loop->computeDepth();
+
+  return loop;
+}
+
+// =====================================================================================================================
+// Iterate through all loop blocks marking them and locating backedge.
+// Recursively maps nested loops.
+//
+// @param [in/out] loop : loop to be mapped
+// @param [in/out] loopBlocks : map of blocks to loops
+// @param [in] loopMergeInsts : map of blocks to loop merge instructions
+// @param [in/out] loopDescriptors : storage for loop descriptors (in nested loops)
+// @param [in] convergentValues : set of blocks and functions with convergent calls
+// @returns : true if mapping was successful
+bool mapLoop(LoopDesc *loop, DenseMap<BasicBlock *, LoopDesc *> &loopBlocks,
+             DenseMap<BasicBlock *, CallInst *> &loopMergeInsts,
+             SmallVector<std::unique_ptr<LoopDesc>> &loopDescriptors, const DenseSet<Value *> &convergentValues) {
+  LLVM_DEBUG(dbgs() << "mapping loop " << loop << ", parent: " << loop->parent << "\n");
+
+  loopBlocks[loop->loopHeader] = loop;
+
+  SmallSet<BasicBlock *, 16> visited;
+  SmallVector<BasicBlock *> worklist;
+
+  worklist.push_back(loop->loopHeader);
+  while (!worklist.empty()) {
+    BasicBlock *block = worklist.pop_back_val();
+
+    LLVM_DEBUG(dbgs() << "Visit: " << OpPrinter(block) << " for " << loop << "\n");
+
+    if (!visited.insert(block).second)
+      continue;
+
+    // TODO: we actually only need to care about convergent operations on break/return path.
+    // However this is complex as we have to consider nested loop operations on same path.
+    if (!loop->convergentOps)
+      loop->convergentOps = convergentValues.count(block) > 0;
+
+    unsigned int successorCount = 0;
+    for (BasicBlock *succ : successors(block)) {
+      successorCount++;
+      if (succ == loop->loopHeader) {
+        // Backedge block
+        if (loop->backedgeBlock) {
+          LLVM_DEBUG(dbgs() << "abort loop convergence; loop with more than one backedge detected\n");
+          return false;
+        }
+        loop->backedgeBlock = block;
+      } else if (succ == loop->mergeBlock) {
+        // End of this loop
+      } else if (loopMergeInsts.count(succ)) {
+        // Nested loop
+        if (loopBlocks.count(succ))
+          continue; // Avoid marking loop twice if there are multiple edges to same block
+        CallInst *mergeInst = loopMergeInsts[succ];
+        LoopDesc *nestedLoop = allocateLoop(mergeInst, succ, loop, loopDescriptors);
+        if (!nestedLoop)
+          return false;
+        if (!mapLoop(nestedLoop, loopBlocks, loopMergeInsts, loopDescriptors, convergentValues))
+          return false;
+        // Critically, merge block of nested loop is part of this loop.
+        // Add this to work list here as all paths to it may be dominated
+        // by the nested loop.
+        loopBlocks[nestedLoop->mergeBlock] = loop;
+        loop->convergentOps = loop->convergentOps || nestedLoop->convergentOps;
+        worklist.push_back(nestedLoop->mergeBlock);
+      } else {
+        loopBlocks[succ] = loop;
+        worklist.push_back(succ);
+      }
+    }
+    if (successorCount == 0) {
+      // Return block / unreachable block
+      Instruction *termInst = block->getTerminator();
+      if (isa<ReturnInst>(termInst))
+        loop->returnBlocks.push_back(block);
+    }
+  }
+
+  return true;
+}
+
+// =====================================================================================================================
+// Determine all functions and block with a convergent function call.
+//
+// @param [in/out] module : LLVM module to be run on
+void SpirvLowerCfgMerges::mapConvergentValues(Module &module) {
+  // Map convergent exposure for blocks and functions
+
+  SmallVector<Function *> worklist;
+  SmallSet<Function *, 8> visited;
+
+  // Initial worklist is all convergent functions
+  for (Function &func : module) {
+    if (func.isConvergent())
+      worklist.push_back(&func);
+  }
+
+  while (!worklist.empty()) {
+    Function *func = worklist.pop_back_val();
+    if (visited.count(func))
+      continue;
+    if (func->getName().startswith("spirv.loop."))
+      continue;
+
+    // Record each convergent call block and function
+    for (User *user : func->users()) {
+      Instruction *userInst = dyn_cast<Instruction>(user);
+      if (!userInst)
+        continue;
+
+      BasicBlock *userBlock = userInst->getParent();
+      Function *userFunc = userBlock->getParent();
+
+      m_convergentValues.insert(userBlock);
+      m_convergentValues.insert(userFunc);
+
+      // If a function calls a convergent function, consider it convergent
+      if (!visited.count(userFunc))
+        worklist.push_back(userFunc);
+    }
+  }
+}
+
+// =====================================================================================================================
+// Executes this SPIR-V lowering pass on the specified LLVM module.
+//
+// @param [in/out] module : LLVM module to be run on
+bool SpirvLowerCfgMerges::runImpl(Module &module) {
+  LLVM_DEBUG(dbgs() << "Run the pass Spirv-Lower-CfgMerges\n");
+  LLVM_DEBUG(dbgs() << "Processing module: " << module);
+
+  SpirvLower::init(&module);
+
+  // Check for loops
+  Function *loopMergeFunc = module.getFunction("spirv.loop.merge");
+  if (!loopMergeFunc)
+    return false;
+
+  // Map convergent values
+  m_convergentValues.clear();
+  mapConvergentValues(module);
+
+  // Map loop merges
+  SmallVector<std::unique_ptr<LoopDesc>> loopDescriptors;
+  DenseMap<BasicBlock *, LoopDesc *> loopBlocks;
+  DenseMap<BasicBlock *, CallInst *> loopMergeInsts;
+
+  for (User *user : loopMergeFunc->users()) {
+    CallInst *loopMerge = cast<CallInst>(user);
+    assert(loopMergeInsts.count(loopMerge->getParent()) == 0);
+    loopMergeInsts[loopMerge->getParent()] = loopMerge;
+  }
+
+  // Iterate IR to find loops
+  // Note: this visit blocks deterministically and loop headers from outer loops before inner ones
+  bool hasConvergentLoops = false;
+  bool changed = false;
+  bool valid = EnableLoopReconvergence && !m_convergentValues.empty();
+
+  for (Function &F : module) {
+    if (F.empty())
+      continue;
+    for (BasicBlock *block : depth_first(&F)) {
+      if (!loopMergeInsts.count(block))
+        continue;
+
+      CallInst *mergeInst = loopMergeInsts[block];
+      if (valid && !loopBlocks.count(block)) {
+        LoopDesc *loop = allocateLoop(mergeInst, block, nullptr, loopDescriptors);
+        if (loop) {
+          valid = valid && mapLoop(loop, loopBlocks, loopMergeInsts, loopDescriptors, m_convergentValues);
+          hasConvergentLoops = hasConvergentLoops || loop->convergentOps;
+        } else {
+          valid = false;
+        }
+      }
+
+      for (User *loopUser : make_early_inc_range(mergeInst->users())) {
+        Instruction *loopInst = cast<Instruction>(loopUser);
+        LLVM_DEBUG(dbgs() << "remove: " << *loopInst << "\n");
+        loopInst->eraseFromParent();
+      }
+      LLVM_DEBUG(dbgs() << "remove: " << *mergeInst << "\n");
+      mergeInst->eraseFromParent();
+
+      changed = true;
+    }
+  }
+
+  if (!changed || !valid || !hasConvergentLoops) {
+    m_convergentValues.clear();
+    return changed;
+  }
+
+  // Output debug information before changing IR structure
+  LLVM_DEBUG(dbgs() << "Found " << loopDescriptors.size() << " loop(s)\n");
+  LLVM_DEBUG(for (auto &loop
+                  : loopDescriptors) {
+    dbgs() << "loop " << loop.get() << " in " << OpPrinter(loop->function) << "\n";
+    dbgs() << "  header: " << OpPrinter(loop->loopHeader) << "\n";
+    dbgs() << "  merge: " << OpPrinter(loop->mergeBlock) << "\n";
+    dbgs() << "  continue: " << OpPrinter(loop->continueBlock) << "\n";
+    dbgs() << "  backedge: " << OpPrinter(loop->backedgeBlock) << "\n";
+    dbgs() << "  depth: " << loop->depth << "\n";
+    dbgs() << "  convergentOps: " << loop->convergentOps << "\n";
+    if (loop->parent)
+      dbgs() << "  parent: " << loop->parent << "\n";
+    if (!loop->returnBlocks.empty()) {
+      dbgs() << "  returns:";
+      for (BasicBlock *returnBlock : loop->returnBlocks)
+        dbgs() << " " << OpPrinter(returnBlock);
+      dbgs() << "\n";
+    }
+  });
+
+  // Setup sigma blocks and loop depths
+  int maxDepth = 0;
+  for (auto &loop : loopDescriptors) {
+    if (!loop->convergentOps)
+      continue;
+    loop->sigmaBlock = BasicBlock::Create(*m_context, "", loop->function, loop->mergeBlock);
+    maxDepth = std::max(maxDepth, loop->depth);
+  }
+  LLVM_DEBUG(dbgs() << "Max loop depth is " << maxDepth << "\n");
+
+  // Process loops, starting with the innermost and working outward
+  for (int depth = maxDepth; depth >= 0; --depth) {
+    LLVM_DEBUG(dbgs() << "Processing depth: " << depth << "\n");
+
+    for (auto &loop : loopDescriptors) {
+      if (loop->depth != depth || !loop->convergentOps)
+        continue;
+
+      LLVM_DEBUG(dbgs() << "Processing: " << loop.get() << "\n");
+
+      SmallVector<BasicBlock *, 8> sigmaPreds(pred_begin(loop->sigmaBlock), pred_end(loop->sigmaBlock));
+      SmallSetVector<BasicBlock *, 8> mergePreds(pred_begin(loop->mergeBlock), pred_end(loop->mergeBlock));
+
+      // If we did not find the backedge block then it implies it is unreachable in the CFG.
+      // Substitute the continueBlock (which might also be unreachable).
+      // Lack of a backedge generally suggests this loop is not really a loop,
+      // but it is possible that an unreachable block might contribute to phis in reachable blocks.
+      if (!loop->backedgeBlock)
+        loop->backedgeBlock = loop->continueBlock;
+      if (loop->backedgeBlock && !mergePreds.contains(loop->backedgeBlock))
+        mergePreds.insert(loop->backedgeBlock);
+
+      // Rewrite loop exits
+      // +1 edge from waveHeader to sigmaBlock
+      PHINode *breakPhi =
+          PHINode::Create(m_builder->getInt1Ty(), sigmaPreds.size() + mergePreds.size() + 1, "", loop->sigmaBlock);
+
+      // Process return blocks
+      // Nested loop returns will already be routed to sigma block
+      if (loop->returnBlocks.size() > 0 || !sigmaPreds.empty()) {
+        unsigned int edgeCount = mergePreds.size() + sigmaPreds.size() + loop->returnBlocks.size();
+
+        loop->returnPhi = PHINode::Create(m_builder->getInt1Ty(), edgeCount, "", loop->sigmaBlock);
+        if (loop->function->getReturnType() != m_builder->getVoidTy())
+          loop->returnValuePhi = PHINode::Create(loop->function->getReturnType(), edgeCount, "", loop->sigmaBlock);
+
+        // Reroute all returns for this loop level
+        for (BasicBlock *block : loop->returnBlocks) {
+          ReturnInst *returnInst = static_cast<ReturnInst *>(block->getTerminator());
+
+          loop->returnPhi->addIncoming(m_builder->getTrue(), block);
+          if (loop->returnValuePhi)
+            loop->returnValuePhi->addIncoming(returnInst->getReturnValue(), block);
+
+          returnInst->dropAllReferences();
+          returnInst->eraseFromParent();
+          BranchInst::Create(loop->sigmaBlock, block);
+
+          breakPhi->addIncoming(m_builder->getTrue(), block);
+        }
+
+        // Connect returns from nested loops
+        for (BasicBlock *block : sigmaPreds) {
+          LoopDesc *otherLoop = loopBlocks[block];
+          assert(otherLoop != loop.get());
+          loop->returnPhi->addIncoming(m_builder->getTrue(), block);
+          if (loop->returnValuePhi) {
+            assert(otherLoop->returnValuePhi);
+            loop->returnValuePhi->addIncoming(otherLoop->returnValuePhi, block);
+          }
+        }
+      }
+
+      // Reroute all exits via sigma block
+      for (BasicBlock *block : mergePreds) {
+        BranchInst *termInst = cast<BranchInst>(block->getTerminator());
+        assert(termInst);
+        // Note: the only edge that is not a break here is from backedge/continue block
+        if (termInst->isUnconditional()) {
+          bool isBreak = (termInst->getSuccessor(0) == loop->mergeBlock);
+          termInst->eraseFromParent();
+          breakPhi->addIncoming(m_builder->getInt1(isBreak), block);
+          BranchInst::Create(loop->sigmaBlock, block);
+        } else {
+          Value *condition = termInst->getCondition();
+          BasicBlock *ifTrue = termInst->getSuccessor(0);
+          BasicBlock *ifFalse = termInst->getSuccessor(1);
+          if (ifTrue != loop->loopHeader && ifFalse != loop->loopHeader) {
+            // FIXME: can the other target be the mergeBlock?
+            // If so, then we'll need to split this edge.
+            // Cover this with assertions for now.
+            if (ifTrue == loop->mergeBlock) {
+              assert(ifFalse != loop->mergeBlock);
+              termInst->setSuccessor(0, loop->sigmaBlock);
+            } else {
+              assert(ifTrue != loop->mergeBlock);
+              assert(ifFalse == loop->mergeBlock);
+              termInst->setSuccessor(1, loop->sigmaBlock);
+            }
+            breakPhi->addIncoming(m_builder->getTrue(), block);
+          } else {
+            termInst->eraseFromParent();
+            if (ifTrue == loop->mergeBlock) {
+              breakPhi->addIncoming(condition, block);
+            } else {
+              auto notCondition = BinaryOperator::CreateNot(condition, "", block);
+              breakPhi->addIncoming(notCondition, block);
+            }
+            BranchInst::Create(loop->sigmaBlock, block);
+          }
+        }
+        if (loop->returnPhi) {
+          loop->returnPhi->addIncoming(m_builder->getFalse(), block);
+          if (loop->returnValuePhi)
+            loop->returnValuePhi->addIncoming(UndefValue::get(loop->function->getReturnType()), block);
+        }
+      }
+
+      // Add return edges to break
+      for (BasicBlock *block : sigmaPreds)
+        breakPhi->addIncoming(m_builder->getTrue(), block);
+
+      // If there are returns then we need another block after sigma
+      BasicBlock *postSigmaBlock = loop->mergeBlock;
+      if (loop->returnPhi) {
+        postSigmaBlock = BasicBlock::Create(*m_context, "", loop->function, loop->mergeBlock);
+        if (loop->depth == 0) {
+          // Root level loops branch to dedicate return blocks
+          BasicBlock *returnBlock = BasicBlock::Create(*m_context, "", loop->function, loop->mergeBlock);
+          ReturnInst::Create(*m_context, loop->returnValuePhi ? loop->returnValuePhi : nullptr, returnBlock);
+          BranchInst::Create(returnBlock, loop->mergeBlock, loop->returnPhi, postSigmaBlock);
+        } else {
+          // Inner loops move to outer loop sigma
+          BranchInst::Create(loop->parent->sigmaBlock, loop->mergeBlock, loop->returnPhi, postSigmaBlock);
+        }
+      }
+
+      // Define wave header
+      BasicBlock *waveHeader = loop->loopHeader;
+
+      // Store loop predecessors before modifying CFG
+      SmallVector<BasicBlock *, 2> wavePreds(pred_begin(waveHeader), pred_end(waveHeader));
+      MDNode *loopMetadata = loop->loopHeader->getTerminator()->getMetadata("llvm.loop");
+
+      // Split lane header and wave header
+      BasicBlock *laneHeader = waveHeader->splitBasicBlock(waveHeader->getFirstInsertionPt());
+      laneHeader->getTerminator()->setMetadata("llvm.loop", loopMetadata);
+
+      // Fix up PHIs in wave header
+      for (PHINode &headerPhi : waveHeader->phis()) {
+        LLVM_DEBUG(dbgs() << "fix up phi: " << headerPhi << "\n");
+
+        PHINode *sigmaPhi =
+            PHINode::Create(headerPhi.getType(), breakPhi->getNumIncomingValues(), "", loop->sigmaBlock);
+        Value *thisUndef = UndefValue::get(headerPhi.getType());
+
+        int backedgeIndex = loop->backedgeBlock ? headerPhi.getBasicBlockIndex(loop->backedgeBlock) : -1;
+        assert(!loop->backedgeBlock || backedgeIndex >= 0);
+
+        for (BasicBlock *block : predecessors(loop->sigmaBlock)) {
+          assert(block != waveHeader);
+          if (block == loop->backedgeBlock) {
+            assert(backedgeIndex >= 0);
+            sigmaPhi->addIncoming(headerPhi.getIncomingValue(backedgeIndex), block);
+          } else {
+            sigmaPhi->addIncoming(thisUndef, block);
+          }
+        }
+        // Account for edge from wave header to sigma block
+        sigmaPhi->addIncoming(&headerPhi, waveHeader);
+
+        // Update header phi to use sigma value
+        headerPhi.setIncomingBlock(backedgeIndex, loop->sigmaBlock);
+        headerPhi.setIncomingValue(backedgeIndex, sigmaPhi);
+      }
+
+      // Note: phis() requires terminator to function, so cannot be removed until here
+      waveHeader->getTerminator()->eraseFromParent();
+
+      // Determine if any lanes continue
+      Value *notBreakPhi = BinaryOperator::CreateNot(breakPhi, "", loop->sigmaBlock);
+      m_builder->SetInsertPoint(loop->sigmaBlock);
+      Value *anyContinue = m_builder->CreateSubgroupAny(notBreakPhi);
+
+      // Connect sigma block to wave header
+      BranchInst *loopEnd = BranchInst::Create(waveHeader, postSigmaBlock, anyContinue, loop->sigmaBlock);
+      loopEnd->setMetadata("llvm.loop", loopMetadata);
+
+      // Setup wave exit status in wave header
+      PHINode *waveExitPhi = PHINode::Create(m_builder->getInt1Ty(), wavePreds.size() + 1, "", waveHeader);
+      for (BasicBlock *block : wavePreds)
+        waveExitPhi->addIncoming(m_builder->getFalse(), block);
+      waveExitPhi->addIncoming(breakPhi, loop->sigmaBlock);
+
+      // Setup wave return status in wave header
+      PHINode *waveReturnPhi = nullptr;
+      if (loop->returnPhi) {
+        waveReturnPhi = PHINode::Create(m_builder->getInt1Ty(), wavePreds.size() + 1, "", waveHeader);
+        for (BasicBlock *block : wavePreds)
+          waveReturnPhi->addIncoming(m_builder->getFalse(), block);
+        waveReturnPhi->addIncoming(loop->returnPhi, loop->sigmaBlock);
+      }
+
+      // This is horrible hack to avoid SimplifyCFG from threading through wave header
+      // and rotating the loop:
+      // - Add an assembly call generated value (0) to wave header,
+      //   then use this value with similar assembly in the sigma block.
+      // This will not generate any instructions in the final shader.
+      Type *const int32Type = m_builder->getInt32Ty();
+      FunctionType *const idFuncType = FunctionType::get(int32Type, int32Type, false);
+      InlineAsm *const idFuncAsm = InlineAsm::get(idFuncType, "; %1", "=v,0", true);
+
+      m_builder->SetInsertPoint(waveHeader);
+      Value *headerValue = m_builder->CreateCall(idFuncAsm, m_builder->getInt32(0));
+      m_builder->SetInsertPoint(loop->sigmaBlock->getFirstNonPHIOrDbg());
+      m_builder->CreateCall(idFuncAsm, headerValue);
+
+      // Add wave header branch based on exit phi (new loop entry)
+      BranchInst *loopEntry = BranchInst::Create(loop->sigmaBlock, laneHeader, waveExitPhi, waveHeader);
+      loopEntry->setMetadata("llvm.loop", loopMetadata);
+
+      // Add wave header to break and return phis
+      breakPhi->addIncoming(m_builder->getTrue(), waveHeader);
+      if (waveReturnPhi)
+        loop->returnPhi->addIncoming(waveReturnPhi, waveHeader);
+
+      // Move PHIs in merge block to sigma block
+      Instruction *firstSigmaInst = &*loop->sigmaBlock->getFirstInsertionPt();
+      for (PHINode &mergePhi : make_early_inc_range(loop->mergeBlock->phis())) {
+        LLVM_DEBUG(dbgs() << "move phi: " << mergePhi << "\n");
+        mergePhi.moveBefore(firstSigmaInst);
+
+        // Add any missing predecessor references
+        Value *thisUndef = UndefValue::get(mergePhi.getType());
+        for (BasicBlock *block : predecessors(loop->sigmaBlock)) {
+          // FIXME: use poison here?
+          if (mergePhi.getBasicBlockIndex(block) == -1)
+            mergePhi.addIncoming(thisUndef, block);
+        }
+      }
+    }
+  }
+
+  m_convergentValues.clear();
+  return true;
+}
+
+} // namespace Llpc
+
+// =====================================================================================================================
+// Initializes the pass of SPIR-V lowering terminator operations..
+INITIALIZE_PASS(LegacySpirvLowerCfgMerges, DEBUG_TYPE, "Lower SPIR-V CFG merges", false, false)
diff --git a/llpc/lower/llpcSpirvLowerCfgMerges.h b/llpc/lower/llpcSpirvLowerCfgMerges.h
new file mode 100644
index 000000000..c72a355fd
--- /dev/null
+++ b/llpc/lower/llpcSpirvLowerCfgMerges.h
@@ -0,0 +1,70 @@
+/*
+ ***********************************************************************************************************************
+ *
+ *  Copyright (c) 2022 Advanced Micro Devices, Inc. All Rights Reserved.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy
+ *  of this software and associated documentation files (the "Software"), to deal
+ *  in the Software without restriction, including without limitation the rights
+ *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ *  copies of the Software, and to permit persons to whom the Software is
+ *  furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice shall be included in all
+ *  copies or substantial portions of the Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *  SOFTWARE.
+ *
+ **********************************************************************************************************************/
+/**
+ ***********************************************************************************************************************
+ * @file  llpcSpirvLowerCfgMerges.h
+ * @brief LLPC header file: contains declaration of Llpc::SpirvLowerCfgMerges
+ ***********************************************************************************************************************
+ */
+#pragma once
+
+#include "llpcSpirvLower.h"
+#include "llvm/IR/PassManager.h"
+
+namespace Llpc {
+
+// =====================================================================================================================
+// Represents the pass of SPIR-V lowering CFG merges.
+class SpirvLowerCfgMerges : public SpirvLower, public llvm::PassInfoMixin<SpirvLowerCfgMerges> {
+public:
+  llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
+  bool runImpl(llvm::Module &module);
+
+  void mapConvergentValues(llvm::Module &module);
+
+  static llvm::StringRef name() { return "Lower SPIR-V CFG merges"; }
+
+private:
+  llvm::DenseSet<llvm::Value *> m_convergentValues;
+};
+
+// =====================================================================================================================
+// Legacy pass manager wrapper class
+class LegacySpirvLowerCfgMerges : public llvm::ModulePass {
+public:
+  LegacySpirvLowerCfgMerges();
+
+  virtual bool runOnModule(llvm::Module &module);
+
+  static char ID; // ID of this pass
+
+private:
+  LegacySpirvLowerCfgMerges(const LegacySpirvLowerCfgMerges &) = delete;
+  LegacySpirvLowerCfgMerges &operator=(const LegacySpirvLowerCfgMerges &) = delete;
+
+  SpirvLowerCfgMerges Impl;
+};
+
+} // namespace Llpc
diff --git a/llpc/lower/llpcSpirvLowerGlobal.cpp b/llpc/lower/llpcSpirvLowerGlobal.cpp
index ff25bc76a..bce62a9a3 100644
--- a/llpc/lower/llpcSpirvLowerGlobal.cpp
+++ b/llpc/lower/llpcSpirvLowerGlobal.cpp
@@ -336,41 +336,31 @@ void SpirvLowerGlobal::handleCallInst(bool checkEmitCall, bool checkInterpCall)
             auxInterpValue = callInst->getArgOperand(1); // Sample ID
           } else if (mangledName.startswith(gSPIRVName::InterpolateAtOffset)) {
             interpLoc = InterpLocCenter;
             auxInterpValue = callInst->getArgOperand(1); // Offset from pixel center
           } else {
             assert(mangledName.startswith(gSPIRVName::InterpolateAtVertexAMD));
             interpLoc = InterpLocCustom;
             auxInterpValue = callInst->getArgOperand(1); // Vertex no.
           }
 
-          if (isa<GetElementPtrInst>(loadSrc)) {
+          GlobalVariable *gv = nullptr;
+          SmallVector<Value *, 6> indexOperands;
+          if (auto getElemPtr = dyn_cast<GetElementPtrInst>(loadSrc)) {
             // The interpolant is an element of the input
-            interpolateInputElement(interpLoc, auxInterpValue, *callInst);
+            for (auto &index : getElemPtr->indices())
+              indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
+            gv = cast<GlobalVariable>(getElemPtr->getPointerOperand());
           } else {
-            // The interpolant is an input
-            assert(isa<GlobalVariable>(loadSrc));
-
-            auto input = cast<GlobalVariable>(loadSrc);
-            auto inputTy = input->getValueType();
-
-            MDNode *metaNode = input->getMetadata(gSPIRVMD::InOut);
-            assert(metaNode);
-            auto inputMeta = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
-
-            m_builder->SetInsertPoint(callInst);
-            auto loadValue = addCallInstForInOutImport(inputTy, SPIRAS_Input, inputMeta, nullptr, 0, nullptr, nullptr,
-                                                       interpLoc, auxInterpValue, false);
-
-            m_interpCalls.insert(callInst);
-            callInst->replaceAllUsesWith(loadValue);
+            gv = cast<GlobalVariable>(loadSrc);
           }
+          interpolateInputElement(interpLoc, auxInterpValue, *callInst, gv, indexOperands);
         }
       }
     }
   }
 }
 
 // =====================================================================================================================
 // Check if the given metadata value has a vertex index.
 //
 // @param metaVal : Metadata
@@ -404,103 +394,61 @@ static bool hasPrimitiveIdx(const Constant &metaVal) {
   if (inOutMeta.IsBuiltIn) {
     unsigned builtInId = inOutMeta.Value;
     return (builtInId == spv::BuiltInPerPrimitive || builtInId == spv::BuiltInPrimitivePointIndicesEXT ||
             builtInId == spv::BuiltInPrimitiveLineIndicesEXT || builtInId == spv::BuiltInPrimitiveTriangleIndicesEXT);
   }
 
   return static_cast<bool>(inOutMeta.PerPrimitive);
 }
 
 // =====================================================================================================================
-// Handle a single "load" instruction directly loading a global.
+// Handle a single "load" instruction loading a global.
 //
+// @param inOut : Global Variable instruction
+// @param indexOperands : Indices of GEP instruction
 // @param loadInst : Load instruction
-// @param addrSpace : Address space
-void SpirvLowerGlobal::handleLoadInstGlobal(LoadInst &loadInst, const unsigned addrSpace) {
-  Value *loadSrc = loadInst.getOperand(0);
-  auto inOut = cast<GlobalVariable>(loadSrc);
-  auto inOutTy = inOut->getValueType();
+void SpirvLowerGlobal::handleLoadInstGEP(GlobalVariable *inOut, ArrayRef<Value *> indexOperands, LoadInst &loadInst) {
 
-  const bool isTaskPayload = addrSpace == SPIRAS_TaskPayload;
-  MDNode *metaNode = inOut->getMetadata(isTaskPayload ? gSPIRVMD::Block : gSPIRVMD::InOut);
-  assert(metaNode);
-  auto inOutMetaVal = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
+  assert(indexOperands.empty() || cast<ConstantInt>(indexOperands.front())->isZero() && "Non-zero GEP first index\n");
+  if (!indexOperands.empty())
+    indexOperands = indexOperands.drop_front();
 
   m_builder->SetInsertPoint(&loadInst);
 
-  Value *loadValue = UndefValue::get(inOutTy);
-
-  // If the input/output is arrayed, the outermost index might be used for vertex indexing
-  if (!isTaskPayload && inOutTy->isArrayTy() && hasVertexIdx(*inOutMetaVal)) {
-    auto elemTy = inOutTy->getArrayElementType();
-    auto elemMeta = cast<Constant>(inOutMetaVal->getOperand(1));
-
-    const unsigned elemCount = inOutTy->getArrayNumElements();
-    for (unsigned i = 0; i < elemCount; ++i) {
-      Value *vertexIdx = m_builder->getInt32(i);
-      auto elemValue = addCallInstForInOutImport(elemTy, addrSpace, elemMeta, nullptr, 0, nullptr, vertexIdx,
-                                                 InterpLocUnknown, nullptr, false);
-      loadValue = m_builder->CreateInsertValue(loadValue, elemValue, {i});
-    }
-  } else if (isTaskPayload) {
-    loadValue = loadValueFromTaskPayload(inOutTy, inOutMetaVal, nullptr);
-  } else {
-    loadValue = addCallInstForInOutImport(inOutTy, addrSpace, inOutMetaVal, nullptr, 0, nullptr, nullptr,
-                                          InterpLocUnknown, nullptr, false);
-  }
-  m_loadInsts.insert(&loadInst);
-  loadInst.replaceAllUsesWith(loadValue);
-}
-
-// =====================================================================================================================
-// Handle a single "load" instruction loading a global through a GEP instruction
-//
-// @param getElemPtr : Load source GEP instruction
-// @param loadInst : Load instruction
-// @param addrSpace : Address space
-void SpirvLowerGlobal::handleLoadInstGEP(GetElementPtrInst *const getElemPtr, LoadInst &loadInst,
-                                         const unsigned addrSpace) {
-  std::vector<Value *> indexOperands;
-
-  assert(cast<ConstantInt>(getElemPtr->getOperand(1))->isZero() && "Non-zero GEP first index\n");
-
-  GlobalVariable *inOut = cast<GlobalVariable>(getElemPtr->getPointerOperand());
-  assert(!isa<GetElementPtrInst>(getElemPtr->getPointerOperand()) &&
-         "Chained GEPs should have been coalesced by SpirvLowerAccessChain.");
-
-  m_builder->SetInsertPoint(&loadInst);
-
-  for (auto &index : drop_begin(getElemPtr->indices()))
-    indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
-
   Value *vertexIdx = nullptr;
   auto inOutTy = inOut->getValueType();
 
+  auto addrSpace = inOut->getType()->getPointerAddressSpace();
+
   const bool isTaskPayload = addrSpace == SPIRAS_TaskPayload;
   MDNode *metaNode = inOut->getMetadata(isTaskPayload ? gSPIRVMD::Block : gSPIRVMD::InOut);
   assert(metaNode);
   auto inOutMetaVal = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
 
   // If the input/output is arrayed, the outermost index might be used for vertex indexing
   if (!isTaskPayload && inOutTy->isArrayTy() && hasVertexIdx(*inOutMetaVal)) {
+    if (!indexOperands.empty()) {
+      vertexIdx = indexOperands.front();
+      indexOperands = indexOperands.drop_front();
+    } else if (inOutTy != loadInst.getType()) {
+      vertexIdx = m_builder->getInt32(0);
+    }
     inOutTy = inOutTy->getArrayElementType();
-    vertexIdx = indexOperands.front();
-    indexOperands.erase(indexOperands.begin());
     inOutMetaVal = cast<Constant>(inOutMetaVal->getOperand(1));
   }
 
   Value *loadValue = nullptr;
   if (isTaskPayload) {
-    loadValue = loadIndexedValueFromTaskPayload(inOutTy, indexOperands, inOutMetaVal, nullptr);
+    loadValue = loadIndexedValueFromTaskPayload(inOutTy, loadInst.getType(), indexOperands, inOutMetaVal, nullptr);
   } else {
-    loadValue = loadInOutMember(inOutTy, addrSpace, indexOperands, 0, inOutMetaVal, nullptr, vertexIdx,
-                                InterpLocUnknown, nullptr, false);
+    loadValue = loadInOutMember(inOutTy, loadInst.getType(), addrSpace, indexOperands, 0, inOutMetaVal, nullptr,
+                                vertexIdx, InterpLocUnknown, nullptr, false);
   }
 
   m_loadInsts.insert(&loadInst);
   loadInst.replaceAllUsesWith(loadValue);
 }
 
 // =====================================================================================================================
 // Handle "load" instructions.
 void SpirvLowerGlobal::handleLoadInst() {
   auto shouldHandle = [&](const unsigned addrSpace) {
@@ -515,144 +463,114 @@ void SpirvLowerGlobal::handleLoadInst() {
         (m_shaderStage == ShaderStageMesh && (addrSpace == SPIRAS_Input || addrSpace == SPIRAS_TaskPayload));
 
     return isTcsInput || isTcsOutput || isTesInput || isTaskOutput || isMeshInput;
   };
 
   for (GlobalVariable &global : m_module->globals()) {
     const unsigned addrSpace = global.getType()->getPointerAddressSpace();
     if (!shouldHandle(addrSpace))
       continue;
     for (User *user : global.users()) {
-      if (LoadInst *loadInst = dyn_cast<LoadInst>(user))
-        // The user is a load
-        handleLoadInstGlobal(*loadInst, addrSpace);
-      else if (GetElementPtrInst *gep = dyn_cast<GetElementPtrInst>(user)) {
+      if (LoadInst *loadInst = dyn_cast<LoadInst>(user)) {
+        handleLoadInstGEP(&global, {}, *loadInst);
+      } else if (GetElementPtrInst *gep = dyn_cast<GetElementPtrInst>(user)) {
         // The user is a GEP
         // We look for load instructions in the GEP users
         for (User *gepUser : gep->users()) {
           // We shouldn't have any chained GEPs here, they are coalesced by the LowerAccessChain pass.
           assert(!isa<GetElementPtrInst>(gepUser));
-          if (LoadInst *loadInst = dyn_cast<LoadInst>(gepUser))
-            handleLoadInstGEP(gep, *loadInst, addrSpace);
+          if (LoadInst *loadInst = dyn_cast<LoadInst>(gepUser)) {
+            SmallVector<Value *, 6> indexOperands;
+            for (auto &index : gep->indices())
+              indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
+            handleLoadInstGEP(&global, indexOperands, *loadInst);
+          }
         }
       }
     }
   }
 }
 
 // =====================================================================================================================
-// Handle a single "store" instruction directly storing a global.
+// Handle a single "store" instruction storing a global.
 //
+// @param output : Global Variable instruction
+// @param indexOperands : Indices of GEP instruction
 // @param storeInst : Store instruction
-void SpirvLowerGlobal::handleStoreInstGlobal(StoreInst &storeInst) {
-  Value *storeDest = storeInst.getOperand(1);
-  Value *storeValue = storeInst.getOperand(0);
-
-  auto output = cast<GlobalVariable>(storeDest);
-  auto outputy = output->getValueType();
+void SpirvLowerGlobal::handleStoreInstGEP(GlobalVariable *output, ArrayRef<Value *> indexOperands,
+                                          StoreInst &storeInst) {
+  assert(indexOperands.empty() || cast<ConstantInt>(indexOperands.front())->isZero() && "Non-zero GEP first index\n");
+  // drop first element
+  if (!indexOperands.empty())
+    indexOperands = indexOperands.drop_front();
 
   m_builder->SetInsertPoint(&storeInst);
 
-  const bool isTaskPayload = output->getType()->getAddressSpace() == SPIRAS_TaskPayload;
-  MDNode *metaNode = output->getMetadata(isTaskPayload ? gSPIRVMD::Block : gSPIRVMD::InOut);
-  assert(metaNode);
-  auto outputMetaVal = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
-
-  // If the output is arrayed, the outermost dimension might for vertex or primitive indexing
-  if (!isTaskPayload && outputy->isArrayTy() && (hasVertexIdx(*outputMetaVal) || hasPrimitiveIdx(*outputMetaVal))) {
-    auto elemMeta = cast<Constant>(outputMetaVal->getOperand(1));
-
-    const unsigned elemCount = outputy->getArrayNumElements();
-    for (unsigned i = 0; i < elemCount; ++i) {
-      auto elemValue = ExtractValueInst::Create(storeValue, {i}, "", &storeInst);
-      Value *vertexOrPrimitiveIdx = ConstantInt::get(Type::getInt32Ty(*m_context), i);
-      addCallInstForOutputExport(elemValue, elemMeta, nullptr, 0, InvalidValue, 0, nullptr, vertexOrPrimitiveIdx,
-                                 InvalidValue);
-    }
-  } else if (isTaskPayload) {
-    storeValueToTaskPayload(storeValue, outputMetaVal, nullptr);
-  } else {
-    addCallInstForOutputExport(storeValue, outputMetaVal, nullptr, 0, InvalidValue, 0, nullptr, nullptr, InvalidValue);
-  }
-  m_storeInsts.insert(&storeInst);
-}
-
-// =====================================================================================================================
-// Handle a single "store" instruction storing a global through a GEP instruction
-//
-// @param getElemPtr : Store destination GEP instruction
-// @param storeInst : Store instruction
-void SpirvLowerGlobal::handleStoreInstGEP(GetElementPtrInst *const getElemPtr, StoreInst &storeInst) {
   Value *storeValue = storeInst.getOperand(0);
-
-  std::vector<Value *> indexOperands;
-
-  assert(cast<ConstantInt>(getElemPtr->getOperand(1))->isZero() && "Non-zero GEP first index\n");
-
-  GlobalVariable *output = cast<GlobalVariable>(getElemPtr->getPointerOperand());
-  assert(!isa<GetElementPtrInst>(getElemPtr->getPointerOperand()) &&
-         "Chained GEPs should have been coalesced by SpirvLowerAccessChain.");
-
-  m_builder->SetInsertPoint(&storeInst);
-
-  for (auto &index : drop_begin(getElemPtr->indices()))
-    indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
-
   Value *vertexOrPrimitiveIdx = nullptr;
   auto outputTy = output->getValueType();
 
   const bool isTaskPayload = output->getType()->getAddressSpace() == SPIRAS_TaskPayload;
   MDNode *metaNode = output->getMetadata(isTaskPayload ? gSPIRVMD::Block : gSPIRVMD::InOut);
   assert(metaNode);
   auto outputMetaVal = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
   // If the output is arrayed, the outermost index might be used for vertex or primitive indexing
   if (!isTaskPayload && outputTy->isArrayTy() && (hasVertexIdx(*outputMetaVal) || hasPrimitiveIdx(*outputMetaVal))) {
+    if (!indexOperands.empty()) {
+      vertexOrPrimitiveIdx = indexOperands.front();
+      indexOperands = indexOperands.drop_front();
+    } else if (outputTy != storeInst.getValueOperand()->getType()) {
+      vertexOrPrimitiveIdx = m_builder->getInt32(0);
+    }
     outputTy = outputTy->getArrayElementType();
-    vertexOrPrimitiveIdx = indexOperands.front();
-    indexOperands.erase(indexOperands.begin());
     outputMetaVal = cast<Constant>(outputMetaVal->getOperand(1));
   }
 
   if (isTaskPayload)
-    storeIndexedValueToTaskPayload(outputTy, storeValue, indexOperands, outputMetaVal, nullptr);
+    storeIndexedValueToTaskPayload(outputTy, storeInst.getValueOperand()->getType(), storeValue, indexOperands,
+                                   outputMetaVal, nullptr);
   else
-    storeOutputMember(outputTy, storeValue, indexOperands, 0, outputMetaVal, nullptr, vertexOrPrimitiveIdx);
+    storeOutputMember(outputTy, storeInst.getValueOperand()->getType(), storeValue, indexOperands, 0, outputMetaVal,
+                      nullptr, vertexOrPrimitiveIdx);
 
   m_storeInsts.insert(&storeInst);
 }
 
 // =====================================================================================================================
 // Visits "store" instructions.
 void SpirvLowerGlobal::handleStoreInst() {
   auto shouldHandle = [&](const unsigned addrSpace) {
     const bool isTcsOutput = (m_shaderStage == ShaderStageTessControl && addrSpace == SPIRAS_Output);
     const bool isTaskOutput = (m_shaderStage == ShaderStageTask && addrSpace == SPIRAS_TaskPayload);
     const bool isMeshOutput = (m_shaderStage == ShaderStageMesh && addrSpace == SPIRAS_Output);
     return isTcsOutput || isTaskOutput || isMeshOutput;
   };
 
   for (GlobalVariable &global : m_module->globals()) {
     const unsigned addrSpace = global.getType()->getPointerAddressSpace();
     if (!shouldHandle(addrSpace))
       continue;
     for (User *user : global.users()) {
-      if (StoreInst *storeInst = dyn_cast<StoreInst>(user))
-        // The user is a store
-        handleStoreInstGlobal(*storeInst);
-      else if (GetElementPtrInst *gep = dyn_cast<GetElementPtrInst>(user)) {
+      if (StoreInst *storeInst = dyn_cast<StoreInst>(user)) {
+        handleStoreInstGEP(&global, {}, *storeInst);
+      } else if (GetElementPtrInst *gep = dyn_cast<GetElementPtrInst>(user)) {
         // The user is a GEP
         // We look for store instructions in the GEP users
         for (User *gepUser : gep->users()) {
           // We shouldn't have any chained GEPs here, they are coalesced by the LowerAccessChain pass.
           assert(!isa<GetElementPtrInst>(gepUser));
-          if (StoreInst *storeInst = dyn_cast<StoreInst>(gepUser))
-            handleStoreInstGEP(gep, *storeInst);
+          if (StoreInst *storeInst = dyn_cast<StoreInst>(gepUser)) {
+            SmallVector<Value *, 6> indexOperands;
+            for (auto &index : gep->indices())
+              indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
+            handleStoreInstGEP(&global, indexOperands, *storeInst);
+          }
         }
       }
     }
   }
 }
 
 // =====================================================================================================================
 // Visits "atomicrmw" or "cmpxchg" instructions.
 void SpirvLowerGlobal::handleAtomicInst() {
   auto shouldHandle = [&](const unsigned addrSpace) {
@@ -1512,21 +1430,21 @@ void SpirvLowerGlobal::addCallInstForOutputExport(Value *outputValue, Constant *
           EnableXfb = true;
         }
 
         auto builtInName = getNameMap(static_cast<BuiltIn>(builtInId)).map(static_cast<BuiltIn>(builtInId));
         LLPC_OUTS(*outputValue->getType() << " (builtin = " << builtInName.substr(strlen("BuiltIn")) << "), "
                                           << "xfbBuffer = " << outputMeta.XfbBuffer << ", "
                                           << "xfbStride = " << outputMeta.XfbStride << ", "
                                           << "xfbOffset = " << cast<ConstantInt>(xfbOffset)->getZExtValue() << "\n");
       }
 
-      if (builtInId == BuiltInCullPrimitiveEXT && outputTy->isIntegerTy(32)) {
+      if (builtInId == lgc::BuiltInCullPrimitive && outputTy->isIntegerTy(32)) {
         // NOTE: In SPIR-V translation, the boolean type (i1) in output block is converted to i32. Here, we convert it
         // back to i1 for further processing in LGC.
         outputValue = m_builder->CreateTrunc(outputValue, m_builder->getInt1Ty());
       }
       m_builder->CreateWriteBuiltInOutput(outputValue, builtInId, outputInfo, vertexOrPrimitiveIdx, elemIdx);
       return;
     }
 
     unsigned location = outputMeta.Value + outputMeta.Index;
     assert((outputMeta.Index == 1 && outputMeta.Value == 0) || outputMeta.Index == 0);
@@ -1675,273 +1593,297 @@ Value *SpirvLowerGlobal::loadDynamicIndexedMembers(Type *inOutTy, unsigned addrS
 
   // Simple scalar type
   return addCallInstForInOutImport(inOutTy, addrSpace, inOutMetaVal, locOffset, 0, nullptr, nullptr, interpLoc,
                                    auxInterpValue, isPerVertexDimension);
 }
 
 // =====================================================================================================================
 // Inserts instructions to load value from input/ouput member.
 //
 // @param inOutTy : Type of this input/output member
+// @param loadTy : Type of load instruction
 // @param addrSpace : Address space
-// @param indexOperands : Index operands to process (if empty, all indices have been processed)
+// @param indexOperands : Index operands to process.
 // @param maxLocOffset : Max+1 location offset if variable index has been encountered
 // @param inOutMetaVal : Metadata of this input/output member
 // @param locOffset : Relative location offset of this input/output member
 // @param vertexIdx : Input/output array outermost index used for vertex indexing
 // @param interpLoc : Interpolation location, valid for fragment shader (use "InterpLocUnknown" as don't-care value)
 // @param auxInterpValue : Auxiliary value of interpolation (valid for fragment shader): - Sample ID for
 // "InterpLocSample" - Offset from the center of the pixel for "InterpLocCenter" - Vertex no. (0 ~ 2) for
 // "InterpLocCustom"
-Value *SpirvLowerGlobal::loadInOutMember(Type *inOutTy, unsigned addrSpace, ArrayRef<Value *> indexOperands,
-                                         unsigned maxLocOffset, Constant *inOutMetaVal, Value *locOffset,
-                                         Value *vertexIdx, unsigned interpLoc, Value *auxInterpValue,
+Value *SpirvLowerGlobal::loadInOutMember(Type *inOutTy, Type *loadTy, unsigned addrSpace,
+                                         ArrayRef<Value *> indexOperands, unsigned maxLocOffset, Constant *inOutMetaVal,
+                                         Value *locOffset, Value *vertexIdx, unsigned interpLoc, Value *auxInterpValue,
                                          bool isPerVertexDimension) {
   assert(m_shaderStage == ShaderStageTessControl || m_shaderStage == ShaderStageTessEval ||
          m_shaderStage == ShaderStageMesh || m_shaderStage == ShaderStageFragment);
 
-  if (indexOperands.empty()) {
+  // indexOperands can be empty with mismatch of types, if zero-index GEP was removed and global is used directly by
+  // load.
+  if (indexOperands.empty() && inOutTy == loadTy) {
     // All indices have been processed
     return addCallInstForInOutImport(inOutTy, addrSpace, inOutMetaVal, locOffset, maxLocOffset, nullptr, vertexIdx,
                                      interpLoc, auxInterpValue, isPerVertexDimension);
   }
 
   if (inOutTy->isArrayTy()) {
     // Array type
     assert(inOutMetaVal->getNumOperands() == 4);
     ShaderInOutMetadata inOutMeta = {};
 
     inOutMeta.U64All[0] = cast<ConstantInt>(inOutMetaVal->getOperand(2))->getZExtValue();
     inOutMeta.U64All[1] = cast<ConstantInt>(inOutMetaVal->getOperand(3))->getZExtValue();
 
     auto elemMeta = cast<Constant>(inOutMetaVal->getOperand(1));
     auto elemTy = inOutTy->getArrayElementType();
 
     if (inOutMeta.IsBuiltIn) {
-      assert(indexOperands.size() == 1);
-      auto elemIdx = indexOperands.front();
+      auto elemIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
       return addCallInstForInOutImport(elemTy, addrSpace, elemMeta, locOffset, inOutTy->getArrayNumElements(), elemIdx,
                                        vertexIdx, interpLoc, auxInterpValue, isPerVertexDimension);
     }
 
     // NOTE: If the relative location offset is not specified, initialize it to 0.
     if (!locOffset)
       locOffset = m_builder->getInt32(0);
 
     Value *elemLocOffset = nullptr;
 
     if (inOutMeta.PerVertexDimension) {
       // The input is a pervertex variable. The location offset is 0.
       assert(inOutMeta.InterpMode == InterpModeCustom);
-      auxInterpValue = indexOperands.front();
+      auxInterpValue = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
       elemLocOffset = m_builder->getInt32(0);
     } else {
       // elemLocOffset = locOffset + stride * elemIdx
       unsigned stride = cast<ConstantInt>(inOutMetaVal->getOperand(0))->getZExtValue();
-      auto elemIdx = indexOperands.front();
+      auto elemIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
       elemLocOffset = m_builder->CreateMul(m_builder->getInt32(stride), elemIdx);
       elemLocOffset = m_builder->CreateAdd(locOffset, elemLocOffset);
 
       // Mark the end+1 possible location offset if the index is variable. The Builder call needs it
       // so it knows how many locations to mark as used by this access.
       if (maxLocOffset == 0 && !isa<ConstantInt>(elemIdx)) {
         maxLocOffset = cast<ConstantInt>(locOffset)->getZExtValue() + stride * inOutTy->getArrayNumElements();
       }
     }
 
-    return loadInOutMember(elemTy, addrSpace, indexOperands.drop_front(), maxLocOffset, elemMeta, elemLocOffset,
-                           vertexIdx, interpLoc, auxInterpValue, inOutMeta.PerVertexDimension);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return loadInOutMember(elemTy, loadTy, addrSpace, indexOperands, maxLocOffset, elemMeta, elemLocOffset, vertexIdx,
+                           interpLoc, auxInterpValue, inOutMeta.PerVertexDimension);
   }
 
   if (inOutTy->isStructTy()) {
     // Struct type
-    unsigned memberIdx = cast<ConstantInt>(indexOperands.front())->getZExtValue();
+    unsigned memberIdx = indexOperands.empty() ? 0 : cast<ConstantInt>(indexOperands.front())->getZExtValue();
 
     auto memberTy = inOutTy->getStructElementType(memberIdx);
     auto memberMeta = cast<Constant>(inOutMetaVal->getOperand(memberIdx));
 
-    return loadInOutMember(memberTy, addrSpace, indexOperands.drop_front(), maxLocOffset, memberMeta, locOffset,
-                           vertexIdx, interpLoc, auxInterpValue, isPerVertexDimension);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return loadInOutMember(memberTy, loadTy, addrSpace, indexOperands, maxLocOffset, memberMeta, locOffset, vertexIdx,
+                           interpLoc, auxInterpValue, isPerVertexDimension);
   }
 
   if (inOutTy->isVectorTy()) {
     // Vector type
-    assert(indexOperands.size() == 1);
-
     Type *loadTy = cast<VectorType>(inOutTy)->getElementType();
-    Value *compIdx = indexOperands.front();
+    Value *compIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
 
     return addCallInstForInOutImport(loadTy, addrSpace, inOutMetaVal, locOffset, maxLocOffset, compIdx, vertexIdx,
                                      interpLoc, auxInterpValue, isPerVertexDimension);
   }
 
   llvm_unreachable("Should never be called!");
   return nullptr;
 }
 
 // =====================================================================================================================
 // Inserts instructions to store value to output member.
 //
 // @param outputTy : Type of this output member
+// @param storeTy : Type of store instruction
 // @param storeValue : Value stored to output member
 // @param indexOperands : Index operands to process (if empty, all indices have been processed)
 // @param maxLocOffset : Max+1 location offset if variable index has been encountered
 // @param outputMetaVal : Metadata of this output member
 // @param locOffset : Relative location offset of this output member
 // @param vertexOrPrimitiveIdx : Input array outermost index used for vertex indexing
-void SpirvLowerGlobal::storeOutputMember(Type *outputTy, Value *storeValue, ArrayRef<Value *> indexOperands,
-                                         unsigned maxLocOffset, Constant *outputMetaVal, Value *locOffset,
-                                         Value *vertexOrPrimitiveIdx) {
+void SpirvLowerGlobal::storeOutputMember(Type *outputTy, Type *storeTy, Value *storeValue,
+                                         ArrayRef<Value *> indexOperands, unsigned maxLocOffset,
+                                         Constant *outputMetaVal, Value *locOffset, Value *vertexOrPrimitiveIdx) {
   assert(m_shaderStage == ShaderStageTessControl || m_shaderStage == ShaderStageMesh);
 
-  if (indexOperands.empty()) {
+  // indexOperands can be empty with mismatch of types, if zero-index GEP was removed and global is used directly by
+  // store.
+  if (indexOperands.empty() && outputTy == storeTy) {
     // All indices have been processed
     return addCallInstForOutputExport(storeValue, outputMetaVal, locOffset, maxLocOffset, InvalidValue, 0, nullptr,
                                       vertexOrPrimitiveIdx, InvalidValue);
   }
 
   if (outputTy->isArrayTy()) {
     assert(outputMetaVal->getNumOperands() == 4);
     ShaderInOutMetadata outputMeta = {};
 
     outputMeta.U64All[0] = cast<ConstantInt>(outputMetaVal->getOperand(2))->getZExtValue();
     outputMeta.U64All[1] = cast<ConstantInt>(outputMetaVal->getOperand(3))->getZExtValue();
 
     auto elemMeta = cast<Constant>(outputMetaVal->getOperand(1));
     auto elemTy = outputTy->getArrayElementType();
 
     if (outputMeta.IsBuiltIn) {
       assert(!locOffset);
-      assert(indexOperands.size() == 1);
+      assert(indexOperands.empty() || indexOperands.size() == 1);
 
-      auto elemIdx = indexOperands.front();
+      auto elemIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
       return addCallInstForOutputExport(storeValue, elemMeta, nullptr, outputTy->getArrayNumElements(), InvalidValue, 0,
                                         elemIdx, vertexOrPrimitiveIdx, InvalidValue);
     }
 
     // NOTE: If the relative location offset is not specified, initialize it.
     if (!locOffset)
       locOffset = m_builder->getInt32(0);
 
     // elemLocOffset = locOffset + stride * elemIdx
     unsigned stride = cast<ConstantInt>(outputMetaVal->getOperand(0))->getZExtValue();
-    auto elemIdx = indexOperands.front();
+    auto elemIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
     Value *elemLocOffset = m_builder->CreateMul(m_builder->getInt32(stride), elemIdx);
     elemLocOffset = m_builder->CreateAdd(locOffset, elemLocOffset);
 
     // Mark the end+1 possible location offset if the index is variable. The Builder call needs it
     // so it knows how many locations to mark as used by this access.
     if (maxLocOffset == 0 && !isa<ConstantInt>(elemIdx)) {
       maxLocOffset = cast<ConstantInt>(locOffset)->getZExtValue() + stride * outputTy->getArrayNumElements();
     }
 
-    return storeOutputMember(elemTy, storeValue, indexOperands.drop_front(), maxLocOffset, elemMeta, elemLocOffset,
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return storeOutputMember(elemTy, storeTy, storeValue, indexOperands, maxLocOffset, elemMeta, elemLocOffset,
                              vertexOrPrimitiveIdx);
   }
 
   if (outputTy->isStructTy()) {
     // Structure type
-    unsigned memberIdx = cast<ConstantInt>(indexOperands.front())->getZExtValue();
+    unsigned memberIdx = indexOperands.empty() ? 0 : cast<ConstantInt>(indexOperands.front())->getZExtValue();
 
     auto memberTy = outputTy->getStructElementType(memberIdx);
     auto memberMeta = cast<Constant>(outputMetaVal->getOperand(memberIdx));
 
-    return storeOutputMember(memberTy, storeValue, indexOperands.drop_front(), maxLocOffset, memberMeta, locOffset,
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return storeOutputMember(memberTy, storeTy, storeValue, indexOperands, maxLocOffset, memberMeta, locOffset,
                              vertexOrPrimitiveIdx);
   }
 
   if (outputTy->isVectorTy()) {
     // Vector type
-    assert(indexOperands.size() == 1);
-    auto compIdx = indexOperands.front();
+    assert(indexOperands.empty() || indexOperands.size() == 1);
+    auto compIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
 
     return addCallInstForOutputExport(storeValue, outputMetaVal, locOffset, maxLocOffset, InvalidValue, 0, compIdx,
                                       vertexOrPrimitiveIdx, InvalidValue);
   }
 
   llvm_unreachable("Should never be called!");
 }
 
 // =====================================================================================================================
 // Loads indexed value from task payload.
 //
 // @param indexedTy : Current indexed type in processing when we traverse the index operands
-// @param indexOperands : Index operands to process (if empty, all indices have been processed)
+// @param loadTy : Type of load instruction
+// @param indexOperands : Index operands to process
 // @param metadata : Metadata corresponding to current indexed type
 // @param extraByteOffset : Extra byte offset resulting from indexed access of part of task payload (could be null)
 // @returns : The indexed value loaded from task payload
-Value *SpirvLowerGlobal::loadIndexedValueFromTaskPayload(Type *indexedTy, ArrayRef<Value *> indexOperands,
+Value *SpirvLowerGlobal::loadIndexedValueFromTaskPayload(Type *indexedTy, Type *loadTy, ArrayRef<Value *> indexOperands,
                                                          Constant *metadata, Value *extraByteOffset) {
   assert(m_shaderStage == ShaderStageTask || m_shaderStage == ShaderStageMesh);
 
-  if (indexOperands.empty()) {
+  // indexOperands can be empty with mismatch of types, if zero-index GEP was removed and global is used directly by
+  // load.
+  if (indexOperands.empty() && indexedTy == loadTy) {
     // All indices have been processed
     return loadValueFromTaskPayload(indexedTy, metadata, extraByteOffset);
   }
 
   if (indexedTy->isArrayTy()) {
     // Array type
     assert(metadata->getNumOperands() == 3);
 
-    ShaderBlockMetadata arrayMeta = {};
-    arrayMeta.U64All = cast<ConstantInt>(metadata->getOperand(1))->getZExtValue();
-
     auto elemMeta = cast<Constant>(metadata->getOperand(2));
     auto elemTy = indexedTy->getArrayElementType();
 
     // extraByteOffset += stride * elemIdx
     unsigned stride = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
-    auto elemIdx = indexOperands.front();
+    auto elemIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
     if (extraByteOffset) {
       extraByteOffset =
           m_builder->CreateAdd(extraByteOffset, m_builder->CreateMul(m_builder->getInt32(stride), elemIdx));
     } else {
       extraByteOffset = m_builder->CreateMul(m_builder->getInt32(stride), elemIdx);
     }
 
-    return loadIndexedValueFromTaskPayload(elemTy, indexOperands.drop_front(), elemMeta, extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return loadIndexedValueFromTaskPayload(elemTy, loadTy, indexOperands, elemMeta, extraByteOffset);
   } else if (indexedTy->isStructTy()) {
     // Structure type
     ShaderBlockMetadata structMeta = {};
     structMeta.U64All = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
     if (structMeta.offset > 0) {
       if (extraByteOffset)
         extraByteOffset = m_builder->CreateAdd(extraByteOffset, m_builder->getInt32(structMeta.offset));
       else
         extraByteOffset = m_builder->getInt32(structMeta.offset);
     }
 
     auto membersMeta = cast<Constant>(metadata->getOperand(1));
-    unsigned memberIdx = cast<ConstantInt>(indexOperands.front())->getZExtValue();
+    unsigned memberIdx = indexOperands.empty() ? 0 : cast<ConstantInt>(indexOperands.front())->getZExtValue();
 
     auto memberTy = indexedTy->getStructElementType(memberIdx);
     auto memberMeta = isa<ConstantAggregateZero>(membersMeta)
                           ? cast<ConstantAggregateZero>(membersMeta)->getStructElement(memberIdx)
                           : cast<Constant>(membersMeta->getOperand(memberIdx));
 
-    return loadIndexedValueFromTaskPayload(memberTy, indexOperands.drop_front(), memberMeta, extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return loadIndexedValueFromTaskPayload(memberTy, loadTy, indexOperands, memberMeta, extraByteOffset);
   } else if (indexedTy->isVectorTy()) {
     // Vector type
-    assert(indexOperands.size() == 1);
+    assert(indexOperands.empty() || indexOperands.size() == 1);
     auto compTy = indexedTy->getScalarType();
 
     // extraByteOffset += compByteSize * compIdx
     unsigned compByteSize = indexedTy->getScalarSizeInBits() / 8;
-    auto compIdx = indexOperands.front();
+    auto compIdx = indexOperands.empty() ? m_builder->getInt32(0) : indexOperands.front();
     if (extraByteOffset) {
       extraByteOffset =
           m_builder->CreateAdd(extraByteOffset, m_builder->CreateMul(m_builder->getInt32(compByteSize), compIdx));
     } else {
       extraByteOffset = m_builder->CreateMul(m_builder->getInt32(compByteSize), compIdx);
     }
 
-    return loadIndexedValueFromTaskPayload(compTy, indexOperands.drop_front(), metadata, extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return loadIndexedValueFromTaskPayload(compTy, loadTy, indexOperands, metadata, extraByteOffset);
   }
 
   llvm_unreachable("Should never be called!");
 }
 
 // =====================================================================================================================
 // Loads value from task payload.
 //
 // @param storeValue : Value to store
 // @param metadata : Metadata corresponding to the task payload
@@ -1949,23 +1891,20 @@ Value *SpirvLowerGlobal::loadIndexedValueFromTaskPayload(Type *indexedTy, ArrayR
 // @returns : The value loaded from task payload
 Value *SpirvLowerGlobal::loadValueFromTaskPayload(Type *loadTy, Constant *metadata, Value *extraByteOffset) {
   assert(m_shaderStage == ShaderStageTask || m_shaderStage == ShaderStageMesh);
 
   Value *loadValue = UndefValue::get(loadTy);
 
   if (loadTy->isArrayTy()) {
     // Array type
     assert(metadata->getNumOperands() == 3);
 
-    ShaderBlockMetadata arrayMeta = {};
-    arrayMeta.U64All = cast<ConstantInt>(metadata->getOperand(1))->getZExtValue();
-
     unsigned stride = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
     auto elemMeta = cast<Constant>(metadata->getOperand(2));
     auto elemTy = loadTy->getArrayElementType();
 
     for (unsigned elemIdx = 0; elemIdx < loadTy->getArrayNumElements(); ++elemIdx) {
       // Handle array elements recursively
 
       // elemExtraByteOffset = extraByteOffset + stride * elemIdx
       Value *elemExtraByteOffset = nullptr;
       if (extraByteOffset)
@@ -2012,115 +1951,122 @@ Value *SpirvLowerGlobal::loadValueFromTaskPayload(Type *loadTy, Constant *metada
     loadValue = m_builder->CreateReadTaskPayload(loadTy, byteOffset);
   }
 
   return loadValue;
 }
 
 // =====================================================================================================================
 // Stores indexed value to task payload.
 //
 // @param indexedTy : Current indexed type in processing when we traverse the index operands
+// @param storeTy : Type of store instruction
 // @param storeValue : Value to store
-// @param indexOperands : Index operands to process (if empty, all indices have been processed)
+// @param indexOperands : Index operands to process
 // @param metadata : Metadata corresponding to current indexed type
 // @param extraByteOffset : Extra byte offset resulting from indexed access of part of task payload (could be null)
-void SpirvLowerGlobal::storeIndexedValueToTaskPayload(Type *indexedTy, Value *storeValue,
+void SpirvLowerGlobal::storeIndexedValueToTaskPayload(Type *indexedTy, Type *storeTy, Value *storeValue,
                                                       ArrayRef<Value *> indexOperands, Constant *metadata,
                                                       Value *extraByteOffset) {
   assert(m_shaderStage == ShaderStageTask);
 
-  if (indexOperands.empty()) {
+  // indexOperands can be empty with mismatch of types, if zero-index GEP was removed and global is used directly by
+  // store.
+  if (indexOperands.empty() && indexedTy == storeTy) {
     // All indices have been processed
     return storeValueToTaskPayload(storeValue, metadata, extraByteOffset);
   }
 
+  auto zero = m_builder->getInt32(0);
+
   if (indexedTy->isArrayTy()) {
     // Array type
     assert(metadata->getNumOperands() == 3);
 
-    ShaderBlockMetadata arrayMeta = {};
-    arrayMeta.U64All = cast<ConstantInt>(metadata->getOperand(1))->getZExtValue();
-
     auto elemMeta = cast<Constant>(metadata->getOperand(2));
     auto elemTy = indexedTy->getArrayElementType();
 
     // extraByteOffset += stride * elemIdx
     unsigned stride = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
-    auto elemIdx = indexOperands.front();
+    auto elemIdx = indexOperands.empty() ? zero : indexOperands.front();
     if (extraByteOffset) {
       extraByteOffset =
           m_builder->CreateAdd(extraByteOffset, m_builder->CreateMul(m_builder->getInt32(stride), elemIdx));
     } else {
       extraByteOffset = m_builder->CreateMul(m_builder->getInt32(stride), elemIdx);
     }
 
-    return storeIndexedValueToTaskPayload(elemTy, storeValue, indexOperands.drop_front(), elemMeta, extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return storeIndexedValueToTaskPayload(elemTy, storeTy, storeValue, indexOperands, elemMeta, extraByteOffset);
   } else if (indexedTy->isStructTy()) {
     // Structure type
     ShaderBlockMetadata structMeta = {};
     structMeta.U64All = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
     if (structMeta.offset > 0) {
       if (extraByteOffset)
         extraByteOffset = m_builder->CreateAdd(extraByteOffset, m_builder->getInt32(structMeta.offset));
       else
         extraByteOffset = m_builder->getInt32(structMeta.offset);
     }
 
     auto membersMeta = cast<Constant>(metadata->getOperand(1));
-    unsigned memberIdx = cast<ConstantInt>(indexOperands.front())->getZExtValue();
+    unsigned memberIdx = indexOperands.empty() ? 0 : cast<ConstantInt>(indexOperands.front())->getZExtValue();
 
     auto memberTy = indexedTy->getStructElementType(memberIdx);
     auto memberMeta = isa<ConstantAggregateZero>(membersMeta)
                           ? cast<ConstantAggregateZero>(membersMeta)->getStructElement(memberIdx)
                           : cast<Constant>(membersMeta->getOperand(memberIdx));
 
-    return storeIndexedValueToTaskPayload(memberTy, storeValue, indexOperands.drop_front(), memberMeta,
-                                          extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return storeIndexedValueToTaskPayload(memberTy, storeTy, storeValue, indexOperands, memberMeta, extraByteOffset);
   } else if (indexedTy->isVectorTy()) {
     // Vector type
-    assert(indexOperands.size() == 1);
+    assert(indexOperands.empty() || indexOperands.size() == 1);
     auto compTy = indexedTy->getScalarType();
 
     // extraByteOffset += compByteSize * compIdx
     unsigned compByteSize = indexedTy->getScalarSizeInBits() / 8;
-    auto compIdx = indexOperands.front();
+    auto compIdx = indexOperands.empty() ? zero : indexOperands.front();
     if (extraByteOffset) {
       extraByteOffset =
           m_builder->CreateAdd(extraByteOffset, m_builder->CreateMul(m_builder->getInt32(compByteSize), compIdx));
     } else {
       extraByteOffset = m_builder->CreateMul(m_builder->getInt32(compByteSize), compIdx);
     }
 
-    return storeIndexedValueToTaskPayload(compTy, storeValue, indexOperands.drop_front(), metadata, extraByteOffset);
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+
+    return storeIndexedValueToTaskPayload(compTy, storeTy, storeValue, indexOperands, metadata, extraByteOffset);
   }
 
   llvm_unreachable("Should never be called!");
 }
 
 // =====================================================================================================================
 // Stores value to task payload.
 //
 // @param storeValue : Value to store
 // @param metadata : Metadata corresponding to the task payload
 // @param extraByteOffset : Extra byte offset resulting from indexed access of part of task payload (could be null)
 void SpirvLowerGlobal::storeValueToTaskPayload(Value *storeValue, Constant *metadata, Value *extraByteOffset) {
   assert(m_shaderStage == ShaderStageTask);
 
   auto storeTy = storeValue->getType();
 
   if (storeTy->isArrayTy()) {
     // Array type
     assert(metadata->getNumOperands() == 3);
 
-    ShaderBlockMetadata arrayMeta = {};
-    arrayMeta.U64All = cast<ConstantInt>(metadata->getOperand(1))->getZExtValue();
-
     unsigned stride = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
     auto elemMeta = cast<Constant>(metadata->getOperand(2));
 
     for (unsigned elemIdx = 0; elemIdx < storeTy->getArrayNumElements(); ++elemIdx) {
       // Handle array elements recursively
       Value *elem = m_builder->CreateExtractValue(storeValue, elemIdx);
 
       // elemExtraByteOffset = extraByteOffset + stride * elemIdx
       Value *elemExtraByteOffset = nullptr;
       if (extraByteOffset)
@@ -2180,23 +2126,20 @@ Value *SpirvLowerGlobal::atomicOpWithIndexedValueInTaskPayload(Type *indexedTy,
 
   if (indexOperands.empty()) {
     // All indices have been processed
     return atomicOpWithValueInTaskPayload(atomicInstToHandle, metadata, extraByteOffset);
   }
 
   if (indexedTy->isArrayTy()) {
     // Array type
     assert(metadata->getNumOperands() == 3);
 
-    ShaderBlockMetadata arrayMeta = {};
-    arrayMeta.U64All = cast<ConstantInt>(metadata->getOperand(1))->getZExtValue();
-
     auto elemMeta = cast<Constant>(metadata->getOperand(2));
     auto elemTy = indexedTy->getArrayElementType();
 
     // extraByteOffset += stride * elemIdx
     unsigned stride = cast<ConstantInt>(metadata->getOperand(0))->getZExtValue();
     auto elemIdx = indexOperands.front();
     if (extraByteOffset) {
       extraByteOffset =
           m_builder->CreateAdd(extraByteOffset, m_builder->CreateMul(m_builder->getInt32(stride), elemIdx));
     } else {
@@ -2282,23 +2225,26 @@ Value *SpirvLowerGlobal::atomicOpWithValueInTaskPayload(Instruction *atomicInstT
 
   return m_builder->CreateTaskPayloadAtomic(atomicRmw->getOperation(), atomicRmw->getOrdering(),
                                             atomicRmw->getValOperand(), byteOffset);
 }
 
 // =====================================================================================================================
 // Lowers buffer blocks.
 void SpirvLowerGlobal::lowerBufferBlock() {
   SmallVector<GlobalVariable *, 8> globalsToRemove;
 
-  // Represent the users of the global variables, expect a bitCast, a GEP or a select used by GEPs
+  // Represent the users of the global variables, expect a bitCast, a load, a store, a GEP or a select used by GEPs
   struct ReplaceInstsInfo {
+    // TODO: Remove this when LLPC will switch fully to opaque pointers.
+    // remove bitCastInst.
     BitCastInst *bitCastInst;                         // The user is a bitCast
+    Instruction *loadStoreInst;                       // The user is a load or a store.
     SelectInst *selectInst;                           // The user is a select
     SmallVector<GetElementPtrInst *> getElemPtrInsts; // The user is a GEP. If the user is a select, we store its users.
   };
 
   // Skip the globals that are handled with previous global.
   SmallSet<GlobalVariable *, 4> skipGlobals;
 
   for (GlobalVariable &global : m_module->globals()) {
     // Skip anything that is not a block.
     if (global.getAddressSpace() != SPIRAS_Uniform)
@@ -2345,87 +2291,118 @@ void SpirvLowerGlobal::lowerBufferBlock() {
           // Skip over non-instructions.
           if (auto *inst = dyn_cast<Instruction>(user)) {
             // Skip instructions in other functions.
             if (inst->getFunction() != func)
               continue;
 
             ReplaceInstsInfo replaceInstsInfo = {};
             // We have a user of the global, expect a GEP, a bitcast or a select.
             if (auto *getElemPtr = dyn_cast<GetElementPtrInst>(inst)) {
               replaceInstsInfo.getElemPtrInsts.push_back(getElemPtr);
+              // TODO: Remove this when LLPC will switch fully to opaque pointers.
+              // Remove else if with bitcast
             } else if (auto *bitCast = dyn_cast<BitCastInst>(inst)) {
               // We need to modify the bitcast if we did not find a GEP.
               assert(bitCast->getOperand(0) == &global);
               replaceInstsInfo.bitCastInst = bitCast;
+            } else if (isa<LoadInst>(inst) || isa<StoreInst>(inst)) {
+              replaceInstsInfo.loadStoreInst = inst;
             } else {
               // The users of the select must be a GEP.
               SelectInst *selectInst = cast<SelectInst>(inst);
               assert(selectInst->getTrueValue() == &global || selectInst->getFalseValue() == &global);
               replaceInstsInfo.selectInst = selectInst;
               for (User *selectUser : selectInst->users()) {
                 if (auto *userInst = dyn_cast<Instruction>(selectUser)) {
                   assert(userInst->getFunction() == func);
                   if (auto *getElemPtr = dyn_cast<GetElementPtrInst>(userInst))
                     replaceInstsInfo.getElemPtrInsts.push_back(getElemPtr);
                 }
               }
             }
             instructionsToReplace.push_back(replaceInstsInfo);
           }
         }
 
         for (const auto &replaceInstsInfo : instructionsToReplace) {
+          // TODO: Remove this when LLPC will switch fully to opaque pointers.
+          // For opaque pointers BitCast Instruction will not be created.
           if (replaceInstsInfo.bitCastInst) {
             // All bitcasts recorded here are for GEPs that indexed by 0, 0 into the arrayed resource, and LLVM
             // has been clever enough to realise that doing a GEP of 0, 0 is actually a no-op (because the pointer
             // does not change!), and has removed it.
             m_builder->SetInsertPoint(replaceInstsInfo.bitCastInst);
             unsigned bufferFlags = global.isConstant() ? 0 : lgc::Builder::BufferFlagWritten;
             Value *const bufferDesc = m_builder->CreateLoadBufferDesc(descSet, binding, m_builder->getInt32(0),
                                                                       bufferFlags, m_builder->getInt8Ty());
 
             // If the global variable is a constant, the data it points to is invariant.
             if (global.isConstant())
               m_builder->CreateInvariantStart(bufferDesc);
 
             replaceInstsInfo.bitCastInst->replaceUsesOfWith(&global, m_builder->CreateBitCast(bufferDesc, blockType));
+          } else if (replaceInstsInfo.loadStoreInst) {
+            // All load or store recorded here are for GEPs that indexed by 0, 0 into the arrayed resource. Opaque
+            // pointers are removing zero-index GEPs and BitCast with pointer to pointer cast.
+            m_builder->SetInsertPoint(replaceInstsInfo.loadStoreInst);
+            unsigned bufferFlags = global.isConstant() ? 0 : lgc::Builder::BufferFlagWritten;
+
+            Value *const bufferDesc = m_builder->CreateLoadBufferDesc(descSet, binding, m_builder->getInt32(0),
+                                                                      bufferFlags, m_builder->getInt8Ty());
+
+            // If the global variable is a constant, the data it points to is invariant.
+            if (global.isConstant())
+              m_builder->CreateInvariantStart(bufferDesc);
+
+            replaceInstsInfo.loadStoreInst->replaceUsesOfWith(&global, bufferDesc);
           } else {
             assert(!replaceInstsInfo.getElemPtrInsts.empty());
 
             for (GetElementPtrInst *getElemPtr : replaceInstsInfo.getElemPtrInsts) {
               // The second index is the block offset, so we need at least two indices!
               assert(getElemPtr->getNumIndices() >= 2);
               SmallVector<Value *, 8> indices;
 
+              // Types of Global Variable and GEP can be different, these may happen when zero-index elimination
+              // occurred. For opaque pointers this is quite often. If types are not equal it means leading zeros where
+              // removed and we can assume that BlockIndex is '0' (since second index is describing BlockIndex).
+              bool isBlockIndexZero = getElemPtr->getSourceElementType() != global.getValueType();
+              bool gepsLeadingZerosEliminated = isBlockIndexZero;
+
               for (Value *const index : getElemPtr->indices())
                 indices.push_back(index);
 
-              // The first index should always be zero.
-              assert(isa<ConstantInt>(indices[0]) && cast<ConstantInt>(indices[0])->getZExtValue() == 0);
-
-              // The second index is the block index.
-              Value *const blockIndex = indices[1];
-
-              bool isNonUniform = false;
-
-              // Run the users of the GEP to check for any nonuniform calls.
-              for (User *const user : getElemPtr->users()) {
-                CallInst *const call = dyn_cast<CallInst>(user);
-                // If the user is not a call or the call is the function pointer call, bail.
-                if (!call)
-                  continue;
-                auto callee = call->getCalledFunction();
-                if (!callee)
-                  continue;
-                // If the call is our non uniform decoration, record we are non uniform.
-                isNonUniform = callee->getName().startswith(gSPIRVName::NonUniform);
-                break;
+              // Verify GEPs indices if zero-index elimination did not occurred.
+              assert(gepsLeadingZerosEliminated ||
+                     (isa<ConstantInt>(indices[0]) && cast<ConstantInt>(indices[0])->getZExtValue() == 0));
+
+              // Get block index from the second gep index, if it is not zero.
+              Value *const blockIndex = isBlockIndexZero ? m_builder->getInt32(0) : indices[1];
+
+              bool isNonUniform = isShaderStageInMask(
+                  m_shaderStage,
+                  m_context->getPipelineContext()->getPipelineOptions()->forceNonUniformResourceIndexStageMask);
+
+              if (!isNonUniform) {
+                // Run the users of the GEP to check for any nonuniform calls.
+                for (User *const user : getElemPtr->users()) {
+                  CallInst *const call = dyn_cast<CallInst>(user);
+                  // If the user is not a call or the call is the function pointer call, bail.
+                  if (!call)
+                    continue;
+                  auto callee = call->getCalledFunction();
+                  if (!callee)
+                    continue;
+                  // If the call is our non uniform decoration, record we are non uniform.
+                  isNonUniform = callee->getName().startswith(gSPIRVName::NonUniform);
+                  break;
+                }
               }
               if (!isNonUniform) {
                 // Run the users of the block index to check for any nonuniform calls.
                 for (User *const user : blockIndex->users()) {
                   CallInst *const call = dyn_cast<CallInst>(user);
 
                   // If the user is not a call, bail.
                   if (!call)
                     continue;
                   // If the call is our non uniform decoration, record we are non uniform.
@@ -2485,32 +2462,40 @@ void SpirvLowerGlobal::lowerBufferBlock() {
                   m_builder->CreateInvariantStart(bufferDescs[idx]);
 
                 bitCasts[idx] = m_builder->CreateBitCast(bufferDescs[idx], blockType);
               }
 
               Value *newSelect = nullptr;
               if (select)
                 newSelect = m_builder->CreateSelect(select->getCondition(), bitCasts[0], bitCasts[1]);
 
               Value *base = newSelect ? newSelect : bitCasts[0];
-              // We need to remove the block index from the original GEP indices so that we can use them.
-              indices[1] = indices[0];
+              // We need to remove the block index from the original GEP indices so that we can use them, but first we
+              // have to check if it was not removed already by zero-index elimination.
+              if (!gepsLeadingZerosEliminated)
+                indices[1] = indices[0];
 
               ArrayRef<Value *> newIndices(indices);
-              newIndices = newIndices.drop_front(1);
+              // Drop first index only if it was not removed earlier by zero-index elimination while creating GEP
+              // instructions.
+              if (!gepsLeadingZerosEliminated)
+                newIndices = newIndices.drop_front(1);
 
               Value *newGetElemPtr = nullptr;
+              // If zero-index elimination removed leading zeros from OldGEP indices then we need to use OldGEP Source
+              // type as a Source type for newGEP. In other cases use global variable array element type.
+              Type *newGetElemType = gepsLeadingZerosEliminated ? getElemPtr->getSourceElementType() : elementType;
 
               if (getElemPtr->isInBounds())
-                newGetElemPtr = m_builder->CreateInBoundsGEP(elementType, base, newIndices);
+                newGetElemPtr = m_builder->CreateInBoundsGEP(newGetElemType, base, newIndices);
               else
-                newGetElemPtr = m_builder->CreateGEP(elementType, base, newIndices);
+                newGetElemPtr = m_builder->CreateGEP(newGetElemType, base, newIndices);
 
               getElemPtr->replaceAllUsesWith(newGetElemPtr);
               getElemPtr->eraseFromParent();
 
               if (select)
                 select->eraseFromParent();
             }
           }
         }
       } else {
@@ -2676,41 +2661,48 @@ void SpirvLowerGlobal::cleanupReturnBlock() {
 }
 
 // =====================================================================================================================
 // Interpolates an element of the input.
 //
 // @param interpLoc : Interpolation location, valid for fragment shader (use "InterpLocUnknown" as don't-care value)
 // @param auxInterpValue : Auxiliary value of interpolation (valid for fragment shader): - Sample ID for
 // "InterpLocSample" - Offset from the center of the pixel for "InterpLocCenter" - Vertex no. (0 ~ 2) for
 // "InterpLocCustom"
 // @param callInst : "Call" instruction
-void SpirvLowerGlobal::interpolateInputElement(unsigned interpLoc, Value *auxInterpValue, CallInst &callInst) {
-  GetElementPtrInst *getElemPtr = cast<GetElementPtrInst>(callInst.getArgOperand(0));
-
-  assert(cast<ConstantInt>(getElemPtr->getOperand(1))->isZero() && "Non-zero GEP first index\n");
+// @param indexOperands : indices of GEP instruction
+// @param gv : Global Variable instruction
+void SpirvLowerGlobal::interpolateInputElement(unsigned interpLoc, Value *auxInterpValue, CallInst &callInst,
+                                               GlobalVariable *gv, ArrayRef<Value *> indexOperands) {
+  assert(indexOperands.empty() || cast<ConstantInt>(indexOperands.front())->isZero() && "Non-zero GEP first index\n");
 
   m_builder->SetInsertPoint(&callInst);
 
-  std::vector<Value *> indexOperands;
-  for (auto &index : getElemPtr->indices())
-    indexOperands.push_back(m_builder->CreateZExtOrTrunc(index, m_builder->getInt32Ty()));
-
-  auto input = cast<GlobalVariable>(getElemPtr->getPointerOperand());
-  auto inputTy = input->getValueType();
+  auto inputTy = gv->getValueType();
 
-  MDNode *metaNode = input->getMetadata(gSPIRVMD::InOut);
+  MDNode *metaNode = gv->getMetadata(gSPIRVMD::InOut);
   assert(metaNode);
   auto inputMeta = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
 
-  if (getElemPtr->hasAllConstantIndices()) {
-    auto loadValue = loadInOutMember(inputTy, SPIRAS_Input, makeArrayRef(indexOperands).drop_front(), 0, inputMeta,
-                                     nullptr, nullptr, interpLoc, auxInterpValue, false);
+  auto hasAllConstantIndices = [](ArrayRef<Value *> &indexOperands) {
+    // if indexOperands is empty then add_of will return TRUE.
+    return std::all_of(indexOperands.begin(), indexOperands.end(), [](auto &idx) {
+      if (isa<ConstantInt>(idx))
+        return true;
+      return false;
+    });
+  };
+
+  if (hasAllConstantIndices(indexOperands)) {
+    if (!indexOperands.empty())
+      indexOperands = indexOperands.drop_front();
+    auto loadValue = loadInOutMember(inputTy, callInst.getFunctionType()->getReturnType(), SPIRAS_Input, indexOperands,
+                                     0, inputMeta, nullptr, nullptr, interpLoc, auxInterpValue, false);
 
     m_interpCalls.insert(&callInst);
     callInst.replaceAllUsesWith(loadValue);
   } else {
     // Interpolant an element via dynamic index by extending interpolant to each element
     //
     // Regardless of where we do the interpolation, the alloca for the temporary must be inserted in the function entry
     // block for efficient code generation, so we don't use the builder for it.
     auto interpPtr = new AllocaInst(inputTy, m_module->getDataLayout().getAllocaAddrSpace(), Twine(),
                                     &*(m_entryPoint->begin()->getFirstInsertionPt()));
diff --git a/llpc/lower/llpcSpirvLowerGlobal.h b/llpc/lower/llpcSpirvLowerGlobal.h
index d4848860e..f9d5c9432 100644
--- a/llpc/lower/llpcSpirvLowerGlobal.h
+++ b/llpc/lower/llpcSpirvLowerGlobal.h
@@ -46,26 +46,24 @@ namespace Llpc {
 class SpirvLowerGlobal : public SpirvLower, public llvm::PassInfoMixin<SpirvLowerGlobal> {
 public:
   SpirvLowerGlobal();
   llvm::PreservedAnalyses run(llvm::Module &module, llvm::ModuleAnalysisManager &analysisManager);
   bool runImpl(llvm::Module &module);
 
   void handleCallInst(bool checkEmitCall, bool checkInterpCall);
   void handleReturnInst();
 
   void handleLoadInst();
-  void handleLoadInstGlobal(LoadInst &loadInst, const unsigned addrSpace);
-  void handleLoadInstGEP(GetElementPtrInst *const getElemPtr, LoadInst &loadInst, const unsigned addrSpace);
+  void handleLoadInstGEP(GlobalVariable *inOut, ArrayRef<Value *> indexOperands, LoadInst &loadInst);
 
   void handleStoreInst();
-  void handleStoreInstGlobal(StoreInst &storeInst);
-  void handleStoreInstGEP(GetElementPtrInst *const getElemPtr, StoreInst &storeInst);
+  void handleStoreInstGEP(GlobalVariable *output, ArrayRef<Value *> indexOperands, StoreInst &storeInst);
 
   void handleAtomicInst();
   void handleAtomicInstGlobal(Instruction &atomicInst);
   void handleAtomicInstGEP(GetElementPtrInst *const getElemPtr, Instruction &atomicInst);
 
   static llvm::StringRef name() { return "Lower SPIR-V globals (global variables, inputs, and outputs)"; }
 
 private:
   void mapGlobalVariableToProxy(llvm::GlobalVariable *globalVar);
   void mapInputToProxy(llvm::GlobalVariable *input);
@@ -87,43 +85,45 @@ private:
                                          bool isPerVertexDimension);
 
   void addCallInstForOutputExport(llvm::Value *outputValue, llvm::Constant *outputMeta, llvm::Value *locOffset,
                                   unsigned maxLocOffset, unsigned xfbOffsetAdjust, unsigned xfbBufferAdjust,
                                   llvm::Value *elemIdx, llvm::Value *vertexIdx, unsigned emitStreamId);
 
   Value *loadDynamicIndexedMembers(Type *inOutTy, unsigned addrSpace, llvm::ArrayRef<llvm::Value *> indexOperands,
                                    Constant *inOutMetaVal, Value *locOffset, unsigned interpLoc, Value *auxInterpValue,
                                    bool isPerVertexDimension);
 
-  llvm::Value *loadInOutMember(llvm::Type *inOutTy, unsigned addrSpace, llvm::ArrayRef<llvm::Value *> indexOperands,
-                               unsigned maxLocOffset, llvm::Constant *inOutMeta, llvm::Value *locOffset,
-                               llvm::Value *vertexIdx, unsigned interpLoc, llvm::Value *interpInfo,
-                               bool isPerVertexDimension);
+  llvm::Value *loadInOutMember(llvm::Type *inOutTy, llvm::Type *loadType, unsigned addrSpace,
+                               llvm::ArrayRef<llvm::Value *> indexOperands, unsigned maxLocOffset,
+                               llvm::Constant *inOutMeta, llvm::Value *locOffset, llvm::Value *vertexIdx,
+                               unsigned interpLoc, llvm::Value *interpInfo, bool isPerVertexDimension);
 
-  void storeOutputMember(llvm::Type *outputTy, llvm::Value *storeValue, llvm::ArrayRef<llvm::Value *> indexOperands,
-                         unsigned maxLocOffset, llvm::Constant *outputMeta, llvm::Value *locOffset,
-                         llvm::Value *vertexOrPrimitiveIdx);
+  void storeOutputMember(llvm::Type *outputTy, llvm::Type *storeTy, llvm::Value *storeValue,
+                         llvm::ArrayRef<llvm::Value *> indexOperands, unsigned maxLocOffset, llvm::Constant *outputMeta,
+                         llvm::Value *locOffset, llvm::Value *vertexOrPrimitiveIdx);
 
-  llvm::Value *loadIndexedValueFromTaskPayload(llvm::Type *indexedTy, llvm::ArrayRef<llvm::Value *> indexOperands,
-                                               llvm::Constant *metadata, llvm::Value *extraByteOffset);
+  llvm::Value *loadIndexedValueFromTaskPayload(llvm::Type *indexedTy, llvm::Type *loadTy,
+                                               llvm::ArrayRef<llvm::Value *> indexOperands, llvm::Constant *metadata,
+                                               llvm::Value *extraByteOffset);
   llvm::Value *loadValueFromTaskPayload(llvm::Type *loadTy, llvm::Constant *metadata, llvm::Value *extraByteOffset);
-  void storeIndexedValueToTaskPayload(llvm::Type *indexedTy, llvm::Value *storeValue,
+  void storeIndexedValueToTaskPayload(llvm::Type *indexedTy, llvm::Type *storeTy, llvm::Value *storeValue,
                                       llvm::ArrayRef<llvm::Value *> indexOperands, llvm::Constant *metadata,
                                       llvm::Value *extraByteOffset);
   void storeValueToTaskPayload(llvm::Value *storeValue, llvm::Constant *metadata, llvm::Value *extraByteOffse);
   llvm::Value *atomicOpWithIndexedValueInTaskPayload(llvm::Type *indexedTy, llvm::Instruction *atomicInst,
                                                      llvm::ArrayRef<llvm::Value *> indexOperands,
                                                      llvm::Constant *metadata, llvm::Value *extraByteOffset);
   llvm::Value *atomicOpWithValueInTaskPayload(llvm::Instruction *atomicInst, llvm::Constant *metadata,
                                               llvm::Value *extraByteOffset);
 
-  void interpolateInputElement(unsigned interpLoc, llvm::Value *interpInfo, llvm::CallInst &callInst);
+  void interpolateInputElement(unsigned interpLoc, llvm::Value *interpInfo, llvm::CallInst &callInst,
+                               GlobalVariable *gv, ArrayRef<Value *> indexOperands);
 
   std::unordered_map<llvm::Value *, llvm::Value *> m_globalVarProxyMap; // Proxy map for lowering global variables
   std::unordered_map<llvm::Value *, llvm::Value *> m_inputProxyMap;     // Proxy map for lowering inputs
 
   // NOTE: Here we use list to store pairs of output proxy mappings. This is because we want output patching to be
   // "ordered" (resulting LLVM IR for the patching always be consistent).
   std::list<std::pair<llvm::Value *, llvm::AllocaInst *>> m_outputProxyMap; // Proxy list for lowering outputs
 
   llvm::BasicBlock *m_retBlock; // The return block of entry point
 
diff --git a/llpc/lower/llpcSpirvLowerRayQuery.cpp b/llpc/lower/llpcSpirvLowerRayQuery.cpp
index 8a4209d2e..6b244abf4 100644
--- a/llpc/lower/llpcSpirvLowerRayQuery.cpp
+++ b/llpc/lower/llpcSpirvLowerRayQuery.cpp
@@ -62,20 +62,24 @@ extern const char *ConvertF32toF16PosInf;
 static const char *GetStackSize = "AmdTraceRayGetStackSize";
 static const char *LdsRead = "AmdTraceRayLdsRead";
 static const char *LdsWrite = "AmdTraceRayLdsWrite";
 static const char *GetStackBase = "AmdTraceRayGetStackBase";
 static const char *GetStackStride = "AmdTraceRayGetStackStride";
 static const char *GetStaticFlags = "AmdTraceRayGetStaticFlags";
 static const char *GetTriangleCompressionMode = "AmdTraceRayGetTriangleCompressionMode";
 static const char *SetHitTokenData = "AmdTraceRaySetHitTokenData";
 static const char *GetBoxSortHeuristicMode = "AmdTraceRayGetBoxSortHeuristicMode";
 static const char *SampleGpuTimer = "AmdTraceRaySampleGpuTimer";
+#if VKI_BUILD_GFX11
+static const char *LdsStackInit = "AmdTraceRayLdsStackInit";
+static const char *LdsStackStore = "AmdTraceRayLdsStackStore";
+#endif
 } // namespace RtName
 
 // Enum for the RayDesc
 namespace RayDescParams {
 enum : unsigned {
   Origin = 0, // 0, Origin
   TMin,       // 1, T Min
   Direction,  // 2, Direction
   TMax        // 3, T Max
 };
@@ -441,21 +445,29 @@ void SpirvLowerRayQuery::processLibraryFunction(Function *&func) {
   } else if (mangledName.startswith(RtName::SampleGpuTimer)) {
     createSampleGpuTime(func);
   } else if (mangledName.startswith(RtName::SetHitTokenData)) {
     // TODO: The "hit token" feature that this function is a part of seems non-trivial and
   } else if (mangledName.startswith(RtName::GetBoxSortHeuristicMode)) {
     eraseFunctionBlocks(func);
     BasicBlock *entryBlock = BasicBlock::Create(*m_context, "", func);
     m_builder->SetInsertPoint(entryBlock);
     m_builder->CreateRet(m_builder->getInt32(rtState->boxSortHeuristicMode));
     func->setName(RtName::GetBoxSortHeuristicMode);
-  } else {
+  }
+#if VKI_BUILD_GFX11
+  else if (mangledName.startswith(RtName::LdsStackInit)) {
+    createLdsStackInit(func);
+  } else if (mangledName.startswith(RtName::LdsStackStore)) {
+    createLdsStackStore(func);
+  }
+#endif
+  else {
     // Nothing to do
   }
 }
 
 // =====================================================================================================================
 // Process RayQuery OpRayQueryInitializeKHR
 //
 // @param func : The function to create
 template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryInitializeKHR>(Function *func) {
   //  void TraceRayInlineAmdInternal(
@@ -635,49 +647,25 @@ Value *SpirvLowerRayQuery::createGetBvhSrd(llvm::Value *expansion, llvm::Value *
     Value *boxSortEnabled = m_builder->CreateICmpNE(boxSortMode, m_builder->getInt32(BvhSrdBoxSortDisableValue));
     bvhSrdDw1 = m_builder->CreateSelect(boxSortEnabled, newBvhSrdDw1, bvhSrdDw1);
   }
 
   // Fill in modified DW1 to the BVH SRD.
   bvhSrd = m_builder->CreateInsertElement(bvhSrd, bvhSrdDw1, 1u);
 
   return bvhSrd;
 }
 
-// =====================================================================================================================
-// Process RayQuery OpRayQueryProceedKHR
-//
-// @param func : The function to create
-template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryProceedKHR>(Function *func) {
+void SpirvLowerRayQuery::createRayQueryProceedFunc(Function *func) {
   func->addFnAttr(Attribute::AlwaysInline);
   BasicBlock *entryBlock = BasicBlock::Create(*m_context, "", func);
   m_builder->SetInsertPoint(entryBlock);
 
-  // bool RayQueryProceedAmdInternal(
-  //     inout RayQueryInternal rayQuery,
-  //     in    uint             constRayFlags,
-  //     in    uint3            dispatchThreadId)
-
-  // bool rayQueryProceedEXT(rayQueryEXT q -> rayQuery)
-  // {
-  //     if (stageNotSupportLds(stage))
-  //         ldsUsage = 0;
-  //     else
-  //         ldsUsage = 1;
-  //     if (rayQuery != prevRayQueryObj)
-  //         rayQuery.stackNumEntries = 0
-  //     prevRayQueryObj = rayQuery
-  //     constRayFlags = 0
-  //     rayId = 0
-  //     bool proceed = call RayQueryProceedAmdInternal
-  //     ldsUsage = 1;
-  //     return proceed;
-  // }
   auto int32x3Ty = FixedVectorType::get(m_builder->getInt32Ty(), 3);
   Value *constRayFlags = m_builder->CreateAlloca(m_builder->getInt32Ty(), SPIRAS_Private);
   Value *threadId = m_builder->CreateAlloca(int32x3Ty, SPIRAS_Private);
 
   Value *zero = m_builder->getInt32(0);
   Value *rayQuery = func->arg_begin();
   Type *rayQueryEltTy = getRayQueryInternalTy(m_builder);
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(rayQuery->getType()->getScalarType(), rayQueryEltTy));
 
@@ -700,27 +688,61 @@ template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryProceedKHR>(Fu
   Value *stackNumEntries = m_builder->CreateLoad(m_builder->getInt32Ty(), stackNumEntriesAddr);
   stackNumEntries = m_builder->CreateSelect(notEqual, zero, stackNumEntries);
   m_builder->CreateStore(stackNumEntries, stackNumEntriesAddr);
 
   m_builder->CreateStore(rayQueryObj, m_prevRayQueryObj);
 
   m_builder->CreateStore(zero, constRayFlags);
 
   m_builder->CreateStore(getDispatchId(), threadId);
 
-  Value *result = m_builder->CreateNamedCall(
-      m_context->getPipelineContext()->getRayTracingFunctionName(Vkgc::RT_ENTRY_RAY_QUERY_PROCEED),
-      func->getReturnType(), {rayQuery, constRayFlags, threadId}, {Attribute::NoUnwind, Attribute::AlwaysInline});
+  Value *result;
+  {
+    result = m_builder->CreateNamedCall(
+        m_context->getPipelineContext()->getRayTracingFunctionName(Vkgc::RT_ENTRY_RAY_QUERY_PROCEED),
+        func->getReturnType(), {rayQuery, constRayFlags, threadId}, {Attribute::NoUnwind, Attribute::AlwaysInline});
+  }
+
   m_builder->CreateStore(m_builder->getInt32(1), m_ldsUsage);
   m_builder->CreateRet(result);
 }
 
+// =====================================================================================================================
+// Process RayQuery OpRayQueryProceedKHR
+//
+// @param func : The function to create
+template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryProceedKHR>(Function *func) {
+
+  // bool RayQueryProceedAmdInternal(
+  //     inout RayQueryInternal rayQuery,
+  //     in    uint             constRayFlags,
+  //     in    uint3            dispatchThreadId)
+
+  // bool rayQueryProceedEXT(rayQueryEXT q -> rayQuery)
+  // {
+  //     if (stageNotSupportLds(stage))
+  //         ldsUsage = 0;
+  //     else
+  //         ldsUsage = 1;
+  //     if (rayQuery != prevRayQueryObj)
+  //         rayQuery.stackNumEntries = 0
+  //     prevRayQueryObj = rayQuery
+  //     constRayFlags = 0
+  //     rayId = 0
+  //     bool proceed = call RayQueryProceedAmdInternal
+  //     ldsUsage = 1;
+  //     return proceed;
+  // }
+
+  createRayQueryProceedFunc(func);
+}
+
 // =====================================================================================================================
 // Process RayQuery OpRayQueryGetIntersectionTypeKHR
 //
 // @param func : The function to create
 template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryGetIntersectionTypeKHR>(Function *func) {
   // uint rayQueryGetIntersectionTypeEXT(rayQueryEXT q -> rayQuery, bool committed)
   // {
   //     if (committed)
   //         return q.committedStatus
   //     else
@@ -919,20 +941,32 @@ template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryGetIntersectio
 template <> void SpirvLowerRayQuery::createRayQueryFunc<OpRayQueryTerminateKHR>(Function *func) {
   func->addFnAttr(Attribute::AlwaysInline);
   BasicBlock *entryBlock = BasicBlock::Create(*m_context, "", func);
   m_builder->SetInsertPoint(entryBlock);
 
   Value *rayQuery = func->arg_begin();
   auto rayQueryEltTy = getRayQueryInternalTy(m_builder);
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(rayQuery->getType()->getScalarType(), rayQueryEltTy));
 
+#if VKI_BUILD_GFX11
+  if (m_context->getGfxIpVersion().major >= 11) {
+    // Navi3x and beyond, use rayQuery.currentNodePtr == TERMINAL_NODE to determine Terminate()
+
+    // TERMINAL_NODE defined in GPURT is 0xFFFFFFFE
+    static const unsigned RayQueryTerminalNode = 0xFFFFFFFE;
+
+    Value *currNodeAddr = m_builder->CreateGEP(
+        rayQueryEltTy, rayQuery, {m_builder->getInt32(0), m_builder->getInt32(RayQueryParams::CurrNodePtr)});
+    m_builder->CreateStore(m_builder->getInt32(RayQueryTerminalNode), currNodeAddr);
+  } else
+#endif
   {
     // Navi2x, use the following combination to determine Terminate()
     //  rayQuery.nodeIndex = 0xFFFFFFFF // invalid index
     //  rayQuery.numStackEntries = 0;
     //  rayQuery.stackPtr = ThreadIdInGroup()
 
     Value *currNodeAddr = m_builder->CreateGEP(
         rayQueryEltTy, rayQuery, {m_builder->getInt32(0), m_builder->getInt32(RayQueryParams::CurrNodePtr)});
     m_builder->CreateStore(m_builder->getInt32(InvalidValue), currNodeAddr);
 
@@ -1473,20 +1507,26 @@ unsigned SpirvLowerRayQuery::getWorkgroupSize() const {
   if (m_context->isRayTracing()) {
     const auto *rtState = m_context->getPipelineContext()->getRayTracingState();
     workgroupSize = rtState->threadGroupSizeX * rtState->threadGroupSizeY * rtState->threadGroupSizeZ;
   } else if (m_context->isGraphics()) {
     workgroupSize = m_context->getPipelineContext()->getRayTracingWaveSize();
   } else {
     const lgc::ComputeShaderMode &computeMode = m_builder->getComputeShaderMode();
     workgroupSize = computeMode.workgroupSizeX * computeMode.workgroupSizeY * computeMode.workgroupSizeZ;
   }
   assert(workgroupSize != 0);
+#if VKI_BUILD_GFX11
+  if (m_context->getPipelineContext()->getGfxIpVersion().major >= 11) {
+    // Round up to multiple of 32, as the ds_bvh_stack swizzle as 32 threads
+    workgroupSize = alignTo(workgroupSize, 32);
+  }
+#endif
   return workgroupSize;
 }
 
 // =====================================================================================================================
 // Get flat thread id in work group/wave
 Value *SpirvLowerRayQuery::getThreadIdInGroup() const {
   unsigned builtIn = m_context->isGraphics() ? BuiltInSubgroupLocalInvocationId : BuiltInLocalInvocationIndex;
   lgc::InOutInfo inputInfo = {};
   return m_builder->CreateReadBuiltInInput(static_cast<lgc::BuiltInKind>(builtIn), inputInfo, nullptr, nullptr, "");
 }
@@ -1533,47 +1573,30 @@ void SpirvLowerRayQuery::createIntersectBvh(Function *func) {
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(argIt->getType(), m_builder->getFloatTy()));
   Value *extent = m_builder->CreateLoad(m_builder->getFloatTy(), argIt);
   argIt++;
 
   // Ray origin vec3 Type
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(argIt->getType(), FixedVectorType::get(m_builder->getFloatTy(), 3)));
   Value *origin = m_builder->CreateLoad(FixedVectorType::get(m_builder->getFloatTy(), 3), argIt);
   argIt++;
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 406441
-  // Construct vec3 = {0.0, 1.0, 0.0}
-  auto zero = ConstantFP::get(m_builder->getFloatTy(), 0.0f);
-  auto one = ConstantFP::get(m_builder->getFloatTy(), 1.0f);
-  Value *constVec = ConstantVector::get({zero, one, zero});
-
-  // vec4 origin = vec4(origin.xyz, 1.0);
-  origin = m_builder->CreateShuffleVector(origin, constVec, ArrayRef<int>{0, 1, 2, 4});
-#endif
   // Ray dir vec3 type
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(argIt->getType(), FixedVectorType::get(m_builder->getFloatTy(), 3)));
   Value *dir = m_builder->CreateLoad(FixedVectorType::get(m_builder->getFloatTy(), 3), argIt);
   argIt++;
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 406441
-  // vec4 dir = vec4(dir.xyz, 0.0)
-  dir = m_builder->CreateShuffleVector(dir, constVec, ArrayRef<int>{0, 1, 2, 3});
-#endif
   // Ray inv_dir vec3 type
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(argIt->getType(), FixedVectorType::get(m_builder->getFloatTy(), 3)));
   Value *invDir = m_builder->CreateLoad(FixedVectorType::get(m_builder->getFloatTy(), 3), argIt);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 406441
-  // vec4 inDir = vec4(invDir, 0.0)
-  invDir = m_builder->CreateShuffleVector(invDir, constVec, ArrayRef<int>{0, 1, 2, 3});
-#endif
   argIt++;
 
   // uint flag
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
   assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(argIt->getType(), m_builder->getInt32Ty()));
   Value *flags = m_builder->CreateLoad(m_builder->getInt32Ty(), argIt);
   argIt++;
 
   // uint expansion
   // TODO: Remove this when LLPC will switch fully to opaque pointers.
@@ -1765,15 +1788,97 @@ Value *SpirvLowerRayQuery::createLoadMatrixFromAddr(Value *matrixAddr) {
   }
   Value *matrix = UndefValue::get(matrixTy);
   matrix = m_builder->CreateInsertValue(matrix, matrixRow[0], 0);
   matrix = m_builder->CreateInsertValue(matrix, matrixRow[1], 1);
   matrix = m_builder->CreateInsertValue(matrix, matrixRow[2], 2);
   matrix = m_builder->CreateInsertValue(matrix, matrixRow[3], 3);
 
   return matrix;
 }
 
+#if VKI_BUILD_GFX11
+// =====================================================================================================================
+// Init LDS stack address
+//
+// @param func : The function to create
+void SpirvLowerRayQuery::createLdsStackInit(Function *func) {
+  eraseFunctionBlocks(func);
+  BasicBlock *block = BasicBlock::Create(*m_context, "", func);
+  m_builder->SetInsertPoint(block);
+
+  // The initial stack index is 0 currently.
+  // stackIndex = 0
+  // stackBase = AmdTraceRayGetStackBase()
+  // stackAddr = ((stackBase << 18u) | startIndex)
+  Type *ldsStackElemTy = m_ldsStack->getValueType();
+  // TODO: Remove this when LLPC will switch fully to opaque pointers.
+  assert(IS_OPAQUE_OR_POINTEE_TYPE_MATCHES(m_ldsStack->getType()->getScalarType(), ldsStackElemTy));
+  Value *stackBasePerThread = getThreadIdInGroup();
+
+  // From Navi3x on, Hardware has decided that the stacks are only swizzled across every 32 threads,
+  // with stacks for every set of 32 threads stored after all the stack data for the previous 32 threads.
+  if (getWorkgroupSize() > 32) {
+    // localThreadId = (LinearLocalThreadID%32)
+    // localGroupId = (LinearLocalThreadID/32)
+    // stackSize = STACK_SIZE * 32 = m_stackEntries * 32
+    // groupOf32ThreadSize = (LinearLocalThreadID/32) * stackSize
+    // stackBasePerThread (in DW) = (LinearLocalThreadID%32)+(LinearLocalThreadID/32)*STACK_SIZE*32
+    //                            = localThreadId + groupOf32ThreadSize
+    Value *localThreadId = m_builder->CreateAnd(stackBasePerThread, m_builder->getInt32(31));
+    Value *localGroupId = m_builder->CreateLShr(stackBasePerThread, m_builder->getInt32(5));
+    Value *stackSize = m_builder->getInt32(MaxLdsStackEntries * 32);
+    Value *groupOf32ThreadSize = m_builder->CreateMul(localGroupId, stackSize);
+    stackBasePerThread = m_builder->CreateAdd(localThreadId, groupOf32ThreadSize);
+  }
+
+  Value *stackBaseAsInt = m_builder->CreatePtrToInt(
+      m_builder->CreateGEP(ldsStackElemTy, m_ldsStack, {m_builder->getInt32(0), stackBasePerThread}),
+      m_builder->getInt32Ty());
+
+  // stack_addr[31:18] = stack_base[15:2]
+  // stack_addr[17:0] = stack_index[17:0]
+  // The low 18 bits of stackAddr contain stackIndex which we always initialize to 0.
+  // Note that this relies on stackAddr being a multiple of 4, so that bits 17 and 16 are 0.
+  Value *stackAddr = m_builder->CreateShl(stackBaseAsInt, 16);
+
+  m_builder->CreateRet(stackAddr);
+}
+
+// =====================================================================================================================
+// Store to LDS stack
+//
+// @param func : The function to create
+void SpirvLowerRayQuery::createLdsStackStore(Function *func) {
+  eraseFunctionBlocks(func);
+  BasicBlock *block = BasicBlock::Create(*m_context, "", func);
+  m_builder->SetInsertPoint(block);
+
+  auto int32x4Ty = FixedVectorType::get(m_builder->getInt32Ty(), 4);
+
+  auto argIt = func->arg_begin();
+  Value *stackAddr = argIt++;
+  Value *stackAddrVal = m_builder->CreateLoad(m_builder->getInt32Ty(), stackAddr);
+  Value *lastVisited = m_builder->CreateLoad(m_builder->getInt32Ty(), argIt++);
+  Value *data = m_builder->CreateLoad(int32x4Ty, argIt);
+  // OFFSET = {OFFSET1, OFFSET0}
+  // stack_size[1:0] = OFFSET1[5:4]
+  // Stack size is encoded in the offset argument as:
+  // 8 -> {0x00, 0x00}
+  // 16 -> {0x10, 0x00}
+  // 32 -> {0x20, 0x00}
+  // 64 -> {0x30, 0x00}
+  assert(MaxLdsStackEntries == 16);
+  Value *offset = m_builder->getInt32((Log2_32(MaxLdsStackEntries) - 3) << 12);
+
+  Value *result =
+      m_builder->CreateIntrinsic(Intrinsic::amdgcn_ds_bvh_stack_rtn, {}, {stackAddrVal, lastVisited, data, offset});
+
+  m_builder->CreateStore(m_builder->CreateExtractValue(result, 1), stackAddr);
+  m_builder->CreateRet(m_builder->CreateExtractValue(result, 0));
+}
+#endif
+
 } // namespace Llpc
 
 // =====================================================================================================================
 // Initializes the pass of SPIR-V lowering the ray query operations.
 INITIALIZE_PASS(LegacySpirvLowerRayQuery, DEBUG_TYPE, "Lower SPIR-V RayQuery operations", false, false)
diff --git a/llpc/lower/llpcSpirvLowerRayQuery.h b/llpc/lower/llpcSpirvLowerRayQuery.h
index 5dff3cec0..ab726ee5b 100644
--- a/llpc/lower/llpcSpirvLowerRayQuery.h
+++ b/llpc/lower/llpcSpirvLowerRayQuery.h
@@ -134,26 +134,31 @@ protected:
   void eraseFunctionBlocks(llvm::Function *func);
   unsigned getFuncOpcode(llvm::Function *func);
   llvm::Value *createLoadInstanceIndex(llvm::Value *instNodeAddr);
   llvm::Value *createLoadInstanceId(llvm::Value *instNodeAddr);
   llvm::Value *createLoadMatrixFromAddr(llvm::Value *matrixAddr);
 
   bool m_rayQueryLibrary;       // Whether the module is ray query library
   unsigned m_spirvOpMetaKindId; // Metadata kind ID for "spirv.op"
 private:
   template <spv::Op> void createRayQueryFunc(llvm::Function *func);
+  void createRayQueryProceedFunc(llvm::Function *func);
   llvm::Value *createIntersectSystemValue(llvm::Function *func, unsigned raySystem);
   void createWriteLdsStack(llvm::Function *func);
   void createReadLdsStack(llvm::Function *func);
   void createIntersectMatrix(llvm::Function *func, unsigned builtInId);
   void createIntersectBvh(llvm::Function *func);
   void createSampleGpuTime(llvm::Function *func);
+#if VKI_BUILD_GFX11
+  void createLdsStackInit(llvm::Function *func);
+  void createLdsStackStore(llvm::Function *func);
+#endif
   llvm::Value *getStackArrayIndex(llvm::Value *stackOffset);
   uint32_t getWorkgroupSize() const;
   llvm::Value *createGetInstanceNodeAddr(llvm::Value *instNodePtr, llvm::Value *rayQuery);
   llvm::Value *getDispatchId();
   llvm::Value *createGetBvhSrd(llvm::Value *expansion, llvm::Value *boxSortMode);
   bool stageNotSupportLds(ShaderStage stage);
   llvm::GlobalVariable *m_ldsStack;        // LDS to hold stack value
   llvm::GlobalVariable *m_ldsUsage;        // LDS usage
   llvm::GlobalVariable *m_stackArray;      // Stack array to hold stack value
   llvm::GlobalVariable *m_prevRayQueryObj; // Previous ray query Object
diff --git a/llpc/lower/llpcSpirvLowerRayTracing.cpp b/llpc/lower/llpcSpirvLowerRayTracing.cpp
index b28ef0d59..a85417dfb 100644
--- a/llpc/lower/llpcSpirvLowerRayTracing.cpp
+++ b/llpc/lower/llpcSpirvLowerRayTracing.cpp
@@ -617,20 +617,21 @@ bool SpirvLowerRayTracing::runImpl(Module &module) {
 }
 
 // =====================================================================================================================
 // Process function in the TraceRays module
 //
 // @param func : Function to process
 void SpirvLowerRayTracing::processLibraryFunction(Function *func) {
   assert(m_shaderStage == ShaderStageCompute);
   auto mangledName = func->getName();
   const char *traceRayFuncName = m_context->getPipelineContext()->getRayTracingFunctionName(Vkgc::RT_ENTRY_TRACE_RAY);
+
   if (mangledName.startswith(traceRayFuncName)) {
     func->setLinkage(GlobalValue::ExternalLinkage);
   } else if (mangledName.startswith(RtName::GetFlattenedGroupThreadId)) {
     eraseFunctionBlocks(func);
     BasicBlock *entryBlock = BasicBlock::Create(*m_context, "", func);
     m_builder->SetInsertPoint(entryBlock);
     m_builder->CreateRet(getThreadIdInGroup());
   } else if (mangledName.startswith(RtName::GetHitAttributes)) {
     eraseFunctionBlocks(func);
     BasicBlock *entryBlock = BasicBlock::Create(*m_context, "", func);
@@ -1450,21 +1451,21 @@ void SpirvLowerRayTracing::createRayGenEntryFunc() {
 // =====================================================================================================================
 // Create DICompileUnit and DISubprogram
 //
 // @param module : LLVM module to be used by the DIBuilder
 // @param func : Function to process
 void SpirvLowerRayTracing::createDbgInfo(Module &module, Function *func) {
   DIBuilder builder(module);
   DIFile *file = builder.createFile(func->getName(), ".");
 
   // Create the DISubprogram for the module entry function
-  auto *funcTy = builder.createSubroutineType(builder.getOrCreateTypeArray(llvm::None));
+  auto *funcTy = builder.createSubroutineType(builder.getOrCreateTypeArray({}));
   auto spFlags = DISubprogram::SPFlagDefinition;
   auto subProgram =
       builder.createFunction(file, func->getName(), module.getName(), file, 0, funcTy, 0, DINode::FlagZero, spFlags);
   auto dbgInfoLoc = DILocation::get(subProgram->getContext(), 0, 0, subProgram);
   func->setSubprogram(subProgram);
   // Builder finalize to remove temporary node
   builder.finalize();
   m_builder->SetCurrentDebugLocation(dbgInfoLoc);
 }
 
diff --git a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
index d0d3499ea..49676cf84 100644
--- a/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
+++ b/llpc/lower/llpcSpirvLowerRayTracingBuiltIn.cpp
@@ -158,21 +158,21 @@ bool SpirvLowerRayTracingBuiltIn::runImpl(Module &module) {
     removeConstantExpr(m_context, global);
     for (auto user = global->user_begin(), end = global->user_end(); user != end; ++user) {
       // NOTE: "Getelementptr" and "bitcast" will propagate the address space of pointer value (input variable)
       // to the element pointer value (destination). We have to clear the address space of this element pointer
       // value. The original pointer value has been lowered and therefore the address space is invalid now.
       Instruction *inst = dyn_cast<Instruction>(*user);
       if (inst) {
         Type *instTy = inst->getType();
         if (isa<PointerType>(instTy) && instTy->getPointerAddressSpace() == SPIRAS_Input) {
           assert(isa<GetElementPtrInst>(inst) || isa<BitCastInst>(inst));
-          Type *newInstTy = PointerType::get(instTy->getContainedType(0), SPIRAS_Private);
+          Type *newInstTy = PointerType::getWithSamePointeeType(cast<PointerType>(instTy), SPIRAS_Private);
           inst->mutateType(newInstTy);
         }
       }
     }
 
     global->mutateType(input->getType()); // To clear address space for pointer to make replacement valid
     global->replaceAllUsesWith(input);
     global->eraseFromParent();
   }
 
diff --git a/llpc/lower/llpcSpirvLowerTranslator.cpp b/llpc/lower/llpcSpirvLowerTranslator.cpp
index ee70dada8..35f2926a4 100644
--- a/llpc/lower/llpcSpirvLowerTranslator.cpp
+++ b/llpc/lower/llpcSpirvLowerTranslator.cpp
@@ -169,26 +169,19 @@ void SpirvLowerTranslator::translateSpirvToLlvm(const PipelineShaderInfo *shader
         func.setDLLStorageClass(GlobalValue::DefaultStorageClass);
         func.setLinkage(GlobalValue::ExternalLinkage);
         continue;
       }
 #endif
       lgc::Pipeline::markShaderEntryPoint(&func, getLgcShaderStage(entryStage));
       continue;
     }
     // Not shader entry-point.
     func.setLinkage(GlobalValue::InternalLinkage);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-    // Old version of the code
-    if (func.getAttributes().hasFnAttribute(Attribute::NoInline))
-      func.removeFnAttr(Attribute::NoInline);
-#else
-    // New version of the code (also handles unknown version, which we treat as latest)
     if (func.hasFnAttribute(Attribute::NoInline))
       func.removeFnAttr(Attribute::NoInline);
-#endif
     func.addFnAttr(Attribute::AlwaysInline);
   }
 }
 
 // =====================================================================================================================
 // Initializes the pass
 INITIALIZE_PASS(LegacySpirvLowerTranslator, DEBUG_TYPE, "LLPC translate SPIR-V binary to LLVM IR", false, false)
diff --git a/llpc/test/lit.cfg.py b/llpc/test/lit.cfg.py
index 9accc6ee1..153ef8f3b 100644
--- a/llpc/test/lit.cfg.py
+++ b/llpc/test/lit.cfg.py
@@ -75,10 +75,18 @@ llvm_config.use_default_substitutions()
 config.substitutions.append(('%PATH%', config.environment['PATH']))
 config.substitutions.append(('%gfxip', config.gfxip))
 config.substitutions.append(('%spvgendir%', config.spvgen_dir))
 
 tool_dirs = [config.llvm_tools_dir, config.amdllpc_dir]
 
 tools = ['amdllpc', 'llvm-objdump', 'llvm-readelf', 'not', 'count']
 
 llvm_config.add_tool_substitutions(tools, tool_dirs)
 
+#if LLPC_BUILD_NAVI31
+# Propagate options for lit feature tests. These can be used in XFAIL, REQUIRES, and UNSUPPORTED
+p = subprocess.Popen([config.amdllpc_dir + "/amdllpc", "-gfxip=11.0.0","dummy.comp"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
+out,err = p.communicate()
+check_str = out.decode("utf-8")
+if check_str.find("Invalid gfxip: gfx1100") == -1:
+    config.available_features.add('gfx11')
+#endif
diff --git a/llpc/test/shaderdb/core/OpAccessChain_TestUniformVectorExtract_lit.frag b/llpc/test/shaderdb/core/OpAccessChain_TestUniformVectorExtract_lit.frag
index 595579d26..85d400070 100644
--- a/llpc/test/shaderdb/core/OpAccessChain_TestUniformVectorExtract_lit.frag
+++ b/llpc/test/shaderdb/core/OpAccessChain_TestUniformVectorExtract_lit.frag
@@ -9,21 +9,20 @@ layout(binding = 0) uniform Uniforms
 };
 
 void main()
 {
     double d1 = d4[index];
     d1 += d4[2];
     fragColor = vec4(float(d1));
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
-; SHADERTEST: [[GEPVAR:%[^ ]+]] = getelementptr <{ [4 x double], i32 }>, <{ [4 x double], i32 }> addrspace(7)* {{%[^,]+}}, i64 0, i32 0, i64 %
-; SHADERTEST: load double, double addrspace(7)* [[GEPVAR]], align 8
-; SHADERTEST: [[GEP16:%[^ ]+]] = getelementptr inbounds i8, i8 addrspace(7)* {{%[^,]+}}, i64 16
-; SHADERTEST: [[BC:%[^ ]+]] = bitcast i8 addrspace(7)* [[GEP16]] to double addrspace(7)*
-; SHADERTEST: load double, double addrspace(7)* [[BC]], align 8
+; SHADERTEST: [[GEPVAR:%[^ ]+]] = getelementptr <{ [4 x double], i32 }>, ptr addrspace(7) {{%[^,]+}}, i64 0, i32 0, i64 %
+; SHADERTEST: load double, ptr addrspace(7) [[GEPVAR]], align 8
+; SHADERTEST: [[GEP16:%[^ ]+]] = getelementptr inbounds <{ [4 x double], i32 }>, ptr addrspace(7) {{%[^,]+}}, i64 0, i32 0, i64 2
+; SHADERTEST: load double, ptr addrspace(7) [[GEP16]], align 8
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpAny_TestBvec2_lit.frag b/llpc/test/shaderdb/core/OpAny_TestBvec2_lit.frag
index a77404b0f..0f184b58d 100644
--- a/llpc/test/shaderdb/core/OpAny_TestBvec2_lit.frag
+++ b/llpc/test/shaderdb/core/OpAny_TestBvec2_lit.frag
@@ -1,30 +1,36 @@
+// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
+// RUN: amdllpc -o - -gfxip 10.1 -emit-lgc -enable-opaque-pointers %s | FileCheck -check-prefixes=CHECK %s
+
 #version 450
 
 layout(binding = 0) uniform Uniforms
 {
     bvec2 b2;
 };
 
 layout(location = 0) out vec4 fragColor;
 
 void main()
 {
     vec4 color = vec4(0.5);
 
     if (any(b2) == true)
     {
         color = vec4(1.0);
     }
 
     fragColor = color;
 }
-// BEGIN_SHADERTEST
-/*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
-
-; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST-COUNT-3: = or i1
-
-; SHADERTEST: AMDLLPC SUCCESS
-*/
-// END_SHADERTEST
+// CHECK-LABEL: @lgc.shader.FS.main(
+// CHECK-NEXT:  .entry:
+// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(7) (...) @lgc.create.load.buffer.desc.p7(i32 0, i32 0, i32 0, i32 0)
+// CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.invariant.start.p7(i64 -1, ptr addrspace(7) [[TMP0]])
+// CHECK-NEXT:    [[TMP2:%.*]] = load <2 x i32>, ptr addrspace(7) [[TMP0]], align 8
+// CHECK-NEXT:    [[TMP3:%.*]] = icmp ne <2 x i32> [[TMP2]], zeroinitializer
+// CHECK-NEXT:    [[TMP4:%.*]] = extractelement <2 x i1> [[TMP3]], i64 0
+// CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i1> [[TMP3]], i64 1
+// CHECK-NEXT:    [[TMP6:%.*]] = or i1 [[TMP4]], [[TMP5]]
+// CHECK-NEXT:    [[SPEC_SELECT:%.*]] = select i1 [[TMP6]], <4 x float> <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, <4 x float> <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
+// CHECK-NEXT:    call void (...) @lgc.create.write.generic.output(<4 x float> [[SPEC_SELECT]], i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
+// CHECK-NEXT:    ret void
+//
diff --git a/llpc/test/shaderdb/core/OpAtomicIIncrement_TestStorageBlock_lit.spvasm b/llpc/test/shaderdb/core/OpAtomicIIncrement_TestStorageBlock_lit.spvasm
index 09a4cba96..def86cf75 100644
--- a/llpc/test/shaderdb/core/OpAtomicIIncrement_TestStorageBlock_lit.spvasm
+++ b/llpc/test/shaderdb/core/OpAtomicIIncrement_TestStorageBlock_lit.spvasm
@@ -1,16 +1,16 @@
 ; BEGIN_SHADERTEST
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
 ; SHADERTEST; store i32
-; SHADERTEST: atomicrmw add i32
+; SHADERTEST: atomicrmw add ptr
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.add.i32(i32 1, <4 x i32> %{{[0-9]*}}, i32 24, i32 0, i32 0)
 ; SHADERTEST: call void @llvm.amdgcn.raw.buffer.store.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 ; SPIR-V
 ; Version: 1.0
 ; Generator: Khronos Glslang Reference Front End; 1
diff --git a/llpc/test/shaderdb/core/OpAtomicXXX_TestSharedVariable_lit.comp b/llpc/test/shaderdb/core/OpAtomicXXX_TestSharedVariable_lit.comp
index 5ded84dee..dd1deae04 100644
--- a/llpc/test/shaderdb/core/OpAtomicXXX_TestSharedVariable_lit.comp
+++ b/llpc/test/shaderdb/core/OpAtomicXXX_TestSharedVariable_lit.comp
@@ -6,21 +6,21 @@ shared int  imem;
 shared uint umem[4];
 
 layout(binding = 0) uniform Uniforms
 {
     int   idata;
     uint  udata;
 
     int index;
 };
 
-uvec4 u4;
+shared uvec4 u4;
 
 void main()
 {
     int i1  = 0;
     uint u1 = 0;
 
     switch (gl_LocalInvocationID.x)
     {
     case 0:
         i1 = atomicAdd(imem, idata);
diff --git a/llpc/test/shaderdb/core/OpAtomicXXX_TestStorageBlock_lit.frag b/llpc/test/shaderdb/core/OpAtomicXXX_TestStorageBlock_lit.frag
index f09a7ec63..ea63153a8 100644
--- a/llpc/test/shaderdb/core/OpAtomicXXX_TestStorageBlock_lit.frag
+++ b/llpc/test/shaderdb/core/OpAtomicXXX_TestStorageBlock_lit.frag
@@ -36,39 +36,39 @@ void main()
     u1 += atomicAnd(umem[3], udata);
     u1 += atomicOr(umem[index], udata);
     u1 += atomicXor(umem[index], udata);
     u1 += atomicExchange(umem[index], udata);
     u1 += atomicCompSwap(umem[index], 16u, udata);
 
     u4[i1 % 4] = u1;
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
-; SHADERTEST: atomicrmw add i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw min i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw max i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw and i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw or i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw xor i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw xchg i32 {{.*}} monotonic
-; SHADERTEST: cmpxchg i32 {{.*}} monotonic monotonic
-; SHADERTEST: atomicrmw add i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw umin i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw umax i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw and i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw or i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw xor i32 {{.*}} monotonic
-; SHADERTEST: atomicrmw xchg i32 {{.*}} monotonic
-; SHADERTEST: cmpxchg i32 {{.*}} monotonic monotonic
+; SHADERTEST: atomicrmw add ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw min ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw max ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw and ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw or ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw xor ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw xchg ptr {{.*}} monotonic
+; SHADERTEST: cmpxchg ptr {{.*}} monotonic monotonic
+; SHADERTEST: atomicrmw add ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw umin ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw umax ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw and ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw or ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw xor ptr {{.*}} monotonic
+; SHADERTEST: atomicrmw xchg ptr {{.*}} monotonic
+; SHADERTEST: cmpxchg ptr {{.*}} monotonic monotonic
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.add.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.smin.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.smax.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.and.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.or.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.xor.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.swap.i32(i32 %{{[0-9]*}}, <4 x i32> %{{[0-9]*}}, i32 0, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.raw.buffer.atomic.cmpswap.i32(i32 %{{[0-9]*}}, i32 28, <4 x i32> %{{[0-9a-z.]*}}, i32 0, i32 0, i32 0)
diff --git a/llpc/test/shaderdb/core/OpFunctionCall_TestArguTexArray_lit.frag b/llpc/test/shaderdb/core/OpFunctionCall_TestArguTexArray_lit.frag
index f07a00787..894b9b2d5 100644
--- a/llpc/test/shaderdb/core/OpFunctionCall_TestArguTexArray_lit.frag
+++ b/llpc/test/shaderdb/core/OpFunctionCall_TestArguTexArray_lit.frag
@@ -20,14 +20,14 @@ void main()
     color += func(samp2D[1], vec2(1.0));
 
     fragColor = color;
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST-COUNT-2: call {{.*}} <4 x float> @{{.*}}
-; SHADERTEST: define internal {{.*}} <4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
+; SHADERTEST: define internal {{.*}} <4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpFunctionCall_TestManyParameters_lit.frag b/llpc/test/shaderdb/core/OpFunctionCall_TestManyParameters_lit.frag
index bc9961ddd..1da224982 100644
--- a/llpc/test/shaderdb/core/OpFunctionCall_TestManyParameters_lit.frag
+++ b/llpc/test/shaderdb/core/OpFunctionCall_TestManyParameters_lit.frag
@@ -44,17 +44,17 @@ void main()
                       vec4(-7.0),
                       false,
                       bvec2(true),
                       bvec3(false),
                       bvec4(true));
 
     fragColor = (value == false) ? vec4(1.0) : vec4(0.5);
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST: call {{.*}} i1 @{{.*}}
-; SHADERTEST: define internal {{.*}} i1 @{{.*}}(i32{{.*}}, <2 x i32>{{.*}}, <3 x i32>{{.*}}, <4 x i32>{{.*}}, float{{.*}}, <2 x float>{{.*}}, <3 x float>{{.*}}, <4 x float>{{.*}}, i32{{.*}}, <2 x i32>{{.*}}, <3 x i32>{{.*}}, <4 x i32>{{.*}})
+; SHADERTEST: define internal {{.*}} i1 @{{.*}}(ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}}, ptr{{.*}})
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpFunctionCall_TestParamSimpleTex_lit.frag b/llpc/test/shaderdb/core/OpFunctionCall_TestParamSimpleTex_lit.frag
index 8c4ec2c50..98b3215c9 100644
--- a/llpc/test/shaderdb/core/OpFunctionCall_TestParamSimpleTex_lit.frag
+++ b/llpc/test/shaderdb/core/OpFunctionCall_TestParamSimpleTex_lit.frag
@@ -14,14 +14,14 @@ void main()
 {
     fragColor  = func(samp2D_0, vec2(1.0));
     fragColor += func(samp2D_1, vec2(0.0));
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST-COUNT-2: call {{.*}} <4 x float> @{{.*}}
-; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
+; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexArray_lit.frag b/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexArray_lit.frag
index 602f378a9..43bb7a2da 100644
--- a/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexArray_lit.frag
+++ b/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexArray_lit.frag
@@ -20,14 +20,14 @@ vec4 func(sampler2D s2D[4], vec2 coord)
 
 void main()
 {
     fragColor = func(samp2D_0, vec2(0.5)) + func(samp2D_1, vec2(1.0));
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST-COUNT-2: call {{.*}} <4 x float> @{{.*}}
-; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { ptr addrspace(4), i32 }, { ptr addrspace(4), i32, i32 } } %{{[a-zA-Z0-9]+}}, ptr addrspace(5) %{{[a-z0-9]+}})
+; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexNestedCall_lit.frag b/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexNestedCall_lit.frag
index 986b6f53b..f002c7bd2 100644
--- a/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexNestedCall_lit.frag
+++ b/llpc/test/shaderdb/core/OpFunctionCall_TestParamTexNestedCall_lit.frag
@@ -25,14 +25,14 @@ void main()
     vec4 color = func1(samp2D_0, vec2(1.0));
     color *= func1(samp2D_1, vec2(0.5));
 
     fragColor = color;
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST-COUNT-2: call {{.*}} <4 x float> @{{.*}}
-; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { ptr addrspace(4), i32 }, { ptr addrspace(4), i32, i32 } } %{{[a-zA-Z0-9]+}}, ptr addrspace(5) %{{[a-z0-9]+}})
+; SHADERTEST: define internal {{.*}}<4 x float> @{{.*}}({ { {{<8 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32, i32 }, { {{<4 x i32> addrspace\(4\)\*|ptr addrspace\(4\)}}, i32, i32 } } %{{[a-zA-Z0-9]+}}, {{<2 x float> addrspace\(5\)\*|ptr addrspace\(5\)}} %{{[a-z0-9]+}})
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/core/OpPtrDiff_Buffer_mem.spvasm b/llpc/test/shaderdb/core/OpPtrDiff_Buffer_mem.spvasm
index d6ea04943..a4cc687e4 100644
--- a/llpc/test/shaderdb/core/OpPtrDiff_Buffer_mem.spvasm
+++ b/llpc/test/shaderdb/core/OpPtrDiff_Buffer_mem.spvasm
@@ -1,34 +1,37 @@
 ; BEGIN_SHADERTEST
+; REQUIRES: do-not-run-me
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i32 0, ptr addrspace(7) {{@[0-9]+}}, ptr addrspace(7) {{%[0-9]+}})
 ; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i64 0, ptr addrspace(7) {{@[0-9]+}}, ptr addrspace(7) {{%[0-9]+}})
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline before-patching results
 
 ; SHADERTEST: call i64 @lgc.late.buffer.ptrdiff.i32.p7.p7(i32 0, ptr addrspace(7) {{%[0-9]+}}, ptr addrspace(7) {{%[0-9]+}})
 ; SHADERTEST: call i64 @lgc.late.buffer.ptrdiff.i64.p7.p7(i64 0, ptr addrspace(7) {{%[0-9]+}}, ptr addrspace(7) {{%[0-9]+}})
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 
 ; SHADERTEST: [[a:%[0-9a-zA-Z.]+]] = shl i32 {{%[0-9a-zA-Z.]+}}, 2
 ; SHADERTEST: [[b:%[0-9]+]] = zext i32 [[a]] to i64
 ; SHADERTEST: [[c:%[0-9]+]] = sub nsw i64 0, [[b]]
-; SHADERTEST: [[d:%[0-9]+]] = ashr exact i64 [[c]], 2
-; SHADERTEST: {{%[0-9]+}} = trunc i64 [[d]] to i32
+; SHADERTEST: [[d1:%[0-9]+]] = ashr exact i64 [[c]], 2
 
 ; SHADERTEST: [[a:%[0-9a-zA-Z.]+]] = shl i32 {{%[0-9a-zA-Z.]+}}, 3
 ; SHADERTEST: [[b:%[0-9]+]] = zext i32 [[a]] to i64
 ; SHADERTEST: [[c:%[0-9]+]] = sub nsw i64 0, [[b]]
 ; SHADERTEST: [[d:%[0-9]+]] = ashr exact i64 [[c]], 3
-; SHADERTEST: {{%[0-9]+}} = trunc i64 [[d]] to i32
+; SHADERTEST: [[e:%[0-9]+]] = trunc i64 [[d]] to i32
+
+; SHADERTEST: [[e1:%[0-9a-zA-Z.]+]] = bitcast i64 [[d1]] to <2 x i32>
+; SHADERTEST: {{%[0-9]+}} = insertelement <2 x i32> [[e1]], i32 [[e]], i64 1
 
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 ; SPIR-V
 ; Version: 1.4
 ; Generator: Khronos SPIR-V Tools Assembler; 0
 ; Bound: 41
 ; Schema: 0
                OpCapability Int64
diff --git a/llpc/test/shaderdb/core/OpPtrDiff_Workgroup_mem.spvasm b/llpc/test/shaderdb/core/OpPtrDiff_Workgroup_mem.spvasm
index 26489599c..9df7090ba 100644
--- a/llpc/test/shaderdb/core/OpPtrDiff_Workgroup_mem.spvasm
+++ b/llpc/test/shaderdb/core/OpPtrDiff_Workgroup_mem.spvasm
@@ -1,29 +1,32 @@
 ; BEGIN_SHADERTEST
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; REQUIRES: do-not-run-me
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i32 0, i32 addrspace(3)* getelementptr inbounds ([32 x i32], [32 x i32] addrspace(3)* @lds, i32 0, i32 0), i32 addrspace(3)* {{%[0-9]+}})
-; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i64 0, i64 addrspace(3)* getelementptr inbounds ([32 x i64], [32 x i64] addrspace(3)* @lds.1, i32 0, i32 0), i64 addrspace(3)* {{%[0-9]+}})
+; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i32 0, ptr addrspace(3) @lds, ptr addrspace(3) {{%[0-9]+}})
+; SHADERTEST: call i64 (...) @lgc.create.buffer.ptrdiff.i64(i64 0, ptr addrspace(3) @lds.1, ptr addrspace(3) {{%[0-9]+}})
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline before-patching results
 
-; SHADERTEST: [[a:%[0-9]+]] = getelementptr [32 x i32], [32 x i32] addrspace(3)* @lds, i32 0, i32 {{%[0-9]+}}
-; SHADERTEST: [[b:%[0-9]+]] = ptrtoint i32 addrspace(3)* [[a]] to i64
-; SHADERTEST: [[c:%[0-9]+]] = sub i64 ptrtoint ([32 x i32] addrspace(3)* @lds to i64), [[b]]
-; SHADERTEST: [[d:%[0-9]+]] = sdiv exact i64 [[c]], ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i64)
-; SHADERTEST: {{%[0-9]+}} = trunc i64 [[d]] to i32
+; SHADERTEST: [[a:%[0-9]+]] = getelementptr [32 x i32], ptr addrspace(3) @lds, i32 0, i32 {{%[0-9]+}}
+; SHADERTEST: [[b:%[0-9]+]] = ptrtoint ptr addrspace(3)* [[a]] to i64
+; SHADERTEST: [[c:%[0-9]+]] = sub i64 ptrtoint (ptr addrspace(3) @lds to i64), [[b]]
+; SHADERTEST: [[d1:%[0-9]+]] = sdiv exact i64 [[c]], ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64)
 
-; SHADERTEST: [[a:%[0-9]+]] = getelementptr [32 x i64], [32 x i64] addrspace(3)* @lds.1, i32 0, i32 {{%[0-9]+}}
-; SHADERTEST: [[b:%[0-9]+]] = ptrtoint i64 addrspace(3)* [[a]] to i64
-; SHADERTEST: [[c:%[0-9]+]] = sub i64 ptrtoint ([32 x i64] addrspace(3)* @lds.1 to i64), [[b]]
-; SHADERTEST: [[d:%[0-9]+]] = sdiv exact i64 [[c]], ptrtoint (i64* getelementptr (i64, i64* null, i32 1) to i64)
-; SHADERTEST: {{%[0-9]+}} = trunc i64 [[d]] to i32
+; SHADERTEST: [[a:%[0-9]+]] = getelementptr [32 x i64], ptr addrspace(3) @lds.1, i32 0, i32 {{%[0-9]+}}
+; SHADERTEST: [[b:%[0-9]+]] = ptrtoint ptr addrspace(3) [[a]] to i64
+; SHADERTEST: [[c:%[0-9]+]] = sub i64 ptrtoint (ptr addrspace(3) @lds.1 to i64), [[b]]
+; SHADERTEST: [[d:%[0-9]+]] = sdiv exact i64 [[c]], ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64)
+; SHADERTEST: [[e:%[0-9]+]] = trunc i64 [[d]] to i32
+
+; SHADERTEST: [[e1:%[0-9a-zA-Z.]+]] = bitcast i64 [[d1]] to <2 x i32>
+; SHADERTEST: {{%[0-9]+}} = insertelement <2 x i32> [[e1]], i32 [[e]], i64 1
 
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 ; SPIR-V
 ; Version: 1.4
 ; Generator: Khronos SPIR-V Tools Assembler; 0
 ; Bound: 41
 ; Schema: 0
                OpCapability Int64
diff --git a/llpc/test/shaderdb/core/OpPtrEqualTest.spvasm b/llpc/test/shaderdb/core/OpPtrEqualTest.spvasm
index b16b09d30..258260e1d 100644
--- a/llpc/test/shaderdb/core/OpPtrEqualTest.spvasm
+++ b/llpc/test/shaderdb/core/OpPtrEqualTest.spvasm
@@ -1,23 +1,27 @@
 ; Test OpPtrEqual
 
 ; BEGIN_SHADERTEST
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 ; Normal comparison
-; SHADERTEST: [[CMP1:%[0-9]*]] = icmp eq float addrspace(7)* getelementptr inbounds ({{.*}}, i32 0, i32 2), getelementptr inbounds ({{.*}}, i32 0, i32 3)
-; SHADERTEST: [[Value1:%[0-9]*]] = select i1 [[CMP1]], i32 0, i32 1
-; SHADERTEST: store i32 [[Value1]], i32 addrspace(7)* {{.*}}, align 4
-; Comparing 4X4 ColMajor and RowMajor matrics, which have the same SPIR-V type "OpTypeMatrix %v4float 4", return false.
-; SHADERTEST: [[CMP2:%[0-9]*]] = icmp eq i32 0, 1
-; SHADERTEST: [[Value2:%[0-9]*]] = select i1 [[CMP2]], i32 0, i32 1
-; SHADERTEST: store i32 [[Value2]], i32 addrspace(7)* {{.*}}, align 4
+; SHADERTEST: [[Value1:%[0-9]*]] = select i1 icmp eq (ptr addrspace(7) getelementptr inbounds ({{.*}}, i32 0, i32 3), ptr addrspace(7) getelementptr inbounds ({{.*}}, i32 0, i32 4)), i32 0, i32 1
+; SHADERTEST: store i32 [[Value1]], ptr addrspace(7) {{.*}}, align 4
+; Comparing 4X4 ColMajor and RowMajor matrics.
+; SHADERTEST: [[Value2:%[0-9]*]] = select i1 icmp eq (ptr addrspace(7) getelementptr inbounds ({{.*}}, i32 0, i32 1), ptr addrspace(7) @{{[0-9]+}}), i32 0, i32 1
+; SHADERTEST: store i32 [[Value2]], ptr addrspace(7) {{.*}}, align 4
+; Comparing 4X4 RowMajor and RowMajor matrics.
+; SHADERTEST: [[Value3:%[0-9]*]] = select i1 icmp eq (ptr addrspace(7) getelementptr inbounds ({{.*}}, i32 0, i32 1), ptr addrspace(7) getelementptr inbounds ({{.*}}, i32 0, i32 2)), i32 0, i32 1
+; SHADERTEST: store i32 [[Value3]], ptr addrspace(7) {{.*}}, align 4
+; Comparing the same pointers.
+; SHADERTEST: [[Value4:%[0-9]*]] = select i1 true, i32 0, i32 1
+; SHADERTEST: store i32 [[Value4]], ptr addrspace(7) {{.*}}, align 4
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 ; SPIR-V
 ; Version: 1.4
 ; Generator: Khronos SPIR-V Tools Assembler; 0
 ; Bound: 59
 ; Schema: 0
                OpCapability Shader
                OpCapability VariablePointersStorageBuffer
@@ -26,61 +30,74 @@
                OpExecutionMode %1 LocalSize 1 1 1
                OpDecorate %_runtimearr_uint ArrayStride 4
                OpDecorate %_struct_5 Block
                OpDecorate %_struct_6 Block
                OpMemberDecorate %_struct_5 0 ColMajor
                OpMemberDecorate %_struct_5 0 Offset 0
                OpMemberDecorate %_struct_5 0 MatrixStride 16
                OpMemberDecorate %_struct_5 1 RowMajor
                OpMemberDecorate %_struct_5 1 Offset 64
                OpMemberDecorate %_struct_5 1 MatrixStride 16
+               OpMemberDecorate %_struct_5 2 RowMajor
                OpMemberDecorate %_struct_5 2 Offset 128
-               OpMemberDecorate %_struct_5 3 Offset 132
+               OpMemberDecorate %_struct_5 2 MatrixStride 16
+               OpMemberDecorate %_struct_5 3 Offset 192
+               OpMemberDecorate %_struct_5 4 Offset 196
                OpMemberDecorate %_struct_6 0 Offset 0
                OpDecorate %2 DescriptorSet 0
                OpDecorate %2 Binding 0
                OpDecorate %4 DescriptorSet 0
                OpDecorate %4 Binding 2
        %void = OpTypeVoid
        %bool = OpTypeBool
        %uint = OpTypeInt 32 0
      %uint_0 = OpConstant %uint 0
      %uint_1 = OpConstant %uint 1
      %uint_2 = OpConstant %uint 2
      %uint_3 = OpConstant %uint 3
+     %uint_4 = OpConstant %uint 4
       %float = OpTypeFloat 32
 %_runtimearr_uint = OpTypeRuntimeArray %uint
     %v4float = OpTypeVector %float 4
 %mat4v4float = OpTypeMatrix %v4float 4
-  %_struct_5 = OpTypeStruct %mat4v4float %mat4v4float %float %float
+  %_struct_5 = OpTypeStruct %mat4v4float %mat4v4float %mat4v4float %float %float
   %_struct_6 = OpTypeStruct %_runtimearr_uint
 %_ptr_StorageBuffer__struct_5 = OpTypePointer StorageBuffer %_struct_5
 %_ptr_StorageBuffer__struct_6 = OpTypePointer StorageBuffer %_struct_6
 %_ptr_StorageBuffer_mat4v4float = OpTypePointer StorageBuffer %mat4v4float
 %_ptr_StorageBuffer_uint = OpTypePointer StorageBuffer %uint
 %_ptr_StorageBuffer_float = OpTypePointer StorageBuffer %float
 %_ptr_StorageBuffer_v4float = OpTypePointer StorageBuffer %v4float
           %2 = OpVariable %_ptr_StorageBuffer__struct_5 StorageBuffer
           %4 = OpVariable %_ptr_StorageBuffer__struct_6 StorageBuffer
          %24 = OpTypeFunction %void
           %1 = OpFunction %void None %24
          %25 = OpLabel
          %26 = OpCopyObject %uint %uint_0
-         %27 = OpAccessChain %_ptr_StorageBuffer_float %2 %uint_2
-         %28 = OpAccessChain %_ptr_StorageBuffer_float %2 %uint_3
+         %27 = OpAccessChain %_ptr_StorageBuffer_float %2 %uint_3
+         %28 = OpAccessChain %_ptr_StorageBuffer_float %2 %uint_4
          %31 = OpAccessChain %_ptr_StorageBuffer_mat4v4float %2 %uint_0
          %32 = OpAccessChain %_ptr_StorageBuffer_mat4v4float %2 %uint_1
-         %33 = OpAccessChain %_ptr_StorageBuffer_v4float %2 %uint_0 %uint_0
-         %34 = OpAccessChain %_ptr_StorageBuffer_v4float %2 %uint_0 %uint_1
-         %35 = OpAccessChain %_ptr_StorageBuffer_float %2 %uint_0 %uint_0 %uint_0
+         %34 = OpAccessChain %_ptr_StorageBuffer_mat4v4float %2 %uint_1
+         %35 = OpAccessChain %_ptr_StorageBuffer_mat4v4float %2 %uint_2
          %36 = OpPtrEqual %bool %27 %28
          %37 = OpSelect %uint %36 %uint_0 %uint_1
          %38 = OpAccessChain %_ptr_StorageBuffer_uint %4 %uint_0 %26
          %39 = OpIAdd %uint %26 %uint_1
                OpStore %38 %37
          %55 = OpPtrEqual %bool %31 %32
          %56 = OpSelect %uint %55 %uint_0 %uint_1
          %57 = OpAccessChain %_ptr_StorageBuffer_uint %4 %uint_0 %39
          %58 = OpIAdd %uint %39 %uint_1
                OpStore %57 %56
+         %60 = OpPtrEqual %bool %34 %35
+         %61 = OpSelect %uint %60 %uint_0 %uint_1
+         %62 = OpAccessChain %_ptr_StorageBuffer_uint %4 %uint_0 %58
+         %63 = OpIAdd %uint %58 %uint_1
+               OpStore %62 %61
+         %70 = OpPtrEqual %bool %32 %32
+         %71 = OpSelect %uint %70 %uint_0 %uint_1
+         %72 = OpAccessChain %_ptr_StorageBuffer_uint %4 %uint_0 %63
+         %73 = OpIAdd %uint %63 %uint_1
+               OpStore %72 %71
                OpReturn
                OpFunctionEnd
diff --git a/llpc/test/shaderdb/core/TestForceNonUniformResourceIndex.frag b/llpc/test/shaderdb/core/TestForceNonUniformResourceIndex.frag
new file mode 100644
index 000000000..13b66e12f
--- /dev/null
+++ b/llpc/test/shaderdb/core/TestForceNonUniformResourceIndex.frag
@@ -0,0 +1,33 @@
+// Test not forcing NURI
+// BEGIN_SHADERTEST
+// RUN: amdllpc -v %gfxip %s --force-non-uniform-resource-index-stage-mask=0x00000000 | FileCheck -check-prefix=NOTFORCENURITEST %s
+// NOTFORCENURITEST-LABEL: {{^// LLPC}} pipeline before-patching results
+// When not forcing NURI (Non Uniform Resource Index), there should be a `readfirstlane`.
+// NOTFORCENURITEST: %{{[0-9]+}} = call i32 @llvm.amdgcn.readfirstlane(i32 %{{[0-9]+}})
+// NOTFORCENURITEST: AMDLLPC SUCCESS
+// END_SHADERTEST
+
+// Test forcing NURI
+// BEGIN_SHADERTEST
+// RUN: amdllpc -v %gfxip %s --force-non-uniform-resource-index-stage-mask=0xFFFFFFFF | FileCheck -check-prefix=FORCENURITEST %s
+// FORCENURITEST-LABEL: {{^// LLPC}} pipeline before-patching results
+// When forcing NURI (Non Uniform Resource Index), there should not be a `readfirstlane`.
+// FORCENURITEST-NOT: %{{[0-9]+}} = call i32 @llvm.amdgcn.readfirstlane(i32 %{{[0-9]+}})
+// FORCENURITEST: AMDLLPC SUCCESS
+// END_SHADERTEST
+
+#version 450
+
+#extension GL_EXT_nonuniform_qualifier : require
+
+layout(set = 0, binding = 0) buffer Data
+{
+    vec4 color;
+} data[];
+
+layout(location = 0) out vec4 FragColor;
+layout(location = 0) in flat int index;
+void main()
+{
+  FragColor = data[index].color;
+}
diff --git a/llpc/test/shaderdb/core/TestXfbStateMetadata.geom b/llpc/test/shaderdb/core/TestXfbStateMetadata.geom
new file mode 100644
index 000000000..873ee7682
--- /dev/null
+++ b/llpc/test/shaderdb/core/TestXfbStateMetadata.geom
@@ -0,0 +1,39 @@
+// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py UTC_ARGS: --function-signature --check-globals
+// RUN: amdllpc -o - -gfxip 10.1 -emit-lgc %s | FileCheck -check-prefixes=CHECK %s
+#version 450
+
+struct S {
+    vec4 a;
+    int b;
+};
+layout(points) in;
+
+layout(points, max_vertices = 1) out;
+layout(xfb_buffer = 0, xfb_offset = 0, xfb_stride = 16, location = 0) out Block
+{
+    S s;
+} block[2][3];
+
+void main(void)
+{
+    EmitVertex();
+    EndPrimitive();
+}
+// CHECK-LABEL: define {{[^@]+}}@lgc.shader.GS.main
+// CHECK-SAME: () local_unnamed_addr #[[ATTR0:[0-9]+]] !spirv.ExecutionModel !7 !lgc.xfb.state !8 !lgc.shaderstage !9 {
+// CHECK-NEXT:  .entry:
+// CHECK-NEXT:    call void (...) @lgc.create.emit.vertex(i32 0)
+// CHECK-NEXT:    call void (...) @lgc.create.end.primitive(i32 0)
+// CHECK-NEXT:    ret void
+//
+//.
+// CHECK: attributes #[[ATTR0]] = { nounwind }
+//.
+// CHECK: [[META0:![0-9]+]] = !{i32 0, i32 0, i32 1, i32 1}
+// CHECK: [[META1:![0-9]+]] = !{!"Vulkan"}
+// CHECK: [[META2:![0-9]+]] = !{i32 1}
+// CHECK: [[META5:![0-9]+]] = !{i32 0, i32 3}
+// CHECK: [[META7:![0-9]+]] = !{i32 3}
+// CHECK: [[META8:![0-9]+]] = !{i32 0, i32 16, i32 0, i32 16, i32 0, i32 16, i32 -1, i32 0}
+// CHECK: [[META9:![0-9]+]] = !{i32 4}
+//.
diff --git a/llpc/test/shaderdb/general/AggressiveInvariantLoads.pipe b/llpc/test/shaderdb/general/AggressiveInvariantLoads.pipe
index 2937511c6..22b2bacc8 100644
--- a/llpc/test/shaderdb/general/AggressiveInvariantLoads.pipe
+++ b/llpc/test/shaderdb/general/AggressiveInvariantLoads.pipe
@@ -1,15 +1,15 @@
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
-; SHADERTEST: load <4 x i32>, <4 x i32> addrspace(4)* %4, align 16, !invariant.load
-; SHADERTEST: load <4 x float>, <4 x float> addrspace(4)* %4, align 16, !invariant.load
+; SHADERTEST: load <4 x i32>, ptr addrspace(4) %4, align 16, !invariant.load
+; SHADERTEST: load <4 x float>, ptr addrspace(4) %4, align 16, !invariant.load
 ; SHADERTEST-LABEL: {{^// LLPC}} final pipeline module info
 
 [VsGlsl]
 #version 450
 
 layout( location = 0 ) in vec4 app_position;
 
 void main() {
   gl_Position = app_position;
 }
diff --git a/llpc/test/shaderdb/general/PipelineCs_TestInlineConstDirect_lit.pipe b/llpc/test/shaderdb/general/PipelineCs_TestInlineConstDirect_lit.pipe
index 66829126c..0714bf1c2 100644
--- a/llpc/test/shaderdb/general/PipelineCs_TestInlineConstDirect_lit.pipe
+++ b/llpc/test/shaderdb/general/PipelineCs_TestInlineConstDirect_lit.pipe
@@ -1,26 +1,24 @@
 ; BEGIN_SHADERTEST
-; RUN: amdllpc -enable-load-scalarizer=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; REQUIRES: do-not-run-me
+; RUN: amdllpc -enable-load-scalarizer=false -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
 ; SHADERTEST: %{{.*}} = call {{.*}} {{.*}}@lgc.create.load.buffer.desc.{{[0-9a-z.]*}}(i32 0, i32 1, i32 0,
-; SHADERTEST: getelementptr inbounds i8, i8 addrspace(7)* %{{.*}}, i64 64
-; SHADERTEST: bitcast i8 addrspace(7)* %{{.*}} to <2 x double> addrspace(7)*
-; SHADERTEST: load <2 x double>, <2 x double> addrspace(7)* %{{.*}}, align 16
+; SHADERTEST: getelementptr inbounds {{.*}}, ptr addrspace(7) %{{.*}}, i64 0, i32 2
+; SHADERTEST: load <2 x double>, ptr addrspace(7) %{{.*}}, align 16
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
-; SHADERTEST: %{{.*}} = bitcast i8 addrspace(4)* %4 to <4 x i32> addrspace(4)*
-; SHADERTEST: %{{.*}} = insertelement <4 x i32> <i32 {{undef|poison}}, i32 {{undef|poison}}, i32 -1, i32 151468>, i32 %{{.*}}, {{i32|i64}} 0
+; SHADERTEST: %{{.*}} = shufflevector <4 x i32> %{{.*}}, <4 x i32> <i32 {{undef|poison}}, i32 {{undef|poison}}, i32 -1, i32 151468>, <4 x i32> <i32 0
 ; SHADERTEST: %{{.*}} = insertelement <4 x i32> %{{.*}}, i32 %{{.*}}, {{i32|i64}} 1
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{.*}}, i32 64, i32 0)
-; SHADERTEST: bitcast <4 x i32> %{{.*}} to <2 x double>
 
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 ; Test the use of InlineBuffer with relocatable shaders.  This is currently not supported, and we
 ; should fall back to full pipeline compilation.
 ; BEGIN_RELOCTEST
 ; RUN: amdllpc --enable-relocatable-shader-elf -o %t.elf %gfxip %s -v | FileCheck -check-prefix=RELOCTEST %s
 ; RELOCTEST-LABEL: {{^// LLPC}} calculated hash results (compute pipeline)
 ; RELOCTEST-LABEL: {{^Warning:}} Relocatable shader compilation requested but not possible
diff --git a/llpc/test/shaderdb/general/PipelineGs_TestViewIndexAndLayer.pipe b/llpc/test/shaderdb/general/PipelineGs_TestViewIndexAndLayer.pipe
index 28d196649..dabfd962a 100644
--- a/llpc/test/shaderdb/general/PipelineGs_TestViewIndexAndLayer.pipe
+++ b/llpc/test/shaderdb/general/PipelineGs_TestViewIndexAndLayer.pipe
@@ -1,22 +1,23 @@
 // Test gl_ViewIndex when multi-view is disabled
 
 ; BEGIN_SHADERTEST
 ; RUN: amdllpc -v --gfxip=10.3.0 %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: _amdgpu_vs_main:
-// gl_ViewIndex = 0
-; SHADERTEST: v_mov_b32_e32 v[[VIEWINDEX:[0-9]*]], 0
 // export gl_Layer
 ; SHADERTEST: exp pos1 off, off, {{v[0-9]*}}, off done
-// export gl_ViewIndex
-; SHADERTEST: exp param1 v[[VIEWINDEX]], off, off, off
+
+; SHADERTEST-LABEL: _amdgpu_ps_main:
+// gl_ViewIndex = 0
+; SHADERTEST: v_cvt_pkrtz_f16_f32_e32 {{v[0-9]*}}, 0, {{v[0-9]*}}
+
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 [Version]
 version = 53
 
 [VsGlsl]
 #version 450
 layout(location = 0) in vec4 position;
 layout(location = 0) out vec4 positionOut;
diff --git a/llpc/test/shaderdb/general/PipelineVsFs_TestInOutPacking.pipe b/llpc/test/shaderdb/general/PipelineVsFs_TestInOutPacking.pipe
index e25cfa79c..34930649e 100644
--- a/llpc/test/shaderdb/general/PipelineVsFs_TestInOutPacking.pipe
+++ b/llpc/test/shaderdb/general/PipelineVsFs_TestInOutPacking.pipe
@@ -1,127 +1,149 @@
 ; BEGIN_SHADERTEST
 ; RUN: amdllpc -enable-part-pipeline=0 -v %gfxip %s | FileCheck -check-prefix=SHADERTEST_PP0 %s
-; SHADERTEST_PP0-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST_PP0-LABEL: {{^// LLPC}} pipeline patching results
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}32, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}34, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}36, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}33, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}35, i32 {{.*}}7, float {{.*}}, float {{.*}}, float {{.*}}, float undef, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call void @llvm.amdgcn.exp.f32(i32 {{.*}}37, i32 {{.*}}7, float {{.*}}, float {{.*}}, float {{.*}}, float undef, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 3, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 3, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 2, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 3, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 0, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 1, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP0: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
+; SHADERTEST_PP0-LABEL: LLPC pipeline before-patching results
+; SHADERTEST_PP0-LABEL: LLPC location input/output mapping results (FS shader)
+; SHADERTEST_PP0: (FS) Input:  loc = 0, comp = 0 =>  Mapped = 0, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 0, comp = 1 =>  Mapped = 0, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 1, comp = 0 =>  Mapped = 0, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 1, comp = 1 =>  Mapped = 0, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 2, comp = 0 =>  Mapped = 4, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 2, comp = 1 =>  Mapped = 4, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 2, comp = 2 =>  Mapped = 4, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 2, comp = 3 =>  Mapped = 4, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 3, comp = 0 =>  Mapped = 4, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 3, comp = 1 =>  Mapped = 4, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 3, comp = 2 =>  Mapped = 4, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 3, comp = 3 =>  Mapped = 4, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 4, comp = 0 =>  Mapped = 1, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 4, comp = 1 =>  Mapped = 1, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 4, comp = 2 =>  Mapped = 1, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 4, comp = 3 =>  Mapped = 1, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 5, comp = 0 =>  Mapped = 2, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 5, comp = 1 =>  Mapped = 2, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 6, comp = 0 =>  Mapped = 2, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 7, comp = 0 =>  Mapped = 5, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 7, comp = 1 =>  Mapped = 5, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 8, comp = 0 =>  Mapped = 5, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 8, comp = 1 =>  Mapped = 5, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 9, comp = 0 =>  Mapped = 5, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 9, comp = 1 =>  Mapped = 5, 2
+; SHADERTEST_PP0: (FS) Input:  loc = 9, comp = 2 =>  Mapped = 5, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 9, comp = 3 =>  Mapped = 5, 3
+; SHADERTEST_PP0: (FS) Input:  loc = 10, comp = 0 =>  Mapped = 3, 0
+; SHADERTEST_PP0: (FS) Input:  loc = 10, comp = 1 =>  Mapped = 3, 1
+; SHADERTEST_PP0: (FS) Input:  loc = 10, comp = 2 =>  Mapped = 3, 2
+; SHADERTEST_PP0-LABEL: LLPC location input/output mapping results (VS shader)
+; SHADERTEST_PP0: (VS) Output: loc = 0, comp = 0  =>  Mapped = 0, 0
+; SHADERTEST_PP0: (VS) Output: loc = 0, comp = 1  =>  Mapped = 0, 1
+; SHADERTEST_PP0: (VS) Output: loc = 1, comp = 0  =>  Mapped = 0, 2
+; SHADERTEST_PP0: (VS) Output: loc = 1, comp = 1  =>  Mapped = 0, 3
+; SHADERTEST_PP0: (VS) Output: loc = 2, comp = 0  =>  Mapped = 4, 0
+; SHADERTEST_PP0: (VS) Output: loc = 2, comp = 1  =>  Mapped = 4, 0
+; SHADERTEST_PP0: (VS) Output: loc = 2, comp = 2  =>  Mapped = 4, 1
+; SHADERTEST_PP0: (VS) Output: loc = 2, comp = 3  =>  Mapped = 4, 1
+; SHADERTEST_PP0: (VS) Output: loc = 3, comp = 0  =>  Mapped = 4, 2
+; SHADERTEST_PP0: (VS) Output: loc = 3, comp = 1  =>  Mapped = 4, 2
+; SHADERTEST_PP0: (VS) Output: loc = 3, comp = 2  =>  Mapped = 4, 3
+; SHADERTEST_PP0: (VS) Output: loc = 3, comp = 3  =>  Mapped = 4, 3
+; SHADERTEST_PP0: (VS) Output: loc = 4, comp = 0  =>  Mapped = 1, 0
+; SHADERTEST_PP0: (VS) Output: loc = 4, comp = 1  =>  Mapped = 1, 1
+; SHADERTEST_PP0: (VS) Output: loc = 4, comp = 2  =>  Mapped = 1, 2
+; SHADERTEST_PP0: (VS) Output: loc = 4, comp = 3  =>  Mapped = 1, 3
+; SHADERTEST_PP0: (VS) Output: loc = 5, comp = 0  =>  Mapped = 2, 0
+; SHADERTEST_PP0: (VS) Output: loc = 5, comp = 1  =>  Mapped = 2, 1
+; SHADERTEST_PP0: (VS) Output: loc = 6, comp = 0  =>  Mapped = 2, 2
+; SHADERTEST_PP0: (VS) Output: loc = 7, comp = 0  =>  Mapped = 5, 0
+; SHADERTEST_PP0: (VS) Output: loc = 7, comp = 1  =>  Mapped = 5, 0
+; SHADERTEST_PP0: (VS) Output: loc = 8, comp = 0  =>  Mapped = 5, 1
+; SHADERTEST_PP0: (VS) Output: loc = 8, comp = 1  =>  Mapped = 5, 1
+; SHADERTEST_PP0: (VS) Output: loc = 9, comp = 0  =>  Mapped = 5, 2
+; SHADERTEST_PP0: (VS) Output: loc = 9, comp = 1  =>  Mapped = 5, 2
+; SHADERTEST_PP0: (VS) Output: loc = 9, comp = 2  =>  Mapped = 5, 3
+; SHADERTEST_PP0: (VS) Output: loc = 9, comp = 3  =>  Mapped = 5, 3
+; SHADERTEST_PP0: (VS) Output: loc = 10, comp = 0  =>  Mapped = 3, 0
+; SHADERTEST_PP0: (VS) Output: loc = 10, comp = 1  =>  Mapped = 3, 1
+; SHADERTEST_PP0: (VS) Output: loc = 10, comp = 2  =>  Mapped = 3, 2
 ; SHADERTEST_PP0: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 
 
 
 ; BEGIN_SHADERTEST
 ; RUN: amdllpc -enable-part-pipeline=1 -v %gfxip %s | FileCheck -check-prefix=SHADERTEST_PP1 %s
 ; Fragment shader part-pipeline:
-; SHADERTEST_PP1-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST_PP1-LABEL: {{^// LLPC}} pipeline patching results
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 3, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 4, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg false, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1.f16(float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call half @llvm.amdgcn.interp.p2.f16(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 1, i1 immarg true, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 3, i32 immarg 2, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 3, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 2, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 2, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 3, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 3, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 0, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 0, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p1(float %{{[^,]*}}, i32 immarg 1, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.p2(float %{{[0-9]*}}, float %{{[^,]*}}, i32 immarg 1, i32 immarg 0, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 0, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 1, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 0, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 1, i32 immarg 5, i32 %PrimMask)
-; SHADERTEST_PP1: call float @llvm.amdgcn.interp.mov(i32 immarg 2, i32 immarg 2, i32 immarg 5, i32 %PrimMask)
+; SHADERTEST_PP1-LABEL: LLPC pipeline before-patching results
+; SHADERTEST_PP1-LABEL: LLPC location input/output mapping results (FS shader)
+; SHADERTEST_PP1: (FS) Input:  loc = 0, comp = 0 =>  Mapped = 0, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 0, comp = 1 =>  Mapped = 0, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 1, comp = 0 =>  Mapped = 0, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 1, comp = 1 =>  Mapped = 0, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 2, comp = 0 =>  Mapped = 4, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 2, comp = 1 =>  Mapped = 4, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 2, comp = 2 =>  Mapped = 4, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 2, comp = 3 =>  Mapped = 4, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 3, comp = 0 =>  Mapped = 4, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 3, comp = 1 =>  Mapped = 4, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 3, comp = 2 =>  Mapped = 4, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 3, comp = 3 =>  Mapped = 4, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 4, comp = 0 =>  Mapped = 1, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 4, comp = 1 =>  Mapped = 1, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 4, comp = 2 =>  Mapped = 1, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 4, comp = 3 =>  Mapped = 1, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 5, comp = 0 =>  Mapped = 2, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 5, comp = 1 =>  Mapped = 2, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 6, comp = 0 =>  Mapped = 2, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 7, comp = 0 =>  Mapped = 5, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 7, comp = 1 =>  Mapped = 5, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 8, comp = 0 =>  Mapped = 5, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 8, comp = 1 =>  Mapped = 5, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 9, comp = 0 =>  Mapped = 5, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 9, comp = 1 =>  Mapped = 5, 2
+; SHADERTEST_PP1: (FS) Input:  loc = 9, comp = 2 =>  Mapped = 5, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 9, comp = 3 =>  Mapped = 5, 3
+; SHADERTEST_PP1: (FS) Input:  loc = 10, comp = 0 =>  Mapped = 3, 0
+; SHADERTEST_PP1: (FS) Input:  loc = 10, comp = 1 =>  Mapped = 3, 1
+; SHADERTEST_PP1: (FS) Input:  loc = 10, comp = 2 =>  Mapped = 3, 2
 ; Pre-rasterization part-pipeline:
-; SHADERTEST_PP1-LABEL: {{^// LLPC}} pipeline patching results
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}32, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}34, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}36, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}33, i32 {{.*}}15, float {{.*}}, float {{.*}}, float {{.*}}, float {{.*}}, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}35, i32 {{.*}}7, float {{.*}}, float {{.*}}, float {{.*}}, float undef, i1 {{.*}}false, i1 {{.*}}false)
-; SHADERTEST_PP1: call void @llvm.amdgcn.exp.f32(i32 {{.*}}37, i32 {{.*}}7, float {{.*}}, float {{.*}}, float {{.*}}, float undef, i1 {{.*}}false, i1 {{.*}}false)
+; SHADERTEST_PP1-LABEL: LLPC pipeline before-patching results
+; SHADERTEST_PP1-LABEL: LLPC location input/output mapping results (VS shader)
+; SHADERTEST_PP1: (VS) Output: loc = 0, comp = 0  =>  Mapped = 0, 0
+; SHADERTEST_PP1: (VS) Output: loc = 0, comp = 1  =>  Mapped = 0, 1
+; SHADERTEST_PP1: (VS) Output: loc = 1, comp = 0  =>  Mapped = 0, 2
+; SHADERTEST_PP1: (VS) Output: loc = 1, comp = 1  =>  Mapped = 0, 3
+; SHADERTEST_PP1: (VS) Output: loc = 2, comp = 0  =>  Mapped = 4, 0
+; SHADERTEST_PP1: (VS) Output: loc = 2, comp = 1  =>  Mapped = 4, 0
+; SHADERTEST_PP1: (VS) Output: loc = 2, comp = 2  =>  Mapped = 4, 1
+; SHADERTEST_PP1: (VS) Output: loc = 2, comp = 3  =>  Mapped = 4, 1
+; SHADERTEST_PP1: (VS) Output: loc = 3, comp = 0  =>  Mapped = 4, 2
+; SHADERTEST_PP1: (VS) Output: loc = 3, comp = 1  =>  Mapped = 4, 2
+; SHADERTEST_PP1: (VS) Output: loc = 3, comp = 2  =>  Mapped = 4, 3
+; SHADERTEST_PP1: (VS) Output: loc = 3, comp = 3  =>  Mapped = 4, 3
+; SHADERTEST_PP1: (VS) Output: loc = 4, comp = 0  =>  Mapped = 1, 0
+; SHADERTEST_PP1: (VS) Output: loc = 4, comp = 1  =>  Mapped = 1, 1
+; SHADERTEST_PP1: (VS) Output: loc = 4, comp = 2  =>  Mapped = 1, 2
+; SHADERTEST_PP1: (VS) Output: loc = 4, comp = 3  =>  Mapped = 1, 3
+; SHADERTEST_PP1: (VS) Output: loc = 5, comp = 0  =>  Mapped = 2, 0
+; SHADERTEST_PP1: (VS) Output: loc = 5, comp = 1  =>  Mapped = 2, 1
+; SHADERTEST_PP1: (VS) Output: loc = 6, comp = 0  =>  Mapped = 2, 2
+; SHADERTEST_PP1: (VS) Output: loc = 7, comp = 0  =>  Mapped = 5, 0
+; SHADERTEST_PP1: (VS) Output: loc = 7, comp = 1  =>  Mapped = 5, 0
+; SHADERTEST_PP1: (VS) Output: loc = 8, comp = 0  =>  Mapped = 5, 1
+; SHADERTEST_PP1: (VS) Output: loc = 8, comp = 1  =>  Mapped = 5, 1
+; SHADERTEST_PP1: (VS) Output: loc = 9, comp = 0  =>  Mapped = 5, 2
+; SHADERTEST_PP1: (VS) Output: loc = 9, comp = 1  =>  Mapped = 5, 2
+; SHADERTEST_PP1: (VS) Output: loc = 9, comp = 2  =>  Mapped = 5, 3
+; SHADERTEST_PP1: (VS) Output: loc = 9, comp = 3  =>  Mapped = 5, 3
+; SHADERTEST_PP1: (VS) Output: loc = 10, comp = 0  =>  Mapped = 3, 0
+; SHADERTEST_PP1: (VS) Output: loc = 10, comp = 1  =>  Mapped = 3, 1
+; SHADERTEST_PP1: (VS) Output: loc = 10, comp = 2  =>  Mapped = 3, 2
 ; SHADERTEST_PP1: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 [Version]
 version = 6
 
 [VsGlsl]
 #version 450
 #extension GL_AMD_gpu_shader_half_float: enable
 #extension GL_ARB_gpu_shader_int64 : enable
diff --git a/llpc/test/shaderdb/general/PipelineVsFs_TestNullFs.pipe b/llpc/test/shaderdb/general/PipelineVsFs_TestNullFs.pipe
index 7a7891ccc..4909a47d3 100644
--- a/llpc/test/shaderdb/general/PipelineVsFs_TestNullFs.pipe
+++ b/llpc/test/shaderdb/general/PipelineVsFs_TestNullFs.pipe
@@ -1,25 +1,124 @@
-
-; BEGIN_SHADERTEST
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
-; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: AMDLLPC SUCCESS
-; END_SHADERTEST
+; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py UTC_ARGS: --check-pal-metadata
+; RUN: amdllpc -gfxip 10.3 -o - -filetype=asm %s | FileCheck -check-prefixes=CHECK %s
 
 [VsGlsl]
 #version 450 core
 
 void main()
 {
     gl_Position = vec4(0);
 }
 
 [VsInfo]
 entryPoint = main
 
 [GraphicsPipelineState]
 patchControlPoints = 0
 alphaToCoverageEnable = 0
 dualSourceBlendEnable = 0
 colorBuffer[0].format = VK_FORMAT_B8G8R8A8_UNORM
 colorBuffer[0].blendEnable = 0
 colorBuffer[0].blendSrcAlphaToColor = 0
+
+; CHECK-LABEL: amdgpu_vs_main:
+; CHECK:         v_mov_b32_e32 v0, 0
+; CHECK-NEXT:    exp pos0 v0, v0, v0, v0 done
+; CHECK-NEXT:    s_endpgm
+;
+; CHECK-LABEL: amdgpu_ps_main:
+; CHECK:         s_endpgm
+;
+; CHECK-LABEL: .amdgpu_pal_metadata
+; CHECK-NEXT: ---
+; CHECK-NEXT: amdpal.pipelines:
+; CHECK-NEXT:   - .api:            Vulkan
+; CHECK-NEXT:     .hardware_stages:
+; CHECK-NEXT:       .ps:
+; CHECK-NEXT:         .entry_point:    _amdgpu_ps_main
+; CHECK-NEXT:         .scratch_memory_size: 0
+; CHECK-NEXT:         .sgpr_count:     0x3
+; CHECK-NEXT:         .sgpr_limit:     0x6a
+; CHECK-NEXT:         .vgpr_count:     0x2
+; CHECK-NEXT:         .vgpr_limit:     0x100
+; CHECK-NEXT:         .wavefront_size: 0x40
+; CHECK-NEXT:       .vs:
+; CHECK-NEXT:         .entry_point:    _amdgpu_vs_main
+; CHECK-NEXT:         .scratch_memory_size: 0
+; CHECK-NEXT:         .sgpr_count:     0x4
+; CHECK-NEXT:         .sgpr_limit:     0x6a
+; CHECK-NEXT:         .vgpr_count:     0x4
+; CHECK-NEXT:         .vgpr_limit:     0x100
+; CHECK-NEXT:         .wavefront_size: 0x20
+; CHECK-NEXT:     .internal_pipeline_hash:
+; CHECK-NEXT:       - 0x{{[0-9a-f]+}}
+; CHECK-NEXT:       - 0x{{[0-9a-f]+}}
+; CHECK-NEXT:     .registers:
+; CHECK-NEXT:       0x2c01:          0
+; CHECK-NEXT:       0x2c06 (SPI_SHADER_PGM_CHKSUM_PS): {{.*}}
+; CHECK-NEXT:       0x2c0a (SPI_SHADER_PGM_RSRC1_PS): 0x22c0000
+; CHECK-NEXT:       0x2c0b (SPI_SHADER_PGM_RSRC2_PS): 0x4
+; CHECK-NEXT:       0x2c0c (SPI_SHADER_USER_DATA_PS_0): 0x10000000
+; CHECK-NEXT:       0x2c45 (SPI_SHADER_PGM_CHKSUM_VS): {{.*}}
+; CHECK-NEXT:       0x2c4a (SPI_SHADER_PGM_RSRC1_VS): 0x82c0000
+; CHECK-NEXT:       0x2c4b (SPI_SHADER_PGM_RSRC2_VS): 0x8
+; CHECK-NEXT:       0x2c4c (SPI_SHADER_USER_DATA_VS_0): 0x10000000
+; CHECK-NEXT:       0x2c4e (SPI_SHADER_USER_DATA_VS_2): 0x10000003
+; CHECK-NEXT:       0x2c4f (SPI_SHADER_USER_DATA_VS_3): 0x10000004
+; CHECK-NEXT:       0xa08f (CB_SHADER_MASK): 0
+; CHECK-NEXT:       0xa191 (SPI_PS_INPUT_CNTL_0): 0
+; CHECK-NEXT:       0xa1b1 (SPI_VS_OUT_CONFIG): 0x80
+; CHECK-NEXT:       0xa1b3 (SPI_PS_INPUT_ENA): 0x1
+; CHECK-NEXT:       0xa1b4 (SPI_PS_INPUT_ADDR): 0x1
+; CHECK-NEXT:       0xa1b5 (SPI_INTERP_CONTROL_0): 0
+; CHECK-NEXT:       0xa1b6 (SPI_PS_IN_CONTROL): 0
+; CHECK-NEXT:       0xa1b8 (SPI_BARYC_CNTL): 0x1000000
+; CHECK-NEXT:       0xa1c3 (SPI_SHADER_POS_FORMAT): 0x4
+; CHECK-NEXT:       0xa1c4 (SPI_SHADER_Z_FORMAT): 0
+; CHECK-NEXT:       0xa1c5 (SPI_SHADER_COL_FORMAT): 0
+; CHECK-NEXT:       0xa203 (DB_SHADER_CONTROL): 0x810
+; CHECK-NEXT:       0xa204 (PA_CL_CLIP_CNTL): 0x1000000
+; CHECK-NEXT:       0xa206 (PA_CL_VTE_CNTL): 0x43f
+; CHECK-NEXT:       0xa207 (PA_CL_VS_OUT_CNTL): 0
+; CHECK-NEXT:       0xa210 (PA_STEREO_CNTL): 0x2
+; CHECK-NEXT:       0xa291 (VGT_GS_ONCHIP_CNTL): 0
+; CHECK-NEXT:       0xa293 (PA_SC_MODE_CNTL_1): 0x602018c
+; CHECK-NEXT:       0xa2a1 (VGT_PRIMITIVEID_EN): 0
+; CHECK-NEXT:       0xa2ad (VGT_REUSE_OFF): 0
+; CHECK-NEXT:       0xa2b5 (VGT_STRMOUT_VTX_STRIDE_0): 0
+; CHECK-NEXT:       0xa2b9 (VGT_STRMOUT_VTX_STRIDE_1): 0
+; CHECK-NEXT:       0xa2bd (VGT_STRMOUT_VTX_STRIDE_2): 0
+; CHECK-NEXT:       0xa2c1 (VGT_STRMOUT_VTX_STRIDE_3): 0
+; CHECK-NEXT:       0xa2d5 (VGT_SHADER_STAGES_EN): 0x810000
+; CHECK-NEXT:       0xa2e5 (VGT_STRMOUT_CONFIG): 0
+; CHECK-NEXT:       0xa2e6 (VGT_STRMOUT_BUFFER_CONFIG): 0
+; CHECK-NEXT:       0xa2f8 (PA_SC_AA_CONFIG): 0
+; CHECK-NEXT:       0xa2f9 (PA_SU_VTX_CNTL): 0x2d
+; CHECK-NEXT:       0xa310 (PA_SC_SHADER_CONTROL): 0
+; CHECK-NEXT:       0xc258 (IA_MULTI_VGT_PARAM_PIPED): 0x7f
+; CHECK-NEXT:       0xc25f (GE_STEREO_CNTL): 0
+; CHECK-NEXT:       0xc262 (GE_USER_VGPR_EN): 0
+; CHECK-NEXT:     .shaders:
+; CHECK-NEXT:       .pixel:
+; CHECK-NEXT:         .api_shader_hash:
+; CHECK-NEXT:           - 0
+; CHECK-NEXT:           - 0
+; CHECK-NEXT:         .hardware_mapping:
+; CHECK-NEXT:           - .ps
+; CHECK-NEXT:       .vertex:
+; CHECK-NEXT:         .api_shader_hash:
+; CHECK-NEXT:           - 0x{{[0-9a-f]+}}
+; CHECK-NEXT:           - 0
+; CHECK-NEXT:         .hardware_mapping:
+; CHECK-NEXT:           - .vs
+; CHECK-NEXT:     .spill_threshold: 0xffffffff
+; CHECK-NEXT:     .type:           VsPs
+; CHECK-NEXT:     .user_data_limit: 0
+; CHECK-NEXT:     .xgl_cache_info:
+; CHECK-NEXT:       .128_bit_cache_hash:
+; CHECK-NEXT:         - 0x{{[0-9a-f]+}}
+; CHECK-NEXT:         - 0x{{[0-9a-f]+}}
+; CHECK-NEXT:       .llpc_version: {{.*}}
+; CHECK-NEXT: amdpal.version:
+; CHECK-NEXT:   - 0x2
+; CHECK-NEXT:   - 0x3
+; CHECK-NEXT: ...
diff --git a/llpc/test/shaderdb/general/PipelineVsGsFs_TestDwordPacking.pipe b/llpc/test/shaderdb/general/PipelineVsGsFs_TestDwordPacking.pipe
index cdc41056b..3cb00d8f1 100644
--- a/llpc/test/shaderdb/general/PipelineVsGsFs_TestDwordPacking.pipe
+++ b/llpc/test/shaderdb/general/PipelineVsGsFs_TestDwordPacking.pipe
@@ -1,24 +1,46 @@
 ; Test that GS outputs get extended from 16-bit to 32-bit during in/out packing.
+; Test that unused GS outputs are removed without corresponding item in the mapping table
 
 ; BEGIN_SHADERTEST
 ; RUN: amdllpc -enable-part-pipeline=0 -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-part-pipeline=1 -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; SHADERTEST-LABEL: LLPC location input/output mapping results (FS shader)
+; SHADERTEST: (FS) Input:  loc = 1, comp = 0 =>  Mapped = 0, 0
+; SHADERTEST: (FS) Input:  loc = 1, comp = 1 =>  Mapped = 0, 1
+; SHADERTEST: (FS) Input:  loc = 1, comp = 2 =>  Mapped = 0, 2
+; SHADERTEST: (FS) Input:  loc = 1, comp = 3 =>  Mapped = 0, 3
+; SHADERTEST: (FS) Input:  loc = 4, comp = 0 =>  Mapped = 1, 0
+; SHADERTEST: (FS) Input:  loc = 4, comp = 1 =>  Mapped = 1, 1
+; SHADERTEST: (FS) Input:  loc = 2, comp = 0 =>  Mapped = 2, 0
+; SHADERTEST: (FS) Input:  loc = 2, comp = 1 =>  Mapped = 2, 1
+; SHADERTEST: (FS) Input:  loc = 2, comp = 2 =>  Mapped = 2, 2
+; SHADERTEST: (FS) Input:  loc = 2, comp = 3 =>  Mapped = 2, 3
+; SHADERTEST-LABEL: LLPC location count results (after builtin-to-generic mapping)
+; SHADERTEST: (FS) Input:  loc count = 3
+; SHADERTEST: (FS) Output: loc count = 2
 ; SHADERTEST-LABEL: LLPC location input/output mapping results (GS shader)
 ; SHADERTEST: (GS) Output: stream = 0,  loc = 1, comp = 0  =>  Mapped = 0, 0
 ; SHADERTEST: (GS) Output: stream = 0,  loc = 1, comp = 1  =>  Mapped = 0, 1
 ; SHADERTEST: (GS) Output: stream = 0,  loc = 1, comp = 2  =>  Mapped = 0, 2
 ; SHADERTEST: (GS) Output: stream = 0,  loc = 1, comp = 3  =>  Mapped = 0, 3
-; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 0  =>  Mapped = 1, 0
-; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 1  =>  Mapped = 1, 1
-; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 2  =>  Mapped = 1, 2
-; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 3  =>  Mapped = 1, 3
+; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 0  =>  Mapped = 2, 0
+; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 1  =>  Mapped = 2, 1
+; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 2  =>  Mapped = 2, 2
+; SHADERTEST: (GS) Output: stream = 0,  loc = 2, comp = 3  =>  Mapped = 2, 3
+; SHADERTEST: (GS) Output: stream = 0,  loc = 4, comp = 0  =>  Mapped = 1, 0
+; SHADERTEST: (GS) Output: stream = 0,  loc = 4, comp = 1  =>  Mapped = 1, 1
+; SHADERTEST: (GS) Output: stream = 0,  loc = 5, comp = 0  =>  Mapped = 1, 2
+; SHADERTEST: (GS) Output: stream = 0,  loc = 5, comp = 1  =>  Mapped = 1, 3
+; SHADERTEST-LABEL: LLPC location count results (after input/output matching)
+; SHADERTEST: (GS) Input:  loc count = 2
+; SHADERTEST: (GS) Output: loc count = 3
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 [Version]
 version = 52
 
 [VsGlsl]
 #version 450
 #extension GL_AMD_gpu_shader_int16 : require
 
@@ -35,63 +57,67 @@ void main()
     outp1 = inp1;
 }
 
 [VsInfo]
 entryPoint = main
 
 [GsGlsl]
 #version 450
 #extension GL_AMD_gpu_shader_int16 : require
 layout(triangles) in;
-layout(max_vertices = 3, triangle_strip) out;
+layout(max_vertices = 3, triangle_strip, stream=0) out;
 
-layout(location = 1) out vec4 outp1;
 layout(location = 1) in vec4 inp1[3];
 layout(location = 2) in u16vec4 inp2[3];
+layout(location = 1) out vec4 outp1;
 layout(location = 2) out u16vec4 outp2;
+layout(location = 3) out vec2 outp3;
+layout(location = 4) out vec2 outp4;
+layout(location = 5, xfb_buffer = 0, xfb_offset = 0) out vec2 outp5;
 
 void main()
 {
-    outp2 = inp2[0];
-    gl_Position = gl_in[0].gl_Position;
-    outp1 = inp1[0];
-    EmitVertex();
-    gl_Position = gl_in[1].gl_Position;
-    outp1 = inp1[1];
-    EmitVertex();
-    gl_Position = gl_in[2].gl_Position;
-    outp1 = inp1[2];
-    EmitVertex();
+    for (int i = 0; i < gl_in.length(); ++i)
+    {
+        outp1 = inp1[i];
+        outp2 = inp2[i];
+        outp4 = inp1[i].xy + inp2[i].xy;
+        outp5 = inp1[i].zw + inp2[i].zw;
+        gl_Position = gl_in[i].gl_Position;
+        EmitVertex();
+    }
     EndPrimitive();
 }
 
 [GsInfo]
 entryPoint = main
 
 
 [FsGlsl]
 #version 450
 #extension GL_AMD_gpu_shader_int16 : require
 
-layout(location = 0) out vec4 outp0;
 layout(location = 1) in vec4 inp1;
 layout(location = 2) flat in u16vec4 inp2;
+layout(location = 4) in vec2 inp4;
+layout(location = 0) out vec4 outp0;
 layout(location = 1) out u16vec4 outp1;
 
+
 vec4 _91(vec4 _101)
 {
     return _101;
 }
 
 void main()
 {
-    outp0 = inp1;
+    outp0 = inp1 + vec4(inp4, 0, 1.0);
     outp1 = inp2;
 }
 
 [FsInfo]
 entryPoint = main
 
 
 [ResourceMapping]
 userDataNode[0].visibility = 8
 userDataNode[0].type = StreamOutTableVaPtr
diff --git a/llpc/test/shaderdb/general/TestResourceLayout_Pushconst.frag b/llpc/test/shaderdb/general/TestResourceLayout_Pushconst.frag
index ee15cbc75..6fc91cc9a 100644
--- a/llpc/test/shaderdb/general/TestResourceLayout_Pushconst.frag
+++ b/llpc/test/shaderdb/general/TestResourceLayout_Pushconst.frag
@@ -1,33 +1,30 @@
 // Check the resource layout option '--resource-layout-scheme'
 
 // BEGIN_SHADERTEST
-// RUN: amdllpc -v %gfxip --resource-layout-scheme=indirect %s | FileCheck -check-prefix=SHADERTEST %s
+// RUN: amdllpc -v %gfxip --resource-layout-scheme=indirect -enable-opaque-pointers=true %s | FileCheck -check-prefix=SHADERTEST %s
 // SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
-// SHADERTEST: [[Desc:%[0-9]*]] = call [16 x i8] addrspace(4)* (...) @lgc.create.load.push.constants.ptr.p4a16i8()
-// SHADERTEST: [[Addr:%[0-9]*]] = bitcast [16 x i8] addrspace(4)* [[Desc]] to <4 x float> addrspace(4)*
-// SHADERTEST: [[Value:%[0-9]*]] = load <4 x float>, <4 x float> addrspace(4)* [[Addr]], align 16
+// SHADERTEST: [[Desc:%[0-9]*]] = call ptr addrspace(4) (...) @lgc.create.load.push.constants.ptr.p4()
+// SHADERTEST: [[Value:%[0-9]*]] = load <4 x float>, ptr addrspace(4) [[Desc]], align 16
 // SHADERTEST: call void (...) @lgc.create.write.generic.output(<4 x float> [[Value]], i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
 
 // SHADERTEST-LABEL: {{^// LLPC}} pipeline before-patching results
-// SHADERTEST: [[Desc:%[0-9]*]] = call i8 addrspace(4)* @lgc.descriptor.table.addr(i32 9, i32 9, i32 -1, i32 0, i32 -1)
-// SHADERTEST: [[Addr1:%[0-9]*]] = bitcast i8 addrspace(4)* [[Desc]] to [16 x i8] addrspace(4)*
-// SHADERTEST: [[Addr2:%[0-9]*]] = bitcast [16 x i8] addrspace(4)* [[Addr1]] to <4 x float> addrspace(4)*
-// SHADERTEST: [[Value:%[0-9]*]] = load <4 x float>, <4 x float> addrspace(4)* [[Addr2]], align 16
+// SHADERTEST: [[Desc:%[0-9]*]] = call ptr addrspace(4) @lgc.descriptor.table.addr(i32 9, i32 9, i32 -1, i32 0, i32 -1)
+// SHADERTEST: [[Value:%[0-9]*]] = load <4 x float>, ptr addrspace(4) [[Desc]], align 16
 // SHADERTEST: call void @lgc.output.export.generic.i32.i32.v4f32(i32 0, i32 0, <4 x float> [[Value]])
 
 // SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 // SHADERTEST: define dllexport amdgpu_ps { <4 x float> } @_amdgpu_ps_main(i32 inreg %{{[^,]*}}, i32 inreg %{{[^,]*}}, i32 inreg %descTable0,
 // SHADERTEST: [[Addr0:%[0-9]*]] = zext i32 %descTable0 to i64
 // SHADERTEST: [[Addr1:%[0-9]*]] = or i64 %{{[0-9]*}}, [[Addr0]]
-// SHADERTEST: [[Addr2:%[0-9]*]] = inttoptr i64 [[Addr1]] to <4 x float> addrspace(4)*
-// SHADERTEST: load <4 x float>, <4 x float> addrspace(4)* [[Addr2]], align 16
+// SHADERTEST: [[Addr2:%[0-9]*]] = inttoptr i64 [[Addr1]] to ptr addrspace(4)
+// SHADERTEST: load <4 x float>, ptr addrspace(4) [[Addr2]], align 16
 // SHADERTEST: AMDLLPC SUCCESS
 // END_SHADERTEST
 
 #version 450
 
 layout( location = 0 ) out vec4 frag_color;
 
 layout( push_constant ) uniform ColorBlock {
   vec4 Color;
 } PushConstant;
diff --git a/llpc/test/shaderdb/general/UndefVertexOutput.spvasm b/llpc/test/shaderdb/general/UndefVertexOutput.spvasm
index 549b97d08..dbb5ace88 100644
--- a/llpc/test/shaderdb/general/UndefVertexOutput.spvasm
+++ b/llpc/test/shaderdb/general/UndefVertexOutput.spvasm
@@ -1,23 +1,16 @@
+; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
+; RUN: amdllpc -o - -filetype=asm -gfxip 9.0 %s | FileCheck -check-prefixes=CHECK %s
+
 ; Make sure that the export channels match the location in the spir-v.
 ; This is how the PS knows which channel from which to read the value.
 
-; BEGIN_SHADERTEST
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
-; SHADERTEST-LABEL: _amdgpu_vs_main_fetchless:
-; SHADERTEST: v_mov_b32_e32 [[zero:v[0-9]*]], 0
-; SHADERTEST: v_mov_b32_e32 [[one:v[0-9]*]], 1.0
-; SHADERTEST-DAG: exp param8 [[one]], [[zero]], [[zero]], [[one]]
-; SHADERTEST-DAG: exp param7 [[zero]], [[zero]], [[one]], [[one]]
-; SHADERTEST: AMDLLPC SUCCESS
-; END_SHADERTEST
-
                OpCapability Shader
           %1 = OpExtInstImport "GLSL.std.450"
                OpMemoryModel Logical GLSL450
                OpEntryPoint Vertex %2 "main" %3 %gl_Position %5 %6 %7
           %8 = OpString ""
                OpDecorate %3 Location 1
                OpDecorate %3 Binding 0
                OpDecorate %gl_Position Binding 0
                OpDecorate %gl_Position BuiltIn Position
                OpDecorate %5 Location 5
@@ -46,10 +39,18 @@
          %21 = OpConstantComposite %v4float %float_0 %float_0 %float_1 %float_1
           %2 = OpFunction %void None %10
          %22 = OpLabel
          %23 = OpLoad %v4float %3
                OpStore %gl_Position %23
                OpStore %5 %17
                OpStore %6 %21
                OpStore %7 %20
                OpReturn
                OpFunctionEnd
+
+; CHECK-LABEL: amdgpu_vs_main_fetchless:
+; CHECK:         exp pos0 v4, v5, v6, v7 done
+; CHECK-NEXT:    v_mov_b32_e32 v0, 0
+; CHECK-NEXT:    v_mov_b32_e32 v1, 1.0
+; CHECK-NEXT:    exp param8 v1, v0, v0, v1
+; CHECK-NEXT:    exp param7 v0, v0, v1, v1
+; CHECK-NEXT:    s_endpgm
diff --git a/llpc/test/shaderdb/gfx10/WgpModeDisabled.pipe b/llpc/test/shaderdb/gfx10/WgpModeDisabled.pipe
new file mode 100644
index 000000000..21e067e17
--- /dev/null
+++ b/llpc/test/shaderdb/gfx10/WgpModeDisabled.pipe
@@ -0,0 +1,14 @@
+; RUN: amdllpc  -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; SHADERTEST-LABEL: LLPC final pipeline module info
+; SHADERTEST: {{^}}attributes {{.*}}+cumode
+; SHADERTEST: AMDLLPC SUCCESS
+
+[CsGlsl]
+#version 450
+
+void main() {
+}
+
+[CsInfo]
+entryPoint = main
+options.wgpMode = 0
diff --git a/llpc/test/shaderdb/gfx10/WgpModeEnabled.pipe b/llpc/test/shaderdb/gfx10/WgpModeEnabled.pipe
new file mode 100644
index 000000000..c0e7dbc63
--- /dev/null
+++ b/llpc/test/shaderdb/gfx10/WgpModeEnabled.pipe
@@ -0,0 +1,14 @@
+; RUN: amdllpc  -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; SHADERTEST-LABEL: LLPC final pipeline module info
+; SHADERTEST: {{^}}attributes {{.*}}-cumode
+; SHADERTEST: AMDLLPC SUCCESS
+
+[CsGlsl]
+#version 450
+
+void main() {
+}
+
+[CsInfo]
+entryPoint = main
+options.wgpMode = 1
diff --git a/llpc/test/shaderdb/object/ObjPushConst_TestNestedStruct_lit.vert b/llpc/test/shaderdb/object/ObjPushConst_TestNestedStruct_lit.vert
index 9e488e4c6..3c01e4945 100644
--- a/llpc/test/shaderdb/object/ObjPushConst_TestNestedStruct_lit.vert
+++ b/llpc/test/shaderdb/object/ObjPushConst_TestNestedStruct_lit.vert
@@ -12,21 +12,20 @@ layout (push_constant) uniform UBO
     layout (offset = 4)     Str  m1;
 } g_pc;
 
 void main()
 {
     gl_Position = vec4(g_pc.m1.m1);
 }
 
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC.*}} SPIR-V lowering results
 ; SHADERTEST:  [[V0:%.*]] = call {{.*}} @lgc.create.load.push.constants.ptr
-; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4)* [[V0]], i64 0, i64 8
-; SHADERTEST:  [[V2:%.*]] = bitcast {{.*}} [[V1]]
-; SHADERTEST:  load float, float addrspace(4)* [[V2]], align 4
+; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4) [[V0]], i64 0, i32 1, i32 1
+; SHADERTEST:  load float, ptr addrspace(4) [[V1]], align 4
 
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjPushConst_TestSpillToMemory_lit.vert b/llpc/test/shaderdb/object/ObjPushConst_TestSpillToMemory_lit.vert
index 7bd53aed5..f1e7ca9c3 100644
--- a/llpc/test/shaderdb/object/ObjPushConst_TestSpillToMemory_lit.vert
+++ b/llpc/test/shaderdb/object/ObjPushConst_TestSpillToMemory_lit.vert
@@ -7,20 +7,19 @@ layout(push_constant) uniform PCB
 } g_pc;
 
 void main()
 {
     gl_Position = g_pc.m1[8];
 }
 
 
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC.*}} SPIR-V lowering results
 ; SHADERTEST:  [[V0:%.*]] = call {{.*}} @lgc.create.load.push.constants.ptr
-; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4)* [[V0]], i64 0, i64 144
-; SHADERTEST:  [[V2:%.*]] = bitcast {{.*}} [[V1]]
-; SHADERTEST:  load <4 x float>, <4 x float> addrspace(4)* [[V2]], align 16
+; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4) [[V0]], i64 0, i32 1, i64 8
+; SHADERTEST:  load <4 x float>, ptr addrspace(4) [[V1]], align 16
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjPushConstant_TestBasic_lit.frag b/llpc/test/shaderdb/object/ObjPushConstant_TestBasic_lit.frag
index 9ab3e7ed0..f9f0d8cdb 100644
--- a/llpc/test/shaderdb/object/ObjPushConstant_TestBasic_lit.frag
+++ b/llpc/test/shaderdb/object/ObjPushConstant_TestBasic_lit.frag
@@ -25,23 +25,21 @@ layout(std140, push_constant) uniform PushConstant
 } pushConst;
 
 layout(location = 0) out vec4 o1;
 
 void main()
 {
     o1 = pushConst.m5 + pushConst.m10;
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC.*}} SPIR-V lowering results
 ; SHADERTEST:  [[V0:%.*]] = call {{.*}} @lgc.create.load.push.constants.ptr
-; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4)* [[V0]], i64 0, i64 64
-; SHADERTEST:  [[V2:%.*]] = bitcast {{.*}} [[V1]]
-; SHADERTEST:  load <4 x float>, <4 x float> addrspace(4)* [[V2]], align 16
-; SHADERTEST:  [[V11:%.*]] = getelementptr {{.*}} addrspace(4)* [[V0]], i64 0, i64 144
-; SHADERTEST:  [[V12:%.*]] = bitcast {{.*}} [[V11]]
-; SHADERTEST:  load <4 x float>, <4 x float> addrspace(4)* [[V12]], align 16
+; SHADERTEST:  [[V1:%.*]] = getelementptr {{.*}} addrspace(4) [[V0]], i64 0, i32 4
+; SHADERTEST:  load <4 x float>, ptr addrspace(4) [[V1]], align 16
+; SHADERTEST:  [[V11:%.*]] = getelementptr {{.*}} addrspace(4) [[V0]], i64 0, i32 4
+; SHADERTEST:  load <4 x float>, ptr addrspace(4) [[V11]], align 16
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjStorageBlock_TestMultiLevelAccessChain_lit.vert b/llpc/test/shaderdb/object/ObjStorageBlock_TestMultiLevelAccessChain_lit.vert
index 2b75ce3eb..daf525c12 100644
--- a/llpc/test/shaderdb/object/ObjStorageBlock_TestMultiLevelAccessChain_lit.vert
+++ b/llpc/test/shaderdb/object/ObjStorageBlock_TestMultiLevelAccessChain_lit.vert
@@ -16,21 +16,21 @@ void main()
     S s;
     s.f4 = vec4(1.0);
 
     block.s = s;
 
     gl_Position = vec4(1.0);
 }
 
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: getelementptr { <4 x float> }, { <4 x float> } addrspace({{.*}})* %{{[a-z0-9]*}}, i32 0, i32 0
-; SHADERTEST: getelementptr inbounds (<{ [3 x float], [4 x i8], <{ [4 x float] }> }>, <{ [3 x float], [4 x i8], <{ [4 x float] }> }> addrspace({{.*}})* @{{.*}}, i32 0, i32 2
+; SHADERTEST: getelementptr { <4 x float> }, ptr addrspace({{.*}}) %{{[a-z0-9]*}}, i32 0, i32 0
+; SHADERTEST: getelementptr inbounds (<{ [3 x float], [4 x i8], <{ [4 x float] }> }>, ptr addrspace({{.*}}) @{{.*}}, i32 0, i32 2
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
 ; SHADERTEST: store <4 x float> <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>,
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjStorageBlock_TestRuntimeArray_lit.vert b/llpc/test/shaderdb/object/ObjStorageBlock_TestRuntimeArray_lit.vert
index 6f5f59aa8..02c1b6cf4 100644
--- a/llpc/test/shaderdb/object/ObjStorageBlock_TestRuntimeArray_lit.vert
+++ b/llpc/test/shaderdb/object/ObjStorageBlock_TestRuntimeArray_lit.vert
@@ -7,20 +7,20 @@ layout(std430, binding = 0) buffer Block
 } block;
 
 void main()
 {
     block.o[gl_VertexIndex] = block.base + vec4(gl_VertexIndex);
 
     gl_Position = vec4(1.0);
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: getelementptr <{ [4 x float], [4294967295 x [4 x float]] }>, <{ [4 x float], [4294967295 x [4 x float]] }> addrspace({{.*}})* @{{.*}}, i32 0, i32 1, i32 %{{[0-9]*}}
+; SHADERTEST: getelementptr <{ [4 x float], [4294967295 x [4 x float]] }>, ptr addrspace({{.*}}) @{{.*}}, i32 0, i32 1, i32 %{{[0-9]*}}
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
 ; SHADERTEST: store <4 x float>
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjStorageBlock_TestVectorComponentStore_lit.comp b/llpc/test/shaderdb/object/ObjStorageBlock_TestVectorComponentStore_lit.comp
index d081c4e59..57f741e1d 100644
--- a/llpc/test/shaderdb/object/ObjStorageBlock_TestVectorComponentStore_lit.comp
+++ b/llpc/test/shaderdb/object/ObjStorageBlock_TestVectorComponentStore_lit.comp
@@ -5,21 +5,21 @@ layout(set = 0, binding = 0) buffer BO
 };
 
 layout(local_size_x = 1) in;
 void main()
 {
     m.y = m.x;
 }
 
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
-; SHADERTEST: %{{[0-9]*}} = call i8 addrspace(7)* {{.*}} @lgc.create.load.buffer.desc.{{[0-9a-z.]*}}(i32 0, i32 0, i32 0,
-; SHADERTEST: %{{[0-9]*}} = load float, float addrspace(7)* %{{[0-9]*}}, align 4
-; SHADERTEST: %{{[0-9]*}} = getelementptr inbounds i8, i8 addrspace(7)* %{{[0-9]*}}, i64 4
-; SHADERTEST: store float %{{[0-9]*}}, float addrspace(7)* %{{[0-9]*}}, align 4
+; SHADERTEST: %{{[0-9]*}} = call ptr addrspace(7) {{.*}} @lgc.create.load.buffer.desc.{{[0-9a-z.]*}}(i32 0, i32 0, i32 0,
+; SHADERTEST: %{{[0-9]*}} = load float, ptr addrspace(7) %{{[0-9]*}}, align 4
+; SHADERTEST: %{{[0-9]*}} = getelementptr inbounds <{ [4 x float] }>, ptr addrspace(7) %{{[0-9]*}}, i64 0, i32 0, i64 1
+; SHADERTEST: store float %{{[0-9]*}}, ptr addrspace(7) %{{[0-9]*}}, align 4
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjUniformBlock_TestDirectIndex_lit.frag b/llpc/test/shaderdb/object/ObjUniformBlock_TestDirectIndex_lit.frag
index 59c577788..2322eb371 100644
--- a/llpc/test/shaderdb/object/ObjUniformBlock_TestDirectIndex_lit.frag
+++ b/llpc/test/shaderdb/object/ObjUniformBlock_TestDirectIndex_lit.frag
@@ -8,23 +8,23 @@ layout(set = 1, binding = 0) uniform BB
 
 
 layout(location = 0) out vec4 o1;
 
 void main()
 {
     o1 = b[0].m1 + b[3].m2[5];
 }
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: getelementptr inbounds ([4 x <{ [4 x float], [10 x [4 x float]] }>], [4 x <{ [4 x float], [10 x [4 x float]] }>] addrspace({{.*}})* @{{.*}}, i32 0, i32 3, i32 1, i32 5
+; SHADERTEST: getelementptr inbounds ([4 x <{ [4 x float], [10 x [4 x float]] }>], ptr addrspace({{.*}}) @{{.*}}, i32 0, i32 3, i32 1, i32 5
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIR-V lowering results
 ; SHADERTEST: call {{.*}} {{.*}}@lgc.create.load.buffer.desc.{{[0-9a-z.]*}}(i32 1, i32 0, i32 0
 ; SHADERTEST: call {{.*}} {{.*}}@lgc.create.load.buffer.desc.{{[0-9a-z.]*}}(i32 1, i32 0, i32 3
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 0, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 96, i32 0)
 ; SHADERTEST: AMDLLPC SUCCESS
 */
diff --git a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrixArray_lit.vert b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrixArray_lit.vert
index b427c9f42..572f8d7e6 100644
--- a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrixArray_lit.vert
+++ b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrixArray_lit.vert
@@ -10,25 +10,25 @@ void main()
 {
     int i = block.i;
     mat4 m4[2] = block.m4;
     m4[0][0] = vec4(3.0);
     m4[i][i] = vec4(2.0);
     gl_Position = m4[i][i];
 }
 
 // BEGIN_SHADERTEST
 /*
-; RUN: amdllpc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
+; RUN: amdllpc -v -enable-opaque-pointers=true %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} SPIRV-to-LLVM translation results
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 0, i32 0, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 0, i32 1, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 0, i32 2, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 0, i32 3, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 0, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 1, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 2, i32 0) to <4 x float> addrspace(7)*), align 16
-; SHADERTEST: %{{[0-9]*}} = load <4 x float>, <4 x float> addrspace(7)* bitcast ([4 x float] addrspace(7)* getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, <{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }> addrspace(7)* @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 3, i32 0) to <4 x float> addrspace(7)*), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr ([4 x %llpc.matrix.column], ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2), i32 0, i32 1, i32 0), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr ([4 x %llpc.matrix.column], ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2), i32 0, i32 2, i32 0), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr ([4 x %llpc.matrix.column], ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2), i32 0, i32 3, i32 0), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2, i32 1), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 1, i32 0), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 2, i32 0), align 16
+; SHADERTEST: %{{[0-9]*}} = load <4 x float>, ptr addrspace(7) getelementptr inbounds (<{ i32, [12 x i8], [2 x [4 x %{{[a-z.]*}}]] }>, ptr addrspace(7) @{{[a-z0-9]+}}, i32 0, i32 2, i32 1, i32 3, i32 0), align 16
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrix_lit.vert b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrix_lit.vert
index 5d41d791f..bc7bbb6ea 100644
--- a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrix_lit.vert
+++ b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadMatrix_lit.vert
@@ -1,30 +1,30 @@
 #version 450 core
 
 layout(std140, binding = 0) uniform Block
 {
     int  i;
     mat4 m4;
+    int  j;
 } block;
 
 void main()
 {
     int i = block.i;
     mat4 m4 = block.m4;
     m4[i] = vec4(2.0);
-    gl_Position = m4[i];
+    gl_Position = m4[block.j];
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 16, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 32, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 48, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 64, i32 0)
-; SHADERTEST: store <4 x float> <float 2.000000e+00, float 2.000000e+00, float 2.000000e+00, float 2.000000e+00>, {{<4 x float> addrspace\(.*\)*|ptr addrspace\(.*\)}} %{{[0-9]*}}
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadScalarArray_lit.vert b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadScalarArray_lit.vert
index dff38122f..adfb4cd8a 100644
--- a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadScalarArray_lit.vert
+++ b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadScalarArray_lit.vert
@@ -1,29 +1,29 @@
 #version 450 core
 
 layout(std140, binding = 0) uniform Block
 {
     float f1[2];
     int  i;
+    int  j;
 } block;
 
 void main()
 {
     int i = block.i;
     float f1[2] = block.f1;
     f1[i] = 2.0;
-    gl_Position = vec4(f1[i]);
+    gl_Position = vec4(f1[block.j]);
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call i32 @llvm.amdgcn.s.buffer.load.i32(<4 x i32> %{{[0-9]*}}, i32 32, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.s.buffer.load.i32(<4 x i32> %{{[0-9]*}}, i32 0, i32 0)
 ; SHADERTEST: call i32 @llvm.amdgcn.s.buffer.load.i32(<4 x i32> %{{[0-9]*}}, i32 16, i32 0)
-; SHADERTEST: store float 2.000000e+00, {{float addrspace\(.*\)*|ptr addrspace\(.*\)}} %{{[0-9]*}}
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadVectorArray_lit.vert b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadVectorArray_lit.vert
index e94669577..81d89f202 100644
--- a/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadVectorArray_lit.vert
+++ b/llpc/test/shaderdb/object/ObjUniformBlock_TestLoadVectorArray_lit.vert
@@ -1,30 +1,30 @@
 #version 450 core
 
 layout(std140, binding = 0) uniform Block
 {
     int  i;
     vec4 f4[4];
+    int  j;
 } block;
 
 void main()
 {
     int i = block.i;
     vec4 f4[4] = block.f4;
     f4[i] = vec4(2.0);
-    gl_Position = f4[i];
+    gl_Position = f4[block.j];
 }
 // BEGIN_SHADERTEST
 /*
 ; RUN: amdllpc -enable-opaque-pointers=false -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; RUN: amdllpc -enable-opaque-pointers=true -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 16, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 32, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 48, i32 0)
 ; SHADERTEST: call <4 x i32> @llvm.amdgcn.s.buffer.load.v4i32(<4 x i32> %{{[0-9]*}}, i32 64, i32 0)
-; SHADERTEST: store <4 x float> <float 2.000000e+00, float 2.000000e+00, float 2.000000e+00, float 2.000000e+00>, {{<4 x float> addrspace\(.*\)*|ptr addrspace\(.*\)}} %{{[0-9]*}}
 
 ; SHADERTEST: AMDLLPC SUCCESS
 */
 // END_SHADERTEST
diff --git a/llpc/test/shaderdb/relocatable_shaders/PipelineVsFs_TestRelocatableSeparateCompilation.pipe b/llpc/test/shaderdb/relocatable_shaders/PipelineVsFs_TestRelocatableSeparateCompilation.pipe
index 3cbdc7563..0fa3883ac 100644
--- a/llpc/test/shaderdb/relocatable_shaders/PipelineVsFs_TestRelocatableSeparateCompilation.pipe
+++ b/llpc/test/shaderdb/relocatable_shaders/PipelineVsFs_TestRelocatableSeparateCompilation.pipe
@@ -1,23 +1,23 @@
 ; This test checks that pipeline patching is done for each shader separately.
 ; It shows that the shaders were compiled individually and then linked.
 
 ; BEGIN_SHADERTEST
 ; RUN: amdllpc -enable-relocatable-shader-elf -auto-layout-desc -v %gfxip %s | FileCheck -check-prefix=SHADERTEST %s
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST-EMPTY:
 ; SHADERTEST-NEXT: ; ModuleID = 'lgcPipeline'
-; SHADERTEST-NEXT: source_filename = "llpcvertex
+; SHADERTEST-NEXT: source_filename = "llpc_vertex
 ; SHADERTEST-LABEL: {{^// LLPC}} pipeline patching results
 ; SHADERTEST-EMPTY:
 ; SHADERTEST-NEXT: ; ModuleID = 'lgcPipeline'
-; SHADERTEST-NEXT: source_filename = "llpcfragment
+; SHADERTEST-NEXT: source_filename = "llpc_fragment
 ; SHADERTEST: AMDLLPC SUCCESS
 ; END_SHADERTEST
 
 
 [Version]
 version = 38
 
 [VsSpirv]
                OpCapability Shader
                OpMemoryModel Logical GLSL450
diff --git a/llpc/tool/amdllpc.cpp b/llpc/tool/amdllpc.cpp
index 02630d7a1..da74a00e2 100644
--- a/llpc/tool/amdllpc.cpp
+++ b/llpc/tool/amdllpc.cpp
@@ -269,20 +269,25 @@ cl::opt<unsigned> OverrideThreadGroupSizeY("override-threadGroupSizeY",
 // -override-threadGroupSizeZ
 cl::opt<unsigned> OverrideThreadGroupSizeZ("override-threadGroupSizeZ",
                                               cl::desc("override threadGroupSize Z\n"
                                                        "0x00 - No override\n"
                                                        "0x01 - Override threadGroupSizeZ with Value:1 in wave32 or wave64\n"),
                                               cl::init(0));
 
 // -reverse-thread-group
 cl::opt<bool> ReverseThreadGroup("reverse-thread-group", cl::desc("Reverse thread group ID\n"), cl::init(false));
 
+// -force-non-uniform-resource-index-stage-mask
+cl::opt<unsigned> ForceNonUniformResourceIndexStageMask("force-non-uniform-resource-index-stage-mask",
+                                                        cl::desc("Stage mask to force non uniform resource index\n"),
+                                                        cl::init(0));
+
 // -filter-pipeline-dump-by-type: filter which kinds of pipeline should be disabled.
 cl::opt<unsigned> FilterPipelineDumpByType("filter-pipeline-dump-by-type",
                                            cl::desc("Filter which types of pipeline dump are disabled\n"
                                                     "0x00 - Always enable pipeline logging\n"
                                                     "0x01 - Disable logging for CS pipelines\n"
                                                     "0x02 - Disable logging for NGG pipelines\n"
                                                     "0x04 - Disable logging for GS pipelines\n"
                                                     "0x08 - Disable logging for TS pipelines\n"
                                                     "0x10 - Disable logging for VS-PS pipelines"),
                                            cl::init(0));
@@ -483,20 +488,27 @@ static Result initCompileInfo(CompileInfo *compileInfo) {
   compileInfo->compPipelineInfo.options.optimizationLevel = CodeGenOpt::Level::Default;
 #endif
   compileInfo->gfxPipelineInfo.options.resourceLayoutScheme = LayoutScheme;
   compileInfo->compPipelineInfo.options.forceCsThreadIdSwizzling = ForceCsThreadIdSwizzling;
   compileInfo->compPipelineInfo.options.overrideThreadGroupSizeX = OverrideThreadGroupSizeX;
   compileInfo->compPipelineInfo.options.overrideThreadGroupSizeY = OverrideThreadGroupSizeY;
   compileInfo->compPipelineInfo.options.overrideThreadGroupSizeZ = OverrideThreadGroupSizeZ;
   compileInfo->compPipelineInfo.options.threadGroupSwizzleMode = ThreadGroupSwizzleModeSetting;
   compileInfo->compPipelineInfo.options.reverseThreadGroup = ReverseThreadGroup;
 
+  compileInfo->compPipelineInfo.options.forceNonUniformResourceIndexStageMask = ForceNonUniformResourceIndexStageMask;
+  compileInfo->gfxPipelineInfo.options.forceNonUniformResourceIndexStageMask = ForceNonUniformResourceIndexStageMask;
+#if VKI_RAY_TRACING
+  compileInfo->rayTracePipelineInfo.options.forceNonUniformResourceIndexStageMask =
+      ForceNonUniformResourceIndexStageMask;
+#endif
+
   // Set NGG control settings
   if (ParsedGfxIp.major >= 10) {
     auto &nggState = compileInfo->gfxPipelineInfo.nggState;
 
     nggState.enableNgg = EnableNgg;
     nggState.enableGsUse = NggEnableGsUse;
     nggState.forceCullingMode = NggForceCullingMode;
     nggState.compactMode = static_cast<NggCompactMode>(NggCompactionMode.getValue());
     nggState.enableVertexReuse = NggEnableVertexReuse;
     nggState.enableBackfaceCulling = NggEnableBackfaceCulling;
@@ -558,21 +570,21 @@ static Error processInputs(ICompiler *compiler, InputSpecGroup &inputSpecs) {
   if (compileInfo.stageMask != 0)
     if (Error err = buildShaderModules(compiler, &compileInfo))
       return err;
 
   if (!ToLink)
     return Error::success();
 
   //
   // Build pipeline
   //
-  Optional<PipelineDumpOptions> dumpOptions = None;
+  Optional<PipelineDumpOptions> dumpOptions;
   if (cl::EnablePipelineDump) {
     dumpOptions.emplace();
     dumpOptions->pDumpDir = cl::PipelineDumpDir.c_str();
     dumpOptions->filterPipelineDumpByType = FilterPipelineDumpByType;
     dumpOptions->filterPipelineDumpByHash = FilterPipelineDumpByHash;
     dumpOptions->dumpDuplicatePipelines = DumpDuplicatePipelines;
   }
 
   std::unique_ptr<PipelineBuilder> builder =
       createPipelineBuilder(*compiler, compileInfo, dumpOptions, TimePassesIsEnabled || cl::EnableTimerProfile);
@@ -628,29 +640,29 @@ int main(int argc, char *argv[]) {
 #else
   EnablePrettyStackTrace();
   sys::PrintStackTraceOnErrorSignal(argv[0]);
   PrettyStackTraceProgram x(argc, argv);
 
 #ifdef WIN_OS
   signal(SIGABRT, llpcSignalAbortHandler);
 #endif
 #endif
 
+  ICompiler *compiler = nullptr;
+  Result result = init(argc, argv, compiler);
+
 #ifdef WIN_OS
   if (AssertToMsgBox) {
     _set_error_mode(_OUT_TO_MSGBOX);
   }
 #endif
 
-  ICompiler *compiler = nullptr;
-  Result result = init(argc, argv, compiler);
-
   // Cleanup code that gets run automatically before returning.
   auto onExit = make_scope_exit([compiler, &result] {
     FinalizeSpvgen();
 
     if (compiler)
       compiler->Destroy();
 
     if (result == Result::Success)
       LLPC_OUTS("\n=====  AMDLLPC SUCCESS  =====\n");
     else
diff --git a/llpc/tool/llpcPipelineBuilder.cpp b/llpc/tool/llpcPipelineBuilder.cpp
index 3c92ee35d..b422e93b9 100644
--- a/llpc/tool/llpcPipelineBuilder.cpp
+++ b/llpc/tool/llpcPipelineBuilder.cpp
@@ -75,21 +75,21 @@ using namespace Vkgc;
 
 namespace Llpc {
 namespace StandaloneCompiler {
 
 // =====================================================================================================================
 // Factory function that returns a `PipelineBuilder` appropriate for the given pipeline type (e.g., graphics, compute).
 // To support new pipeline types, create a new class deriving from `PipelineBuilder` and register its constructor here.
 //
 // @param compiler : LLPC compiler object.
 // @param [in/out] compileInfo : Compilation info of LLPC standalone tool.
-// @param dumpOptions : Pipeline dump options. Pipeline dumps are disabled when `llvm::None` is passed.
+// @param dumpOptions : Pipeline dump options. Pipeline dumps are disabled when `std::nullopt` is passed.
 // @param printPipelineInfo : Whether to print pipeline info (hash, filenames) before compilation.
 // @returns : Concrete `PipelineBuilder` object for this pipeline type.
 std::unique_ptr<PipelineBuilder> createPipelineBuilder(ICompiler &compiler, CompileInfo &compileInfo,
                                                        llvm::Optional<Vkgc::PipelineDumpOptions> dumpOptions,
                                                        bool printPipelineInfo) {
   const unsigned stageMask = compileInfo.stageMask;
 
 #if VKI_RAY_TRACING
   assert(!(isGraphicsPipeline(stageMask) && isComputePipeline(stageMask) && isRayTracingPipeline(stageMask)) &&
          "Invalid stage mask");
@@ -114,21 +114,21 @@ std::unique_ptr<PipelineBuilder> createPipelineBuilder(ICompiler &compiler, Comp
 
 // =====================================================================================================================
 // Runs pre-compilation actions: starts a pipeline dump (if requested) and prints pipeline info (if requested).
 // The caller must call `runPostBuildActions` after calling this function to perform the necessary cleanup.
 //
 // @param buildInfo : Build info of the pipeline.
 // @returns : Handle to the started pipeline dump, nullptr if pipeline dump was not started.
 void *PipelineBuilder::runPreBuildActions(PipelineBuildInfo buildInfo) {
   void *pipelineDumpHandle = nullptr;
   if (shouldDumpPipelines())
-    pipelineDumpHandle = IPipelineDumper::BeginPipelineDump(m_dumpOptions.getPointer(), buildInfo);
+    pipelineDumpHandle = IPipelineDumper::BeginPipelineDump(&m_dumpOptions.value(), buildInfo);
 
   if (m_printPipelineInfo)
     printPipelineInfo(buildInfo);
 
   return pipelineDumpHandle;
 }
 
 // =====================================================================================================================
 // Runs post-compilation actions: finalizes the pipeline dump, if started. Must be called after `runPreBuildActions`.
 //
diff --git a/llpc/tool/llpcPipelineBuilder.h b/llpc/tool/llpcPipelineBuilder.h
index b5067b982..6ece6c58f 100644
--- a/llpc/tool/llpcPipelineBuilder.h
+++ b/llpc/tool/llpcPipelineBuilder.h
@@ -49,21 +49,21 @@ std::unique_ptr<PipelineBuilder> createPipelineBuilder(ICompiler &compiler, Comp
 
 // Base class for pipeline compilation. Dumps compiled pipelines when requested.
 //
 // Note: We make all key functions virtual to give experimental implementations maximum freedom.
 class PipelineBuilder {
 public:
   // Initializes PipelineBuilder. Use `createPipelineBuilder` to create concrete instances of this class.
   //
   // @param compiler : LLPC compiler object.
   // @param [in/out] compileInfo : Compilation info of LLPC standalone tool. This will be modified by `build()`.
-  // @param dumpOptions : Pipeline dump options. Pipeline dumps are disabled when `llvm::None` is passed.
+  // @param dumpOptions : Pipeline dump options. Pipeline dumps are disabled when `std::nullopt` is passed.
   // @param printPipelineInfo : Whether to print pipeline info (hash, filenames) before compilation.
   PipelineBuilder(ICompiler &compiler, CompileInfo &compileInfo, llvm::Optional<Vkgc::PipelineDumpOptions> dumpOptions,
                   bool printPipelineInfo)
       : m_compiler(compiler), m_compileInfo(compileInfo), m_dumpOptions(std::move(dumpOptions)),
         m_printPipelineInfo(printPipelineInfo) {}
 
   virtual ~PipelineBuilder() = default;
 
   // Compiles the pipeline and performs linking.
   // The implementations should call `runPreBuildActions` before performing compilation with `m_compiler` and
@@ -88,21 +88,21 @@ public:
   // @returns : Compiler handle.
   ICompiler &getCompiler() { return m_compiler; }
 
   // Returns the compile info.
   //
   // @returns : Compile info.
   CompileInfo &getCompileInfo() { return m_compileInfo; }
 
   // Returns the pipeline dump options.
   //
-  // @returns : `PipelineDumpOptions` or `llpc::None` if pipeline dumps were not requested.
+  // @returns : `PipelineDumpOptions` or `std::nullopt` if pipeline dumps were not requested.
   llvm::Optional<Vkgc::PipelineDumpOptions> &getDumpOptions() { return m_dumpOptions; }
 
   // Returns true iff pipeline dumps are requested.
   //
   // @returns : `true` is pipeline dumps were requested, `false` if not.
   LLPC_NODISCARD bool shouldDumpPipelines() const { return m_dumpOptions.has_value(); }
 
   // Runs optional pre-build code (pipeline dumping, pipeline info printing).
   LLPC_NODISCARD void *runPreBuildActions(Vkgc::PipelineBuildInfo buildInfo);
 
@@ -113,16 +113,16 @@ public:
   void printPipelineInfo(Vkgc::PipelineBuildInfo buildInfo);
 
   // Output LLPC single one elf ((ELF binary, ISA assembly text, or LLVM bitcode)) of pipeline binaries to the specified
   // target file.
   llvm::Error outputElf(const BinaryData &pipelineBin, const llvm::StringRef suppliedOutFile,
                         llvm::StringRef firstInFile);
 
 private:
   ICompiler &m_compiler;
   CompileInfo &m_compileInfo;
-  llvm::Optional<Vkgc::PipelineDumpOptions> m_dumpOptions = llvm::None;
+  llvm::Optional<Vkgc::PipelineDumpOptions> m_dumpOptions = {};
   bool m_printPipelineInfo = false;
 };
 
 } // namespace StandaloneCompiler
 } // namespace Llpc
diff --git a/llpc/translator/lib/SPIRV/SPIRVInternal.h b/llpc/translator/lib/SPIRV/SPIRVInternal.h
index a996ab019..50fe89055 100644
--- a/llpc/translator/lib/SPIRV/SPIRVInternal.h
+++ b/llpc/translator/lib/SPIRV/SPIRVInternal.h
@@ -346,23 +346,20 @@ template <typename T> void move(std::vector<T> &V, size_t Begin, size_t End, siz
   auto B = V.begin() + Begin, E = V.begin() + End;
   if (Target > V.size())
     Target = V.size();
   if (Target > End)
     Target -= (End - Begin);
   std::vector<T> Segment(B, E);
   V.erase(B, E);
   V.insert(V.begin() + Target, Segment.begin(), Segment.end());
 }
 
-void removeFnAttr(LLVMContext *Context, CallInst *Call, Attribute::AttrKind Attr);
-void addFnAttr(LLVMContext *Context, CallInst *Call, Attribute::AttrKind Attr);
-
 Function *getOrCreateFunction(Module *M, Type *RetTy, ArrayRef<Type *> ArgTypes, StringRef Name,
                               AttributeList *Attrs = nullptr, bool TakeName = true);
 
 void dumpUsers(Value *V, StringRef Prompt = "");
 
 bool eraseUselessFunctions(Module *M);
 
 /// Erase a function if it is declaration, has internal linkage and has no use.
 bool eraseIfNoUse(Function *F);
 
diff --git a/llpc/translator/lib/SPIRV/SPIRVReader.cpp b/llpc/translator/lib/SPIRV/SPIRVReader.cpp
index 431f909d3..21ed7f5e0 100644
--- a/llpc/translator/lib/SPIRV/SPIRVReader.cpp
+++ b/llpc/translator/lib/SPIRV/SPIRVReader.cpp
@@ -149,21 +149,21 @@ static bool isStorageClassExplicitlyLaidOut(SPIRVModule *m_bm, SPIRVStorageClass
                             storageClass) ||
 #if VKI_RAY_TRACING
          storageClass == StorageClassShaderRecordBufferKHR ||
 #endif
          (storageClass == StorageClassWorkgroup && m_bm->hasCapability(CapabilityWorkgroupMemoryExplicitLayoutKHR));
 }
 
 SPIRVToLLVM::SPIRVToLLVM(Module *llvmModule, SPIRVModule *theSpirvModule, const SPIRVSpecConstMap &theSpecConstMap,
                          ArrayRef<ConvertingSampler> convertingSamplers, lgc::Builder *builder,
                          const Vkgc::ShaderModuleUsage *moduleUsage, const Vkgc::PipelineShaderOptions *shaderOptions)
-    : m_m(llvmModule), m_builder(builder), m_bm(theSpirvModule), m_enableXfb(false), m_entryTarget(nullptr),
+    : m_m(llvmModule), m_builder(builder), m_bm(theSpirvModule), m_entryTarget(nullptr),
       m_specConstMap(theSpecConstMap), m_convertingSamplers(convertingSamplers), m_dbgTran(m_bm, m_m, this),
       m_moduleUsage(reinterpret_cast<const Vkgc::ShaderModuleUsage *>(moduleUsage)),
       m_shaderOptions(reinterpret_cast<const Vkgc::PipelineShaderOptions *>(shaderOptions)) {
   assert(m_m);
   m_context = &m_m->getContext();
   m_spirvOpMetaKindId = m_context->getMDKindID(MetaNameSpirvOp);
   m_scratchBoundsChecksEnabled = scratchBoundsChecksEnabled();
 }
 
 void SPIRVToLLVM::recordRemappedTypeElements(SPIRVType *bt, unsigned from, unsigned to) {
@@ -465,22 +465,23 @@ Type *SPIRVToLLVM::transTypeWithOpcode<OpTypePointer>(SPIRVType *const spvType,
           spvImageTy = static_cast<SPIRVTypeSampledImage *>(spvElementType)->getImageType();
         else
           spvImageTy = static_cast<SPIRVTypeImage *>(spvElementType);
         if (spvImageTy->getDescriptor().Dim == DimBuffer) {
           // Texel buffer.
           imagePtrTy = getBuilder()->getDescPtrTy(ResourceNodeType::DescriptorTexelBuffer);
         } else {
           // Image descriptor.
           imagePtrTy = getBuilder()->getDescPtrTy(ResourceNodeType::DescriptorResource);
         }
-        // Pointer to image is represented as a struct containing pointer and stride.
-        imagePtrTy = StructType::get(*m_context, {imagePtrTy, getBuilder()->getInt32Ty()});
+        // Pointer to image is represented as a struct containing {pointer, stride, planeStride, isResource}.
+        imagePtrTy = StructType::get(*m_context, {imagePtrTy, getBuilder()->getInt32Ty(), getBuilder()->getInt32Ty(),
+                                                  getBuilder()->getInt32Ty()});
 
         if (spvImageTy->getDescriptor().MS) {
           // Pointer to multisampled image is represented as two image pointers, the second one for the fmask.
           imagePtrTy = StructType::get(*m_context, {imagePtrTy, imagePtrTy});
         }
       }
 
       // For an image (not sampler or sampledimage), just return the pointer-to-image type.
       if (spvElementType->getOpCode() == OpTypeImage)
         return imagePtrTy;
@@ -894,21 +895,21 @@ void SPIRVToLLVM::setName(llvm::Value *v, SPIRVValue *bv) {
   if (v->getType()->isVoidTy())
     return;
 
   v->setName(name);
 }
 
 void SPIRVToLLVM::setLLVMLoopMetadata(SPIRVLoopMerge *lm, BranchInst *bi) {
   if (!lm)
     return;
   llvm::MDString *name = nullptr;
-  auto temp = MDNode::getTemporary(*m_context, None);
+  auto temp = MDNode::getTemporary(*m_context, {});
   auto self = MDNode::get(*m_context, temp.get());
   self->replaceOperandWith(0, self);
   std::vector<llvm::Metadata *> mDs;
   if (lm->getLoopControl() == LoopControlMaskNone) {
     bi->setMetadata("llvm.loop", self);
     return;
   }
   if (lm->getLoopControl() == LoopControlUnrollMask) {
     name = llvm::MDString::get(*m_context, "llvm.loop.unroll.full");
     mDs.push_back(name);
@@ -1146,48 +1147,42 @@ Value *SPIRVToLLVM::transShiftLogicalBitwiseInst(SPIRVValue *bv, BasicBlock *bb,
   // bit width.
   if (shift->getType()->isIntOrIntVectorTy())
     shift = getBuilder()->CreateZExtOrTrunc(shift, base->getType());
 
   auto inst = BinaryOperator::Create(bo, base, shift, bv->getName(), bb);
   setFastMathFlags(inst);
 
   return inst;
 }
 
-Instruction *SPIRVToLLVM::transCmpInst(SPIRVValue *bv, BasicBlock *bb, Function *f) {
+Value *SPIRVToLLVM::transCmpInst(SPIRVValue *bv, BasicBlock *bb, Function *f) {
   SPIRVCompare *bc = static_cast<SPIRVCompare *>(bv);
   assert(bb && "Invalid BB");
-  SPIRVType *bt = bc->getOperand(0)->getType();
-  Instruction *inst = nullptr;
   auto op = bc->getOpCode();
   if (op == OpPtrEqual || op == OpPtrNotEqual) {
     // NOTE: The two compared operands have the same SPIR-V type, but the IR types are different.
     // for example: struct {
     //                mat4 mat1;  // rowMajor
     //                mat4 mat2;  // colMajor
     //              };
     auto lValue = transValue(bc->getOperand(0), f, bb);
     auto rValue = transValue(bc->getOperand(1), f, bb);
+    // TODO: Remove this when LLPC will switch fully to opaque pointers.
+    // For opaque pointers this condition will be always FALSE.
     if (lValue->getType() != rValue->getType())
-      return new ICmpInst(*bb, CmpMap::rmap(op), getBuilder()->getInt32(0), getBuilder()->getInt32(1));
+      return getBuilder()->CreateCmp(CmpMap::rmap(op), getBuilder()->getInt32(0), getBuilder()->getInt32(1));
   }
 
   if (isLogicalOpCode(op))
     op = IntBoolOpMap::rmap(op);
-  if (bt->isTypeVectorOrScalarInt() || bt->isTypeVectorOrScalarBool() || bt->isTypePointer())
-    inst =
-        new ICmpInst(*bb, CmpMap::rmap(op), transValue(bc->getOperand(0), f, bb), transValue(bc->getOperand(1), f, bb));
-  else if (bt->isTypeVectorOrScalarFloat())
-    inst =
-        new FCmpInst(*bb, CmpMap::rmap(op), transValue(bc->getOperand(0), f, bb), transValue(bc->getOperand(1), f, bb));
-  assert(inst && "not implemented");
-  return inst;
+  return getBuilder()->CreateCmp(CmpMap::rmap(op), transValue(bc->getOperand(0), f, bb),
+                                 transValue(bc->getOperand(1), f, bb));
 }
 
 // =====================================================================================================================
 // Perform matrix transpose on given input type.
 //
 // @param t : type which will be transposed.
 static Type *getTransposedType(Type *t) {
   assert(t->isArrayTy() && t->getArrayElementType()->isStructTy());
   Type *const columnVectorType = t->getArrayElementType()->getStructElementType(0);
   assert(columnVectorType->isArrayTy());
@@ -1333,21 +1328,24 @@ bool SPIRVToLLVM::postProcessRowMajorMatrix() {
             assert(remappedValue->getType()->isVectorTy());
             assert(cast<VectorType>(remappedValue->getType())->getElementType()->isPointerTy());
             Value *const extractElem = getBuilder()->CreateExtractElement(remappedValue, indices[1]);
             valueMap[getElemPtr] = extractElem;
 
             valueToTypeMap[extractElem] = GetElementPtrInst::getIndexedType(remappedBaseType, indices[1]);
           }
 
           // Add all the users of this GEP to the worklist for processing.
           for (User *const user : getElemPtr->users())
-            workList.push_back(user);
+            // Add only unique instructions to the list. If comparing the same pointers then
+            // GEP can be used twice by the same CmpInst as operand 0 and operand 1.
+            if (std::find(workList.begin(), workList.end(), user) == workList.end())
+              workList.push_back(user);
         } else if (LoadInst *const load = dyn_cast<LoadInst>(value)) {
           // For loads we have to handle three cases:
           // 1. We are loading a full matrix, so do a load + transpose.
           // 2. We are loading a column of a matrix, and since this is represented as a vector of GEPs we need
           //    to issue a load for each element of this vector and recombine the result.
           // 3. We are loading a single scalar element, do a simple load.
 
           Value *const pointer = valueMap[load->getPointerOperand()];
           Type *const pointerType = pointer->getType();
           assert(valueToTypeMap.count(pointer) > 0);
@@ -1521,20 +1519,36 @@ bool SPIRVToLLVM::postProcessRowMajorMatrix() {
                                                                          store->getAlign(), store->isVolatile());
             newStore->setOrdering(store->getOrdering());
             newStore->setSyncScopeID(store->getSyncScopeID());
 
             if (store->getMetadata(LLVMContext::MD_nontemporal))
               transNonTemporalMetadata(newStore);
           }
         } else if (CallInst *const callInst = dyn_cast<CallInst>(value)) {
           if (callInst->getCalledFunction()->getName().startswith(gSPIRVMD::NonUniform))
             continue;
+        } else if (CmpInst *const cmpInst = dyn_cast<CmpInst>(value)) {
+          if (cmpInst->use_empty())
+            continue;
+
+          Value *lhs = cmpInst->getOperand(0);
+          Value *rhs = cmpInst->getOperand(1);
+          if (Value *mapped = valueMap.lookup(lhs))
+            lhs = mapped;
+          if (Value *mapped = valueMap.lookup(rhs))
+            rhs = mapped;
+
+          Value *newCmpInst = getBuilder()->CreateCmp(cmpInst->getPredicate(), lhs, rhs, cmpInst->getName());
+          cmpInst->replaceAllUsesWith(newCmpInst);
+          // Drop all references to eliminate double add to remove list.
+          // This can happen when we are comparing pointers of two matrices of row major.
+          cmpInst->dropAllReferences();
         } else
           llvm_unreachable("Should never be called!");
       }
     }
   }
 
   const bool changed = (!valuesToRemove.empty());
 
   while (!valuesToRemove.empty()) {
     Value *const value = valuesToRemove.pop_back_val();
@@ -1939,28 +1953,22 @@ Constant *SPIRVToLLVM::buildConstStoreRecursively(SPIRVType *const spvType, Type
 
       if (needsPad)
         indices.push_back(zero);
 
       Type *const elementStoreType = GetElementPtrInst::getIndexedType(storeType, indices);
       Constant *const constElement =
           buildConstStoreRecursively(spvElementType, elementStoreType->getPointerTo(addrSpace), elementStoreType,
                                      constStoreValue->getAggregateElement(i));
 
       if (needsPad) {
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 428736
-        // Old version of the code
-        constElements[i] = ConstantExpr::getInsertValue(constElements[i], constElement, 0);
-#else
-        // New version of the code (also handles unknown version, which we treat as latest).
         constElements[i] = llvm::ConstantFoldInsertValueInstruction(constElements[i], constElement, 0);
         assert(constElements[i] && "unexpected error creating aggregate initializer, malformed aggregate?");
-#endif
       } else {
         constElements[i] = constElement;
       }
     }
 
     return ConstantArray::get(cast<ArrayType>(storeType), constElements);
   }
   // If the store was a bool or vector of bool, need to zext the storing value.
   if (spvType->isTypeBool() || (spvType->isTypeVector() && spvType->getVectorComponentType()->isTypeBool()))
     constStoreValue = ConstantExpr::getZExtOrBitCast(constStoreValue, storeType);
@@ -2595,23 +2603,30 @@ Value *SPIRVToLLVM::loadImageSampler(Type *elementTy, Value *base) {
   Value *ptr = getBuilder()->CreateExtractValue(base, 0);
 
   if (auto arrayTy = dyn_cast<ArrayType>(elementTy)) {
     // The element type being loaded is an array. That must be where a non-texel-buffer image is represented as
     // an array of three image descriptors, to allow for multiple planes in YCbCr conversion. Normally we only
     // load one descriptor; if there are any converting samplers, we load all three, and rely on later optimizations
     // to remove the unused ones (and thus stop us reading off the end of the descriptor table).
     elementTy = arrayTy->getElementType();
     Value *oneVal = getBuilder()->CreateLoad(elementTy, ptr);
     Value *result = getBuilder()->CreateInsertValue(UndefValue::get(arrayTy), oneVal, 0);
-    if (!m_convertingSamplers.empty()) {
+    // Pointer to image is represented as a struct containing {pointer, stride, planeStride, isResource}.
+    if (!m_convertingSamplers.empty() && base->getType()->getStructNumElements() >= 4) {
+      Value *planeStride = getBuilder()->CreateExtractValue(base, 2);
+      Type *ptrTy = ptr->getType();
+
       for (unsigned planeIdx = 1; planeIdx != arrayTy->getNumElements(); ++planeIdx) {
-        ptr = getBuilder()->CreateGEP(elementTy, ptr, getBuilder()->getInt32(1));
+        ptr = getBuilder()->CreateBitCast(
+            ptr, getBuilder()->getInt8Ty()->getPointerTo(ptr->getType()->getPointerAddressSpace()));
+        ptr = getBuilder()->CreateGEP(getBuilder()->getInt8Ty(), ptr, planeStride);
+        ptr = getBuilder()->CreateBitCast(ptr, ptrTy);
         oneVal = getBuilder()->CreateLoad(elementTy, ptr);
         result = getBuilder()->CreateInsertValue(result, oneVal, planeIdx);
       }
     }
     return result;
   }
 
   // Other cases: Just load the element from the pointer.
   return getBuilder()->CreateLoad(elementTy, ptr);
 }
@@ -2689,26 +2704,53 @@ Value *SPIRVToLLVM::transImagePointer(SPIRVValue *spvImagePtr) {
 // =====================================================================================================================
 // Get an image/sampler descriptor pointer-and-stride struct
 //
 // @param resType : ResourceNodeType value
 // @param descriptorSet : Descriptor set
 // @param binding : Binding
 // @param searchType : ResourceNodeType to find user resource node
 Value *SPIRVToLLVM::getDescPointerAndStride(ResourceNodeType resType, unsigned descriptorSet, unsigned binding,
                                             ResourceNodeType searchType) {
   if (resType != ResourceNodeType::DescriptorSampler) {
-    // Image/f-mask/texel buffer, where a pointer is represented by a struct {pointer,stride}.
+    // f-mask/texel buffer, where a pointer is represented by a struct {pointer,stride}.
     Value *descPtr = getBuilder()->CreateGetDescPtr(resType, searchType, descriptorSet, binding);
     Value *descStride = getBuilder()->CreateGetDescStride(resType, searchType, descriptorSet, binding);
     descPtr = getBuilder()->CreateInsertValue(
-        UndefValue::get(StructType::get(*m_context, {descPtr->getType(), descStride->getType()})), descPtr, 0);
+        PoisonValue::get(StructType::get(*m_context, {descPtr->getType(), descStride->getType(), descStride->getType(),
+                                                      getBuilder()->getInt32Ty()})),
+        descPtr, 0);
     descPtr = getBuilder()->CreateInsertValue(descPtr, descStride, 1);
+
+    if (resType == ResourceNodeType::DescriptorResource) {
+      // Image, where a pointer is represented by a struct {pointer, stride, planeStride, isResource}
+      unsigned convertingSamplerIdx = 0;
+      unsigned nextIdx = 1;
+      for (const ConvertingSampler &convertingSampler : m_convertingSamplers) {
+        if (convertingSampler.set == descriptorSet && convertingSampler.binding == binding) {
+          convertingSamplerIdx = nextIdx;
+          break;
+        }
+        nextIdx += convertingSampler.values.size() / ConvertingSamplerDwordCount;
+      }
+      if (convertingSamplerIdx == 0) {
+        descPtr = getBuilder()->CreateInsertValue(descPtr, getBuilder()->getInt32(DescriptorSizeResource), 2);
+      } else {
+        // Sampler Descriptor includes {sampler, YCbCrMetaDta}
+        auto samplerMetadata =
+            m_convertingSamplers[convertingSamplerIdx - 1].values.data() + DescriptorSizeSamplerInDwords;
+        Value *planes = getBuilder()->getInt32(
+            reinterpret_cast<const Vkgc::SamplerYCbCrConversionMetaData *>(samplerMetadata)->word1.planes);
+        Value *planeStride = getBuilder()->CreateUDiv(descStride, planes);
+        descPtr = getBuilder()->CreateInsertValue(descPtr, planeStride, 2);
+      }
+      descPtr = getBuilder()->CreateInsertValue(descPtr, getBuilder()->getInt32(1), 3);
+    }
     return descPtr;
   }
 
   // A sampler pointer is represented by a struct {pointer,stride,convertingSamplerIdx}, where
   // convertingSamplerIdx is 0 or the 1-based converting sampler index. Here we use descriptorSet and binding
   // to detect whether it is a converting sampler, and set up the converting sampler index.
   unsigned convertingSamplerIdx = 0;
   unsigned nextIdx = 1;
   for (const ConvertingSampler &convertingSampler : m_convertingSamplers) {
     if (convertingSampler.set == descriptorSet && convertingSampler.binding == binding) {
@@ -3140,21 +3182,21 @@ Value *SPIRVToLLVM::indexDescPtr(Type *elementTy, Value *base, Value *index) {
     ptr0 = indexDescPtr(structTy->getElementType(0), ptr0, index);
     ptr1 = indexDescPtr(structTy->getElementType(1), ptr1, index);
     base = getBuilder()->CreateInsertValue(UndefValue::get(base->getType()), ptr0, 0);
     base = getBuilder()->CreateInsertValue(base, ptr1, 1);
     return base;
   }
 
   // A sampler pointer is represented by a {pointer,stride,convertingSamplerIdx} struct. If the converting sampler
   // index is non-zero (i.e. it is actually a converting sampler), we also want to modify that index. That can only
   // happen if there are any converting samplers at all.
-  if (!m_convertingSamplers.empty() && base->getType()->getStructNumElements() >= 3) {
+  if (!m_convertingSamplers.empty() && base->getType()->getStructNumElements() == 3) {
     Value *convertingSamplerIdx = getBuilder()->CreateExtractValue(base, 2);
     Value *modifiedIdx = getBuilder()->CreateAdd(convertingSamplerIdx, index);
     Value *isConvertingSampler = getBuilder()->CreateICmpNE(convertingSamplerIdx, getBuilder()->getInt32(0));
     modifiedIdx = getBuilder()->CreateSelect(isConvertingSampler, modifiedIdx, getBuilder()->getInt32(0));
     base = getBuilder()->CreateInsertValue(base, modifiedIdx, 2);
   }
 
   // The descriptor "pointer" is in fact a struct containing the pointer and stride.
   Value *ptr = getBuilder()->CreateExtractValue(base, 0);
   Value *stride = getBuilder()->CreateExtractValue(base, 1);
@@ -4187,66 +4229,48 @@ Constant *SPIRVToLLVM::transInitializer(SPIRVValue *const spvValue, Type *const
 
     assert(needsPad == false || isRemappedTypeElements(spvType));
 
     Constant *structInitializer = UndefValue::get(type);
 
     for (unsigned i = 0, memberCount = spvMembers.size(); i < memberCount; i++) {
       const unsigned memberIndex = needsPad ? lookupRemappedTypeElements(spvType, i) : i;
 
       Constant *const initializer = transInitializer(spvMembers[i], type->getStructElementType(memberIndex));
 
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 428736
-      // Old version of the code
-      structInitializer = ConstantExpr::getInsertValue(structInitializer, initializer, memberIndex);
-#else
-      // New version of the code (also handles unknown version, which we treat as latest).
       structInitializer = llvm::ConstantFoldInsertValueInstruction(structInitializer, initializer, memberIndex);
       assert(structInitializer && "unexpected error creating aggregate initializer, malformed aggregate?");
-#endif
     }
 
     return structInitializer;
   }
   if (type->isArrayTy()) {
     SPIRVConstantComposite *const spvConstArray = static_cast<SPIRVConstantComposite *>(spvValue);
 
     std::vector<SPIRVValue *> spvElements(spvConstArray->getElements());
     assert(spvElements.size() == type->getArrayNumElements());
 
     // Matrix and arrays both get here. For both we need to turn [<{element-type, pad}>] into [element-type].
     const bool needsPad = isTypeWithPad(type);
 
     Constant *arrayInitializer = UndefValue::get(type);
 
     for (unsigned i = 0, elementCount = spvElements.size(); i < elementCount; i++) {
       if (needsPad) {
         Type *const elementType = type->getArrayElementType()->getStructElementType(0);
         Constant *const initializer = transInitializer(spvElements[i], elementType);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 428736
-        // Old version of the code
-        arrayInitializer = ConstantExpr::getInsertValue(arrayInitializer, initializer, {i, 0});
-#else
-        // New version of the code (also handles unknown version, which we treat as latest).
         arrayInitializer = llvm::ConstantFoldInsertValueInstruction(arrayInitializer, initializer, {i, 0});
         assert(arrayInitializer && "unexpected error creating aggregate initializer, malformed aggregate?");
-#endif
       } else {
         Type *const elementType = type->getArrayElementType();
         Constant *const initializer = transInitializer(spvElements[i], elementType);
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 428736
-        // Old version of the code
-        arrayInitializer = ConstantExpr::getInsertValue(arrayInitializer, initializer, i);
-#else
-        // New version of the code (also handles unknown version, which we treat as latest).
         arrayInitializer = llvm::ConstantFoldInsertValueInstruction(arrayInitializer, initializer, i);
         assert(arrayInitializer && "unexpected error creating aggregate initializer, malformed aggregate?");
-#endif
       }
     }
 
     return arrayInitializer;
   }
   Constant *initializer = cast<Constant>(transValue(spvValue, nullptr, nullptr, false));
   if (initializer->getType() != type) {
     // The translated value type is different to the requested type. This can only happen in the
     // case that the SPIR-V value was (vector of) bool but the requested type was (vector of) i32 because it is a bool
     // in memory.
@@ -4794,23 +4818,41 @@ Value *SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *bv, Function *f, Bas
     SPIRVSelect *bs = static_cast<SPIRVSelect *>(bv);
     return mapValue(bv, SelectInst::Create(transValue(bs->getCondition(), f, bb), transValue(bs->getTrueValue(), f, bb),
                                            transValue(bs->getFalseValue(), f, bb), bv->getName(), bb));
   }
 
   case OpLine:
   case OpSelectionMerge:
     return nullptr;
   case OpLoopMerge: { // Should be translated at OpBranch or OpBranchConditional cases
     SPIRVLoopMerge *lm = static_cast<SPIRVLoopMerge *>(bv);
-    auto label = m_bm->get<SPIRVBasicBlock>(lm->getContinueTarget());
-    label->setLoopMerge(lm);
-    return nullptr;
+    auto continueLabel = m_bm->get<SPIRVBasicBlock>(lm->getContinueTarget());
+    auto mergeLabel = m_bm->get<SPIRVBasicBlock>(lm->getMergeBlock());
+    auto continueBlock = cast<BasicBlock>(transValue(continueLabel, f, bb));
+    auto mergeBlock = cast<BasicBlock>(transValue(mergeLabel, f, bb));
+
+    continueLabel->setLoopMerge(lm);
+
+    // Annotate the loop structure with pseudo intrinsic calls
+    auto builder = getBuilder();
+    IRBuilder<>::InsertPointGuard guard(*builder);
+
+    auto loopMerge = mapValue(lm, builder->CreateNamedCall("spirv.loop.merge", builder->getInt32Ty(), {},
+                                                           {Attribute::ReadNone, Attribute::Convergent}));
+    builder->SetInsertPoint(continueBlock);
+    builder->CreateNamedCall("spirv.loop.continue.block", builder->getVoidTy(), {loopMerge},
+                             {Attribute::ReadNone, Attribute::Convergent});
+    builder->SetInsertPoint(mergeBlock);
+    builder->CreateNamedCall("spirv.loop.merge.block", builder->getVoidTy(), {loopMerge},
+                             {Attribute::ReadNone, Attribute::Convergent});
+
+    return loopMerge;
   }
   case OpSwitch: {
     auto bs = static_cast<SPIRVSwitch *>(bv);
     auto select = transValue(bs->getSelect(), f, bb);
     auto defaultSuccessor = dyn_cast<BasicBlock>(transValue(bs->getDefault(), f, bb));
     recordBlockPredecessor(defaultSuccessor, bb);
     auto ls = SwitchInst::Create(select, defaultSuccessor, bs->getNumPairs(), bb);
     bs->foreachPair([&](SPIRVSwitch::LiteralTy literals, SPIRVBasicBlock *label) {
       assert(!literals.empty() && "Literals should not be empty");
       assert(literals.size() <= 2 && "Number of literals should not be more then two");
@@ -5664,27 +5706,21 @@ Function *SPIRVToLLVM::transFunction(SPIRVFunction *bf) {
     foreachFuncCtlMask(bf, [&](Attribute::AttrKind attr) { f->addFnAttr(attr); });
   }
 
   for (Function::arg_iterator i = f->arg_begin(), e = f->arg_end(); i != e; ++i) {
     auto ba = bf->getArgument(i->getArgNo());
     mapValue(ba, &(*i));
     setName(&(*i), ba);
 
     SPIRVWord maxOffset = 0;
     if (ba->hasDecorate(DecorationMaxByteOffset, 0, &maxOffset)) {
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 409358
-      // Old version of the code
-      AttrBuilder builder;
-#else
-      // New version of the code (also handles unknown version, which we treat as latest)
       AttrBuilder builder(*m_context);
-#endif
       builder.addDereferenceableAttr(maxOffset);
       i->addAttrs(builder);
     }
   }
 
   // Creating all basic blocks before creating instructions.
   for (size_t i = 0, e = bf->getNumBasicBlock(); i != e; ++i)
     transValue(bf->getBasicBlock(i), f, nullptr);
 
   // Set name for entry block
@@ -5915,21 +5951,24 @@ void SPIRVToLLVM::getImageDesc(SPIRVValue *bImageInst, ExtractedImageInfo *info)
       if (idxIt->getOpCode() != OpConstant) {
         enforceReadFirstlane = true;
         break;
       }
     }
     if (enforceReadFirstlane)
       info->flags |= isImage ? lgc::Builder::ImageFlagEnforceReadFirstLaneImage
                              : lgc::Builder::ImageFlagEnforceReadFirstLaneSampler;
   };
 
-  if (bImageInst->hasDecorate(DecorationNonUniformEXT)) {
+  bool forceNonUniform = isShaderStageInMask(convertToShaderStage(m_execModule),
+                                             getPipelineOptions()->forceNonUniformResourceIndexStageMask);
+
+  if (forceNonUniform || bImageInst->hasDecorate(DecorationNonUniformEXT)) {
     info->flags |= lgc::Builder::ImageFlagNonUniformImage;
     if (bImageInst->getType()->getOpCode() == OpTypeSampledImage)
       info->flags |= lgc::Builder::ImageFlagNonUniformSampler;
   }
 
   if (bImageInst->getOpCode() == OpImageTexelPointer) {
     // We are looking at the OpImageTexelPointer for an image atomic. Load the
     // image descriptor from its image pointer.
     SPIRVValue *bImagePtr = static_cast<SPIRVImageTexelPointer *>(bImageInst)->getImage();
     info->desc = &static_cast<SPIRVTypeImage *>(bImagePtr->getType()->getPointerElementType())->getDescriptor();
@@ -5942,21 +5981,21 @@ void SPIRVToLLVM::getImageDesc(SPIRVValue *bImageInst, ExtractedImageInfo *info)
     if (isa<ArrayType>(info->imageDesc->getType())) {
       // Extract image descriptor from possible array of multi-plane image descriptors.
       info->imageDesc = getBuilder()->CreateExtractValue(info->imageDesc, 0);
     }
     // We also need to trace back to the OpVariable or OpFunctionParam to find
     // the coherent and volatile decorations.
     SPIRVValue *imageAccessChain = nullptr;
     while (bImagePtr->getOpCode() == OpAccessChain || bImagePtr->getOpCode() == OpInBoundsAccessChain) {
       std::vector<SPIRVValue *> operands = static_cast<SPIRVInstTemplateBase *>(bImagePtr)->getOperands();
       for (SPIRVValue *operand : operands) {
-        if (operand->hasDecorate(DecorationNonUniformEXT))
+        if (forceNonUniform || operand->hasDecorate(DecorationNonUniformEXT))
           info->flags |= lgc::Builder::ImageFlagNonUniformImage;
       }
       imageAccessChain = bImagePtr;
       bImagePtr = operands[0];
     }
     assert(bImagePtr->getOpCode() == OpVariable || bImagePtr->getOpCode() == OpFunctionParameter);
     if (bImageInst->hasDecorate(DecorationCoherent))
       info->flags |= lgc::Builder::ImageFlagCoherent;
     if (bImageInst->hasDecorate(DecorationVolatile))
       info->flags |= lgc::Builder::ImageFlagVolatile;
@@ -5985,27 +6024,27 @@ void SPIRVToLLVM::getImageDesc(SPIRVValue *bImageInst, ExtractedImageInfo *info)
       imageLoadSrc = loadSrc;
     }
   }
 
   // We need to scan back through OpImage/OpSampledImage just to find any
   // NonUniform decoration.
   SPIRVValue *scanBackInst = bImageInst;
   while (scanBackInst->getOpCode() == OpImage || scanBackInst->getOpCode() == OpSampledImage) {
     if (scanBackInst->getOpCode() == OpSampledImage) {
       auto sampler = static_cast<SPIRVInstTemplateBase *>(scanBackInst)->getOpValue(1);
-      if (sampler->hasDecorate(DecorationNonUniformEXT))
+      if (forceNonUniform || sampler->hasDecorate(DecorationNonUniformEXT))
         info->flags |= lgc::Builder::ImageFlagNonUniformSampler;
       if (sampler->getOpCode() == OpLoad)
         samplerLoadSrc = static_cast<SPIRVLoad *>(sampler)->getSrc();
     }
     scanBackInst = static_cast<SPIRVInstTemplateBase *>(scanBackInst)->getOpValue(0);
-    if (scanBackInst->hasDecorate(DecorationNonUniformEXT))
+    if (forceNonUniform || scanBackInst->hasDecorate(DecorationNonUniformEXT))
       info->flags |= lgc::Builder::ImageFlagNonUniformImage;
     if (scanBackInst->getOpCode() == OpLoad)
       imageLoadSrc = static_cast<SPIRVLoad *>(scanBackInst)->getSrc();
   }
   // Set enforce readfirstlane flag for accessing image or sampled image array
   if ((info->flags & lgc::Builder::ImageFlagNonUniformImage) == 0)
     setEnforceReadFirstLaneFlag(imageLoadSrc, true);
   if ((info->flags & lgc::Builder::ImageFlagNonUniformSampler) == 0)
     setEnforceReadFirstLaneFlag(samplerLoadSrc, false);
 
@@ -6955,35 +6994,39 @@ bool SPIRVToLLVM::translate(ExecutionModel entryExecModel, const char *entryName
 
   m_entryTarget = (entryPoint != nullptr) ? m_bm->get<SPIRVFunction>(entryPoint->getTargetId()) : nullptr;
 
   m_execModule = entryExecModel;
   m_fpControlFlags.U32All = 0;
   static_assert(SPIRVTW_8Bit == (8 >> 3), "Unexpected value!");
   static_assert(SPIRVTW_16Bit == (16 >> 3), "Unexpected value!");
   static_assert(SPIRVTW_32Bit == (32 >> 3), "Unexpected value!");
   static_assert(SPIRVTW_64Bit == (64 >> 3), "Unexpected value!");
 
+  bool enableXfb = false;
   if (m_entryTarget) {
     if (auto em = m_entryTarget->getExecutionMode(ExecutionModeDenormPreserve))
       m_fpControlFlags.DenormPreserve = em->getLiterals()[0] >> 3;
 
     if (auto em = m_entryTarget->getExecutionMode(ExecutionModeDenormFlushToZero))
       m_fpControlFlags.DenormFlushToZero = em->getLiterals()[0] >> 3;
 
     if (auto em = m_entryTarget->getExecutionMode(ExecutionModeSignedZeroInfNanPreserve))
       m_fpControlFlags.SignedZeroInfNanPreserve = em->getLiterals()[0] >> 3;
 
     if (auto em = m_entryTarget->getExecutionMode(ExecutionModeRoundingModeRTE))
       m_fpControlFlags.RoundingModeRTE = em->getLiterals()[0] >> 3;
 
     if (auto em = m_entryTarget->getExecutionMode(ExecutionModeRoundingModeRTZ))
       m_fpControlFlags.RoundingModeRTZ = em->getLiterals()[0] >> 3;
+
+    if (m_execModule >= ExecutionModelVertex && m_execModule <= ExecutionModelGeometry)
+      enableXfb = m_entryTarget->getExecutionMode(ExecutionModeXfb) != nullptr;
   } else {
     createLibraryEntryFunc();
   }
 
   // Determine any denormal overrides to be applied.
   Vkgc::DenormalMode fp32DenormalMode =
       Fp32DenormalModeOpt != Vkgc::DenormalMode::Auto ? Fp32DenormalModeOpt : m_shaderOptions->fp32DenormalMode;
 
   // Set common shader mode (FP mode and useSubgroupSize) for middle-end.
   CommonShaderMode shaderMode = {};
@@ -7024,21 +7067,20 @@ bool SPIRVToLLVM::translate(ExecutionModel entryExecModel, const char *entryName
 
   if (pipelineContext->isGraphics() && subgroupSizeUsage) {
     for (lgc::ShaderStage stage : lgc::enumRange<lgc::ShaderStage>()) {
       if (subgroupSizeUsage & (1 << stage)) {
         getBuilder()->setSubgroupSizeUsage(stage, true);
       }
     }
   }
   getBuilder()->setCommonShaderMode(shaderMode);
 
-  m_enableXfb = m_bm->getCapability().find(CapabilityTransformFeedback) != m_bm->getCapability().end();
   m_enableGatherLodNz =
       m_bm->hasCapability(CapabilityImageGatherBiasLodAMD) && entryExecModel == ExecutionModelFragment;
 
   // Find the compile unit first since it might be needed during translation of
   // debug intrinsics.
   MDNode *compilationUnit = nullptr;
   for (SPIRVExtInst *EI : m_bm->getDebugInstVec()) {
     // Translate Compile Unit first.
     // It shouldn't be far from the beginning of the vector
     if (EI->getExtOp() == SPIRVDebug::CompilationUnit) {
@@ -7110,20 +7152,96 @@ bool SPIRVToLLVM::translate(ExecutionModel entryExecModel, const char *entryName
         insertScratchBoundsChecks(memOpPair.first, memOpPair.second, ff);
       }
 
       m_spirvMemopToLlvmMemopMapping[ff].clear();
     }
   }
 
   if (!transMetadata())
     return false;
 
+  // Preserve XFB relevant information in named metadata !lgc.xfb.stage, defined as follows:
+  // lgc.xfb.state metadata = {
+  // i32 buffer0Stream, i32 buffer0Stride, i32 buffer1Stream, i32 buffer1Stride,
+  // i32 buffer2Stream, i32 buffer2Stride, i32 buffer3Stream, i32 buffer3Stride }
+  // ; buffer${i}Stream is the vertex StreamId that writes to buffer i, or -1 if that particular buffer is unused (e.g.
+  // StreamId in EmitVertex)
+  if (enableXfb) {
+    static const unsigned MaxXfbBuffers = 4;
+    std::array<unsigned, 2 * MaxXfbBuffers> xfbState{InvalidValue, 0,  // xfbBuffer[0] -> <streamId, xfbStride>
+                                                     InvalidValue, 0,  // xfbBuffer[1] -> <streamId, xfbStride>
+                                                     InvalidValue, 0,  // xfbBuffer[2] -> <streamId, xfbStride>
+                                                     InvalidValue, 0}; // xfbBuffer[3] -> <streamId, xfbStride>
+    for (unsigned i = 0, e = m_bm->getNumVariables(); i != e; ++i) {
+      auto bv = m_bm->getVariable(i);
+      if (bv->getStorageClass() == StorageClassOutput) {
+        SPIRVWord xfbBuffer = InvalidValue;
+        if (bv->hasDecorate(DecorationXfbBuffer, 0, &xfbBuffer)) {
+          const unsigned indexOfBuffer = 2 * xfbBuffer;
+          xfbState[indexOfBuffer] = 0;
+          SPIRVWord streamId = InvalidValue;
+          if (bv->hasDecorate(DecorationStream, 0, &streamId))
+            xfbState[indexOfBuffer] = streamId;
+
+          SPIRVWord xfbStride = InvalidValue;
+          if (bv->hasDecorate(DecorationXfbStride, 0, &xfbStride)) {
+            const unsigned indexOfStride = indexOfBuffer + 1;
+            xfbState[indexOfStride] = xfbStride;
+          }
+
+          // Update indexOfBuffer for block array, the N array-elements are captured by N consecutive buffers.
+          SPIRVType *bt = bv->getType()->getPointerElementType();
+          if (bt->isTypeArray()) {
+            assert(m_valueMap.find(bv) != m_valueMap.end());
+            auto output = cast<GlobalVariable>(m_valueMap[bv]);
+            MDNode *metaNode = output->getMetadata(gSPIRVMD::InOut);
+            assert(metaNode);
+            auto elemMeta = mdconst::dyn_extract<Constant>(metaNode->getOperand(0));
+            // Find the innermost array-element
+            auto elemTy = bt;
+            uint64_t elemCount = 0;
+            ShaderInOutMetadata outMetadata = {};
+            do {
+              assert(elemMeta->getNumOperands() == 4);
+              outMetadata.U64All[0] = cast<ConstantInt>(elemMeta->getOperand(2))->getZExtValue();
+              outMetadata.U64All[1] = cast<ConstantInt>(elemMeta->getOperand(3))->getZExtValue();
+              elemCount = elemTy->getArrayLength();
+
+              elemTy = elemTy->getArrayElementType();
+              elemMeta = cast<Constant>(elemMeta->getOperand(1));
+            } while (elemTy->isTypeArray());
+
+            if (outMetadata.IsBlockArray) {
+              // The even index (0,2,4,6) of !lgc.xfb.state metadata corresponds the buffer index (0~3).
+              const unsigned bufferIdx = outMetadata.XfbBuffer;
+              const int streamId = xfbState[2 * bufferIdx];
+              const unsigned stride = xfbState[2 * bufferIdx + 1];
+              for (unsigned idx = 0; idx < elemCount; ++idx) {
+                const unsigned indexOfBuffer = 2 * (bufferIdx + idx);
+                xfbState[indexOfBuffer] = streamId;
+                xfbState[indexOfBuffer + 1] = stride;
+              }
+            }
+          }
+        }
+      }
+    }
+
+    unsigned mdKindId = m_context->getMDKindID(lgc::XfbStateMetadataName);
+    std::array<Metadata *, 2 * MaxXfbBuffers> metadatas{};
+    for (unsigned i = 0; i < 2 * MaxXfbBuffers; ++i)
+      metadatas[i] = ConstantAsMetadata::get(m_builder->getInt32(xfbState[i]));
+    auto entryFunc = m_funcMap[m_entryTarget];
+    assert(entryFunc);
+    entryFunc->setMetadata(mdKindId, MDNode::get(*m_context, metadatas));
+  }
+
   postProcessRowMajorMatrix();
   if (!m_moduleUsage->keepUnusedFunctions)
     eraseUselessFunctions(m_m);
   m_dbgTran.finalize();
   return true;
 }
 
 bool SPIRVToLLVM::transAddressingModel() {
   switch (m_bm->getAddressingModel()) {
   case AddressingModelPhysical64:
@@ -8894,21 +9012,21 @@ Value *SPIRVToLLVM::transGLSLBuiltinFromExtInst(SPIRVExtInst *bc, BasicBlock *bb
   FunctionType *funcTy = FunctionType::get(retType, argTys, false);
   Function *func = m_m->getFunction(mangledName);
   if (!func) {
     func = Function::Create(funcTy, GlobalValue::ExternalLinkage, mangledName, m_m);
     func->setCallingConv(CallingConv::SPIR_FUNC);
     if (isFuncNoUnwind())
       func->addFnAttr(Attribute::NoUnwind);
   }
   CallInst *call = CallInst::Create(func, args, bc->getName(), bb);
   setCallingConv(call);
-  addFnAttr(m_context, call, Attribute::NoUnwind);
+  call->addFnAttr(Attribute::NoUnwind);
   return call;
 }
 
 Instruction *SPIRVToLLVM::transBarrier(BasicBlock *bb, SPIRVWord execScope, SPIRVWord memSema, SPIRVWord memScope) {
   transMemFence(bb, memSema, memScope);
   return getBuilder()->CreateBarrier();
 }
 
 Instruction *SPIRVToLLVM::transMemFence(BasicBlock *bb, SPIRVWord memSema, SPIRVWord memScope) {
   AtomicOrdering ordering = AtomicOrdering::NotAtomic;
diff --git a/llpc/translator/lib/SPIRV/SPIRVReader.h b/llpc/translator/lib/SPIRV/SPIRVReader.h
index 86112d361..2abfafb14 100644
--- a/llpc/translator/lib/SPIRV/SPIRVReader.h
+++ b/llpc/translator/lib/SPIRV/SPIRVReader.h
@@ -221,21 +221,20 @@ private:
 
   // TODO: Workaround to handle opaque pointers for OpTypeForwardPointer.
   // This will be removed after opaque pointer transition is complete.
   typedef DenseMap<SPIRVType *, Type *> SPIRVOpForwardPointerWorkaround;
 
   Module *m_m;
   BuiltinVarMap m_builtinGvMap;
   LLVMContext *m_context;
   lgc::Builder *m_builder;
   SPIRVModule *m_bm;
-  bool m_enableXfb;
   bool m_enableGatherLodNz;
   ShaderFloatControlFlags m_fpControlFlags;
   SPIRVFunction *m_entryTarget;
   const SPIRVSpecConstMap &m_specConstMap;
   llvm::ArrayRef<ConvertingSampler> m_convertingSamplers;
   SPIRVToLLVMTypeMap m_typeMap;
   SPIRVToLLVMFullTypeMap m_fullTypeMap;
   SPIRVToLLVMValueMap m_valueMap;
   SPIRVToLLVMFunctionMap m_funcMap;
   SPIRVBlockToLLVMStructMap m_blockMap;
@@ -361,21 +360,21 @@ private:
     assert(f);
     call->setCallingConv(f->getCallingConv());
   }
 
   void setAttrByCalledFunc(CallInst *call);
   Type *transFPType(SPIRVType *t);
   FastMathFlags getFastMathFlags(SPIRVValue *bv);
   void setFastMathFlags(SPIRVValue *bv);
   void setFastMathFlags(Value *val);
   llvm::Value *transShiftLogicalBitwiseInst(SPIRVValue *bv, BasicBlock *bb, Function *f);
-  Instruction *transCmpInst(SPIRVValue *bv, BasicBlock *bb, Function *f);
+  llvm::Value *transCmpInst(SPIRVValue *bv, BasicBlock *bb, Function *f);
 
   void setName(llvm::Value *v, SPIRVValue *bv);
   void setLLVMLoopMetadata(SPIRVLoopMerge *lm, BranchInst *bi);
   template <class Source, class Func> bool foreachFuncCtlMask(Source, Func);
   llvm::GlobalValue::LinkageTypes transLinkageType(const SPIRVValue *v);
 
   Instruction *transBarrier(BasicBlock *bb, SPIRVWord execScope, SPIRVWord memSema, SPIRVWord memScope);
 
   Instruction *transMemFence(BasicBlock *bb, SPIRVWord memSema, SPIRVWord memScope);
   void truncConstantIndex(std::vector<Value *> &indices, BasicBlock *bb);
diff --git a/llpc/translator/lib/SPIRV/SPIRVToLLVMDbgTran.cpp b/llpc/translator/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
index d667de899..826897cf3 100644
--- a/llpc/translator/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
+++ b/llpc/translator/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
@@ -160,21 +160,27 @@ DIDerivedType *SPIRVToLLVMDbgTran::transTypeQualifier(const SPIRVExtInst *DebugI
   return Builder.createQualifiedType(Tag, BaseTy);
 }
 
 DIType *SPIRVToLLVMDbgTran::transTypePointer(const SPIRVExtInst *DebugInst) {
   using namespace SPIRVDebug::Operand::TypePointer;
   const SPIRVWordVec &Ops = DebugInst->getArguments();
   assert(Ops.size() == OperandCount && "Invalid number of operands");
   DIType *PointeeTy = nullptr;
   if (BM->getEntry(Ops[BaseTypeIdx])->getOpCode() != OpTypeVoid)
     PointeeTy = transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[BaseTypeIdx]));
+#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 444152
+  // Old version of the code
   Optional<unsigned> AS;
+#else
+  // New version of the code (also handles unknown version, which we treat as latest)
+  std::optional<unsigned> AS;
+#endif
   if (Ops[StorageClassIdx] != ~0U) {
     auto SC = static_cast<SPIRVStorageClassKind>(Ops[StorageClassIdx]);
     AS = SPIRSPIRVAddrSpaceMap::rmap(SC);
   }
   DIType *Ty;
   SPIRVWord Flags = Ops[FlagsIdx];
   if (Flags & SPIRVDebug::FlagIsLValueReference)
     Ty = Builder.createReferenceType(dwarf::DW_TAG_reference_type, PointeeTy, 0, 0, AS);
   else if (Flags & SPIRVDebug::FlagIsRValueReference)
     Ty = Builder.createReferenceType(dwarf::DW_TAG_rvalue_reference_type, PointeeTy, 0, 0, AS);
@@ -940,21 +946,21 @@ DebugLoc SPIRVToLLVMDbgTran::transDebugScope(const SPIRVInstruction *SpirvInst,
       Filename = LineInfo->getFileNameStr();
       LN = Line;
     }
     auto DF = getDIFile(Filename);
     auto *F = Inst->getParent()->getParent();
     auto FN = F->getName();
     auto SPFlags = DISubprogram::SPFlagDefinition;
     if (llvm::Function::isInternalLinkage(F->getLinkage())) {
       SPFlags |= DISubprogram::SPFlagLocalToUnit;
     }
-    auto *Ty = Builder.createSubroutineType(Builder.getOrCreateTypeArray(None));
+    auto *Ty = Builder.createSubroutineType(Builder.getOrCreateTypeArray({}));
     Sub = Builder.createFunction(DF, FN, FN, DF, LN, Ty, LN, DINode::FlagZero, SPFlags);
     FuncMap[SF->getId()] = Sub;
     assert(F->getSubprogram() == Sub || F->getSubprogram() == nullptr);
     F->setSubprogram(Sub);
   }
   return DILocation::get(Sub->getContext(), Line, Col, Sub);
 }
 
 MDNode *SPIRVToLLVMDbgTran::transDebugInlined(const SPIRVExtInst *Inst) {
   using namespace SPIRVDebug::Operand::InlinedAt;
diff --git a/llpc/translator/lib/SPIRV/SPIRVUtil.cpp b/llpc/translator/lib/SPIRV/SPIRVUtil.cpp
index c339a03cc..bb2d13cd3 100644
--- a/llpc/translator/lib/SPIRV/SPIRVUtil.cpp
+++ b/llpc/translator/lib/SPIRV/SPIRVUtil.cpp
@@ -36,40 +36,20 @@
 /// This file defines utility classes and functions shared by SPIR-V
 /// reader/writer.
 ///
 //===----------------------------------------------------------------------===//
 #include "SPIRVInternal.h"
 
 #define DEBUG_TYPE "spirv"
 
 namespace SPIRV {
 
-void addFnAttr(LLVMContext *Context, CallInst *Call, Attribute::AttrKind Attr) {
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-  // Old version of the code
-  Call->addAttribute(AttributeList::FunctionIndex, Attr);
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
-  Call->addFnAttr(Attr);
-#endif
-}
-
-void removeFnAttr(LLVMContext *Context, CallInst *Call, Attribute::AttrKind Attr) {
-#if LLVM_MAIN_REVISION && LLVM_MAIN_REVISION < 396596
-  // Old version of the code
-  Call->removeAttribute(AttributeList::FunctionIndex, Attr);
-#else
-  // New version of the code (also handles unknown version, which we treat as latest)
-  Call->removeFnAttr(Attr);
-#endif
-}
-
 Function *getOrCreateFunction(Module *M, Type *RetTy, ArrayRef<Type *> ArgTypes, StringRef Name, AttributeList *Attrs,
                               bool TakeName) {
   const std::string MangledName(Name);
   bool IsVarArg = false;
   FunctionType *FT = FunctionType::get(RetTy, ArgTypes, IsVarArg);
   Function *F = M->getFunction(MangledName);
   if (!F || F->getFunctionType() != FT) {
     auto NewF = Function::Create(FT, GlobalValue::ExternalLinkage, MangledName, M);
     if (F && TakeName) {
       NewF->takeName(F);
diff --git a/llpc/translator/lib/SPIRV/libSPIRV/SPIRVInstruction.h b/llpc/translator/lib/SPIRV/libSPIRV/SPIRVInstruction.h
index 05f736227..d7ccbf21f 100644
--- a/llpc/translator/lib/SPIRV/libSPIRV/SPIRVInstruction.h
+++ b/llpc/translator/lib/SPIRV/libSPIRV/SPIRVInstruction.h
@@ -2389,27 +2389,29 @@ protected:
     SPIRVId Op1 = Ops[0];
     SPIRVId Op2 = Ops[1];
     SPIRVType *Op1Ty = getValueType(Op1);
     SPIRVType *Op2Ty = getValueType(Op2);
     assert(Op1Ty->isTypeInt() || Op1Ty->isTypeVector());
 
     if (Op1Ty->isTypeInt()) {
       // 4x8-bit is packed into a 32-bit integer
       auto Op1IntTy = static_cast<SPIRVTypeInt *>(Op1Ty);
       auto Op2IntTy = static_cast<SPIRVTypeInt *>(Op2Ty);
-      assert(Op1IntTy->getBitWidth() == 32 && Op2IntTy->getBitWidth() == 32 && Type->getBitWidth() >= 8);
+      unsigned bitWidth = 8;
+      assert(Op1IntTy->getBitWidth() == 32 && Op2IntTy->getBitWidth() == 32 && Type->getBitWidth() >= bitWidth);
       unsigned optionalIdx = WordCount == 6 ? 2 : 3;
       assert(isValidPackedVectorFormat(static_cast<spv::PackedVectorFormat>(Ops[optionalIdx])) &&
              "Invalid packed vector format");
       (void)Op1IntTy;
       (void)Op2IntTy;
       (void)optionalIdx;
+      (void)bitWidth;
     } else {
       // 4x8-bit integer vectors
       assert(Op1Ty->getVectorComponentCount() == Op2Ty->getVectorComponentCount() &&
              Op1Ty->getVectorComponentType()->isTypeInt() && Op2Ty->getVectorComponentType()->isTypeInt());
       auto Op1IntTy = static_cast<SPIRVTypeInt *>(Op1Ty->getVectorComponentType());
       auto Op2IntTy = static_cast<SPIRVTypeInt *>(Op2Ty->getVectorComponentType());
       assert(Op1IntTy->getBitWidth() == Op2IntTy->getBitWidth() && Type->getBitWidth() >= Op1IntTy->getBitWidth());
       (void)Op1IntTy;
       (void)Op2IntTy;
     }
diff --git a/llpc/unittests/util/testPipelineDumper.cpp b/llpc/unittests/util/testPipelineDumper.cpp
index faf673f5f..59b6d69df 100644
--- a/llpc/unittests/util/testPipelineDumper.cpp
+++ b/llpc/unittests/util/testPipelineDumper.cpp
@@ -246,20 +246,42 @@ TEST(PipelineDumperTest, TestShadowDescriptorTableUsageGraphics) {
   runGraphicsPipelineVariations(modifyBuildInfo, expectHashToBeEqual);
 }
 
 TEST(PipelineDumperTest, TestShadowDescriptorTableUsageCompute) {
   ModifyComputeBuildInfo modifyBuildInfo = [](ComputePipelineBuildInfo *buildInfo) {
     buildInfo->options.shadowDescriptorTableUsage = ShadowDescriptorTableUsage::Enable;
   };
   HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &params) { return params.isRelocatableShader; };
   runComputePipelineVariations(modifyBuildInfo, expectHashToBeEqual);
 }
+#if VKI_BUILD_GFX11
+
+// =====================================================================================================================
+// Test the optimizeTessFactor option.
+
+TEST(PipelineDumperTest, TestOptimizeTessFactorOptionGraphics) {
+  ModifyGraphicsBuildInfo modifyBuildInfo = [](GraphicsPipelineBuildInfo *buildInfo) {
+    buildInfo->options.optimizeTessFactor = true;
+  };
+  HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &params) { return false; };
+  runGraphicsPipelineVariations(modifyBuildInfo, expectHashToBeEqual);
+}
+
+TEST(PipelineDumperTest, TestOptimizeTessFactorOptionCompute) {
+  ModifyComputeBuildInfo modifyBuildInfo = [](ComputePipelineBuildInfo *buildInfo) {
+    buildInfo->options.optimizeTessFactor = true;
+  };
+  // Should not modify compute shader
+  HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &params) { return true; };
+  runComputePipelineVariations(modifyBuildInfo, expectHashToBeEqual);
+}
+#endif
 
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 53
 // =====================================================================================================================
 // Test the optimization level option.  The default value for the optimization level in the pipeline build info is 0.
 // All tess will be compared with that.
 
 TEST(PipelineDumperTest, TestOptimizationLevelGraphics) {
 
   for (uint32_t optLevel = 1; optLevel <= 3; ++optLevel) {
     ModifyGraphicsBuildInfo modifyBuildInfo = [optLevel](GraphicsPipelineBuildInfo *buildInfo) {
@@ -365,12 +387,32 @@ TEST(PipelineDumperTest, TestInternalRTShadersGraphics) {
 
 TEST(PipelineDumperTest, TestInternalRTShadersCompute) {
   ModifyComputeBuildInfo modifyBuildInfo = [](ComputePipelineBuildInfo *buildInfo) {
     buildInfo->options.internalRtShaders = true;
   };
   HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &) { return false; };
   runComputePipelineVariations(modifyBuildInfo, expectHashToBeEqual);
 }
 #endif
 
+// =====================================================================================================================
+// Test the forceNonUniformResourceIndexStageMask option.
+
+TEST(PipelineDumperTest, TestForceNonUniformResourceIndexStageMaskGraphics) {
+  ModifyGraphicsBuildInfo modifyBuildInfo = [](GraphicsPipelineBuildInfo *buildInfo) {
+    buildInfo->options.forceNonUniformResourceIndexStageMask = ~0u;
+  };
+
+  HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &params) { return false; };
+  runGraphicsPipelineVariations(modifyBuildInfo, expectHashToBeEqual);
+}
+
+TEST(PipelineDumperTest, TestForceNonUniformResourceIndexStageMaskCompute) {
+  ModifyComputeBuildInfo modifyBuildInfo = [](ComputePipelineBuildInfo *buildInfo) {
+    buildInfo->options.forceNonUniformResourceIndexStageMask = ~0u;
+  };
+  HashModifiedFunc expectHashToBeEqual = [](const GenerateHashParams &params) { return false; };
+  runComputePipelineVariations(modifyBuildInfo, expectHashToBeEqual);
+}
+
 } // namespace
 } // namespace Llpc
diff --git a/llpc/util/llpcCacheAccessor.cpp b/llpc/util/llpcCacheAccessor.cpp
index 71274ac3c..213d9a03f 100644
--- a/llpc/util/llpcCacheAccessor.cpp
+++ b/llpc/util/llpcCacheAccessor.cpp
@@ -172,23 +172,25 @@ bool CacheAccessor::lookUpInShaderCache(const MetroHash::Hash &hash, bool alloca
 }
 
 // =====================================================================================================================
 // Sets the ELF entry for the hash on a cache miss.  Does nothing if there was a cache hit or the ELF has already been
 // set.
 //
 // @param elf : The binary encoding of the elf to place in the cache.
 void CacheAccessor::setElfInCache(BinaryData elf) {
   if (m_shaderCacheEntryState == ShaderEntryState::Compiling && m_shaderCacheEntry) {
     updateShaderCache(elf);
-    mustSucceed(m_shaderCache->retrieveShader(m_shaderCacheEntry, &m_elf.pCode, &m_elf.codeSize),
-                "Failed to retrieve shader");
-    m_shaderCacheEntryState = ShaderEntryState::Ready;
+    if (m_shaderCache->retrieveShader(m_shaderCacheEntry, &m_elf.pCode, &m_elf.codeSize) == Result::Success) {
+      m_shaderCacheEntryState = ShaderEntryState::Ready;
+    } else {
+      return;
+    }
   }
 
   if (!m_cacheEntry.IsEmpty()) {
     m_cacheResult = Result::ErrorUnknown;
     if (elf.pCode) {
       mustSucceed(m_cacheEntry.SetValue(true, elf.pCode, elf.codeSize));
       mustSucceed(m_cacheEntry.GetValueZeroCopy(&m_elf.pCode, &m_elf.codeSize));
     }
     Vkgc::EntryHandle::ReleaseHandle(std::move(m_cacheEntry));
     m_cacheResult = elf.pCode ? Result::Success : Result::ErrorUnknown;
diff --git a/tool/UpdateTestChecks/LICENSE.TXT b/tool/UpdateTestChecks/LICENSE.TXT
new file mode 100644
index 000000000..fa6ac5400
--- /dev/null
+++ b/tool/UpdateTestChecks/LICENSE.TXT
@@ -0,0 +1,279 @@
+==============================================================================
+The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:
+==============================================================================
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+    1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+    2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+    3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+    4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+    5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+    6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+    7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+    8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+    9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+    END OF TERMS AND CONDITIONS
+
+    APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+    Copyright [yyyy] [name of copyright owner]
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+
+---- LLVM Exceptions to the Apache 2.0 License ----
+
+As an exception, if, as a result of your compiling your source code, portions
+of this Software are embedded into an Object form of such source code, you
+may redistribute such embedded portions in such Object form without complying
+with the conditions of Sections 4(a), 4(b) and 4(d) of the License.
+
+In addition, if you combine or link compiled forms of this Software with
+software that is licensed under the GPLv2 ("Combined Software") and if a
+court of competent jurisdiction determines that the patent provision (Section
+3), the indemnity provision (Section 9) or other Section of the License
+conflicts with the conditions of the GPLv2, you may retroactively and
+prospectively choose to deem waived or otherwise exclude such Section(s) of
+the License, but only in their entirety and only with respect to the Combined
+Software.
+
+==============================================================================
+Software from third parties included in the LLVM Project:
+==============================================================================
+The LLVM Project contains third party software which is under different license
+terms. All such code will be identified clearly using at least one of two
+mechanisms:
+1) It will be in a separate directory tree with its own `LICENSE.txt` or
+   `LICENSE` file at the top containing the specific license and restrictions
+   which apply to that software, or
+2) It will contain specific license and restriction terms at the top of every
+   file.
+
+==============================================================================
+Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):
+==============================================================================
+University of Illinois/NCSA
+Open Source License
+
+Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.
+All rights reserved.
+
+Developed by:
+
+    LLVM Team
+
+    University of Illinois at Urbana-Champaign
+
+    http://llvm.org
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal with
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimers.
+
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimers in the
+      documentation and/or other materials provided with the distribution.
+
+    * Neither the names of the LLVM Team, University of Illinois at
+      Urbana-Champaign, nor the names of its contributors may be used to
+      endorse or promote products derived from this Software without specific
+      prior written permission.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
+SOFTWARE.
+
diff --git a/tool/UpdateTestChecks/__init__.py b/tool/UpdateTestChecks/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/tool/UpdateTestChecks/common.py b/tool/UpdateTestChecks/common.py
new file mode 100644
index 000000000..7c96db417
--- /dev/null
+++ b/tool/UpdateTestChecks/common.py
@@ -0,0 +1,1302 @@
+###############################################################################
+# This file is taken from the LLVM Project's
+# llvm/utils/UpdateTestChecks/common.py and has been modified for use in LLPC.
+#
+# The original file is licensed under the Apache License v2.0 with LLVM
+# Exceptions, see LICENSE.txt in this directory.
+###############################################################################
+
+from __future__ import print_function
+
+import argparse
+import copy
+import glob
+import itertools
+import os
+import re
+import subprocess
+import sys
+import shlex
+
+from typing import List
+
+##### Common utilities for update_*test_checks.py
+
+
+_verbose = False
+_prefix_filecheck_ir_name = ''
+
+class Regex(object):
+  """Wrap a compiled regular expression object to allow deep copy of a regexp.
+  This is required for the deep copy done in do_scrub.
+
+  """
+  def __init__(self, regex):
+    self.regex = regex
+
+  def __deepcopy__(self, memo):
+    result = copy.copy(self)
+    result.regex = self.regex
+    return result
+
+  def search(self, line):
+    return self.regex.search(line)
+
+  def sub(self, repl, line):
+    return self.regex.sub(repl, line)
+
+  def pattern(self):
+    return self.regex.pattern
+
+  def flags(self):
+    return self.regex.flags
+
+class Filter(Regex):
+  """Augment a Regex object with a flag indicating whether a match should be
+    added (!is_filter_out) or removed (is_filter_out) from the generated checks.
+
+  """
+  def __init__(self, regex, is_filter_out):
+    super(Filter, self).__init__(regex)
+    self.is_filter_out = is_filter_out
+
+  def __deepcopy__(self, memo):
+    result = copy.deepcopy(super(Filter, self), memo)
+    result.is_filter_out = copy.deepcopy(self.is_filter_out, memo)
+    return result
+
+def parse_commandline_args(parser):
+  class RegexAction(argparse.Action):
+    """Add a regular expression option value to a list of regular expressions.
+    This compiles the expression, wraps it in a Regex and adds it to the option
+    value list."""
+    def __init__(self, option_strings, dest, nargs=None, **kwargs):
+      if nargs is not None:
+        raise ValueError('nargs not allowed')
+      super(RegexAction, self).__init__(option_strings, dest, **kwargs)
+
+    def do_call(self, namespace, values, flags):
+      value_list = getattr(namespace, self.dest)
+      if value_list is None:
+        value_list = []
+
+      try:
+        value_list.append(Regex(re.compile(values, flags)))
+      except re.error as error:
+        raise ValueError('{}: Invalid regular expression \'{}\' ({})'.format(
+          option_string, error.pattern, error.msg))
+
+      setattr(namespace, self.dest, value_list)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+      self.do_call(namespace, values, 0)
+
+  class FilterAction(RegexAction):
+    """Add a filter to a list of filter option values."""
+    def __init__(self, option_strings, dest, nargs=None, **kwargs):
+      super(FilterAction, self).__init__(option_strings, dest, nargs, **kwargs)
+
+    def __call__(self, parser, namespace, values, option_string=None):
+      super(FilterAction, self).__call__(parser, namespace, values, option_string)
+
+      value_list = getattr(namespace, self.dest)
+
+      is_filter_out = ( option_string == '--filter-out' )
+
+      value_list[-1] = Filter(value_list[-1].regex, is_filter_out)
+
+      setattr(namespace, self.dest, value_list)
+
+  filter_group = parser.add_argument_group(
+    'filtering',
+    """Filters are applied to each output line according to the order given. The
+    first matching filter terminates filter processing for that current line.""")
+
+  filter_group.add_argument('--filter', action=FilterAction, dest='filters',
+                            metavar='REGEX',
+                            help='Only include lines matching REGEX (may be specified multiple times)')
+  filter_group.add_argument('--filter-out', action=FilterAction, dest='filters',
+                            metavar='REGEX',
+                            help='Exclude lines matching REGEX')
+
+  parser.add_argument('--include-generated-funcs', action='store_true',
+                      help='Output checks for functions not in source')
+  parser.add_argument('-v', '--verbose', action='store_true',
+                      help='Show verbose output')
+  parser.add_argument('-u', '--update-only', action='store_true',
+                      help='Only update test if it was already autogened')
+  parser.add_argument('--force-update', action='store_true',
+                      help='Update test even if it was autogened by a different script')
+  parser.add_argument('--enable', action='store_true', dest='enabled', default=True,
+                       help='Activate CHECK line generation from this point forward')
+  parser.add_argument('--disable', action='store_false', dest='enabled',
+                      help='Deactivate CHECK line generation from this point forward')
+  parser.add_argument('--replace-value-regex', nargs='+', default=[],
+                      help='List of regular expressions to replace matching value names')
+  parser.add_argument('--prefix-filecheck-ir-name', default='',
+                      help='Add a prefix to FileCheck IR value names to avoid conflicts with scripted names')
+  parser.add_argument('--global-value-regex', nargs='+', default=[],
+                      help='List of regular expressions that a global value declaration must match to generate a check (has no effect if checking globals is not enabled)')
+  parser.add_argument('--global-hex-value-regex', nargs='+', default=[],
+                      help='List of regular expressions such that, for matching global value declarations, literal integer values should be encoded in hex in the associated FileCheck directives')
+  # FIXME: in 3.9, we can use argparse.BooleanOptionalAction. At that point,
+  # we need to rename the flag to just -generate-body-for-unused-prefixes.
+  parser.add_argument('--no-generate-body-for-unused-prefixes',
+                      action='store_false',
+                      dest='gen_unused_prefix_body',
+                      default=True,
+                      help='Generate a function body that always matches for unused prefixes. This is useful when unused prefixes are desired, and it avoids needing to annotate each FileCheck as allowing them.')
+  args = parser.parse_args()
+  global _verbose, _global_value_regex, _global_hex_value_regex
+  _verbose = args.verbose
+  _global_value_regex = args.global_value_regex
+  _global_hex_value_regex = args.global_hex_value_regex
+  return args
+
+
+class InputLineInfo(object):
+  def __init__(self, line, line_number, args, argv):
+    self.line = line
+    self.line_number = line_number
+    self.args = args
+    self.argv = argv
+
+
+class TestInfo(object):
+  def __init__(self, test, parser, script_name, input_lines, args, argv,
+               comment_prefix, argparse_callback):
+    self.parser = parser
+    self.argparse_callback = argparse_callback
+    self.path = test
+    self.args = args
+    if args.prefix_filecheck_ir_name:
+      global _prefix_filecheck_ir_name
+      _prefix_filecheck_ir_name = args.prefix_filecheck_ir_name
+    self.argv = argv
+    self.input_lines = input_lines
+    self.run_lines = find_run_lines(test, self.input_lines)
+    self.comment_prefix = comment_prefix
+    if self.comment_prefix is None:
+      if self.path.endswith('.mir'):
+        self.comment_prefix = '#'
+      else:
+        self.comment_prefix = ';'
+    self.autogenerated_note_prefix = self.comment_prefix + ' ' + UTC_ADVERT
+    self.test_autogenerated_note = self.autogenerated_note_prefix + script_name
+    self.test_autogenerated_note += get_autogennote_suffix(parser, self.args)
+    self.test_unused_note = self.comment_prefix + self.comment_prefix + ' ' + UNUSED_NOTE
+
+  def ro_iterlines(self):
+    for line_num, input_line in enumerate(self.input_lines):
+      args, argv = check_for_command(input_line, self.parser,
+                                     self.args, self.argv, self.argparse_callback)
+      yield InputLineInfo(input_line, line_num, args, argv)
+
+  def iterlines(self, output_lines):
+    output_lines.append(self.test_autogenerated_note)
+    for line_info in self.ro_iterlines():
+      input_line = line_info.line
+      # Discard any previous script advertising.
+      if input_line.startswith(self.autogenerated_note_prefix):
+        continue
+      self.args = line_info.args
+      self.argv = line_info.argv
+      if not self.args.enabled:
+        output_lines.append(input_line)
+        continue
+      yield line_info
+
+  def get_checks_for_unused_prefixes(self, run_list, used_prefixes: List[str]) -> List[str]:
+    unused_prefixes = set(
+        [prefix for sublist in run_list for prefix in sublist[0]]).difference(set(used_prefixes))
+
+    ret = []
+    if not unused_prefixes:
+      return ret
+    ret.append(self.test_unused_note)
+    for unused in sorted(unused_prefixes):
+      ret.append('{comment} {prefix}: {match_everything}'.format(
+        comment=self.comment_prefix,
+        prefix=unused,
+        match_everything=r"""{{.*}}"""
+      ))
+    return ret
+
+def itertests(test_patterns, parser, script_name, comment_prefix=None,
+              comment_prefix_callback=None, argparse_callback=None):
+  assert comment_prefix is None or comment_prefix_callback is None
+  for pattern in test_patterns:
+    # On Windows we must expand the patterns ourselves.
+    tests_list = glob.glob(pattern)
+    if not tests_list:
+      warn("Test file pattern '%s' was not found. Ignoring it." % (pattern,))
+      continue
+    for test in tests_list:
+      with open(test) as f:
+        input_lines = [l.rstrip() for l in f]
+      args = parser.parse_args()
+      if argparse_callback is not None:
+        argparse_callback(args)
+      argv = sys.argv[:]
+      first_line = input_lines[0] if input_lines else ""
+      if UTC_ADVERT in first_line:
+        if script_name not in first_line and not args.force_update:
+          warn("Skipping test which wasn't autogenerated by " + script_name, test)
+          continue
+        args, argv = check_for_command(first_line, parser, args, argv, argparse_callback)
+      elif args.update_only:
+        assert UTC_ADVERT not in first_line
+        warn("Skipping test which isn't autogenerated: " + test)
+        continue
+      final_input_lines = []
+      for l in input_lines:
+        if UNUSED_NOTE in l:
+          break
+        final_input_lines.append(l)
+      if comment_prefix_callback is not None:
+        comment_prefix = comment_prefix_callback(test, final_input_lines)
+      yield TestInfo(test, parser, script_name, final_input_lines, args, argv,
+                     comment_prefix, argparse_callback)
+
+
+def should_add_line_to_output(input_line, prefix_set, skip_global_checks = False, comment_marker = ';'):
+  # Skip any blank comment lines in the IR.
+  if not skip_global_checks and input_line.strip() == comment_marker:
+    return False
+  # Skip a special double comment line we use as a separator.
+  if input_line.strip() == comment_marker + SEPARATOR:
+    return False
+  # Skip any blank lines in the IR.
+  #if input_line.strip() == '':
+  #  return False
+  # And skip any CHECK lines. We're building our own.
+  m = CHECK_RE.match(input_line)
+  if m and m.group(1) in prefix_set:
+    if skip_global_checks:
+      global_ir_value_re = re.compile(r'\[\[', flags=(re.M))
+      return not global_ir_value_re.search(input_line)
+    return False
+
+  return True
+
+# Perform lit-like substitutions
+def getSubstitutions(sourcepath):
+  sourcedir = os.path.dirname(sourcepath)
+  return [('%s', sourcepath),
+          ('%S', sourcedir),
+          ('%p', sourcedir),
+          ('%{pathsep}', os.pathsep)]
+
+def applySubstitutions(s, substitutions):
+  for a,b in substitutions:
+    s = s.replace(a, b)
+  return s
+
+# Invoke the tool that is being tested.
+def invoke_tool(exe, cmd_args, ir, preprocess_cmd=None, verbose=False):
+  with open(ir) as ir_file:
+    substitutions = getSubstitutions(ir)
+
+    # TODO Remove the str form which is used by update_test_checks.py and
+    # update_llc_test_checks.py
+    # The safer list form is used by update_cc_test_checks.py
+    if preprocess_cmd:
+      # Allow pre-processing the IR file (e.g. using sed):
+      assert isinstance(preprocess_cmd, str)  # TODO: use a list instead of using shell
+      preprocess_cmd = applySubstitutions(preprocess_cmd, substitutions).strip()
+      if verbose:
+        print('Pre-processing input file: ', ir, " with command '",
+              preprocess_cmd, "'", sep="", file=sys.stderr)
+      # Python 2.7 doesn't have subprocess.DEVNULL:
+      with open(os.devnull, 'w') as devnull:
+        pp = subprocess.Popen(preprocess_cmd, shell=True, stdin=devnull,
+                              stdout=subprocess.PIPE)
+        ir_file = pp.stdout
+
+    if isinstance(cmd_args, list):
+      args = [applySubstitutions(a, substitutions) for a in cmd_args]
+      stdout = subprocess.check_output([exe] + args, stdin=ir_file)
+    else:
+      stdout = subprocess.check_output(exe + ' ' + applySubstitutions(cmd_args, substitutions),
+                                       shell=True, stdin=ir_file)
+    if sys.version_info[0] > 2:
+      # FYI, if you crashed here with a decode error, your run line probably
+      # results in bitcode or other binary format being written to the pipe.
+      # For an opt test, you probably want to add -S or -disable-output.
+      stdout = stdout.decode()
+  # Fix line endings to unix CR style.
+  return stdout.replace('\r\n', '\n')
+
+# Invoke the tool that is being tested, without any preprocessing and without
+# support for pipes.
+def invoke_tool_only(exe, cmd_args, ir, verbose=False):
+  substitutions = getSubstitutions(ir)
+
+  if isinstance(cmd_args, list):
+    args = [applySubstitutions(a, substitutions) for a in cmd_args]
+    stdout = subprocess.check_output([exe] + args)
+  else:
+    stdout = subprocess.check_output(exe + ' ' + applySubstitutions(cmd_args, substitutions),
+                                    shell=True)
+
+  # FYI, if you crashed here with a decode error, your run line probably
+  # results in bitcode or other binary format being written to the pipe.
+  # For an opt test, you probably want to add -S or -disable-output.
+  stdout = stdout.decode()
+
+  # Fix line endings to unix CR style.
+  return stdout.replace('\r\n', '\n')
+
+##### LLVM IR parser
+RUN_LINE_RE = re.compile(r'^\s*(?://|[;#])\s*RUN:\s*(.*)$')
+CHECK_PREFIX_RE = re.compile(r'--?check-prefix(?:es)?[= ](\S+)')
+PREFIX_RE = re.compile('^[a-zA-Z0-9_-]+$')
+CHECK_RE = re.compile(r'^\s*(?://|[;#])\s*([^:]+?)(?:-NEXT|-NOT|-DAG|-LABEL|-SAME|-EMPTY)?:')
+
+UTC_ARGS_KEY = 'UTC_ARGS:'
+UTC_ARGS_CMD = re.compile(r'.*' + UTC_ARGS_KEY + '\s*(?P<cmd>.*)\s*$')
+UTC_ADVERT = 'NOTE: Assertions have been autogenerated by '
+UNUSED_NOTE = 'NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:'
+
+OPT_FUNCTION_RE = re.compile(
+    r'^(\s*;\s*Function\sAttrs:\s(?P<attrs>[\w\s():,]+?))?\s*define\s+(?:internal\s+)?[^@]*@(?P<func>[\w.$-]+?)\s*'
+    r'(?P<args_and_sig>\((\)|(.*?[\w.-]+?)\))[^{]*\{)\n(?P<body>.*?)^\}$',
+    flags=(re.M | re.S))
+
+ANALYZE_FUNCTION_RE = re.compile(
+    r'^\s*\'(?P<analysis>[\w\s-]+?)\'\s+for\s+function\s+\'(?P<func>[\w.$-]+?)\':'
+    r'\s*\n(?P<body>.*)$',
+    flags=(re.X | re.S))
+
+LV_DEBUG_RE = re.compile(
+    r'^\s*\'(?P<func>[\w.$-]+?)\'[^\n]*'
+    r'\s*\n(?P<body>.*)$',
+    flags=(re.X | re.S))
+
+IR_FUNCTION_RE = re.compile(r'^\s*define\s+(?:internal\s+)?[^@]*@"?([\w.$-]+)"?\s*\(')
+TRIPLE_IR_RE = re.compile(r'^\s*target\s+triple\s*=\s*"([^"]+)"$')
+TRIPLE_ARG_RE = re.compile(r'-mtriple[= ]([^ ]+)')
+MARCH_ARG_RE = re.compile(r'-march[= ]([^ ]+)')
+DEBUG_ONLY_ARG_RE = re.compile(r'-debug-only[= ]([^ ]+)')
+
+SCRUB_LEADING_WHITESPACE_RE = re.compile(r'^(\s+)')
+SCRUB_WHITESPACE_RE = re.compile(r'(?!^(|  \w))[ \t]+', flags=re.M)
+SCRUB_TRAILING_WHITESPACE_RE = re.compile(r'[ \t]+$', flags=re.M)
+SCRUB_TRAILING_WHITESPACE_TEST_RE = SCRUB_TRAILING_WHITESPACE_RE
+SCRUB_TRAILING_WHITESPACE_AND_ATTRIBUTES_RE = re.compile(r'([ \t]|(#[0-9]+))+$', flags=re.M)
+SCRUB_KILL_COMMENT_RE = re.compile(r'^ *#+ +kill:.*\n')
+SCRUB_LOOP_COMMENT_RE = re.compile(
+    r'# =>This Inner Loop Header:.*|# in Loop:.*', flags=re.M)
+SCRUB_TAILING_COMMENT_TOKEN_RE = re.compile(r'(?<=\S)+[ \t]*#$', flags=re.M)
+
+SEPARATOR = '.'
+
+def error(msg, test_file=None):
+  if test_file:
+    msg = '{}: {}'.format(msg, test_file)
+  print('ERROR: {}'.format(msg), file=sys.stderr)
+
+def warn(msg, test_file=None):
+  if test_file:
+    msg = '{}: {}'.format(msg, test_file)
+  print('WARNING: {}'.format(msg), file=sys.stderr)
+
+def debug(*args, **kwargs):
+  # Python2 does not allow def debug(*args, file=sys.stderr, **kwargs):
+  if 'file' not in kwargs:
+    kwargs['file'] = sys.stderr
+  if _verbose:
+    print(*args, **kwargs)
+
+def find_run_lines(test, lines):
+  debug('Scanning for RUN lines in test file:', test)
+  raw_lines = [m.group(1)
+               for m in [RUN_LINE_RE.match(l) for l in lines] if m]
+  run_lines = [raw_lines[0]] if len(raw_lines) > 0 else []
+  for l in raw_lines[1:]:
+    if run_lines[-1].endswith('\\'):
+      run_lines[-1] = run_lines[-1].rstrip('\\') + ' ' + l
+    else:
+      run_lines.append(l)
+  debug('Found {} RUN lines in {}:'.format(len(run_lines), test))
+  for l in run_lines:
+    debug('  RUN: {}'.format(l))
+  return run_lines
+
+def get_triple_from_march(march):
+  triples = {
+      'amdgcn': 'amdgcn',
+      'r600': 'r600',
+      'mips': 'mips',
+      'sparc': 'sparc',
+      'hexagon': 'hexagon',
+      've': 've',
+  }
+  for prefix, triple in triples.items():
+    if march.startswith(prefix):
+      return triple
+  print("Cannot find a triple. Assume 'x86'", file=sys.stderr)
+  return 'x86'
+
+def apply_filters(line, filters):
+  has_filter = False
+  for f in filters:
+    if not f.is_filter_out:
+      has_filter = True
+    if f.search(line):
+      return False if f.is_filter_out else True
+  # If we only used filter-out, keep the line, otherwise discard it since no
+  # filter matched.
+  return False if has_filter else True
+
+def do_filter(body, filters):
+  return body if not filters else '\n'.join(filter(
+    lambda line: apply_filters(line, filters), body.splitlines()))
+
+def scrub_body(body):
+  # Scrub runs of whitespace out of the assembly, but leave the leading
+  # whitespace in place.
+  body = SCRUB_WHITESPACE_RE.sub(r' ', body)
+  # Expand the tabs used for indentation.
+  body = str.expandtabs(body, 2)
+  # Strip trailing whitespace.
+  body = SCRUB_TRAILING_WHITESPACE_TEST_RE.sub(r'', body)
+  return body
+
+def do_scrub(body, scrubber, scrubber_args, extra):
+  if scrubber_args:
+    local_args = copy.deepcopy(scrubber_args)
+    local_args[0].extra_scrub = extra
+    return scrubber(body, *local_args)
+  return scrubber(body, *scrubber_args)
+
+# Build up a dictionary of all the function bodies.
+class function_body(object):
+  def __init__(self, string, extra, args_and_sig, attrs, func_name_separator):
+    self.scrub = string
+    self.extrascrub = extra
+    self.args_and_sig = args_and_sig
+    self.attrs = attrs
+    self.func_name_separator = func_name_separator
+  def is_same_except_arg_names(self, extrascrub, args_and_sig, attrs, is_backend):
+    arg_names = set()
+    def drop_arg_names(match):
+      arg_names.add(match.group(variable_group_in_ir_value_match))
+      if match.group(attribute_group_in_ir_value_match):
+        attr = match.group(attribute_group_in_ir_value_match)
+      else:
+        attr = ''
+      return match.group(1) + attr + match.group(match.lastindex)
+    def repl_arg_names(match):
+      if match.group(variable_group_in_ir_value_match) is not None and match.group(variable_group_in_ir_value_match) in arg_names:
+        return match.group(1) + match.group(match.lastindex)
+      return match.group(1) + match.group(2) + match.group(match.lastindex)
+    if self.attrs != attrs:
+      return False
+    ans0 = IR_VALUE_RE.sub(drop_arg_names, self.args_and_sig)
+    ans1 = IR_VALUE_RE.sub(drop_arg_names, args_and_sig)
+    if ans0 != ans1:
+      return False
+    if is_backend:
+      # Check without replacements, the replacements are not applied to the
+      # body for backend checks.
+      return self.extrascrub == extrascrub
+
+    es0 = IR_VALUE_RE.sub(repl_arg_names, self.extrascrub)
+    es1 = IR_VALUE_RE.sub(repl_arg_names, extrascrub)
+    es0 = SCRUB_IR_COMMENT_RE.sub(r'', es0)
+    es1 = SCRUB_IR_COMMENT_RE.sub(r'', es1)
+    return es0 == es1
+
+  def __str__(self):
+    return self.scrub
+
+class FunctionTestBuilder:
+  def __init__(self, run_list, flags, scrubber_args, path):
+    self._verbose = flags.verbose
+    self._record_args = flags.function_signature
+    self._check_attributes = flags.check_attributes
+    # Strip double-quotes if input was read by UTC_ARGS
+    self._filters = list(map(lambda f: Filter(re.compile(f.pattern().strip('"'),
+                                                         f.flags()),
+                                              f.is_filter_out),
+                             flags.filters)) if flags.filters else []
+    self._scrubber_args = scrubber_args
+    self._path = path
+    # Strip double-quotes if input was read by UTC_ARGS
+    self._replace_value_regex = list(map(lambda x: x.strip('"'), flags.replace_value_regex))
+    self._func_dict = {}
+    self._func_order = {}
+    self._global_var_dict = {}
+    self._processed_prefixes = set()
+    for tuple in run_list:
+      for prefix in tuple[0]:
+        self._func_dict.update({prefix:dict()})
+        self._func_order.update({prefix: []})
+        self._global_var_dict.update({prefix:dict()})
+
+  def finish_and_get_func_dict(self):
+    for prefix in self.get_failed_prefixes():
+      warn('Prefix %s had conflicting output from different RUN lines for all functions in test %s' % (prefix,self._path,))
+    return self._func_dict
+
+  def func_order(self):
+    return self._func_order
+
+  def global_var_dict(self):
+    return self._global_var_dict
+
+  def is_filtered(self):
+    return bool(self._filters)
+
+  def process_run_line(self, function_re, scrubber, raw_tool_output, prefixes, is_backend):
+    build_global_values_dictionary(self._global_var_dict, raw_tool_output, prefixes)
+    for m in function_re.finditer(raw_tool_output):
+      if not m:
+        continue
+      func = m.group('func')
+      body = m.group('body')
+      # func_name_separator is the string that is placed right after function name at the
+      # beginning of assembly function definition. In most assemblies, that is just a
+      # colon: `foo:`. But, for example, in nvptx it is a brace: `foo(`. If is_backend is
+      # False, just assume that separator is an empty string.
+      if is_backend:
+        # Use ':' as default separator.
+        func_name_separator = m.group('func_name_separator') if 'func_name_separator' in m.groupdict() else ':'
+      else:
+        func_name_separator = ''
+      attrs = m.group('attrs') if self._check_attributes else ''
+      # Determine if we print arguments, the opening brace, or nothing after the
+      # function name
+      if self._record_args and 'args_and_sig' in m.groupdict():
+        args_and_sig = scrub_body(m.group('args_and_sig').strip())
+      elif 'args_and_sig' in m.groupdict():
+        args_and_sig = '('
+      else:
+        args_and_sig = ''
+      filtered_body = do_filter(body, self._filters)
+      scrubbed_body = do_scrub(filtered_body, scrubber, self._scrubber_args,
+                               extra=False)
+      scrubbed_extra = do_scrub(filtered_body, scrubber, self._scrubber_args,
+                                extra=True)
+      if 'analysis' in m.groupdict():
+        analysis = m.group('analysis')
+        if analysis.lower() != 'cost model analysis':
+          warn('Unsupported analysis mode: %r!' % (analysis,))
+      if func.startswith('stress'):
+        # We only use the last line of the function body for stress tests.
+        scrubbed_body = '\n'.join(scrubbed_body.splitlines()[-1:])
+      if self._verbose:
+        print('Processing function: ' + func, file=sys.stderr)
+        for l in scrubbed_body.splitlines():
+          print('  ' + l, file=sys.stderr)
+      for prefix in prefixes:
+        # Replace function names matching the regex.
+        for regex in self._replace_value_regex:
+          # Pattern that matches capture groups in the regex in leftmost order.
+          group_regex = re.compile(r'\(.*?\)')
+          # Replace function name with regex.
+          match = re.match(regex, func)
+          if match:
+            func_repl = regex
+            # Replace any capture groups with their matched strings.
+            for g in match.groups():
+              func_repl = group_regex.sub(re.escape(g), func_repl, count=1)
+            func = re.sub(func_repl, '{{' + func_repl + '}}', func)
+
+          # Replace all calls to regex matching functions.
+          matches = re.finditer(regex, scrubbed_body)
+          for match in matches:
+            func_repl = regex
+            # Replace any capture groups with their matched strings.
+            for g in match.groups():
+              func_repl = group_regex.sub(re.escape(g), func_repl, count=1)
+            # Substitute function call names that match the regex with the same
+            # capture groups set.
+            scrubbed_body = re.sub(func_repl, '{{' + func_repl + '}}',
+                                   scrubbed_body)
+
+        if func in self._func_dict[prefix]:
+          if (self._func_dict[prefix][func] is not None and
+              (str(self._func_dict[prefix][func]) != scrubbed_body or
+               self._func_dict[prefix][func].args_and_sig != args_and_sig or
+               self._func_dict[prefix][func].attrs != attrs)):
+            if self._func_dict[prefix][func].is_same_except_arg_names(
+                scrubbed_extra,
+                args_and_sig,
+                attrs,
+                is_backend):
+              self._func_dict[prefix][func].scrub = scrubbed_extra
+              self._func_dict[prefix][func].args_and_sig = args_and_sig
+            else:
+              # This means a previous RUN line produced a body for this function
+              # that is different from the one produced by this current RUN line,
+              # so the body can't be common across RUN lines. We use None to
+              # indicate that.
+              self._func_dict[prefix][func] = None
+        else:
+          if prefix not in self._processed_prefixes:
+            self._func_dict[prefix][func] = function_body(
+                scrubbed_body, scrubbed_extra, args_and_sig, attrs,
+                func_name_separator)
+            self._func_order[prefix].append(func)
+          else:
+            # An earlier RUN line used this check prefixes but didn't produce
+            # a body for this function. This happens in Clang tests that use
+            # preprocesser directives to exclude individual functions from some
+            # RUN lines.
+            self._func_dict[prefix][func] = None
+
+  def processed_prefixes(self, prefixes):
+    """
+    Mark a set of prefixes as having had at least one applicable RUN line fully
+    processed. This is used to filter out function bodies that don't have
+    outputs for all RUN lines.
+    """
+    self._processed_prefixes.update(prefixes)
+
+  def get_failed_prefixes(self):
+    # This returns the list of those prefixes that failed to match any function,
+    # because there were conflicting bodies produced by different RUN lines, in
+    # all instances of the prefix.
+    for prefix in self._func_dict:
+      if (self._func_dict[prefix] and
+          (not [fct for fct in self._func_dict[prefix]
+                if self._func_dict[prefix][fct] is not None])):
+        yield prefix
+
+
+##### Generator of LLVM IR CHECK lines
+
+SCRUB_IR_COMMENT_RE = re.compile(r'\s*;.*')
+
+# TODO: We should also derive check lines for global, debug, loop declarations, etc..
+
+class NamelessValue:
+  def __init__(self, check_prefix, check_key, ir_prefix, global_ir_prefix, global_ir_prefix_regexp,
+               ir_regexp, global_ir_rhs_regexp, is_before_functions, *,
+               is_number=False, replace_number_with_counter=False):
+    self.check_prefix = check_prefix
+    self.check_key = check_key
+    self.ir_prefix = ir_prefix
+    self.global_ir_prefix = global_ir_prefix
+    self.global_ir_prefix_regexp = global_ir_prefix_regexp
+    self.ir_regexp = ir_regexp
+    self.global_ir_rhs_regexp = global_ir_rhs_regexp
+    self.is_before_functions = is_before_functions
+    self.is_number = is_number
+    # Some variable numbers (e.g. MCINST1234) will change based on unrelated
+    # modifications to LLVM, replace those with an incrementing counter.
+    self.replace_number_with_counter = replace_number_with_counter
+    self.variable_mapping = {}
+
+  # Return true if this kind of IR value is "local", basically if it matches '%{{.*}}'.
+  def is_local_def_ir_value_match(self, match):
+    return self.ir_prefix == '%'
+
+  # Return true if this kind of IR value is "global", basically if it matches '#{{.*}}'.
+  def is_global_scope_ir_value_match(self, match):
+    return self.global_ir_prefix is not None
+
+  # Return the IR prefix and check prefix we use for this kind or IR value,
+  # e.g., (%, TMP) for locals.
+  def get_ir_prefix_from_ir_value_match(self, match):
+    if self.ir_prefix and match.group(0).strip().startswith(self.ir_prefix):
+      return self.ir_prefix, self.check_prefix
+    return self.global_ir_prefix, self.check_prefix
+
+  # Return the IR regexp we use for this kind or IR value, e.g., [\w.-]+? for locals
+  def get_ir_regex_from_ir_value_re_match(self, match):
+    # for backwards compatibility we check locals with '.*'
+    if self.is_local_def_ir_value_match(match):
+      return '.*'
+    if self.ir_prefix and match.group(0).strip().startswith(self.ir_prefix):
+      return self.ir_regexp
+    return self.global_ir_prefix_regexp
+
+  # Create a FileCheck variable name based on an IR name.
+  def get_value_name(self, var: str, check_prefix: str):
+    var = var.replace('!', '')
+    if self.replace_number_with_counter:
+      assert var.isdigit(), var
+      replacement = self.variable_mapping.get(var, None)
+      if replacement is None:
+        # Replace variable with an incrementing counter
+        replacement = str(len(self.variable_mapping) + 1)
+        self.variable_mapping[var] = replacement
+      var = replacement
+    # This is a nameless value, prepend check_prefix.
+    if var.isdigit():
+      var = check_prefix + var
+    else:
+      # This is a named value that clashes with the check_prefix, prepend with
+      # _prefix_filecheck_ir_name, if it has been defined.
+      if may_clash_with_default_check_prefix_name(check_prefix, var) and _prefix_filecheck_ir_name:
+        var = _prefix_filecheck_ir_name + var
+    var = var.replace('.', '_')
+    var = var.replace('-', '_')
+    return var.upper()
+
+  # Create a FileCheck variable from regex.
+  def get_value_definition(self, var, match):
+    # for backwards compatibility we check locals with '.*'
+    varname = self.get_value_name(var, self.check_prefix)
+    prefix = self.get_ir_prefix_from_ir_value_match(match)[0]
+    if self.is_number:
+      regex = ''  # always capture a number in the default format
+      capture_start = '[[#'
+    else:
+      regex = self.get_ir_regex_from_ir_value_re_match(match)
+      capture_start = '[['
+    if self.is_local_def_ir_value_match(match):
+      return capture_start + varname + ':' + prefix + regex + ']]'
+    return prefix + capture_start + varname + ':' + regex + ']]'
+
+  # Use a FileCheck variable.
+  def get_value_use(self, var, match, var_prefix=None):
+    if var_prefix is None:
+      var_prefix = self.check_prefix
+    capture_start = '[[#' if self.is_number else '[['
+    if self.is_local_def_ir_value_match(match):
+      return capture_start + self.get_value_name(var, var_prefix) + ']]'
+    prefix = self.get_ir_prefix_from_ir_value_match(match)[0]
+    return prefix + capture_start + self.get_value_name(var, var_prefix) + ']]'
+
+# Description of the different "unnamed" values we match in the IR, e.g.,
+# (local) ssa values, (debug) metadata, etc.
+ir_nameless_values = [
+    NamelessValue(r'TMP'     , '%' , r'%'                   , None            , None                   , r'[\w$.-]+?' , None                 , False) ,
+    NamelessValue(r'ATTR'    , '#' , r'#'                   , None            , None                   , r'[0-9]+'    , None                 , False) ,
+    NamelessValue(r'ATTR'    , '#' , None                   , r'attributes #' , r'[0-9]+'              , None         , r'{[^}]*}'           , False) ,
+    NamelessValue(r'GLOB'    , '@' , r'@'                   , None            , None                   , r'[0-9]+'    , None                 , False) ,
+    NamelessValue(r'GLOB'    , '@' , None                   , r'@'            , r'[a-zA-Z0-9_$"\\.-]+' , None         , r'.+'                , True)  ,
+    NamelessValue(r'DBG'     , '!' , r'!dbg '               , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'PROF'    , '!' , r'!prof '              , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'TBAA'    , '!' , r'!tbaa '              , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'RNG'     , '!' , r'!range '             , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'LOOP'    , '!' , r'!llvm.loop '         , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'META'    , '!' , r'metadata '           , None            , None                   , r'![0-9]+'   , None                 , False) ,
+    NamelessValue(r'META'    , '!' , None                   , r''             , r'![0-9]+'             , None         , r'(?:distinct |)!.*' , False) ,
+    NamelessValue(r'ACC_GRP' , '!' , r'!llvm.access.group ' , None            , None                   , r'![0-9]+'   , None                 , False) ,
+]
+
+asm_nameless_values = [
+ NamelessValue(r'MCINST', 'Inst#', None, '<MCInst #', r'\d+', None, r'.+',
+               False, is_number=True, replace_number_with_counter=True),
+ NamelessValue(r'MCREG',  'Reg:', None, '<MCOperand Reg:', r'\d+', None, r'.+',
+               False, is_number=True, replace_number_with_counter=True),
+]
+
+def createOrRegexp(old, new):
+  if not old:
+    return new
+  if not new:
+    return old
+  return old + '|' + new
+
+def createPrefixMatch(prefix_str, prefix_re):
+  if prefix_str is None or prefix_re is None:
+    return ''
+  return '(?:' + prefix_str + '(' + prefix_re + '))'
+
+# Build the regexp that matches an "IR value". This can be a local variable,
+# argument, global, or metadata, anything that is "named". It is important that
+# the PREFIX and SUFFIX below only contain a single group, if that changes
+# other locations will need adjustment as well.
+IR_VALUE_REGEXP_PREFIX = r'(\s*)'
+IR_VALUE_REGEXP_STRING = r''
+for nameless_value in ir_nameless_values:
+  lcl_match = createPrefixMatch(nameless_value.ir_prefix, nameless_value.ir_regexp)
+  glb_match = createPrefixMatch(nameless_value.global_ir_prefix, nameless_value.global_ir_prefix_regexp)
+  assert((lcl_match or glb_match) and not (lcl_match and glb_match))
+  if lcl_match:
+    IR_VALUE_REGEXP_STRING = createOrRegexp(IR_VALUE_REGEXP_STRING, lcl_match)
+  elif glb_match:
+    IR_VALUE_REGEXP_STRING = createOrRegexp(IR_VALUE_REGEXP_STRING, '^' + glb_match)
+IR_VALUE_REGEXP_SUFFIX = r'([,\s\(\)]|\Z)'
+IR_VALUE_RE = re.compile(IR_VALUE_REGEXP_PREFIX + r'(' + IR_VALUE_REGEXP_STRING + r')' + IR_VALUE_REGEXP_SUFFIX)
+
+# Build the regexp that matches an "ASM value" (currently only for --asm-show-inst comments).
+ASM_VALUE_REGEXP_STRING = ''
+for nameless_value in asm_nameless_values:
+  glb_match = createPrefixMatch(nameless_value.global_ir_prefix, nameless_value.global_ir_prefix_regexp)
+  assert not nameless_value.ir_prefix and not nameless_value.ir_regexp
+  ASM_VALUE_REGEXP_STRING = createOrRegexp(ASM_VALUE_REGEXP_STRING, glb_match)
+ASM_VALUE_REGEXP_SUFFIX = r'([>\s]|\Z)'
+ASM_VALUE_RE = re.compile(r'((?:#|//)\s*)' + '(' + ASM_VALUE_REGEXP_STRING + ')' + ASM_VALUE_REGEXP_SUFFIX)
+
+# The entire match is group 0, the prefix has one group (=1), the entire
+# IR_VALUE_REGEXP_STRING is one group (=2), and then the nameless values start.
+first_nameless_group_in_ir_value_match = 3
+
+# constants for the group id of special matches
+variable_group_in_ir_value_match = 3
+attribute_group_in_ir_value_match = 4
+
+# Check a match for IR_VALUE_RE and inspect it to determine if it was a local
+# value, %..., global @..., debug number !dbg !..., etc. See the PREFIXES above.
+def get_idx_from_ir_value_match(match):
+  for i in range(first_nameless_group_in_ir_value_match, match.lastindex):
+    if match.group(i) is not None:
+      return i - first_nameless_group_in_ir_value_match
+  error("Unable to identify the kind of IR value from the match!")
+  return 0
+
+# See get_idx_from_ir_value_match
+def get_name_from_ir_value_match(match):
+  return match.group(get_idx_from_ir_value_match(match) + first_nameless_group_in_ir_value_match)
+
+def get_nameless_value_from_match(match, nameless_values) -> NamelessValue:
+  return nameless_values[get_idx_from_ir_value_match(match)]
+
+# Return true if var clashes with the scripted FileCheck check_prefix.
+def may_clash_with_default_check_prefix_name(check_prefix, var):
+  return check_prefix and re.match(r'^' + check_prefix + r'[0-9]+?$', var, re.IGNORECASE)
+
+def generalize_check_lines_common(lines, is_analyze, vars_seen,
+                                  global_vars_seen, nameless_values,
+                                  nameless_value_regex, is_asm):
+  # This gets called for each match that occurs in
+  # a line. We transform variables we haven't seen
+  # into defs, and variables we have seen into uses.
+  def transform_line_vars(match):
+    var = get_name_from_ir_value_match(match)
+    nameless_value = get_nameless_value_from_match(match, nameless_values)
+    if may_clash_with_default_check_prefix_name(nameless_value.check_prefix, var):
+      warn("Change IR value name '%s' or use --prefix-filecheck-ir-name to prevent possible conflict"
+           " with scripted FileCheck name." % (var,))
+    key = (var, nameless_value.check_key)
+    is_local_def = nameless_value.is_local_def_ir_value_match(match)
+    if is_local_def and key in vars_seen:
+      rv = nameless_value.get_value_use(var, match)
+    elif not is_local_def and key in global_vars_seen:
+      # We could have seen a different prefix for the global variables first,
+      # ensure we use that one instead of the prefix for the current match.
+      rv = nameless_value.get_value_use(var, match, global_vars_seen[key])
+    else:
+      if is_local_def:
+        vars_seen.add(key)
+      else:
+        global_vars_seen[key] = nameless_value.check_prefix
+      rv = nameless_value.get_value_definition(var, match)
+    # re.sub replaces the entire regex match
+    # with whatever you return, so we have
+    # to make sure to hand it back everything
+    # including the commas and spaces.
+    return match.group(1) + rv + match.group(match.lastindex)
+
+  lines_with_def = []
+
+  for i, line in enumerate(lines):
+    if not is_asm:
+      # An IR variable named '%.' matches the FileCheck regex string.
+      line = line.replace('%.', '%dot')
+      for regex in _global_hex_value_regex:
+        if re.match('^@' + regex + ' = ', line):
+          line = re.sub(r'\bi([0-9]+) ([0-9]+)',
+              lambda m : 'i' + m.group(1) + ' [[#' + hex(int(m.group(2))) + ']]',
+              line)
+          break
+      # Ignore any comments, since the check lines will too.
+      scrubbed_line = SCRUB_IR_COMMENT_RE.sub(r'', line)
+      lines[i] = scrubbed_line
+    if is_asm or not is_analyze:
+      # It can happen that two matches are back-to-back and for some reason sub
+      # will not replace both of them. For now we work around this by
+      # substituting until there is no more match.
+      changed = True
+      while changed:
+        (lines[i], changed) = nameless_value_regex.subn(transform_line_vars,
+                                                        lines[i], count=1)
+  return lines
+
+# Replace IR value defs and uses with FileCheck variables.
+def generalize_check_lines(lines, is_analyze, vars_seen, global_vars_seen):
+  return generalize_check_lines_common(lines, is_analyze, vars_seen,
+                                       global_vars_seen, ir_nameless_values,
+                                       IR_VALUE_RE, False)
+
+def generalize_asm_check_lines(lines, vars_seen, global_vars_seen):
+  return generalize_check_lines_common(lines, False, vars_seen,
+                                       global_vars_seen, asm_nameless_values,
+                                       ASM_VALUE_RE, True)
+
+def add_checks(output_lines, comment_marker, prefix_list, func_dict, func_name, check_label_format, is_backend, is_analyze, global_vars_seen_dict, is_filtered):
+  # prefix_exclusions are prefixes we cannot use to print the function because it doesn't exist in run lines that use these prefixes as well.
+  prefix_exclusions = set()
+  printed_prefixes = []
+  for p in prefix_list:
+    checkprefixes = p[0]
+    # If not all checkprefixes of this run line produced the function we cannot check for it as it does not
+    # exist for this run line. A subset of the check prefixes might know about the function but only because
+    # other run lines created it.
+    if any(map(lambda checkprefix: func_name not in func_dict[checkprefix], checkprefixes)):
+      prefix_exclusions |= set(checkprefixes)
+      continue
+
+  # prefix_exclusions is constructed, we can now emit the output
+  for p in prefix_list:
+    global_vars_seen = {}
+    checkprefixes = p[0]
+    for checkprefix in checkprefixes:
+      if checkprefix in global_vars_seen_dict:
+        global_vars_seen.update(global_vars_seen_dict[checkprefix])
+      else:
+        global_vars_seen_dict[checkprefix] = {}
+      if checkprefix in printed_prefixes:
+        break
+
+      # Check if the prefix is excluded.
+      if checkprefix in prefix_exclusions:
+        continue
+
+      # If we do not have output for this prefix we skip it.
+      if not func_dict[checkprefix][func_name]:
+        continue
+
+      # Add some space between different check prefixes, but not after the last
+      # check line (before the test code).
+      if is_backend:
+        if len(printed_prefixes) != 0:
+          output_lines.append(comment_marker)
+
+      if checkprefix not in global_vars_seen_dict:
+        global_vars_seen_dict[checkprefix] = {}
+
+      global_vars_seen_before = [key for key in global_vars_seen.keys()]
+
+      vars_seen = set()
+      printed_prefixes.append(checkprefix)
+      attrs = str(func_dict[checkprefix][func_name].attrs)
+      attrs = '' if attrs == 'None' else attrs
+      if attrs:
+        output_lines.append('%s %s: Function Attrs: %s' % (comment_marker, checkprefix, attrs))
+      args_and_sig = str(func_dict[checkprefix][func_name].args_and_sig)
+      if args_and_sig:
+        args_and_sig = generalize_check_lines([args_and_sig], is_analyze, vars_seen, global_vars_seen)[0]
+      func_name_separator = func_dict[checkprefix][func_name].func_name_separator
+      if '[[' in args_and_sig:
+        output_lines.append(check_label_format % (checkprefix, func_name, '', func_name_separator))
+        output_lines.append('%s %s-SAME: %s' % (comment_marker, checkprefix, args_and_sig))
+      else:
+        output_lines.append(check_label_format % (checkprefix, func_name, args_and_sig, func_name_separator))
+      func_body = str(func_dict[checkprefix][func_name]).splitlines()
+      if not func_body:
+        # We have filtered everything.
+        continue
+
+      # For ASM output, just emit the check lines.
+      if is_backend:
+        body_start = 1
+        if is_filtered:
+          # For filtered output we don't add "-NEXT" so don't add extra spaces
+          # before the first line.
+          body_start = 0
+        else:
+          output_lines.append('%s %s:       %s' % (comment_marker, checkprefix, func_body[0]))
+        func_lines = generalize_asm_check_lines(func_body[body_start:],
+                                                vars_seen, global_vars_seen)
+        for func_line in func_lines:
+          if func_line.strip() == '':
+            output_lines.append('%s %s-EMPTY:' % (comment_marker, checkprefix))
+          else:
+            check_suffix = '-NEXT' if not is_filtered else ''
+            output_lines.append('%s %s%s:  %s' % (comment_marker, checkprefix,
+                                                  check_suffix, func_line))
+        # Remember new global variables we have not seen before
+        for key in global_vars_seen:
+          if key not in global_vars_seen_before:
+            global_vars_seen_dict[checkprefix][key] = global_vars_seen[key]
+        break
+
+      # For IR output, change all defs to FileCheck variables, so we're immune
+      # to variable naming fashions.
+      func_body = generalize_check_lines(func_body, is_analyze, vars_seen, global_vars_seen)
+
+      # This could be selectively enabled with an optional invocation argument.
+      # Disabled for now: better to check everything. Be safe rather than sorry.
+
+      # Handle the first line of the function body as a special case because
+      # it's often just noise (a useless asm comment or entry label).
+      #if func_body[0].startswith("#") or func_body[0].startswith("entry:"):
+      #  is_blank_line = True
+      #else:
+      #  output_lines.append('%s %s:       %s' % (comment_marker, checkprefix, func_body[0]))
+      #  is_blank_line = False
+
+      is_blank_line = False
+
+      for func_line in func_body:
+        if func_line.strip() == '':
+          is_blank_line = True
+          continue
+        # Do not waste time checking IR comments.
+        func_line = SCRUB_IR_COMMENT_RE.sub(r'', func_line)
+
+        # Skip blank lines instead of checking them.
+        if is_blank_line:
+          output_lines.append('{} {}:       {}'.format(
+              comment_marker, checkprefix, func_line))
+        else:
+          check_suffix = '-NEXT' if not is_filtered else ''
+          output_lines.append('{} {}{}:  {}'.format(
+              comment_marker, checkprefix, check_suffix, func_line))
+        is_blank_line = False
+
+      # Add space between different check prefixes and also before the first
+      # line of code in the test function.
+      output_lines.append(comment_marker)
+
+      # Remember new global variables we have not seen before
+      for key in global_vars_seen:
+        if key not in global_vars_seen_before:
+          global_vars_seen_dict[checkprefix][key] = global_vars_seen[key]
+      break
+  return printed_prefixes
+
+def add_ir_checks(output_lines, comment_marker, prefix_list, func_dict,
+                  func_name, preserve_names, function_sig,
+                  global_vars_seen_dict, is_filtered):
+  # Label format is based on IR string.
+  function_def_regex = 'define {{[^@]+}}' if function_sig else ''
+  check_label_format = '{} %s-LABEL: {}@%s%s%s'.format(comment_marker, function_def_regex)
+  return add_checks(output_lines, comment_marker, prefix_list, func_dict, func_name,
+                    check_label_format, False, preserve_names, global_vars_seen_dict,
+                    is_filtered)
+
+def add_analyze_checks(output_lines, comment_marker, prefix_list, func_dict, func_name, is_filtered):
+  check_label_format = '{} %s-LABEL: \'%s%s%s\''.format(comment_marker)
+  global_vars_seen_dict = {}
+  return add_checks(output_lines, comment_marker, prefix_list, func_dict, func_name,
+                    check_label_format, False, True, global_vars_seen_dict,
+                    is_filtered)
+
+def build_global_values_dictionary(glob_val_dict, raw_tool_output, prefixes):
+  for nameless_value in itertools.chain(ir_nameless_values, asm_nameless_values):
+    if nameless_value.global_ir_prefix is None:
+      continue
+
+    lhs_re_str = nameless_value.global_ir_prefix + nameless_value.global_ir_prefix_regexp
+    rhs_re_str = nameless_value.global_ir_rhs_regexp
+
+    global_ir_value_re_str = r'^' + lhs_re_str + r'\s=\s' + rhs_re_str + r'$'
+    global_ir_value_re = re.compile(global_ir_value_re_str, flags=(re.M))
+    lines = []
+    for m in global_ir_value_re.finditer(raw_tool_output):
+      lines.append(m.group(0))
+
+    for prefix in prefixes:
+      if glob_val_dict[prefix] is None:
+        continue
+      if nameless_value.check_prefix in glob_val_dict[prefix]:
+        if lines == glob_val_dict[prefix][nameless_value.check_prefix]:
+          continue
+        if prefix == prefixes[-1]:
+          warn('Found conflicting asm under the same prefix: %r!' % (prefix,))
+        else:
+          glob_val_dict[prefix][nameless_value.check_prefix] = None
+          continue
+      glob_val_dict[prefix][nameless_value.check_prefix] = lines
+
+def add_global_checks(glob_val_dict, comment_marker, prefix_list, output_lines, global_vars_seen_dict, is_analyze, is_before_functions):
+  printed_prefixes = set()
+  for nameless_value in ir_nameless_values:
+    if nameless_value.global_ir_prefix is None:
+      continue
+    if nameless_value.is_before_functions != is_before_functions:
+      continue
+    for p in prefix_list:
+      global_vars_seen = {}
+      checkprefixes = p[0]
+      if checkprefixes is None:
+        continue
+      for checkprefix in checkprefixes:
+        if checkprefix in global_vars_seen_dict:
+          global_vars_seen.update(global_vars_seen_dict[checkprefix])
+        else:
+          global_vars_seen_dict[checkprefix] = {}
+        if (checkprefix, nameless_value.check_prefix) in printed_prefixes:
+          break
+        if not glob_val_dict[checkprefix]:
+          continue
+        if nameless_value.check_prefix not in glob_val_dict[checkprefix]:
+          continue
+        if not glob_val_dict[checkprefix][nameless_value.check_prefix]:
+          continue
+
+        check_lines = []
+        global_vars_seen_before = [key for key in global_vars_seen.keys()]
+        for line in glob_val_dict[checkprefix][nameless_value.check_prefix]:
+          if _global_value_regex:
+            matched = False
+            for regex in _global_value_regex:
+              if re.match('^@' + regex + ' = ', line):
+                matched = True
+                break
+            if not matched:
+              continue
+          tmp = generalize_check_lines([line], is_analyze, set(), global_vars_seen)
+          check_line = '%s %s: %s' % (comment_marker, checkprefix, tmp[0])
+          check_lines.append(check_line)
+        if not check_lines:
+          continue
+
+        output_lines.append(comment_marker + SEPARATOR)
+        for check_line in check_lines:
+          output_lines.append(check_line)
+
+        printed_prefixes.add((checkprefix, nameless_value.check_prefix))
+
+        # Remembe new global variables we have not seen before
+        for key in global_vars_seen:
+          if key not in global_vars_seen_before:
+            global_vars_seen_dict[checkprefix][key] = global_vars_seen[key]
+        break
+
+  if printed_prefixes:
+    output_lines.append(comment_marker + SEPARATOR)
+
+
+def check_prefix(prefix):
+  if not PREFIX_RE.match(prefix):
+    hint = ""
+    if ',' in prefix:
+      hint = " Did you mean '--check-prefixes=" + prefix + "'?"
+    warn(("Supplied prefix '%s' is invalid. Prefix must contain only alphanumeric characters, hyphens and underscores." + hint) %
+         (prefix))
+
+
+def verify_filecheck_prefixes(fc_cmd):
+  fc_cmd_parts = fc_cmd.split()
+  for part in fc_cmd_parts:
+    if "check-prefix=" in part:
+      prefix = part.split('=', 1)[1]
+      check_prefix(prefix)
+    elif "check-prefixes=" in part:
+      prefixes = part.split('=', 1)[1].split(',')
+      for prefix in prefixes:
+        check_prefix(prefix)
+        if prefixes.count(prefix) > 1:
+          warn("Supplied prefix '%s' is not unique in the prefix list." % (prefix,))
+
+
+def get_autogennote_suffix(parser, args):
+  autogenerated_note_args = ''
+  for action in parser._actions:
+    if not hasattr(args, action.dest):
+      continue  # Ignore options such as --help that aren't included in args
+    # Ignore parameters such as paths to the binary or the list of tests
+    if action.dest in ('tests', 'update_only', 'tool_binary', 'opt_binary',
+                       'llc_binary', 'clang', 'opt', 'llvm_bin', 'verbose'):
+      continue
+    value = getattr(args, action.dest)
+    if action.const is not None:  # action stores a constant (usually True/False)
+      # Skip actions with different constant values (this happens with boolean
+      # --foo/--no-foo options)
+      if value != action.const:
+        continue
+    if parser.get_default(action.dest) == value:
+      continue  # Don't add default values
+    if action.dest == 'filters':
+      # Create a separate option for each filter element.  The value is a list
+      # of Filter objects.
+      for elem in value:
+        opt_name = 'filter-out' if elem.is_filter_out else 'filter'
+        opt_value = elem.pattern()
+        new_arg = '--%s "%s" ' % (opt_name, opt_value.strip('"'))
+        if new_arg not in autogenerated_note_args:
+          autogenerated_note_args += new_arg
+    else:
+      autogenerated_note_args += action.option_strings[0] + ' '
+      if action.const is None:  # action takes a parameter
+        if action.nargs == '+':
+          value = ' '.join(map(lambda v: '"' + v.strip('"') + '"', value))
+        autogenerated_note_args += '%s ' % value
+  if autogenerated_note_args:
+    autogenerated_note_args = ' %s %s' % (UTC_ARGS_KEY, autogenerated_note_args[:-1])
+  return autogenerated_note_args
+
+
+def check_for_command(line, parser, args, argv, argparse_callback):
+  cmd_m = UTC_ARGS_CMD.match(line)
+  if cmd_m:
+    for option in shlex.split(cmd_m.group('cmd').strip()):
+      if option:
+        argv.append(option)
+    args = parser.parse_args(filter(lambda arg: arg not in args.tests, argv))
+    if argparse_callback is not None:
+      argparse_callback(args)
+  return args, argv
+
+def find_arg_in_test(test_info, get_arg_to_check, arg_string, is_global):
+  result = get_arg_to_check(test_info.args)
+  if not result and is_global:
+    # See if this has been specified via UTC_ARGS.  This is a "global" option
+    # that affects the entire generation of test checks.  If it exists anywhere
+    # in the test, apply it to everything.
+    saw_line = False
+    for line_info in test_info.ro_iterlines():
+      line = line_info.line
+      if not line.startswith(';') and line.strip() != '':
+        saw_line = True
+      result = get_arg_to_check(line_info.args)
+      if result:
+        if warn and saw_line:
+          # We saw the option after already reading some test input lines.
+          # Warn about it.
+          print('WARNING: Found {} in line following test start: '.format(arg_string)
+                + line, file=sys.stderr)
+          print('WARNING: Consider moving {} to top of file'.format(arg_string),
+                file=sys.stderr)
+        break
+  return result
+
+def dump_input_lines(output_lines, test_info, prefix_set, comment_string):
+  for input_line_info in test_info.iterlines(output_lines):
+    line = input_line_info.line
+    args = input_line_info.args
+    if line.strip() == comment_string:
+      continue
+    if line.strip() == comment_string + SEPARATOR:
+      continue
+    if line.lstrip().startswith(comment_string):
+      m = CHECK_RE.match(line)
+      if m and m.group(1) in prefix_set:
+        continue
+    output_lines.append(line.rstrip('\n'))
+
+def add_checks_at_end(output_lines, prefix_list, func_order,
+                      comment_string, check_generator):
+  added = set()
+  generated_prefixes = set()
+  for prefix in prefix_list:
+    prefixes = prefix[0]
+    tool_args = prefix[1]
+    for prefix in prefixes:
+      for func in func_order[prefix]:
+        # The func order can contain the same functions multiple times.
+        # If we see one again we are done.
+        if (func, prefix) in added:
+            continue
+        if added:
+          output_lines.append(comment_string)
+
+        # The add_*_checks routines expect a run list whose items are
+        # tuples that have a list of prefixes as their first element and
+        # tool command args string as their second element.  They output
+        # checks for each prefix in the list of prefixes.  By doing so, it
+        # implicitly assumes that for each function every run line will
+        # generate something for that function.  That is not the case for
+        # generated functions as some run lines might not generate them
+        # (e.g. -fopenmp vs. no -fopenmp).
+        #
+        # Therefore, pass just the prefix we're interested in.  This has
+        # the effect of generating all of the checks for functions of a
+        # single prefix before moving on to the next prefix.  So checks
+        # are ordered by prefix instead of by function as in "normal"
+        # mode.
+        for generated_prefix in check_generator(output_lines,
+                        [([prefix], tool_args)], func):
+            added.add((func, generated_prefix))
+            generated_prefixes.add(generated_prefix)
+  return generated_prefixes
diff --git a/tool/dumper/vkgcPipelineDumper.cpp b/tool/dumper/vkgcPipelineDumper.cpp
index 83c0277a3..977490356 100644
--- a/tool/dumper/vkgcPipelineDumper.cpp
+++ b/tool/dumper/vkgcPipelineDumper.cpp
@@ -787,30 +787,36 @@ void PipelineDumper::dumpPipelineOptions(const PipelineOptions *options, std::os
   dumpFile << "options.overrideThreadGroupSizeX = " << options->overrideThreadGroupSizeX << "\n";
   dumpFile << "options.overrideThreadGroupSizeY = " << options->overrideThreadGroupSizeY << "\n";
   dumpFile << "options.overrideThreadGroupSizeZ = " << options->overrideThreadGroupSizeZ << "\n";
   dumpFile << "options.shadowDescriptorTableUsage = " << options->shadowDescriptorTableUsage << "\n";
   dumpFile << "options.shadowDescriptorTablePtrHigh = " << options->shadowDescriptorTablePtrHigh << "\n";
   dumpFile << "options.extendedRobustness.robustBufferAccess = " << options->extendedRobustness.robustBufferAccess
            << "\n";
   dumpFile << "options.extendedRobustness.robustImageAccess = " << options->extendedRobustness.robustImageAccess
            << "\n";
   dumpFile << "options.extendedRobustness.nullDescriptor = " << options->extendedRobustness.nullDescriptor << "\n";
+#if VKI_BUILD_GFX11
+  dumpFile << "options.optimizeTessFactor = " << options->optimizeTessFactor << "\n";
+#endif
 
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 53
   dumpFile << "options.optimizationLevel = " << options->optimizationLevel << "\n";
 #endif
   dumpFile << "options.threadGroupSwizzleMode = " << options->threadGroupSwizzleMode << "\n";
   dumpFile << "options.reverseThreadGroup = " << options->reverseThreadGroup << "\n";
 
 #if VKI_RAY_TRACING
   dumpFile << "options.internalRtShaders = " << options->internalRtShaders << "\n";
 #endif
+
+  dumpFile << "options.forceNonUniformResourceIndexStageMask = " << options->forceNonUniformResourceIndexStageMask
+           << "\n";
 }
 
 // =====================================================================================================================
 // Dumps compute pipeline information to file.
 //
 // @param dumpFile : Pipeline dump file
 // @param dumpDir : Directory of pipeline dump
 // @param pipelineInfo : Info of the compute pipeline to be built
 void PipelineDumper::dumpComputePipelineInfo(std::ostream *dumpFile, const char *dumpDir,
                                              const ComputePipelineBuildInfo *pipelineInfo) {
@@ -1079,20 +1085,23 @@ void PipelineDumper::dumpRayTracingRtState(const RtState *rtState, std::ostream
   dumpStream << "rtState.exportConfig.readsDispatchRaysIndex = " << rtState->exportConfig.readsDispatchRaysIndex
              << "\n";
   dumpStream << "rtState.exportConfig.enableDynamicLaunch = " << rtState->exportConfig.enableDynamicLaunch << "\n";
   dumpStream << "rtState.exportConfig.emitRaytracingShaderDataToken = "
              << rtState->exportConfig.emitRaytracingShaderDataToken << "\n";
   dumpStream << "rtState.enableRayQueryCsSwizzle = " << rtState->enableRayQueryCsSwizzle << "\n";
   dumpStream << "rtState.enableDispatchRaysInnerSwizzle = " << rtState->enableDispatchRaysInnerSwizzle << "\n";
   dumpStream << "rtState.enableDispatchRaysOuterSwizzle = " << rtState->enableDispatchRaysOuterSwizzle << "\n";
   dumpStream << "rtState.forceInvalidAccelStruct = " << rtState->forceInvalidAccelStruct << "\n";
   dumpStream << "rtState.enableRayTracingCounters = " << rtState->enableRayTracingCounters << "\n";
+#if VKI_BUILD_GFX11
+  dumpStream << "rtState.enableRayTracingHwTraversalStack = " << rtState->enableRayTracingHwTraversalStack << "\n";
+#endif
   dumpStream << "rtState.enableOptimalLdsStackSizeForIndirect = " << rtState->enableOptimalLdsStackSizeForIndirect
              << "\n";
   dumpStream << "rtState.enableOptimalLdsStackSizeForUnified = " << rtState->enableOptimalLdsStackSizeForUnified
              << "\n";
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 56
   dumpStream << "rtState.maxRayLength = " << rtState->maxRayLength << "\n";
 #endif
 
   for (unsigned i = 0; i < RT_ENTRY_FUNC_COUNT; ++i) {
     dumpStream << "rtState.gpurtFuncTable.pFunc[" << i << "] = " << rtState->gpurtFuncTable.pFunc[i] << "\n";
@@ -1154,20 +1163,23 @@ void PipelineDumper::updateHashForRtState(const RtState *rtState, MetroHash64 *h
   hasher->Update(rtState->exportConfig.enableUniformNoReturn);
   hasher->Update(rtState->exportConfig.enableTraceRayArgsInLds);
   hasher->Update(rtState->exportConfig.readsDispatchRaysIndex);
   hasher->Update(rtState->exportConfig.enableDynamicLaunch);
   hasher->Update(rtState->exportConfig.emitRaytracingShaderDataToken);
   hasher->Update(rtState->enableRayQueryCsSwizzle);
   hasher->Update(rtState->enableDispatchRaysInnerSwizzle);
   hasher->Update(rtState->enableDispatchRaysOuterSwizzle);
   hasher->Update(rtState->forceInvalidAccelStruct);
   hasher->Update(rtState->enableRayTracingCounters);
+#if VKI_BUILD_GFX11
+  hasher->Update(rtState->enableRayTracingHwTraversalStack);
+#endif
   hasher->Update(rtState->enableOptimalLdsStackSizeForIndirect);
   hasher->Update(rtState->enableOptimalLdsStackSizeForUnified);
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 56
   hasher->Update(rtState->maxRayLength);
 #endif
 
   for (unsigned i = 0; i < RT_ENTRY_FUNC_COUNT; ++i) {
     size_t funcNameLen = 0;
     if (rtState->gpurtFuncTable.pFunc[i]) {
       funcNameLen = strlen(rtState->gpurtFuncTable.pFunc[i]);
@@ -1450,20 +1462,23 @@ void PipelineDumper::updateHashForNonFragmentState(const GraphicsPipelineBuildIn
 void PipelineDumper::updateHashForFragmentState(const GraphicsPipelineBuildInfo *pipeline, MetroHash64 *hasher,
                                                 bool isRelocatableShader) {
   auto rsState = &pipeline->rsState;
   hasher->Update(rsState->perSampleShading);
   hasher->Update(rsState->provokingVertexMode);
   hasher->Update(rsState->pixelShaderSamples);
 
   // Topology is required when BaryCoord is used
   hasher->Update(pipeline->iaState.topology);
 
+  // View index in fragment shader depends on the enablement of multi-view
+  hasher->Update(pipeline->iaState.enableMultiView);
+
   if (!isRelocatableShader) {
     hasher->Update(rsState->innerCoverage);
     hasher->Update(rsState->numSamples);
     hasher->Update(rsState->samplePatternIdx);
 
     auto cbState = &pipeline->cbState;
     hasher->Update(cbState->alphaToCoverageEnable);
     hasher->Update(cbState->dualSourceBlendEnable);
     for (unsigned i = 0; i < MaxColorTargets; ++i) {
       if (cbState->target[i].format != VK_FORMAT_UNDEFINED) {
@@ -1479,22 +1494,25 @@ void PipelineDumper::updateHashForFragmentState(const GraphicsPipelineBuildInfo
 // =====================================================================================================================
 // Update hash code from pipeline options
 //
 // @param options: Pipeline options
 // @param [in/out] hasher : Hasher to generate hash code
 // @param isCacheHash : True if the hash will be used as a key for a cache lookup.
 // @param isRelocatableShader : TRUE if we are building a relocatable shader
 // @param stage : The unlinked shader stage that should be included in the hash.
 void PipelineDumper::updateHashForPipelineOptions(const PipelineOptions *options, MetroHash64 *hasher, bool isCacheHash,
                                                   bool isRelocatableShader, UnlinkedShaderStage stage) {
+#if VKI_BUILD_GFX11
+#else
   assert(options->reserved1f == false && "The reserved1f bit should be unused at this time.");
 
+#endif
   hasher->Update(options->includeDisassembly);
   hasher->Update(options->scalarBlockLayout);
   hasher->Update(options->includeIr);
   hasher->Update(options->robustBufferAccess);
   hasher->Update(options->reconfigWorkgroupLayout);
   hasher->Update(options->forceCsThreadIdSwizzling);
   hasher->Update(options->overrideThreadGroupSizeX);
   hasher->Update(options->overrideThreadGroupSizeY);
   hasher->Update(options->overrideThreadGroupSizeZ);
   hasher->Update(options->enableRelocatableShaderElf);
@@ -1503,35 +1521,41 @@ void PipelineDumper::updateHashForPipelineOptions(const PipelineOptions *options
   hasher->Update(options->resourceLayoutScheme);
 
   if (!isRelocatableShader) {
     hasher->Update(options->shadowDescriptorTableUsage);
     hasher->Update(options->shadowDescriptorTablePtrHigh);
   }
 
   hasher->Update(options->extendedRobustness.robustBufferAccess);
   hasher->Update(options->extendedRobustness.robustImageAccess);
   hasher->Update(options->extendedRobustness.nullDescriptor);
+#if VKI_BUILD_GFX11
+  if (stage != UnlinkedStageCompute) {
+    hasher->Update(options->optimizeTessFactor);
+  }
+#endif
 
   if (stage == UnlinkedStageFragment || stage == UnlinkedStageCount) {
     hasher->Update(options->enableInterpModePatch);
   }
 
   hasher->Update(options->pageMigrationEnabled);
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 53
   hasher->Update(options->optimizationLevel);
 #endif
   hasher->Update(options->threadGroupSwizzleMode);
   hasher->Update(options->reverseThreadGroup);
 
 #if VKI_RAY_TRACING
   hasher->Update(options->internalRtShaders);
 #endif
+  hasher->Update(options->forceNonUniformResourceIndexStageMask);
 }
 
 // =====================================================================================================================
 // Updates hash code context for pipeline shader stage.
 //
 // @param stage : Shader stage
 // @param shaderInfo : Shader info in specified shader stage
 // @param isCacheHash : TRUE if the hash is used by shader cache
 // @param [in/out] hasher : Hasher to generate hash code
 // @param isRelocatableShader : TRUE if we are building relocatable shader
diff --git a/tool/dumper/vkgcPipelineDumperRegs.cpp b/tool/dumper/vkgcPipelineDumperRegs.cpp
index 8e21b4c85..c1e734391 100644
--- a/tool/dumper/vkgcPipelineDumperRegs.cpp
+++ b/tool/dumper/vkgcPipelineDumperRegs.cpp
@@ -26,20 +26,23 @@
 ***********************************************************************************************************************
 * @file  vkgcPipelineDumperRegs.cpp
 * @brief VKGC source file: register names for VKGC pipeline dump utility.
 ***********************************************************************************************************************
 */
 #include "vkgcPipelineDumper.h"
 
 namespace Vkgc {
 
 const std::vector<PipelineDumperReg> PipelineDumperRegs = {
+#if VKI_BUILD_GFX11
+    {0x2C01, "SPI_SHADER_PGM_RSRC4_PS"},
+#endif
     {0x2C06, "SPI_SHADER_PGM_CHKSUM_PS"},
     {0x2C07, "SPI_SHADER_PGM_RSRC3_PS"},
     {0x2C0A, "SPI_SHADER_PGM_RSRC1_PS"},
     {0x2C0B, "SPI_SHADER_PGM_RSRC2_PS"},
     {0x2C0C, "SPI_SHADER_USER_DATA_PS_0"},
     {0x2C0D, "SPI_SHADER_USER_DATA_PS_1"},
     {0x2C0E, "SPI_SHADER_USER_DATA_PS_2"},
     {0x2C0F, "SPI_SHADER_USER_DATA_PS_3"},
     {0x2C10, "SPI_SHADER_USER_DATA_PS_4"},
     {0x2C11, "SPI_SHADER_USER_DATA_PS_5"},
@@ -140,20 +143,24 @@ const std::vector<PipelineDumperReg> PipelineDumperRegs = {
     {0x2CA2, "SPI_SHADER_USER_DATA_GS_22"},
     {0x2CA3, "SPI_SHADER_USER_DATA_GS_23"},
     {0x2CA4, "SPI_SHADER_USER_DATA_GS_24"},
     {0x2CA5, "SPI_SHADER_USER_DATA_GS_25"},
     {0x2CA6, "SPI_SHADER_USER_DATA_GS_26"},
     {0x2CA7, "SPI_SHADER_USER_DATA_GS_27"},
     {0x2CA8, "SPI_SHADER_USER_DATA_GS_28"},
     {0x2CA9, "SPI_SHADER_USER_DATA_GS_29"},
     {0x2CAA, "SPI_SHADER_USER_DATA_GS_30"},
     {0x2CAB, "SPI_SHADER_USER_DATA_GS_31"},
+#if VKI_BUILD_GFX11
+    {0x2CAC, "SPI_SHADER_GS_MESHLET_DIM"},
+    {0x2CAD, "SPI_SHADER_GS_MESHLET_EXP_ALLOC"},
+#endif
     {0x2CBC, "SPI_SHADER_PGM_RSRC2_ES_GS"},
     {0x2CCA, "SPI_SHADER_PGM_RSRC1_ES"},
     {0x2CCB, "SPI_SHADER_PGM_RSRC2_ES"},
     {0x2CCC, "SPI_SHADER_USER_DATA_ES_0"},
     {0x2CCD, "SPI_SHADER_USER_DATA_ES_1"},
     {0x2CCE, "SPI_SHADER_USER_DATA_ES_2"},
     {0x2CCF, "SPI_SHADER_USER_DATA_ES_3"},
     {0x2CD0, "SPI_SHADER_USER_DATA_ES_4"},
     {0x2CD1, "SPI_SHADER_USER_DATA_ES_5"},
     {0x2CD2, "SPI_SHADER_USER_DATA_ES_6"},
@@ -177,20 +184,23 @@ const std::vector<PipelineDumperReg> PipelineDumperRegs = {
     {0x2CE4, "SPI_SHADER_USER_DATA_ES_24"},
     {0x2CE5, "SPI_SHADER_USER_DATA_ES_25"},
     {0x2CE6, "SPI_SHADER_USER_DATA_ES_26"},
     {0x2CE7, "SPI_SHADER_USER_DATA_ES_27"},
     {0x2CE8, "SPI_SHADER_USER_DATA_ES_28"},
     {0x2CE9, "SPI_SHADER_USER_DATA_ES_29"},
     {0x2CEA, "SPI_SHADER_USER_DATA_ES_30"},
     {0x2CEB, "SPI_SHADER_USER_DATA_ES_31"},
     {0x2CFD, "SPI_SHADER_PGM_RSRC2_LS_ES"},
     {0x2D00, "SPI_SHADER_PGM_CHKSUM_HS"},
+#if VKI_BUILD_GFX11
+    {0x2D01, "SPI_SHADER_PGM_RSRC4_HS"},
+#endif
     {0x2D07, "SPI_SHADER_PGM_RSRC3_HS"},
     {0x2D0A, "SPI_SHADER_PGM_RSRC1_HS"},
     {0x2D0B, "SPI_SHADER_PGM_RSRC2_HS"},
     {0x2D0C, "SPI_SHADER_USER_DATA_HS_0"},
     {0x2D0C, "SPI_SHADER_USER_DATA_LS_0"},
     {0x2D0D, "SPI_SHADER_USER_DATA_HS_1"},
     {0x2D0D, "SPI_SHADER_USER_DATA_LS_1"},
     {0x2D0E, "SPI_SHADER_USER_DATA_HS_2"},
     {0x2D0E, "SPI_SHADER_USER_DATA_LS_2"},
     {0x2D0F, "SPI_SHADER_USER_DATA_HS_3"},
@@ -384,20 +394,23 @@ const std::vector<PipelineDumperReg> PipelineDumperRegs = {
     {0xA2E5, "VGT_STRMOUT_CONFIG"},
     {0xA2E6, "VGT_STRMOUT_BUFFER_CONFIG"},
     {0xA2F8, "PA_SC_AA_CONFIG"},
     {0xA2F9, "PA_SU_VTX_CNTL"},
     {0xA310, "PA_SC_SHADER_CONTROL"},
     {0xA316, "VGT_VERTEX_REUSE_BLOCK_CNTL"},
     {0xC258, "IA_MULTI_VGT_PARAM"},
     {0xC258, "IA_MULTI_VGT_PARAM_PIPED"},
     {0xC25F, "GE_STEREO_CNTL"},
     {0xC262, "GE_USER_VGPR_EN"},
+#if VKI_BUILD_GFX11
+    {0xC266, "VGT_GS_OUT_PRIM_TYPE"},
+#endif
 };
 
 // =====================================================================================================================
 // Get name of register, or "" if not known
 //
 // @param regNumber : Register number
 const char *PipelineDumper::getRegisterNameString(unsigned regNumber) {
   for (unsigned idx = 0, end = PipelineDumperRegs.size(); idx != end; ++idx) {
     const auto &regEntry = PipelineDumperRegs[idx];
     if (regEntry.number == regNumber)
diff --git a/tool/update_llpc_test_checks.py b/tool/update_llpc_test_checks.py
new file mode 100755
index 000000000..a2ac71fe3
--- /dev/null
+++ b/tool/update_llpc_test_checks.py
@@ -0,0 +1,317 @@
+#!/usr/bin/env python3
+
+# This script is based on the LLVM Project's update_test_checks.py, which is
+# licensed under the Apache License v2.0 with LLVM Exceptions; see the file
+# UpdateTestChecks/LICENSE.txt relative to this directory. It has been heavily
+# modified for use with LLPC.
+
+"""Generate FileCheck statements for LLPC lit tests.
+
+This tool is designed to be used on LLPC lit tests that are configured to
+output a single batch of intermediate IR, for example, using the -emit-lgc
+option.
+
+Example usage:
+
+# Default to using `amdllpc` as found in your PATH.
+$ update_llpc_test_checks.py llpc/test/foo.comp
+
+# Override the lookup of amdllpc.
+$ update_llpc_test_checks.py --tool-binary=../../../build/dbg/compiler/llpc/amdllpc llpc/test/foo.comp
+"""
+
+import argparse
+import os  # Used to advertise this file's name ("autogenerated_note").
+import re
+import sys
+from typing import List
+
+from UpdateTestChecks import common
+
+###############################################################################
+# PAL metadata support
+
+PAL_METADATA_RE = re.compile(
+    r'^[ \t]*\.amdgpu_pal_metadata\n'
+    r'---\n'
+    r'(?P<metadata>.*?)'
+    r'^...\n',
+    flags=(re.MULTILINE | re.DOTALL))
+
+YAML_INDENT_RE = re.compile(r'(?P<indent>[ -]*)((?P<name>[^:]+):)?')
+YAML_SUFFIX_RE = re.compile(r':[^:]*$')
+
+HEX_RE = re.compile(r'0x[0-9a-f]+')
+
+def process_pal_metadata(pal_metadata_dict, prefixes, raw_tool_output):
+  m = PAL_METADATA_RE.search(raw_tool_output)
+  if not m:
+    common.warn(f"Did not find PAL metadata")
+    return
+
+  metadata_in_lines = m.group("metadata").splitlines()
+  scrubbed_lines = []
+
+  scope = []
+  def get_scope_path():
+    return ''.join(name for name, _ in scope)
+
+  for line in metadata_in_lines:
+    m = YAML_INDENT_RE.match(line)
+    indent = len(m.group("indent"))
+    scope = [(name, ind) for name, ind in scope if ind < indent]
+
+    if m.group("name") is not None:
+      scope.append((m.group("name"), indent))
+
+    path = get_scope_path()
+    if 'hash' in path:
+      line = HEX_RE.subn("0x{{[0-9a-f]+}}", line)[0]
+    elif 'llpc_version' in path or 'PGM_CHKSUM' in path:
+      line = YAML_SUFFIX_RE.subn(": {{.*}}", line)[0]
+
+    scrubbed_lines.append(line)
+
+  metadata = '\n'.join(scrubbed_lines)
+  for prefix in prefixes:
+    if prefix not in pal_metadata_dict:
+      pal_metadata_dict[prefix] = metadata
+    else:
+      if pal_metadata_dict[prefix] != metadata:
+        pal_metadata_dict[prefix] = None
+
+def add_pal_metadata_checks(pal_metadata_dict, comment_prefix, prefix_list,
+                            output_lines: List[str]):
+  written_prefixes = set()
+  for prefix_list_entry in prefix_list:
+    prefixes = prefix_list_entry[0]
+    for prefix in prefixes:
+      if prefix in pal_metadata_dict and pal_metadata_dict[prefix] is not None:
+        break
+    else:
+      common.warn(f"Did not find PAL metadata for prefix list {prefixes}")
+      return
+
+    if prefix in written_prefixes:
+      continue
+
+    output_lines.append(comment_prefix)
+    output_lines.append(f'{comment_prefix} {prefix}-LABEL: .amdgpu_pal_metadata')
+    output_lines.append(f'{comment_prefix} {prefix}-NEXT: ---')
+    for line in pal_metadata_dict[prefix].splitlines():
+      output_lines.append(f'{comment_prefix} {prefix}-NEXT: {line}')
+    output_lines.append(f'{comment_prefix} {prefix}-NEXT: ...')
+
+    written_prefixes.add(prefix)
+
+###############################################################################
+# Assembly support
+ASM_FUNCTION_AMDGPU_RE = re.compile(
+    r'^_?(?P<func>[^:\n]+):[ \t]*(?:;+[ \t]*@"?(?P=func)"?)?\n[^:]*?'
+    r'(?P<body>.*?)\n' # (body of the function)
+    # This list is incomplete
+    r'^\s*(\.Lfunc_end[0-9]+:\n|\.section)',
+    flags=(re.M | re.S))
+
+def scrub_asm_amdgpu(asm, *args):
+  # Scrub runs of whitespace out of the assembly, but leave the leading
+  # whitespace in place.
+  asm = common.SCRUB_WHITESPACE_RE.sub(r' ', asm)
+  # Expand the tabs used for indentation.
+  asm = str.expandtabs(asm, 2)
+  # Strip trailing whitespace.
+  asm = common.SCRUB_TRAILING_WHITESPACE_RE.sub(r'', asm)
+  return asm
+
+def add_asm_checks(output_lines, comment_marker, prefix_list, func_dict,
+                   func_name, global_vars_seen_dict, args, is_filtered):
+  # Label format is based on ASM string.
+  check_label_format = '{} %s-LABEL: %s%s%s'.format(comment_marker)
+  return common.add_checks(output_lines, comment_marker, prefix_list, func_dict,
+                           func_name, check_label_format, True, False,
+                           global_vars_seen_dict, is_filtered=is_filtered)
+
+def add_ir_checks(output_lines, comment_marker, prefix_list, func_dict,
+                  func_name, global_vars_seen_dict, args, is_filtered):
+  return common.add_ir_checks(output_lines, comment_marker, prefix_list,
+                              func_dict, func_name, False, args.function_signature,
+                              global_vars_seen_dict, is_filtered)
+
+COMMENT_PREFIXES_BY_FILE_SUFFIX = {
+  '.pipe': ';',
+  '.spvasm': ';',
+  '.ll': ';',
+  # Everything else defaults to '//'
+}
+
+def get_comment_prefix(test_name: str, input_lines):
+  ext = os.path.splitext(test_name)[1]
+  return COMMENT_PREFIXES_BY_FILE_SUFFIX.get(ext, '//')
+
+def main():
+  from argparse import RawTextHelpFormatter
+  parser = argparse.ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
+  parser.add_argument('--tool', default='amdllpc',
+                      help='The name of the tool used to generate the test case (defaults to "amdllpc")')
+  parser.add_argument('--tool-binary',
+                      help='The tool binary used to generate the test case')
+  parser.add_argument('-p', '--preserve-names', action='store_true',
+                      help='Do not scrub IR names')
+  parser.add_argument('--function-signature', action='store_true',
+                      help='Keep function signature information around for the check line')
+  parser.add_argument('--scrub-attributes', action='store_true',
+                      help='Remove attribute annotations (#0) from the end of check line')
+  parser.add_argument('--check-attributes', action='store_true',
+                      help='Check "Function Attributes" for functions')
+  parser.add_argument('--check-globals', action='store_true',
+                      help='Check global entries (global variables, metadata, attribute sets, ...) for functions')
+  parser.add_argument('--check-pal-metadata', action='store_true',
+                      help='Check PAL metadata in output assembly')
+  parser.add_argument('tests', nargs='+')
+  initial_args = common.parse_commandline_args(parser)
+
+  if initial_args.tool_binary:
+    tool_basename = os.path.basename(initial_args.tool_binary)
+    if not re.match(r'^%s(-\d+)?(\.exe)?$' % (initial_args.tool), tool_basename):
+      common.error('Unexpected tool name: ' + tool_basename)
+      sys.exit(1)
+  tool_basename = initial_args.tool
+
+  for ti in common.itertests(initial_args.tests, parser, 'tool/update_llpc_test_checks.py',
+                             comment_prefix_callback=get_comment_prefix):
+    # If requested we scrub trailing attribute annotations, e.g., '#0', together with whitespaces
+    if ti.args.scrub_attributes:
+      common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_AND_ATTRIBUTES_RE
+    else:
+      common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_RE
+
+    prefix_list = []
+    for l in ti.run_lines:
+      if '|' not in l:
+        common.warn('Skipping unparsable RUN line: ' + l)
+        continue
+
+      commands = [cmd.strip() for cmd in l.split('|')]
+      assert len(commands) >= 2
+      if len(commands) > 2:
+        common.error('Complex pipes are unsupported')
+        sys.exit(1)
+      tool_cmd = commands[-2]
+      filecheck_cmd = commands[-1]
+      common.verify_filecheck_prefixes(filecheck_cmd)
+      if not tool_cmd.startswith(tool_basename + ' '):
+        common.warn('Skipping non-%s RUN line: %s' % (tool_basename, l))
+        continue
+
+      if not filecheck_cmd.startswith('FileCheck '):
+        common.warn('Skipping non-FileChecked RUN line: ' + l)
+        continue
+
+      tool_cmd_args = tool_cmd[len(tool_basename):].strip()
+
+      check_prefixes = [item for m in
+                        common.CHECK_PREFIX_RE.finditer(filecheck_cmd)
+                        for item in m.group(1).split(',')]
+      if not check_prefixes:
+        check_prefixes = ['CHECK']
+
+      # FIXME: We should use multiple check prefixes to common check lines. For
+      # now, we just ignore all but the last.
+      prefix_list.append((check_prefixes, tool_cmd_args))
+
+    global_vars_seen_dict = {}
+    builder = common.FunctionTestBuilder(
+      run_list=prefix_list,
+      flags=ti.args,
+      scrubber_args=[],
+      path=ti.path)
+
+    tool_binary = ti.args.tool_binary
+    if not tool_binary:
+      tool_binary = tool_basename
+
+    function_re = None
+    scrubber = None
+    add_checks = None
+    is_backend = None
+
+    pal_metadata_dict = {}
+
+    for prefixes, tool_args in prefix_list:
+      common.debug('Extracted tool cmd: ' + tool_basename + ' ' + tool_args)
+      common.debug('Extracted FileCheck prefixes: ' + str(prefixes))
+
+      raw_tool_output = common.invoke_tool_only(tool_binary, tool_args, ti.path,
+                                                verbose=ti.args.verbose)
+
+      is_ir = common.OPT_FUNCTION_RE.search(raw_tool_output) is not None
+      if is_ir:
+        assert is_backend is None or is_backend == False # Currently can't support a mix of RUN lines
+        function_re = common.OPT_FUNCTION_RE
+        scrubber = common.scrub_body
+        add_checks = add_ir_checks
+        is_backend = False
+      else:
+        assert is_backend is None or is_backend == True # Currently can't support a mix of RUN lines
+        function_re = ASM_FUNCTION_AMDGPU_RE
+        scrubber = scrub_asm_amdgpu
+        add_checks = add_asm_checks
+        is_backend = True
+
+      builder.process_run_line(function_re, scrubber, raw_tool_output, prefixes,
+                               is_backend)
+      builder.processed_prefixes(prefixes)
+
+      if ti.args.check_pal_metadata:
+        if not is_backend:
+          common.error(f"{ti.path}: --check-pal-metadata only applies with asm output")
+          sys.exit(1)
+
+        process_pal_metadata(pal_metadata_dict, prefixes, raw_tool_output)
+
+    func_dict = builder.finish_and_get_func_dict()
+    prefix_set = set([prefix for prefixes, _ in prefix_list for prefix in prefixes])
+    common.debug('Rewriting FileCheck prefixes:', str(prefix_set))
+    output_lines = []
+
+    # Generate the appropriate checks for each function.  We need to emit
+    # these in the order according to the generated output so that CHECK-LABEL
+    # works properly.  func_order provides that.
+
+    # We can't predict where various passes might insert functions so we can't
+    # be sure the input function order is maintained.  Therefore, first spit
+    # out all the source lines.
+    common.dump_input_lines(output_lines, ti, prefix_set, ti.comment_prefix)
+
+    args = ti.args
+
+    if args.check_globals:
+      common.add_global_checks(builder.global_var_dict(), ti.comment_prefix,
+                               prefix_list, output_lines, global_vars_seen_dict,
+                               args.preserve_names, True)
+
+    # Now generate all the checks.
+    common.add_checks_at_end(output_lines, prefix_list, builder.func_order(),
+                             ti.comment_prefix, lambda my_output_lines, prefixes, func:
+                             add_checks(my_output_lines, ti.comment_prefix,
+                                        prefixes, func_dict, func,
+                                        global_vars_seen_dict, args,
+                                        is_filtered=builder.is_filtered()))
+
+    if args.check_globals:
+      common.add_global_checks(builder.global_var_dict(), ti.comment_prefix,
+                               prefix_list, output_lines, global_vars_seen_dict,
+                               args.preserve_names, False)
+
+    if args.check_pal_metadata:
+      add_pal_metadata_checks(pal_metadata_dict, ti.comment_prefix, prefix_list,
+                              output_lines)
+
+    common.debug('Writing %d lines to %s...' % (len(output_lines), ti.path))
+
+    with open(ti.path, 'wb') as f:
+      f.writelines(['{}\n'.format(l).encode('utf-8') for l in output_lines])
+
+
+if __name__ == '__main__':
+  main()
diff --git a/tool/vfx/vfxVkSection.h b/tool/vfx/vfxVkSection.h
index 1ad5453bf..7d7f08e23 100644
--- a/tool/vfx/vfxVkSection.h
+++ b/tool/vfx/vfxVkSection.h
@@ -367,23 +367,28 @@ private:
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, overrideThreadGroupSizeZ, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, shadowDescriptorTableUsage, MemberTypeEnum, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, shadowDescriptorTablePtrHigh, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, resourceLayoutScheme, MemberTypeEnum, false);
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 53
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, optimizationLevel, MemberTypeInt, false);
 #endif
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, threadGroupSwizzleMode, MemberTypeEnum, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, reverseThreadGroup, MemberTypeBool, false);
       INIT_MEMBER_NAME_TO_ADDR(SectionPipelineOption, m_extendedRobustness, MemberTypeExtendedRobustness, true);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, forceNonUniformResourceIndexStageMask, MemberTypeInt,
+                                     false);
       // One internal member
 #if VKI_RAY_TRACING
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, internalRtShaders, MemberTypeBool, false);
+#endif
+#if VKI_BUILD_GFX11
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionPipelineOption, optimizeTessFactor, MemberTypeBool, false);
 #endif
       return addrTableInitializer;
     }();
     return {addrTable.data(), addrTable.size()};
   }
 
   SubState m_state;
   SectionExtendedRobustness m_extendedRobustness;
 };
 
@@ -597,26 +602,29 @@ private:
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, boxSortHeuristicMode, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, counterMode, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, counterMask, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, rayQueryCsSwizzle, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, ldsStackSize, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, dispatchRaysThreadGroupSize, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, ldsSizePerThreadGroup, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, outerTileSize, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, dispatchDimSwizzleMode, MemberTypeInt, false);
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableRayQueryCsSwizzle, MemberTypeBool, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableDispatchRaysInnerSwizzle, MemberTypeInt, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableDispatchRaysOuterSwizzle, MemberTypeInt, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, forceInvalidAccelStruct, MemberTypeInt, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableRayTracingCounters, MemberTypeInt, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableOptimalLdsStackSizeForIndirect, MemberTypeInt, false);
-      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableOptimalLdsStackSizeForUnified, MemberTypeInt, false);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableDispatchRaysInnerSwizzle, MemberTypeBool, false);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableDispatchRaysOuterSwizzle, MemberTypeBool, false);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, forceInvalidAccelStruct, MemberTypeBool, false);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableRayTracingCounters, MemberTypeBool, false);
+#if VKI_BUILD_GFX11
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableRayTracingHwTraversalStack, MemberTypeBool, false);
+#endif
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableOptimalLdsStackSizeForIndirect, MemberTypeBool, false);
+      INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, enableOptimalLdsStackSizeForUnified, MemberTypeBool, false);
 #if LLPC_CLIENT_INTERFACE_MAJOR_VERSION >= 56
       INIT_STATE_MEMBER_NAME_TO_ADDR(SectionRtState, maxRayLength, MemberTypeFloat, false);
 #endif
       INIT_MEMBER_NAME_TO_ADDR(SectionRtState, m_exportConfig, MemberTypeRayTracingShaderExportConfig, true);
 #if GPURT_CLIENT_INTERFACE_MAJOR_VERSION >= 15
       INIT_MEMBER_NAME_TO_ADDR(SectionRtState, m_gpurtFuncTable, MemberTypeGpurtFuncTable, true);
 #endif
       return addrTableInitializer;
     }();
     return {addrTable.data(), addrTable.size()};
